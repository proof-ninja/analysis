
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.fieldext</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.fieldext" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.ssrnum.html">ssrnum</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
<li><a href="mathcomp.ssreflect.bigop.html">bigop</a></li>
<li><a href="mathcomp.ssreflect.binomial.html">binomial</a></li>
<li><a href="mathcomp.ssreflect.choice.html">choice</a></li>
<li><a href="mathcomp.ssreflect.div.html">div</a></li>
<li><a href="mathcomp.ssreflect.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.ssreflect.finfun.html">finfun</a></li>
<li><a href="mathcomp.ssreflect.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.ssreflect.finset.html">finset</a></li>
<li><a href="mathcomp.ssreflect.fintype.html">fintype</a></li>
<li><a href="mathcomp.ssreflect.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.ssreflect.order.html">order</a></li>
<li><a href="mathcomp.ssreflect.path.html">path</a></li>
<li><a href="mathcomp.ssreflect.prime.html">prime</a></li>
<li><a href="mathcomp.ssreflect.seq.html">seq</a></li>
<li><a href="mathcomp.ssreflect.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.ssreflect.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.ssreflect.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.ssreflect.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.ssreflect.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.ssreflect.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.ssreflect.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.ssreflect.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.fieldext</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrfun</span><span class="id"> ssrbool</span><span class="id"> eqtype</span><span class="id"> ssrnat</span><span class="id"> seq</span><span class="id"> div</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> choice</span><span class="id"> fintype</span><span class="id"> tuple</span><span class="id"> finfun</span><span class="id"> bigop</span><span class="id"> ssralg</span><span class="id"> countalg</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> finalg</span><span class="id"> zmodp</span><span class="id"> matrix</span><span class="id"> vector</span><span class="id"> falgebra</span><span class="id"> poly</span><span class="id"> polydiv</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> mxpoly</span><span class="id"> generic_quotient</span>.<br/>
<br/>
<pre class="ssrdoc">
                  Finite dimensional field extensions

     fieldExtType F == the interface type for finite field extensions of F
                       it simply combines the fieldType and falgType F
                       interfaces
                       The HB class is called FieldExt.
       {subfield L} == the type of subfields of L that are also extensions
                       of F; since we are in a finite dimensional setting
                       these are exactly the F-subalgebras of L, and
                       indeed {subfield L} is just display notation for
                       {aspace L} when L is an extFieldType
 --&gt; All aspace operations apply to {subfield L}, but there are several
     additional lemmas and canonical instances specific to {subfield L}
     spaces, e.g., subvs_of E is an extFieldType F when E : {subfield L}.
 --&gt; Also note that not all constructive subfields have type {subfield E}
     in the same way that not all constructive subspaces have type
     {vspace E}. These types only include the so called "detachable"
     subspaces (and subalgebras).

(E :&amp;: F)%AS, (E * F)%AS == the intersection and product (meet and join)
                          of E and F as subfields
   subFExtend iota z p == given a field morphism iota : F -&gt; L, this is a
                          type for the field F^iota(z) obtained by
                          adjoining z to the image of F in L under iota
                          The construction requires a non-zero polynomial
                          p in F such that z is a root of p^iota; it
                          returns the field F^iota if this is not so.
                          However, p need not be irredicible.
           subfx_inj x == the injection of F^iota(z) into L
  inj_subfx iota z p x == the injection of F into F^iota(z)
 subfx_eval iota z p q == given q : {poly F} returns q.[z] as a value of
                          type F^iota(z)
   subfx_root iota z p == the generator of F^iota(z) over F
SubFieldExtType pz0 irr_p == a fieldExtType F structure for F^iota(z)
                          (more precisely, subFExtend iota z p), given
                          proofs pz0: root (map_poly iota p) z and
                          irr_p : irreducible_poly p.
                          The corresponding vectType substructure
                          (SubfxVectType pz0 irr_p) has dimension
                          (size p).-1 over F.
           minPoly K x == the monic minimal polynomial of x over the
                          subfield K
     adjoin_degree K x == the degree of the minimal polynomial or the
                          dimension of K(x)/K
    Fadjoin_poly K x y == a polynomial p over K such that y = p.[x]

           fieldOver F == L, but with an extFieldType (subvs_of F)
                          structure, for F : {subfield L}
        vspaceOver F V == the smallest subspace of fieldOver F containing
                          V; this coincides with V if V is an F-module
       baseFieldType L == L, but with an extFieldType F0 structure, when L
                          has a canonical extFieldType F structure and F
                          in turn has an extFieldType F0 structure
          baseVspace V == the subspace of baseFieldType L that coincides
                          with V : {vspace L}
--&gt; Some caution must be exercised when using fieldOver and baseFieldType,
    because these are convertible to L while carrying different Lmodule
    structures. This means that the safeguards engineered in the ssralg
    library that normally curb the Coq kernel's inclination to diverge are
    no longer effectcive, so additional precautions should be taken when
    matching or rewriting terms of the form a *: u, because Coq may take
    forever to realize it's dealing with a *: in the wrong structure. The
    baseField_scaleE and fieldOver_scaleE lemmas should be used to expand
    or fold such "trans-structure" operations explicitly beforehand.
</pre>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Import</span><span class="id"> GRing</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="id">#[short</span>(<span class="id">type=</span><span class="id">&quot;fieldExtType&quot;</span>)<span class="id">]</span><br/>
<span class="id">HB</span>.<span class="id">structure</span><span class="vernacular"> Definition</span><span class="id"> FieldExt</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> nzRingType</span>)<span class="id"> :=</span><span class="id"> {T</span><span class="id"> of</span><span class="id"> Falgebra</span><span class="id"> R</span><span class="id"> T</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">PzRing_hasCommutativeMul</span><span class="id"> T</span><span class="id"> &amp;</span><span class="id"> GRing</span>.<span class="id">Field</span><span class="id"> T}</span>.<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> FieldExtExports</span>.<br/>
<span class="vernacular">Bind</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span><span class="gallina-kwd"> with</span><span class="id"> FieldExt</span>.<span class="id">sort</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'subfield' L }&quot;</span><span class="id"> :=</span> (<span class="id">aspace</span><span class="id"> L</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'subfield'  L }&quot;</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">End</span><span class="id"> FieldExtExports</span>.<br/>
<span class="id">HB</span>.<span class="id">export</span><span class="id"> FieldExtExports</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldType</span>)<span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Field</span>.<span class="id">on</span><span class="id"> F^o</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FieldExtTheory</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">U</span><span class="id"> V</span><span class="id"> M</span><span class="id"> :</span><span class="id"> {vspace</span><span class="id"> L}</span>) (<span class="id">E</span><span class="id"> F</span><span class="id"> K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_cosetv</span><span class="id"> U</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> \dim</span> (<span class="id">U</span><span class="id"> *</span><span class="id"> &lt;[x]&gt;</span>)<span class="id"> =</span><span class="id"> \dim</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nz_x;</span><span class="id"> rewrite</span><span class="id"> -limg_amulr</span><span class="id"> limg_dim_eq</span><span class="id"> //</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -subv0;</span><span class="id"> apply/subvP=&gt;</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memv_cap</span><span class="id"> memv0</span><span class="id"> memv_ker</span><span class="id"> lfunE</span><span class="id"> mulf_eq0</span> (<span class="id">negPf</span><span class="id"> nz_x</span>)<span class="id"> orbF</span><span class="id"> =&gt;</span><span class="id"> /andP[]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prodvC</span><span class="id"> :</span><span class="id"> commutative</span> (<span class="id">@prodv</span><span class="id"> F0</span><span class="id"> L</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> U</span><span class="id"> V;</span><span class="id"> without</span><span class="id"> loss</span><span class="id"> suffices</span><span class="id"> subC:</span><span class="id"> U</span><span class="id"> V</span><span class="id"> /</span> (<span class="id">U</span><span class="id"> *</span><span class="id"> V</span><span class="id"> &lt;=</span><span class="id"> V</span><span class="id"> *</span><span class="id"> U</span>)<span class="id">%VS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> !{1}subC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/prodvP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> Ux</span><span class="id"> Vy;</span><span class="id"> rewrite</span><span class="id"> mulrC</span><span class="id"> memv_mul</span>.<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">SemiGroup</span>.<span class="id">isCommutativeLaw</span>.<span class="id">Build</span><span class="id"> {vspace</span><span class="id"> L}</span> (<span class="id">@prodv</span><span class="id"> _</span><span class="id"> L</span>)<span class="id"> prodvC</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prodvCA</span><span class="id"> :</span><span class="id"> left_commutative</span> (<span class="id">@prodv</span><span class="id"> F0</span><span class="id"> L</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> Monoid</span>.<span class="id">mulmCA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prodvAC</span><span class="id"> :</span><span class="id"> right_commutative</span> (<span class="id">@prodv</span><span class="id"> F0</span><span class="id"> L</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> Monoid</span>.<span class="id">mulmAC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> algid1</span><span class="id"> K</span><span class="id"> :</span><span class="id"> algid</span><span class="id"> K</span><span class="id"> =</span><span class="id"> 1</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/skew_field_algid1/fieldP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem1v</span><span class="id"> K</span><span class="id"> :</span><span class="id"> 1</span><span class="id"> \in</span><span class="id"> K</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -algid_eq1</span><span class="id"> algid1</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> sub1v</span><span class="id"> K</span><span class="id"> :</span> (<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> K</span>)<span class="id">%VS</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mem1v</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfield_closed</span><span class="id"> K</span><span class="id"> :</span><span class="id"> agenv</span><span class="id"> K</span><span class="id"> =</span><span class="id"> K</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> sub_agenv</span><span class="id"> agenv_sub_modr</span><span class="id"> ?sub1v</span><span class="id"> ?asubv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> AHom_lker0</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> falgType</span><span class="id"> F0</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> 'AHom</span>(<span class="id">L,</span><span class="id"> rT</span>))<span class="id"> :</span><span class="id"> lker</span><span class="id"> f</span><span class="id"> ==</span><span class="id"> 0%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/lker0P;</span><span class="id"> apply:</span><span class="id"> fmorph_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> AEnd_lker0</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> 'AEnd</span>(<span class="id">L</span>))<span class="id"> :</span><span class="id"> lker</span><span class="id"> f</span><span class="id"> ==</span><span class="id"> 0%VS</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> AHom_lker0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> aimg_is_aspace</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> falgType</span><span class="id"> F0</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> 'AHom</span>(<span class="id">L,</span><span class="id"> rT</span>)) (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">is_aspace</span> (<span class="id">f</span><span class="id"> @:</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /is_aspace</span><span class="id"> -aimgM</span><span class="id"> limgS</span><span class="id"> ?prodv_id</span><span class="id"> //</span><span class="id"> has_algid1</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/memv_imgP;</span><span class="gallina-kwd"> exists</span><span class="id"> 1;</span><span class="id"> rewrite</span><span class="id"> ?mem1v</span><span class="id"> ?rmorph1</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> aimg_aspace</span><span class="id"> rT</span><span class="id"> f</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> ASpace</span> (<span class="id">@aimg_is_aspace</span><span class="id"> rT</span><span class="id"> f</span><span class="id"> E</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_idP</span><span class="id"> {K</span><span class="id"> x}</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">&lt;&lt;K;</span><span class="id"> x&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> K</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> K</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/addv_idPl-&gt;</span><span class="id"> |</span><span class="id"> &lt;-];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subfield_closed</span>.<br/>
<span class="id">exact:</span><span class="id"> memv_adjoin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin0</span><span class="id"> K</span><span class="id"> :</span><span class="id"> &lt;&lt;K;</span><span class="id"> 0&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> K</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addv0</span><span class="id"> subfield_closed</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_nil</span><span class="id"> K</span><span class="id"> :</span><span class="id"> &lt;&lt;K</span><span class="id"> &amp;</span><span class="id"> [::]&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> K</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> adjoin_nil</span><span class="id"> subfield_closed</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> FadjoinP</span><span class="id"> {K</span><span class="id"> x</span><span class="id"> E}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">K</span><span class="id"> &lt;=</span><span class="id"> E</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> E</span>)<span class="id">%VS</span> (<span class="id">&lt;&lt;K;</span><span class="id"> x&gt;&gt;%AS</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [sKxE</span><span class="id"> |</span><span class="id"> /andP]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subvP</span><span class="id"> sKxE</span>)<span class="id"> ?memv_adjoin</span><span class="id"> //</span> (<span class="id">subv_trans</span><span class="id"> _</span><span class="id"> sKxE</span>)<span class="id"> ?subv_adjoin</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subv_add</span><span class="id"> =&gt;</span><span class="id"> /agenvS;</span><span class="id"> rewrite</span><span class="id"> subfield_closed</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_seqP</span><span class="id"> {K}</span><span class="id"> {rs</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> L}</span><span class="id"> {E}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">K</span><span class="id"> &lt;=</span><span class="id"> E</span><span class="id"> /\</span><span class="id"> {subset</span><span class="id"> rs</span><span class="id"> &lt;=</span><span class="id"> E}</span>)<span class="id">%VS</span> (<span class="id">&lt;&lt;K</span><span class="id"> &amp;</span><span class="id"> rs&gt;&gt;</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [sKrsE</span><span class="id"> |</span><span class="id"> [sKE</span><span class="id"> /span_subvP/</span>(<span class="id">conj</span><span class="id"> sKE</span>)<span class="id">/andP]]</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [|x</span><span class="id"> rs_x];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subv_trans</span> (<span class="id">subv_adjoin_seq</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> sKrsE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subvP</span><span class="id"> sKrsE</span>)<span class="id"> ?seqv_sub_adjoin</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subv_add</span><span class="id"> =&gt;</span><span class="id"> /agenvS;</span><span class="id"> rewrite</span><span class="id"> subfield_closed</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> alg_polyOver</span><span class="id"> E</span><span class="id"> p</span><span class="id"> :</span><span class="id"> map_poly</span> (<span class="id">in_alg</span><span class="id"> L</span>)<span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">polyOverS</span> (<span class="id">subvP</span> (<span class="id">sub1v</span><span class="id"> _</span>)))<span class="id">/polyOver1P;</span><span class="gallina-kwd"> exists</span><span class="id"> p</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_adjoin1v</span><span class="id"> x</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">&lt;&lt;1;</span><span class="id"> x&gt;&gt;</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> E</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sameP</span><span class="id"> FadjoinP</span><span class="id"> andP</span>)<span class="id"> sub1v</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> vsval_multiplicative</span><span class="id"> K</span><span class="id"> :</span><span class="id"> multiplicative</span> (<span class="id">vsval</span><span class="id"> :</span><span class="id"> subvs_of</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> L</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> algid1</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span> (<span class="id">subvs_of</span><span class="id"> K</span>)<span class="id"> L</span><span class="id"> vsval</span> (<span class="id">vsval_multiplicative</span><span class="id"> K</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> vsval_invf</span><span class="id"> K</span> (<span class="id">w</span><span class="id"> :</span><span class="id"> subvs_of</span><span class="id"> K</span>)<span class="id"> :</span><span class="id"> val</span><span class="id"> w^-1</span><span class="id"> =</span> (<span class="id">vsval</span><span class="id"> w</span>)<span class="id">^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> Uv]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> w</span><span class="id"> 0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !invr0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> vsval_invr;</span><span class="id"> rewrite</span><span class="id"> unitfE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> aspace_divr_closed</span><span class="id"> K</span><span class="id"> :</span><span class="id"> divr_closed</span><span class="id"> K</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> split=&gt;</span><span class="id"> [|u</span><span class="id"> v</span><span class="id"> Ku</span><span class="id"> Kv];</span><span class="id"> rewrite</span><span class="id"> ?mem1v</span><span class="id"> ?memvM</span><span class="id"> ?memvV</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> K</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isDivClosed</span>.<span class="id">Build</span><span class="id"> L</span> (<span class="id">pred_of_vspace</span><span class="id"> K</span>) (<span class="id">aspace_divr_closed</span><span class="id"> K</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isSubPzSemiRing</span>.<span class="id">Build</span><span class="id"> L</span> (<span class="id">pred_of_vspace</span><span class="id"> K</span>) (<span class="id">subvs_of</span><span class="id"> K</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">rmorphM</span><span class="id"> _,</span><span class="id"> rmorph1</span><span class="id"> _</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[SubNzRing_isSubComNzRing</span><span class="id"> of</span><span class="id"> subvs_of</span><span class="id"> K</span><span class="gallina-kwd"> by</span><span class="id"> &lt;:]</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[SubComUnitRing_isSubIntegralDomain</span><span class="id"> of</span><span class="id"> subvs_of</span><span class="id"> K</span><span class="gallina-kwd"> by</span><span class="id"> &lt;:]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subvs_fieldMixin</span><span class="id"> K</span><span class="id"> :</span><span class="id"> GRing</span>.<span class="id">field_axiom</span> (<span class="id">subvs_of</span><span class="id"> K</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> w</span><span class="id"> nz_w;</span><span class="id"> rewrite</span><span class="id"> unitrE</span><span class="id"> -val_eqE</span><span class="id"> /=</span><span class="id"> vsval_invf</span><span class="id"> algid1</span><span class="id"> divff</span>.<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">UnitRing_isField</span>.<span class="id">Build</span> (<span class="id">subvs_of</span><span class="id"> K</span>)<br/>
&nbsp;&nbsp;(<span class="id">@subvs_fieldMixin</span><span class="id"> K</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> polyOver_subvs</span><span class="id"> {K}</span><span class="id"> {p</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> L}}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> q</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> subvs_of</span><span class="id"> K},</span><span class="id"> p</span><span class="id"> =</span><span class="id"> map_poly</span><span class="id"> vsval</span><span class="id"> q</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> polyOverP</span>)<span class="id"> =&gt;</span><span class="id"> [Hp</span><span class="id"> |</span><span class="id"> [q</span><span class="id"> -&gt;]</span><span class="id"> i];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> coef_map</span><span class="id"> //</span><span class="id"> subvsP</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">\poly_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> p</span>) (<span class="id">Subvs</span> (<span class="id">Hp</span><span class="id"> i</span>)))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -{1}[p]coefK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/polyP=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> coef_map</span><span class="id"> !coef_poly;</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> divp_polyOver</span><span class="id"> K</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> p</span><span class="id"> q,</span><span class="id"> p</span><span class="id"> %/</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /polyOver_subvs[p</span><span class="id"> -&gt;]</span><span class="id"> /polyOver_subvs[q</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/polyOver_subvs;</span><span class="gallina-kwd"> exists</span> (<span class="id">p</span><span class="id"> %/</span><span class="id"> q</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> map_divp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modp_polyOver</span><span class="id"> K</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> p</span><span class="id"> q,</span><span class="id"> p</span><span class="id"> %%</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /polyOver_subvs[p</span><span class="id"> -&gt;]</span><span class="id"> /polyOver_subvs[q</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/polyOver_subvs;</span><span class="gallina-kwd"> exists</span> (<span class="id">p</span><span class="id"> %%</span><span class="id"> q</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> map_modp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gcdp_polyOver</span><span class="id"> K</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> p</span><span class="id"> q,</span><span class="id"> gcdp</span><span class="id"> p</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /polyOver_subvs[p</span><span class="id"> -&gt;]</span><span class="id"> /polyOver_subvs[q</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/polyOver_subvs;</span><span class="gallina-kwd"> exists</span> (<span class="id">gcdp</span><span class="id"> p</span><span class="id"> q</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> gcdp_map</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> prodv_is_aspace</span><span class="id"> E</span><span class="id"> F</span><span class="id"> :</span><span class="id"> is_aspace</span> (<span class="id">E</span><span class="id"> *</span><span class="id"> F</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /is_aspace</span><span class="id"> prodvCA</span><span class="id"> -!prodvA</span><span class="id"> prodvA</span><span class="id"> !prodv_id</span><span class="id"> has_algid1</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[1]mulr1</span><span class="id"> memv_mul</span><span class="id"> ?mem1v</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> prodv_aspace</span><span class="id"> E</span><span class="id"> F</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span><span class="id"> :=</span><span class="id"> ASpace</span> (<span class="id">prodv_is_aspace</span><span class="id"> E</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> field_mem_algid</span><span class="id"> E</span><span class="id"> F</span><span class="id"> :</span><span class="id"> algid</span><span class="id"> E</span><span class="id"> \in</span><span class="id"> F</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> algid1</span><span class="id"> mem1v</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> capv_aspace</span><span class="id"> E</span><span class="id"> F</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span><span class="id"> :=</span><span class="id"> aspace_cap</span> (<span class="id">field_mem_algid</span><span class="id"> E</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> polyOverSv</span><span class="id"> U</span><span class="id"> V</span><span class="id"> :</span> (<span class="id">U</span><span class="id"> &lt;=</span><span class="id"> V</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> polyOver</span><span class="id"> U</span><span class="id"> &lt;=</span><span class="id"> polyOver</span><span class="id"> V}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/subvP=&gt;</span><span class="id"> sUV;</span><span class="id"> apply:</span><span class="id"> polyOverS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_subvMl</span><span class="id"> F</span><span class="id"> U</span><span class="id"> :</span> (<span class="id">U</span><span class="id"> &lt;=</span><span class="id"> F</span><span class="id"> *</span><span class="id"> U</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{1}[U]prod1v</span><span class="id"> prodvSl</span><span class="id"> ?sub1v</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_subvMr</span><span class="id"> U</span><span class="id"> F</span><span class="id"> :</span> (<span class="id">U</span><span class="id"> &lt;=</span><span class="id"> U</span><span class="id"> *</span><span class="id"> F</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prodvC</span><span class="id"> field_subvMl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_module_eq</span><span class="id"> F</span><span class="id"> M</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> -&gt;</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> =</span><span class="id"> M</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> modM;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> modM</span><span class="id"> field_subvMl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sup_field_module</span><span class="id"> F</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> E</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> =</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/idP/idP;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subv_trans</span> (<span class="id">field_subvMr</span><span class="id"> F</span><span class="id"> E</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">prodvSl</span><span class="id"> E</span>)<span class="id">/subv_trans-&gt;;</span><span class="id"> rewrite</span><span class="id"> ?asubv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_module_dimS</span><span class="id"> F</span><span class="id"> M</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> -&gt;</span> (<span class="id">\dim</span><span class="id"> F</span><span class="id"> %|</span><span class="id"> \dim</span><span class="id"> M</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/skew_field_module_dimS/fieldP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_dimS</span><span class="id"> F</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span> (<span class="id">\dim</span><span class="id"> F</span><span class="id"> %|</span><span class="id"> \dim</span><span class="id"> E</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/skew_field_dimS/fieldP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_field_module</span><span class="id"> F</span><span class="id"> M</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> \dim</span><span class="id"> M</span><span class="id"> =</span> (<span class="id">\dim_F</span><span class="id"> M</span><span class="id"> *</span><span class="id"> \dim</span><span class="id"> F</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/field_module_dimS/divnK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_sup_field</span><span class="id"> F</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> \dim</span><span class="id"> E</span><span class="id"> =</span> (<span class="id">\dim_F</span><span class="id"> E</span><span class="id"> *</span><span class="id"> \dim</span><span class="id"> F</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/field_dimS/divnK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> field_module_semisimple</span><span class="id"> F</span><span class="id"> M</span> (<span class="id">m</span><span class="id"> :=</span><span class="id"> \dim_F</span><span class="id"> M</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">F</span><span class="id"> *</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{X</span><span class="id"> :</span><span class="id"> m</span>.<span class="id">-tuple</span><span class="id"> L</span><span class="id"> |</span><span class="id"> {subset</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> M}</span><span class="id"> /\</span><span class="id"> 0</span><span class="id"> \notin</span><span class="id"> X</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> let</span><span class="id"> FX</span><span class="id"> :=</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> m</span>)<span class="id"> F</span><span class="id"> *</span><span class="id"> &lt;[X`_i]&gt;</span>)<span class="id">%VS</span><span class="gallina-kwd"> in</span><span class="id"> FX</span><span class="id"> =</span><span class="id"> M</span><span class="id"> /\</span><span class="id"> directv</span><span class="id"> FX}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> modM;</span><span class="id"> have</span><span class="id"> dimM:</span> (<span class="id">m</span><span class="id"> *</span><span class="id"> \dim</span><span class="id"> F</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> \dim</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -dim_field_module</span>.<br/>
<span class="id">have</span><span class="id"> [X</span><span class="id"> [defM</span><span class="id"> dxFX</span><span class="id"> nzX]]</span><span class="id"> :=</span><span class="id"> skew_field_module_semisimple</span> (<span class="id">@fieldP</span><span class="id"> L</span>)<span class="id"> modM</span>.<br/>
<span class="id">have</span><span class="id"> szX:</span><span class="id"> size</span><span class="id"> X</span><span class="id"> ==</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eqn_pmul2r</span> (<span class="id">adim_gt0</span><span class="id"> F</span>))<span class="id"> dimM</span><span class="id"> -defM</span> (<span class="id">directvP</span><span class="id"> dxFX</span>)<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -sum1_size</span><span class="id"> big_distrl;</span><span class="id"> apply/eqP/eq_big_seq</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Xx</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul1n</span><span class="id"> dim_cosetv</span><span class="id"> ?</span>(<span class="id">memPn</span><span class="id"> nzX</span>).<br/>
<span class="id">rewrite</span><span class="id"> directvE</span><span class="id"> /=</span> (<span class="id">big_nth</span><span class="id"> 0</span>)<span class="id"> [eqbRHS]</span>(<span class="id">big_nth</span><span class="id"> 0</span>)<span class="gallina-kwd"> in</span><span class="id"> defM</span><span class="id"> dxFX</span>.<br/>
<span class="id">rewrite</span> (<span class="id">eqP</span><span class="id"> szX</span>)<span class="id"> !big_mkord</span><span class="id"> -directvE</span><span class="gallina-kwd"> in</span><span class="id"> defM</span><span class="id"> dxFX</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">Tuple</span><span class="id"> szX</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /tnthP[i</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span> (<span class="id">tnth_nth</span><span class="id"> 0</span>)<span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defM</span><span class="id"> memvE</span> (<span class="id">sumv_sup</span><span class="id"> i</span>)<span class="id"> ?field_subvMl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> FadjoinPolyDefinitions</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">U</span><span class="id"> :</span><span class="id"> {vspace</span><span class="id"> L}</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> L</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> adjoin_degree</span><span class="id"> :=</span> (<span class="id">\dim_U</span><span class="id"> &lt;&lt;U;</span><span class="id"> x&gt;&gt;</span>).<span class="id">-1</span>.<span class="id">+1</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> adjoin_degree</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> Fadjoin_sum</span><span class="id"> :=</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> U</span><span class="id"> *</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> i]&gt;</span>)<span class="id">%VS</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> Fadjoin_poly</span><span class="id"> v</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> L}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">\poly_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> n</span>) (<span class="id">sumv_pi</span><span class="id"> Fadjoin_sum</span> (<span class="id">inord</span><span class="id"> i</span>)<span class="id"> v</span><span class="id"> /</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> minPoly</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> L}</span><span class="id"> :=</span><span class="id"> 'X^n</span><span class="id"> -</span><span class="id"> Fadjoin_poly</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_Fadjoin_poly</span><span class="id"> v</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">Fadjoin_poly</span><span class="id"> v</span>)<span class="id"> &lt;=</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> size_poly</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_polyOver</span><span class="id"> v</span><span class="id"> :</span><span class="id"> Fadjoin_poly</span><span class="id"> v</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> U</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/</span>(<span class="id">all_nthP</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> coef_poly</span><span class="id"> /=</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> lti;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> mem0v</span>.<br/>
<span class="id">have</span><span class="id"> /memv_cosetP[y</span><span class="id"> Uy</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> memv_sum_pi</span> (<span class="id">erefl</span><span class="id"> Fadjoin_sum</span>) (<span class="id">inord</span><span class="id"> i</span>)<span class="id"> v</span>.<br/>
<span class="id">rewrite</span><span class="id"> inordK</span><span class="id"> //;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> /mulfK-&gt;</span><span class="id"> //]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> i</span>)<span class="id"> 0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr0</span><span class="id"> mul0r</span><span class="id"> mem0v</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> Fadjoin_poly_is_linear</span><span class="id"> :</span><span class="id"> linear_for</span> (<span class="id">in_alg</span><span class="id"> L</span><span class="id"> \;</span><span class="id"> *:%R</span>)<span class="id"> Fadjoin_poly</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> apply/polyP=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> coefD</span><span class="id"> coefZ</span><span class="id"> !coef_poly</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> lti;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulr0</span><span class="id"> addr0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> linearP</span><span class="id"> mulrA</span><span class="id"> -mulrDl</span><span class="id"> mulr_algl</span>.<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isSemilinear</span>.<span class="id">Build</span><span class="id"> F0</span><span class="id"> L</span><span class="id"> {poly</span><span class="id"> L}</span><span class="id"> _</span><span class="id"> Fadjoin_poly</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">GRing</span>.<span class="id">semilinear_linear</span><span class="id"> Fadjoin_poly_is_linear</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_minPoly</span><span class="id"> :</span><span class="id"> size</span><span class="id"> minPoly</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_polyDl</span><span class="id"> ?size_polyXn</span><span class="id"> //</span><span class="id"> size_polyN</span><span class="id"> ltnS</span><span class="id"> size_poly</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> monic_minPoly</span><span class="id"> :</span><span class="id"> minPoly</span><span class="id"> \is</span><span class="id"> monic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> monicE</span><span class="id"> /lead_coef</span><span class="id"> size_minPoly</span><span class="id"> coefB</span><span class="id"> coefXn</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_default</span><span class="id"> ?subr0</span><span class="id"> ?size_poly</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FadjoinPolyDefinitions</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FadjoinPoly</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> L</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">adjoin_degree</span> (<span class="id">asval</span><span class="id"> K</span>)<span class="id"> x</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> sumKx</span><span class="id"> :=</span> (<span class="id">Fadjoin_sum</span> (<span class="id">asval</span><span class="id"> K</span>)<span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> adjoin_degreeE</span><span class="id"> :</span><span class="id"> n</span><span class="id"> =</span><span class="id"> \dim_K</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [n]prednK</span><span class="id"> //</span><span class="id"> divn_gt0</span><span class="id"> ?adim_gt0</span><span class="id"> //</span><span class="id"> dimvS</span><span class="id"> ?subv_adjoin</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_Fadjoin</span><span class="id"> :</span><span class="id"> \dim</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;</span><span class="id"> =</span> (<span class="id">n</span><span class="id"> *</span><span class="id"> \dim</span><span class="id"> K</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> adjoin_degreeE</span><span class="id"> -dim_sup_field</span><span class="id"> ?subv_adjoin</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> adjoin0_deg</span><span class="id"> :</span><span class="id"> adjoin_degree</span><span class="id"> K</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /adjoin_degree</span><span class="id"> addv0</span><span class="id"> subfield_closed</span><span class="id"> divnn</span><span class="id"> adim_gt0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> adjoin_deg_eq1</span><span class="id"> :</span> (<span class="id">n</span><span class="id"> ==</span><span class="id"> 1</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> K</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (<span class="id">sameP</span><span class="id"> Fadjoin_idP</span><span class="id"> eqP</span>)<span class="id"> adjoin_degreeE;</span><span class="id"> have</span><span class="id"> sK_Kx</span><span class="id"> :=</span><span class="id"> subv_adjoin</span><span class="id"> K</span><span class="id"> x</span>.<br/>
<span class="id">apply/eqP/idP=&gt;</span><span class="id"> [dimKx1</span><span class="id"> |</span><span class="id"> /eqP-&gt;];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> divnn</span><span class="id"> adim_gt0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEdim</span><span class="id"> sK_Kx</span><span class="id"> /=</span> (<span class="id">dim_sup_field</span><span class="id"> sK_Kx</span>)<span class="id"> dimKx1</span><span class="id"> mul1n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_sum_direct</span><span class="id"> :</span><span class="id"> directv</span><span class="id"> sumKx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> directvE</span><span class="id"> /=;</span><span class="id"> case:</span> (<span class="id">ubnPgeq</span><span class="id"> n</span>) (<span class="id">isT</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> -[//|m]</span><span class="id"> ltmn</span><span class="id"> _</span>.<br/>
<span class="id">elim:</span><span class="id"> m</span><span class="id"> ltmn</span><span class="id"> =&gt;</span><span class="id"> [|m</span><span class="id"> IHm]</span><span class="id"> ltm1n;</span><span class="id"> rewrite</span><span class="id"> ?big_ord1</span><span class="id"> //</span><span class="id"> !</span>(<span class="id">big_ord_recr</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id"> /=</span>.<br/>
<span class="id">do</span><span class="id"> [move/</span>(_ (<span class="id">ltnW</span><span class="id"> ltm1n</span>))<span class="id">/eqP;</span><span class="id"> set</span><span class="id"> S</span><span class="id"> :=</span> (<span class="id">\sum_i</span><span class="id"> _</span>)<span class="id">%VS]</span><span class="gallina-kwd"> in</span><span class="id"> IHm</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> -IHm</span><span class="id"> dimv_add_leqif;</span><span class="id"> apply/subvP=&gt;</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> memv_cap</span><span class="id"> =&gt;</span><span class="id"> /andP[Sz]</span>.<br/>
<span class="id">case/memv_cosetP=&gt;</span><span class="id"> y</span><span class="id"> Ky</span><span class="id"> Dz;</span><span class="id"> rewrite</span><span class="id"> memv0</span><span class="id"> Dz</span><span class="id"> mulf_eq0</span><span class="id"> expf_eq0</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span><span class="id"> contraLR</span><span class="id"> ltm1n</span><span class="id"> =&gt;</span><span class="id"> /norP[nz_y</span><span class="id"> nz_x]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -leqNgt</span><span class="id"> -</span>(<span class="id">leq_pmul2r</span> (<span class="id">adim_gt0</span><span class="id"> K</span>))<span class="id"> -dim_Fadjoin</span>.<br/>
<span class="id">have{IHm}</span><span class="id"> -&gt;:</span> (<span class="id">m</span>.<span class="id">+1</span><span class="id"> *</span><span class="id"> \dim</span><span class="id"> K</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> \dim</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[m</span>.<span class="id">+1]card_ord</span><span class="id"> -sum_nat_const</span><span class="id"> IHm</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> dim_cosetv</span><span class="id"> ?expf_neq0</span>.<br/>
<span class="id">apply/dimvS/agenv_sub_modl;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sumv_sup</span><span class="id"> 0</span>)<span class="id"> //=</span><span class="id"> prodv1</span><span class="id"> sub1v</span>.<br/>
<span class="id">rewrite</span><span class="id"> prodvDl</span><span class="id"> subv_add</span><span class="id"> -[S]big_distrr</span><span class="id"> prodvA</span><span class="id"> prodv_id</span><span class="id"> subvv</span><span class="id"> !big_distrr</span><span class="id"> /=</span>.<br/>
<span class="id">apply/subv_sumP=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -expv_line</span><span class="id"> prodvCA</span><span class="id"> -expvSl</span><span class="id"> expv_line</span>.<br/>
<span class="id">have</span><span class="id"> [ltim</span><span class="id"> |</span><span class="id"> lemi]</span><span class="id"> :=</span><span class="id"> ltnP</span><span class="id"> i</span><span class="id"> m;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sumv_sup</span> (<span class="id">Sub</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> _</span>)).<br/>
<span class="id">have{lemi}</span><span class="id"> /eqP-&gt;:</span><span class="id"> i</span><span class="id"> ==</span><span class="id"> m</span><span class="id"> :&gt;</span><span class="id"> nat</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> leq_ord</span>.<br/>
<span class="id">rewrite</span><span class="id"> -big_distrr</span><span class="id"> -2!{2}</span>(<span class="id">prodv_id</span><span class="id"> K</span>)<span class="id"> /=</span><span class="id"> -!prodvA</span><span class="id"> big_distrr</span><span class="id"> -/S</span><span class="id"> prodvSr</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">canLR</span> (<span class="id">mulKf</span><span class="id"> nz_y</span>)<span class="id"> Dz</span>)<span class="id"> -memvE</span><span class="id"> memv_mul</span><span class="id"> ?rpredV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nz_x_i</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> 'I_n</span>)<span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expf_eq0;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [-&gt;|_]</span><span class="id"> [[]]</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> adjoin0_deg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_eq_sum</span><span class="id"> :</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> sumKx</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEdim</span><span class="id"> eq_leq</span><span class="id"> ?andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subv_sumP=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -agenvM</span><span class="id"> prodvS</span><span class="id"> ?subv_adjoin</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -expv_line</span> (<span class="id">subv_trans</span> (<span class="id">subX_agenv</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> ?agenvS</span><span class="id"> ?addvSr</span>.<br/>
<span class="id">rewrite</span><span class="id"> dim_Fadjoin</span><span class="id"> -[n]card_ord</span><span class="id"> -sum_nat_const</span> (<span class="id">directvP</span><span class="id"> Fadjoin_sum_direct</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> dim_cosetv</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_poly_eq</span><span class="id"> v</span><span class="id"> :</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;%VS</span><span class="id"> -&gt;</span> (<span class="id">Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v</span>).<span class="id">[x]</span><span class="id"> =</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/</span>(<span class="id">sumv_pi_sum</span><span class="id"> Fadjoin_eq_sum</span>)<span class="id">=&gt;</span><span class="id"> {2}&lt;-;</span><span class="id"> rewrite</span><span class="id"> horner_poly</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> inord_val</span><span class="id"> mulfVK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mempx_Fadjoin</span><span class="id"> p</span><span class="id"> :</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> p</span>.<span class="id">[x]</span><span class="id"> \in</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Kp;</span><span class="id"> rewrite</span><span class="id"> rpred_horner</span><span class="id"> ?memv_adjoin</span><span class="id"> ?</span>(<span class="id">polyOverS</span><span class="id"> _</span><span class="id"> Kp</span>)<span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> subvP_adjoin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_polyP</span><span class="id"> {v}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> p,</span><span class="id"> p</span><span class="id"> \in</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> &amp;</span><span class="id"> v</span><span class="id"> =</span><span class="id"> p</span>.<span class="id">[x]</span>) (<span class="id">v</span><span class="id"> \in</span><span class="id"> &lt;&lt;K;</span><span class="id"> x&gt;&gt;%VS</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [Kx_v</span><span class="id"> |</span><span class="id"> [p</span><span class="id"> Kp</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> mempx_Fadjoin</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?Fadjoin_polyOver</span><span class="id"> ?Fadjoin_poly_eq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_poly_unique</span><span class="id"> p</span><span class="id"> v</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> p</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> p</span>.<span class="id">[x]</span><span class="id"> =</span><span class="id"> v</span><span class="id"> -&gt;</span><span class="id"> Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v</span><span class="id"> =</span><span class="id"> p</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> polyKx</span><span class="id"> q</span><span class="id"> i:</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> q`_i</span><span class="id"> *</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> \in</span> (<span class="id">K</span><span class="id"> *</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> i]&gt;</span>)<span class="id">%VS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/polyOverP=&gt;</span><span class="id"> Kq;</span><span class="id"> rewrite</span><span class="id"> memv_mul</span><span class="id"> ?Kq</span><span class="id"> ?memv_line</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> Kp</span><span class="id"> szp</span><span class="id"> Dv;</span><span class="id"> have</span><span class="id"> /Fadjoin_poly_eq/eqP</span><span class="id"> :=</span><span class="id"> mempx_Fadjoin</span><span class="id"> Kp</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}Dv</span><span class="id"> {Dv}</span><span class="id"> !</span>(<span class="id">@horner_coef_wide</span><span class="id"> _</span><span class="id"> n</span>)<span class="id"> ?size_poly</span><span class="id"> //</span>.<br/>
<span class="id">move/polyKx</span><span class="gallina-kwd"> in</span><span class="id"> Kp;</span><span class="id"> have</span><span class="id"> /polyKx</span><span class="id"> K_pv</span><span class="id"> :=</span><span class="id"> Fadjoin_polyOver</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v</span>.<br/>
<span class="id">rewrite</span> (<span class="id">directv_sum_unique</span><span class="id"> Fadjoin_sum_direct</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /eqfunP</span><span class="id"> eq_pq</span>.<br/>
<span class="id">apply/polyP=&gt;</span><span class="id"> i;</span><span class="id"> have</span><span class="id"> [leni|?]</span><span class="id"> :=</span><span class="id"> leqP</span><span class="id"> n</span><span class="id"> i;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> mulIf</span> (<span class="id">eq_pq</span> (<span class="id">Sub</span><span class="id"> i</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !nth_default</span><span class="id"> ?</span>(<span class="id">leq_trans</span><span class="id"> _</span><span class="id"> leni</span>)<span class="id"> ?size_poly</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_polyC</span><span class="id"> v</span><span class="id"> :</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v</span><span class="id"> =</span><span class="id"> v%:P</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Kv;</span><span class="id"> apply:</span><span class="id"> Fadjoin_poly_unique;</span><span class="id"> rewrite</span><span class="id"> ?polyOverC</span><span class="id"> ?hornerC</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_polyC</span> (<span class="id">leq_trans</span> (<span class="id">leq_b1</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_polyX</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 'X</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> K'x;</span><span class="id"> apply:</span><span class="id"> Fadjoin_poly_unique;</span><span class="id"> rewrite</span><span class="id"> ?polyOverX</span><span class="id"> ?hornerX</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_polyX</span><span class="id"> ltn_neqAle</span><span class="id"> andbT</span><span class="id"> eq_sym</span><span class="id"> adjoin_deg_eq1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPolyOver</span><span class="id"> :</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /minPoly</span><span class="id"> rpredB</span><span class="id"> ?rpredX</span><span class="id"> ?polyOverX</span><span class="id"> ?Fadjoin_polyOver</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPolyxx</span><span class="id"> :</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>).<span class="id">[x]</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !hornerE</span><span class="id"> Fadjoin_poly_eq</span><span class="id"> ?subrr</span><span class="id"> ?rpredX</span><span class="id"> ?memv_adjoin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> root_minPoly</span><span class="id"> :</span><span class="id"> root</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> x</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/rootP/minPolyxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin_poly_mod</span><span class="id"> p</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> Fadjoin_poly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> p</span>.<span class="id">[x]</span><span class="id"> =</span><span class="id"> p</span><span class="id"> %%</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Kp;</span><span class="id"> rewrite</span><span class="id"> {1}</span>(<span class="id">divp_eq</span><span class="id"> p</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>))<span class="id"> 2!hornerE</span><span class="id"> minPolyxx</span><span class="id"> mulr0</span><span class="id"> add0r</span>.<br/>
<span class="id">apply:</span><span class="id"> Fadjoin_poly_unique</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> modp_polyOver</span><span class="id"> //</span><span class="id"> minPolyOver</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ltnS</span><span class="id"> -size_minPoly</span><span class="id"> ltn_modp</span><span class="id"> //</span><span class="id"> monic_neq0</span><span class="id"> ?monic_minPoly</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPoly_XsubC</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 'X</span><span class="id"> -</span><span class="id"> x%:P</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> K</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> x;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [Kx</span><span class="id"> |</span><span class="id"> Dp];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> x</span><span class="id"> =</span><span class="id"> -</span><span class="id"> p`_0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpredN</span> (<span class="id">polyOverP</span><span class="id"> minPolyOver</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dp</span><span class="id"> coefB</span><span class="id"> coefX</span><span class="id"> coefC</span><span class="id"> add0r</span><span class="id"> opprK</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@all_roots_prod_XsubC</span><span class="id"> _</span><span class="id"> p</span><span class="id"> [::</span><span class="id"> x]</span>)<span class="id"> /=</span><span class="id"> ?root_minPoly</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> big_seq1</span> (<span class="id">monicP</span> (<span class="id">monic_minPoly</span><span class="id"> K</span><span class="id"> x</span>))<span class="id"> scale1r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> size_minPoly</span><span class="id"> eqSS</span><span class="id"> adjoin_deg_eq1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> root_small_adjoin_poly</span><span class="id"> p</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> p</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> root</span><span class="id"> p</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ==</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Kp</span><span class="id"> szp;</span><span class="id"> apply/rootP/eqP=&gt;</span><span class="id"> [px0</span><span class="id"> |</span><span class="id"> -&gt;];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> horner0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">Fadjoin_poly_unique</span><span class="id"> Kp</span><span class="id"> szp</span><span class="id"> px0</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Fadjoin_poly_unique;</span><span class="id"> rewrite</span><span class="id"> ?polyOver0</span><span class="id"> ?size_poly0</span><span class="id"> ?horner0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPoly_irr</span><span class="id"> p</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> p</span><span class="id"> %|</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> x</span><span class="id"> -&gt;</span> (<span class="id">p</span><span class="id"> %=</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> ||</span> (<span class="id">p</span><span class="id"> %=</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> dvdp_eq;</span><span class="id"> set</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> %/</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> Kp</span><span class="id"> def_pq</span>.<br/>
<span class="id">have</span><span class="id"> Kq:</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> divp_polyOver</span><span class="id"> //</span><span class="id"> minPolyOver</span>.<br/>
<span class="id">move:</span><span class="id"> q</span><span class="id"> Kq</span><span class="id"> def_pq</span><span class="id"> root_minPoly</span> (<span class="id">size_minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> q</span><span class="id"> Kq</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> rootM</span><span class="id"> =&gt;</span><span class="id"> pqx0</span><span class="id"> szpq</span>.<br/>
<span class="id">have</span><span class="id"> [nzq</span><span class="id"> nzp]:</span><span class="id"> q</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> /\</span><span class="id"> p</span><span class="id"> !=</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/norP;</span><span class="id"> rewrite</span><span class="id"> -mulf_eq0</span><span class="id"> -size_poly_eq0</span><span class="id"> szpq</span>.<br/>
<span class="id">without</span><span class="id"> loss{pqx0}</span><span class="id"> qx0:</span><span class="id"> q</span><span class="id"> p</span><span class="id"> Kp</span><span class="id"> Kq</span><span class="id"> nzp</span><span class="id"> nzq</span><span class="id"> szpq</span><span class="id"> /</span><span class="id"> root</span><span class="id"> q</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IH;</span><span class="id"> case/orP:</span><span class="id"> pqx0</span><span class="id"> =&gt;</span><span class="id"> /IH{}IH;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> IH</span>.<br/>
&nbsp;&nbsp;<span class="id">have{IH}</span><span class="id"> /orP[]:</span> (<span class="id">q</span><span class="id"> %=</span><span class="id"> p</span><span class="id"> *</span><span class="id"> q</span>)<span class="id"> ||</span> (<span class="id">q</span><span class="id"> %=</span><span class="id"> 1</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> IH</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> orbC</span><span class="id"> -{1}[q]mul1r</span><span class="id"> eqp_mul2r</span><span class="id"> //</span><span class="id"> eqp_sym</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}[p]mul1r</span><span class="id"> eqp_sym</span><span class="id"> eqp_mul2r</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">apply/orP;</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> -size_poly_eq1</span><span class="id"> eqn_leq</span><span class="id"> lt0n</span><span class="id"> size_poly_eq0</span><span class="id"> nzp</span><span class="id"> andbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">leq_add2r</span> (<span class="id">size</span><span class="id"> q</span>))<span class="id"> -leq_subLR</span><span class="id"> subn1</span><span class="id"> -size_mul</span><span class="id"> //</span><span class="id"> mulrC</span><span class="id"> szpq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltnNge;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> nzq</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">root_small_adjoin_poly</span><span class="id"> Kq</span>)<span class="id"> &lt;-</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPoly_dvdp</span><span class="id"> p</span><span class="id"> :</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> -&gt;</span><span class="id"> root</span><span class="id"> p</span><span class="id"> x</span><span class="id"> -&gt;</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> %|</span><span class="id"> p</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Kp</span><span class="id"> rootp</span>.<br/>
<span class="id">have</span><span class="id"> gcdK</span><span class="id"> :</span><span class="id"> gcdp</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gcdp_polyOver</span><span class="id"> ?minPolyOver</span>.<br/>
<span class="id">have</span><span class="id"> /orP[gcd_eqK|gcd_eq1]</span><span class="id"> :=</span><span class="id"> minPoly_irr</span><span class="id"> gcdK</span> (<span class="id">dvdp_gcdl</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> p</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eqp_dvdl</span><span class="id"> _</span><span class="id"> gcd_eqK</span>)<span class="id"> dvdp_gcdr</span>.<br/>
<span class="id">case/negP:</span> (<span class="id">root1</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eqp_root</span><span class="id"> gcd_eq1</span>)<span class="id"> root_gcd</span><span class="id"> rootp</span><span class="id"> root_minPoly</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FadjoinPoly</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPolyS</span><span class="id"> K</span><span class="id"> E</span><span class="id"> a</span><span class="id"> :</span> (<span class="id">K</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> minPoly</span><span class="id"> E</span><span class="id"> a</span><span class="id"> %|</span><span class="id"> minPoly</span><span class="id"> K</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sKE;</span><span class="id"> apply:</span><span class="id"> minPoly_dvdp;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> root_minPoly</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">polyOverSv</span><span class="id"> sKE</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> minPolyOver</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Arguments</span><span class="id"> Fadjoin_polyP</span><span class="id"> {K</span><span class="id"> x</span><span class="id"> v}</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> Fadjoin1_polyP</span><span class="id"> x</span><span class="id"> v</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> p,</span><span class="id"> v</span><span class="id"> =</span> (<span class="id">map_poly</span> (<span class="id">in_alg</span><span class="id"> L</span>)<span class="id"> p</span>).<span class="id">[x]</span>) (<span class="id">v</span><span class="id"> \in</span><span class="id"> &lt;&lt;1;</span><span class="id"> x&gt;&gt;%VS</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> Fadjoin_polyP</span>)<span class="id"> =&gt;</span><span class="id"> [[_</span><span class="id"> /polyOver1P]|]</span><span class="id"> [p</span><span class="id"> -&gt;];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> p</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">map_poly</span> (<span class="id">in_alg</span><span class="id"> L</span>)<span class="id"> p</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> alg_polyOver</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Horner</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> z</span><span class="id"> :</span><span class="id"> L</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fieldExt_horner</span><span class="id"> :=</span><span class="id"> horner_morph</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> mulrC</span><span class="id"> z</span> (<span class="id">in_alg</span><span class="id"> L</span><span class="id"> x</span>)).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">RMorphism</span>.<span class="id">on</span><span class="id"> fieldExt_horner</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> fieldExt_hornerC</span><span class="id"> b</span><span class="id"> :</span><span class="id"> fieldExt_horner</span><span class="id"> b%:P</span><span class="id"> =</span><span class="id"> b%:A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> horner_morphC</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> fieldExt_hornerX</span><span class="id"> :</span><span class="id"> fieldExt_horner</span><span class="id"> 'X</span><span class="id"> =</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> horner_morphX</span>. Qed.</div></details>
<span class="vernacular">Fact</span><span class="id"> fieldExt_hornerZ</span><span class="id"> :</span><span class="id"> scalable</span><span class="id"> fieldExt_horner</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> p;</span><span class="id"> rewrite</span><span class="id"> -mul_polyC</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> fieldExt_hornerC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -scalerAl</span><span class="id"> mul1r</span>.<br/>
Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isScalable</span>.<span class="id">Build</span><span class="id"> F0</span><span class="id"> {poly</span><span class="id"> F0}</span><span class="id"> L</span><span class="id"> *:%R</span><span class="id"> fieldExt_horner</span><span class="id"> fieldExt_hornerZ</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Horner</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> FieldExtTheory</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;E :&amp;: F&quot;</span><span class="id"> :=</span> (<span class="id">capv_aspace</span><span class="id"> E</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'C_ E [ x ]&quot;</span><span class="id"> :=</span> (<span class="id">capv_aspace</span><span class="id"> E</span><span class="id"> 'C[x]</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'C_ ( E ) [ x ]&quot;</span><span class="id"> :=</span> (<span class="id">capv_aspace</span><span class="id"> E</span><span class="id"> 'C[x]</span>)<br/>
&nbsp;&nbsp;(<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'C_ E ( V )&quot;</span><span class="id"> :=</span> (<span class="id">capv_aspace</span><span class="id"> E</span><span class="id"> 'C</span>(<span class="id">V</span>))<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'C_ ( E ) ( V )&quot;</span><span class="id"> :=</span> (<span class="id">capv_aspace</span><span class="id"> E</span><span class="id"> 'C</span>(<span class="id">V</span>))<br/>
&nbsp;&nbsp;(<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;E * F&quot;</span><span class="id"> :=</span> (<span class="id">prodv_aspace</span><span class="id"> E</span><span class="id"> F</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;f @: E&quot;</span><span class="id"> :=</span> (<span class="id">aimg_aspace</span><span class="id"> f</span><span class="id"> E</span>)<span class="id"> :</span><span class="id"> aspace_scope</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> Fadjoin_idP</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> FadjoinP</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> x</span><span class="id"> E}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> Fadjoin_seqP</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> rs</span><span class="id"> E}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> polyOver_subvs</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> p}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> Fadjoin_polyP</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> x</span><span class="id"> v}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> Fadjoin1_polyP</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> x</span><span class="id"> v}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> minPoly_XsubC</span><span class="id"> {F0</span><span class="id"> L</span><span class="id"> K</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MapMinPoly</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> rL</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> 'AHom</span>(<span class="id">L,</span><span class="id"> rL</span>)).<br/>
<span class="vernacular">Variables</span> (<span class="id">K</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> L</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> adjoin_degree_aimg</span><span class="id"> :</span><span class="id"> adjoin_degree</span> (<span class="id">f</span><span class="id"> @:</span><span class="id"> K</span>) (<span class="id">f</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> adjoin_degree</span><span class="id"> K</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> !adjoin_degreeE</span><span class="id"> -aimg_adjoin</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !limg_dim_eq</span><span class="id"> ?</span>(<span class="id">eqP</span> (<span class="id">AHom_lker0</span><span class="id"> f</span>))<span class="id"> ?capv0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_minPoly</span><span class="id"> :</span> <span class="id"> map_poly</span><span class="id"> f</span> (<span class="id">minPoly</span><span class="id"> K</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> minPoly</span> (<span class="id">f</span><span class="id"> @:</span><span class="id"> K</span>) (<span class="id">f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> fp</span><span class="id"> :=</span><span class="id"> minPoly</span> (<span class="id">f</span><span class="id"> @:</span><span class="id"> K</span>) (<span class="id">f</span><span class="id"> x</span>).<br/>
<span class="id">have</span><span class="id"> [p</span><span class="id"> Kp</span><span class="id"> Dp]:</span><span class="gallina-kwd"> exists2</span><span class="id"> p,</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> K</span><span class="id"> &amp;</span><span class="id"> map_poly</span><span class="id"> f</span><span class="id"> p</span><span class="id"> =</span><span class="id"> fp</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Kfp:</span><span class="id"> fp</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span> (<span class="id">f</span><span class="id"> @:</span><span class="id"> K</span>)<span class="id">%VS</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> minPolyOver</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">map_poly</span><span class="id"> f^-1%VF</span><span class="id"> fp</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> /memv_imgP[y</span><span class="id"> Ky</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> polyOverP</span><span class="id"> Kfp</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lker0_lfunK</span><span class="id"> ?AHom_lker0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -map_poly_comp</span><span class="id"> map_poly_id</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /</span>(<span class="id">allP</span><span class="id"> Kfp</span>)<span class="id">/memv_imgP[y</span><span class="id"> _</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> limg_lfunVK</span><span class="id"> ?memv_img</span><span class="id"> ?memvf</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -eqp_monic</span><span class="id"> ?monic_map</span><span class="id"> ?monic_minPoly</span><span class="id"> //</span><span class="id"> -Dp</span><span class="id"> eqp_map</span>.<br/>
<span class="id">have:</span><span class="id"> ~~</span> (<span class="id">p</span><span class="id"> %=</span><span class="id"> 1</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_poly_eq1</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> f</span>)<span class="id"> Dp</span><span class="id"> size_minPoly</span>.<br/>
<span class="id">apply:</span><span class="id"> implyP;</span><span class="id"> rewrite</span><span class="id"> implyNb</span><span class="id"> orbC</span><span class="id"> eqp_sym</span><span class="id"> minPoly_irr</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dvdp_map</span><span class="id"> f</span>)<span class="id"> Dp</span><span class="id"> minPoly_dvdp</span><span class="id"> ?fmorph_root</span><span class="id"> ?root_minPoly</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> apply/memv_img/polyOverP/minPolyOver</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MapMinPoly</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FieldOver</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fieldOver</span><span class="id"> of</span><span class="id"> {vspace</span><span class="id"> L}</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> L</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> K_F</span><span class="id"> :=</span> (<span class="id">subvs_of</span><span class="id"> F</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> L_F</span><span class="id"> :=</span> (<span class="id">fieldOver</span><span class="id"> F</span>).<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Field</span>.<span class="id">on</span><span class="id"> L_F</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> fieldOver_scale</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> K_F</span>) (<span class="id">u</span><span class="id"> :</span><span class="id"> L_F</span>)<span class="id"> :</span><span class="id"> L_F</span><span class="id"> :=</span><span class="id"> vsval</span><span class="id"> a</span><span class="id"> *</span><span class="id"> u</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Infix</span> <span class="id">&quot;*F:&quot;</span><span class="id"> :=</span><span class="id"> fieldOver_scale</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 40</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scaleA</span><span class="id"> a</span><span class="id"> b</span><span class="id"> u</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F:</span> (<span class="id">b</span><span class="id"> *F:</span><span class="id"> u</span>)<span class="id"> =</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id"> *F:</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scale1</span><span class="id"> u</span><span class="id"> :</span><span class="id"> 1</span><span class="id"> *F:</span><span class="id"> u</span><span class="id"> =</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /</span>(<span class="id">1</span><span class="id"> *F:</span><span class="id"> u</span>)<span class="id"> /=</span><span class="id"> algid1</span><span class="id"> mul1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scaleDr</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F:</span> (<span class="id">u</span><span class="id"> +</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> *F:</span><span class="id"> u</span><span class="id"> +</span><span class="id"> a</span><span class="id"> *F:</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrDr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scaleDl</span><span class="id"> v</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span> (<span class="id">a</span><span class="id"> +</span><span class="id"> b</span>)<span class="id"> *F:</span><span class="id"> v</span><span class="id"> =</span><span class="id"> a</span><span class="id"> *F:</span><span class="id"> v</span><span class="id"> +</span><span class="id"> b</span><span class="id"> *F:</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrDl</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Zmodule_isLmodule</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L_F</span><br/>
&nbsp;&nbsp;<span class="id">fieldOver_scaleA</span><span class="id"> fieldOver_scale1</span><span class="id"> fieldOver_scaleDr</span><span class="id"> fieldOver_scaleDl</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> fieldOver_scaleE</span><span class="id"> a</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> L</span>)<span class="id"> :</span><span class="id"> a</span><span class="id"> *:</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> L_F</span>)<span class="id"> =</span><span class="id"> vsval</span><span class="id"> a</span><span class="id"> *</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scaleAl</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F:</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span> (<span class="id">a</span><span class="id"> *F:</span><span class="id"> u</span>)<span class="id"> *</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrA</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lmodule_isLalgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L_F</span><br/>
&nbsp;&nbsp;<span class="id">fieldOver_scaleAl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_scaleAr</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F:</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> u</span><span class="id"> *</span> (<span class="id">a</span><span class="id"> *F:</span><span class="id"> v</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrCA</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lalgebra_isAlgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L_F</span><br/>
&nbsp;&nbsp;<span class="id">fieldOver_scaleAr</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> fieldOver_vectMixin</span><span class="id"> :</span><span class="id"> Lmodule_hasFinDim</span><span class="id"> K_F</span><span class="id"> L_F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [bL</span><span class="id"> [_</span><span class="id"> nz_bL]</span><span class="id"> [defL</span><span class="id"> dxSbL]]</span><span class="id"> :=</span><span class="id"> field_module_semisimple</span> (<span class="id">subvf</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> _</span>)).<br/>
<span class="id">do</span><span class="id"> [set</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> \dim_F</span><span class="id"> {:L}</span><span class="gallina-kwd"> in</span><span class="id"> bL</span><span class="id"> nz_bL</span><span class="id"> *;</span><span class="id"> set</span><span class="id"> SbL</span><span class="id"> :=</span> (<span class="id">\sum_i</span><span class="id"> _</span>)<span class="id">%VS]</span><span class="gallina-kwd"> in</span><span class="id"> defL</span><span class="id"> dxSbL</span>.<br/>
<span class="id">have</span><span class="id"> in_bL</span><span class="id"> i</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> K_F</span>)<span class="id"> :</span><span class="id"> val</span><span class="id"> a</span><span class="id"> *</span> (<span class="id">bL`_i</span><span class="id"> :</span><span class="id"> L_F</span>)<span class="id"> \in</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> &lt;[bL`_i]&gt;</span>)<span class="id">%VS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memv_mul</span><span class="id"> ?</span>(<span class="id">valP</span><span class="id"> a</span>)<span class="id"> ?memv_line</span>.<br/>
<span class="id">have</span><span class="id"> nz_bLi</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> 'I_n</span>)<span class="id">:</span><span class="id"> bL`_i</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">memPn</span><span class="id"> nz_bL</span>)<span class="id"> ?memt_nth</span>.<br/>
<span class="id">pose</span><span class="id"> r2v</span> (<span class="id">v</span><span class="id"> :</span><span class="id"> 'rV[K_F]_n</span>)<span class="id"> :</span><span class="id"> L_F</span><span class="id"> :=</span><span class="id"> \sum_i</span><span class="id"> v</span><span class="id"> 0</span><span class="id"> i</span><span class="id"> *:</span> (<span class="id">bL`_i</span><span class="id"> :</span><span class="id"> L_F</span>).<br/>
<span class="id">have</span><span class="id"> r2v_lin:</span><span class="id"> linear</span><span class="id"> r2v</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> /r2v</span><span class="id"> scaler_sumr</span><span class="id"> -big_split</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> scalerA</span><span class="id"> -scalerDl</span><span class="id"> !mxE</span>.<br/>
<span class="id">pose</span><span class="id"> r2vlM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isLinear</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> r2v</span><span class="id"> r2v_lin</span>.<br/>
<span class="id">pose</span><span class="id"> r2vL</span><span class="id"> :</span><span class="id"> {linear</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> r2v</span><span class="id"> r2vlM</span>.<br/>
<span class="id">have</span><span class="id"> v2rP</span><span class="id"> x:</span><span class="id"> {r</span><span class="id"> :</span><span class="id"> 'rV[K_F]_n</span><span class="id"> |</span><span class="id"> x</span><span class="id"> =</span><span class="id"> r2v</span><span class="id"> r}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> sig_eqW;</span><span class="id"> have</span><span class="id"> /memv_sumP[y</span><span class="id"> Fy</span><span class="id"> -&gt;]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> SbL</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defL</span><span class="id"> memvf</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /fin_all_exists[r</span><span class="id"> Dr]</span><span class="id"> i:</span><span class="gallina-kwd"> exists</span><span class="id"> r,</span><span class="id"> y</span><span class="id"> i</span><span class="id"> =</span><span class="id"> r</span><span class="id"> *:</span> (<span class="id">bL`_i</span><span class="id"> :</span><span class="id"> L_F</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /memv_cosetP[a</span><span class="id"> Fa</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> Fy</span><span class="id"> i</span><span class="id"> isT;</span><span class="gallina-kwd"> exists</span> (<span class="id">Subvs</span><span class="id"> Fa</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">\row_i</span><span class="id"> r</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mxE</span>.<br/>
<span class="id">pose</span><span class="id"> v2r</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> sval</span> (<span class="id">v2rP</span><span class="id"> x</span>).<br/>
<span class="id">have</span><span class="id"> v2rK:</span><span class="id"> cancel</span><span class="id"> v2r</span><span class="id"> r2vL</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /v2r</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> case:</span> (<span class="id">v2rP</span><span class="id"> x</span>).<br/>
<span class="id">suffices</span><span class="id"> r2vK:</span><span class="id"> cancel</span><span class="id"> r2v</span><span class="id"> v2r</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> n,</span><span class="id"> v2r;</span><span class="id"> [apply:</span><span class="id"> can2_linear</span><span class="id"> v2rK</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> r2v]</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> r;</span><span class="id"> apply/rowP=&gt;</span><span class="id"> i;</span><span class="id"> apply/val_inj/</span>(<span class="id">mulIf</span> (<span class="id">nz_bLi</span><span class="id"> i</span>))<span class="id">/eqP;</span><span class="id"> move:</span><span class="id"> i</span><span class="id"> isT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/forall_inP;</span><span class="id"> move/directv_sum_unique:</span><span class="id"> dxSbL</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span><span class="id"> //;</span><span class="id"> apply/eqP/v2rK</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> fieldOver_vectMixin</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">V</span><span class="id"> :</span><span class="id"> {vspace</span><span class="id"> L}</span>) (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> trivial_fieldOver</span><span class="id"> :</span> (<span class="id">1%VS</span><span class="id"> :</span><span class="id"> {vspace</span><span class="id"> L_F}</span>)<span class="id"> =i</span><span class="id"> F</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> apply/vlineP/idP=&gt;</span><span class="id"> [[{}x</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> Fx]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fieldOver_scaleE</span><span class="id"> mulr1</span> (<span class="id">valP</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">vsproj</span><span class="id"> F</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> fieldOver_scaleE</span><span class="id"> mulr1</span><span class="id"> vsprojK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> vspaceOver</span><span class="id"> V</span><span class="id"> :=</span><span class="id"> &lt;&lt;vbasis</span><span class="id"> V</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> L_F&gt;&gt;%VS</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_vspaceOver</span><span class="id"> V</span><span class="id"> :</span><span class="id"> vspaceOver</span><span class="id"> V</span><span class="id"> =i</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> V</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP;</span><span class="id"> last</span><span class="id"> rewrite</span><span class="id"> unlock;</span><span class="id"> move/coord_span-&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@memv_suml</span><span class="id"> F0</span><span class="id"> L</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memv_mul</span><span class="id"> ?subvsP</span><span class="id"> //</span><span class="id"> vbasis_mem</span><span class="id"> ?memt_nth</span>.<br/>
<span class="id">rewrite</span><span class="id"> memv_suml</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> ij</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -tnth_nth;</span><span class="id"> set</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> tnth</span><span class="id"> _</span><span class="id"> ij</span>.<br/>
<span class="id">have/allpairsP[[u</span><span class="id"> z]</span><span class="id"> /=</span><span class="id"> [Fu</span><span class="id"> Vz</span><span class="id"> {x}-&gt;]]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> mem_tnth</span><span class="id"> ij</span><span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> scalerAl</span> (<span class="id">memvZ</span> (<span class="id">Subvs</span><span class="id"> _</span>))<span class="id"> ?memvZ</span><span class="id"> ?memv_span</span><span class="id"> //=</span><span class="id"> vbasis_mem</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_aspaceOver</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> vspaceOver</span><span class="id"> E</span><span class="id"> =i</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sFE</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mem_vspaceOver</span><span class="id"> field_module_eq</span><span class="id"> ?sup_field_module</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> aspaceOver_suproof</span><span class="id"> E</span><span class="id"> :</span><span class="id"> is_aspace</span> (<span class="id">vspaceOver</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /is_aspace</span><span class="id"> has_algid1;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_vspaceOver</span> (<span class="id">@mem1v</span><span class="id"> _</span><span class="id"> L</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/prodvP=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> !mem_vspaceOver;</span><span class="id"> apply:</span><span class="id"> memvM</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> aspaceOver</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> ASpace</span> (<span class="id">aspaceOver_suproof</span><span class="id"> E</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_vspaceOver</span><span class="id"> M</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> M</span><span class="id"> &lt;=</span><span class="id"> M</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> \dim</span> (<span class="id">vspaceOver</span><span class="id"> M</span>)<span class="id"> =</span><span class="id"> \dim_F</span><span class="id"> M</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> modM;</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> field_module_semisimple</span><span class="id"> modM</span>.<br/>
<span class="id">set</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> \dim_F</span><span class="id"> M</span><span class="id"> =&gt;</span><span class="id"> b</span><span class="id"> [Mb</span><span class="id"> nz_b]</span><span class="id"> [defM</span><span class="id"> dx_b]</span>.<br/>
<span class="id">suff:</span><span class="id"> basis_of</span> (<span class="id">vspaceOver</span><span class="id"> M</span>)<span class="id"> b</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> size_basis</span>.<br/>
<span class="id">apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubv;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> apply/span_subvP=&gt;</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_vspaceOver</span><span class="id"> field_module_eq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /Mb</span>.<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">@vbasis_mem</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> M</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -defM</span><span class="id"> =&gt;</span><span class="id"> /memv_sumP[{}u</span><span class="id"> Fu</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> /memv_cosetP[a</span><span class="id"> Fa</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> Fu</span><span class="id"> i</span><span class="id"> isT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">memvZ</span> (<span class="id">Subvs</span><span class="id"> Fa</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> memv_span</span><span class="id"> ?memt_nth</span>.<br/>
<span class="id">apply/freeP=&gt;</span><span class="id"> a</span><span class="id"> /</span>(<span class="id">directv_sum_independent</span><span class="id"> dx_b</span>)<span class="id"> a_0</span><span class="id"> i</span>.<br/>
<span class="id">have{a_0}:</span><span class="id"> a</span><span class="id"> i</span><span class="id"> *:</span> (<span class="id">b`_i</span><span class="id"> :</span><span class="id"> L_F</span>)<span class="id"> ==</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> a_0</span><span class="id"> {i}//</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> memv_mul</span><span class="id"> ?memv_line</span><span class="id"> ?subvsP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> scaler_eq0=&gt;</span><span class="id"> /predU1P[]</span><span class="id"> //</span><span class="id"> /idPn[];</span><span class="id"> rewrite</span> (<span class="id">memPn</span><span class="id"> nz_b</span>)<span class="id"> ?memt_nth</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_aspaceOver</span><span class="id"> E</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> \dim</span> (<span class="id">vspaceOver</span><span class="id"> E</span>)<span class="id"> =</span><span class="id"> \dim_F</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sup_field_module;</span><span class="id"> apply:</span><span class="id"> dim_vspaceOver</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> vspaceOverP</span><span class="id"> V_F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{V</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> V_F</span><span class="id"> =</span><span class="id"> vspaceOver</span><span class="id"> V,</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> V</span><span class="id"> &lt;=</span><span class="id"> V</span>)<span class="id">%VS</span><span class="id"> &amp;</span><span class="id"> V_F</span><span class="id"> =i</span><span class="id"> V]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> V</span><span class="id"> :=</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> &lt;&lt;vbasis</span><span class="id"> V_F</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> L&gt;&gt;</span>)<span class="id">%VS</span>.<br/>
<span class="id">have</span><span class="id"> idV:</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> V</span>)<span class="id">%VS</span><span class="id"> =</span><span class="id"> V</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prodvA</span><span class="id"> prodv_id</span>.<br/>
<span class="id">suffices</span><span class="id"> defVF:</span><span class="id"> V_F</span><span class="id"> =</span><span class="id"> vspaceOver</span><span class="id"> V</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> V;</span><span class="id"> split=&gt;</span><span class="id"> [||u];</span><span class="id"> rewrite</span><span class="id"> ?defVF</span><span class="id"> ?mem_vspaceOver</span><span class="id"> ?idV</span>.<br/>
<span class="id">apply/vspaceP=&gt;</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> mem_vspaceOver</span><span class="id"> idV</span>.<br/>
<span class="id">do</span><span class="id"> [apply/idP/idP;</span><span class="id"> last</span><span class="id"> rewrite</span><span class="id"> /V</span><span class="id"> unlock]</span><span class="id"> =&gt;</span><span class="id"> [/coord_vbasis|/coord_span]</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> memv_mul</span><span class="id"> ?subvsP</span><span class="id"> ?memv_span</span><span class="id"> ?memt_nth</span>.<br/>
<span class="id">apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -tnth_nth;</span><span class="id"> set</span><span class="id"> xu</span><span class="id"> :=</span><span class="id"> tnth</span><span class="id"> _</span><span class="id"> i</span>.<br/>
<span class="id">have</span><span class="id"> /allpairsP[[x</span><span class="id"> u]</span><span class="id"> /=]:</span><span class="id"> xu</span><span class="id"> \in</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> mem_tnth</span><span class="id"> i</span><span class="id"> _</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> /vbasis_mem</span><span class="id"> Fx</span><span class="id"> /vbasis_mem</span><span class="id"> Vu</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> scalerAl</span> (<span class="id">coord_span</span><span class="id"> Vu</span>)<span class="id"> mulr_sumr</span><span class="id"> memv_suml</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j_</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -scalerCA</span> (<span class="id">memvZ</span> (<span class="id">Subvs</span><span class="id"> _</span>))<span class="id"> ?memvZ</span><span class="id"> //</span><span class="id"> vbasis_mem</span><span class="id"> ?memt_nth</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> aspaceOverP</span> (<span class="id">E_F</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L_F}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{E</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> E_F</span><span class="id"> =</span><span class="id"> aspaceOver</span><span class="id"> E,</span> (<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> &amp;</span><span class="id"> E_F</span><span class="id"> =i</span><span class="id"> E]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [V</span><span class="id"> [defEF</span><span class="id"> modV</span><span class="id"> memV]]</span><span class="id"> :=</span><span class="id"> vspaceOverP</span><span class="id"> E_F</span>.<br/>
<span class="id">have</span><span class="id"> algE:</span><span class="id"> has_algid</span><span class="id"> V</span><span class="id"> &amp;&amp;</span> (<span class="id">V</span><span class="id"> *</span><span class="id"> V</span><span class="id"> &lt;=</span><span class="id"> V</span>)<span class="id">%VS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> has_algid1;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -memV</span><span class="id"> mem1v</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/prodvP=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> -!memV;</span><span class="id"> apply:</span><span class="id"> memvM</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">ASpace</span><span class="id"> algE</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -sup_field_module;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> val_inj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FieldOver</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> BaseField</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> baseFieldType</span><span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><span class="id"> L</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> L0</span><span class="id"> :=</span><span class="id"> baseFieldType</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Field</span>.<span class="id">on</span><span class="id"> L0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> baseField_scale</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> F0</span>) (<span class="id">u</span><span class="id"> :</span><span class="id"> L0</span>)<span class="id"> :</span><span class="id"> L0</span><span class="id"> :=</span><span class="id"> in_alg</span><span class="id"> F</span><span class="id"> a</span><span class="id"> *:</span><span class="id"> u</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Infix</span> <span class="id">&quot;*F0:&quot;</span><span class="id"> :=</span><span class="id"> baseField_scale</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 40</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scaleA</span><span class="id"> a</span><span class="id"> b</span><span class="id"> u</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F0:</span> (<span class="id">b</span><span class="id"> *F0:</span><span class="id"> u</span>)<span class="id"> =</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id"> *F0:</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [_</span><span class="id"> *F0:</span><span class="id"> _]scalerA</span><span class="id"> -rmorphM</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scale1</span><span class="id"> u</span><span class="id"> :</span><span class="id"> 1</span><span class="id"> *F0:</span><span class="id"> u</span><span class="id"> =</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /</span>(<span class="id">1</span><span class="id"> *F0:</span><span class="id"> u</span>)<span class="id"> rmorph1</span><span class="id"> scale1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scaleDr</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F0:</span> (<span class="id">u</span><span class="id"> +</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> *F0:</span><span class="id"> u</span><span class="id"> +</span><span class="id"> a</span><span class="id"> *F0:</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> scalerDr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scaleDl</span><span class="id"> v</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span> (<span class="id">a</span><span class="id"> +</span><span class="id"> b</span>)<span class="id"> *F0:</span><span class="id"> v</span><span class="id"> =</span><span class="id"> a</span><span class="id"> *F0:</span><span class="id"> v</span><span class="id"> +</span><span class="id"> b</span><span class="id"> *F0:</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -scalerDl</span><span class="id"> -rmorphD</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Zmodule_isLmodule</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L0</span><br/>
&nbsp;&nbsp;<span class="id">baseField_scaleA</span><span class="id"> baseField_scale1</span><span class="id"> baseField_scaleDr</span><span class="id"> baseField_scaleDl</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> baseField_scaleE</span><span class="id"> a</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> L</span>)<span class="id"> :</span><span class="id"> a</span><span class="id"> *:</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> L0</span>)<span class="id"> =</span><span class="id"> a%:A</span><span class="id"> *:</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scaleAl</span><span class="id"> a</span> (<span class="id">u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> L0</span>)<span class="id"> :</span><span class="id"> a</span><span class="id"> *F0:</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span> (<span class="id">a</span><span class="id"> *F0:</span><span class="id"> u</span>)<span class="id"> *</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> scalerAl</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lmodule_isLalgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L0</span><br/>
&nbsp;&nbsp;<span class="id">baseField_scaleAl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_scaleAr</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *F0:</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> u</span><span class="id"> *</span> (<span class="id">a</span><span class="id"> *F0:</span><span class="id"> v</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> scalerAr</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lalgebra_isAlgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> L0</span><br/>
&nbsp;&nbsp;<span class="id">baseField_scaleAr</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> \dim</span><span class="id"> {:F}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> bF</span><span class="id"> :</span><span class="id"> n</span>.<span class="id">-tuple</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> vbasis</span><span class="id"> {:F}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> coordF</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> F</span>)<span class="id"> :=</span> (<span class="id">coord_vbasis</span> (<span class="id">memvf</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseField_vectMixin</span><span class="id"> :</span><span class="id"> Lmodule_hasFinDim</span><span class="id"> F0</span><span class="id"> L0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> bL</span><span class="id"> :=</span><span class="id"> vbasis</span><span class="id"> {:L};</span><span class="id"> set</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> \dim</span><span class="id"> {:L}</span><span class="gallina-kwd"> in</span><span class="id"> bL</span>.<br/>
<span class="id">pose</span><span class="id"> v2r</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> L0</span>)<span class="id"> :=</span><span class="id"> mxvec</span> (<span class="id">\matrix_</span>(<span class="id">i,</span><span class="id"> j</span>)<span class="id"> coord</span><span class="id"> bF</span><span class="id"> j</span> (<span class="id">coord</span><span class="id"> bL</span><span class="id"> i</span><span class="id"> x</span>)).<br/>
<span class="id">have</span><span class="id"> v2r_lin:</span><span class="id"> linear</span><span class="id"> v2r</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -linearP;</span><span class="id"> congr</span><span class="id"> mxvec;</span><span class="id"> apply/matrixP=&gt;</span><span class="id"> i</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !mxE</span><span class="id"> linearP</span><span class="id"> /=</span><span class="id"> mulr_algl</span><span class="id"> linearP</span>.<br/>
<span class="id">pose</span><span class="id"> r2v</span><span class="id"> r</span><span class="id"> :=</span><span class="id"> \sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> m</span>) (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> vec_mx</span><span class="id"> r</span><span class="id"> i</span><span class="id"> j</span><span class="id"> *:</span><span class="id"> bF`_j</span>)<span class="id"> *:</span><span class="id"> bL`_i</span>.<br/>
<span class="id">have</span><span class="id"> v2rK:</span><span class="id"> cancel</span><span class="id"> v2r</span><span class="id"> r2v</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> transitivity</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> m</span>)<span class="id"> coord</span><span class="id"> bL</span><span class="id"> i</span><span class="id"> x</span><span class="id"> *:</span><span class="id"> bL`_i</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -coord_vbasis</span><span class="id"> ?memvf</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;GG:&nbsp;rewrite&nbsp;{2}(coord_vbasis&nbsp;(memvf&nbsp;x))&nbsp;-/m&nbsp;would&nbsp;take&nbsp;8s;&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;-/m&nbsp;takes&nbsp;8s,&nbsp;and&nbsp;without&nbsp;it&nbsp;then&nbsp;apply:&nbsp;eq_bigr&nbsp;takes&nbsp;12s.&nbsp;*)</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="comment">(*&nbsp;The&nbsp;time&nbsp;drops&nbsp;to&nbsp;2s&nbsp;with&nbsp;&nbsp;a&nbsp;-[GRing.Field.ringType&nbsp;F]/(F&nbsp;:&nbsp;fieldType)&nbsp;*)</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mxvecK;</span><span class="id"> congr</span> (_<span class="id"> *:</span><span class="id"> _</span><span class="id"> :</span><span class="id"> L</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">coordF</span> (<span class="id">coord</span><span class="id"> bL</span><span class="id"> i</span><span class="id"> x</span>))<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mxE</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">m</span><span class="id"> *</span><span class="id"> n</span>)<span class="id">%N,</span><span class="id"> v2r</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> r2v</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> r</span>.<br/>
<span class="id">apply:</span> (<span class="id">canLR</span><span class="id"> vec_mxK</span>)<span class="id">;</span><span class="id"> apply/matrixP=&gt;</span><span class="id"> i</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> mxE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !coord_sum_free</span><span class="id"> ?</span>(<span class="id">basis_free</span> (<span class="id">vbasisP</span><span class="id"> _</span>)).<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> baseField_vectMixin</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> F0ZEZ</span><span class="id"> a</span><span class="id"> x</span><span class="id"> v</span><span class="id"> :</span><span class="id"> a</span><span class="id"> *:</span> ((<span class="id">x</span><span class="id"> *:</span><span class="id"> v</span><span class="id"> :</span><span class="id"> L</span>)<span class="id"> :</span><span class="id"> L0</span>) <span class="id"> =</span> (<span class="id">a</span><span class="id"> *:</span><span class="id"> x</span>)<span class="id"> *:</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [a</span><span class="id"> *:</span><span class="id"> _]scalerA</span><span class="id"> -scalerAl</span><span class="id"> mul1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> baseVspace_basis</span><span class="id"> V</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> L0</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> tnth</span><span class="id"> bF</span><span class="id"> ij</span>.<span class="id">2</span><span class="id"> *:</span><span class="id"> tnth</span> (<span class="id">vbasis</span><span class="id"> V</span>)<span class="id"> ij</span>.<span class="id">1</span><span class="id"> |</span><span class="id"> ij</span><span class="id"> :</span><span class="id"> 'I_</span>(<span class="id">\dim</span><span class="id"> V</span>)<span class="id"> *</span><span class="id"> 'I_n]</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> baseVspace</span><span class="id"> V</span><span class="id"> :=</span><span class="id"> &lt;&lt;baseVspace_basis</span><span class="id"> V&gt;&gt;%VS</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_baseVspace</span><span class="id"> V</span><span class="id"> :</span><span class="id"> baseVspace</span><span class="id"> V</span><span class="id"> =i</span><span class="id"> V</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [/coord_span-&gt;|/coord_vbasis-&gt;];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span> (<span class="id">coordF</span> (<span class="id">coord</span><span class="id"> _</span><span class="id"> i</span> (<span class="id">y</span><span class="id"> :</span><span class="id"> L</span>)))<span class="id"> scaler_suml</span><span class="id"> -/n</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -/bF</span><span class="id"> -F0ZEZ</span><span class="id"> memvZ</span><span class="id"> ?memv_span</span><span class="id"> //</span><span class="id"> -!tnth_nth</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/imageP;</span><span class="gallina-kwd"> exists</span> (<span class="id">i,</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="comment">(*&nbsp;GG:&nbsp;the&nbsp;F0ZEZ&nbsp;lemma&nbsp;avoids&nbsp;serious&nbsp;performance&nbsp;issues&nbsp;here.&nbsp;*)</span><br/>
<span class="id">apply:</span><span class="id"> memv_suml</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> nth_image;</span><span class="id"> case:</span> (<span class="id">enum_val</span><span class="id"> k</span>)<span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> F0ZEZ</span><span class="id"> memvZ</span><span class="id"> ?vbasis_mem</span><span class="id"> ?mem_tnth</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_baseVspace</span><span class="id"> V</span><span class="id"> :</span><span class="id"> \dim</span> (<span class="id">baseVspace</span><span class="id"> V</span>)<span class="id"> =</span> (<span class="id">\dim</span><span class="id"> V</span><span class="id"> *</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> bV0</span><span class="id"> :=</span><span class="id"> baseVspace_basis</span><span class="id"> V;</span><span class="id"> set</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> \dim</span><span class="id"> V</span><span class="gallina-kwd"> in</span><span class="id"> bV0</span><span class="id"> *</span>.<br/>
<span class="id">suffices</span><span class="id"> /size_basis-&gt;:</span><span class="id"> basis_of</span> (<span class="id">baseVspace</span><span class="id"> V</span>)<span class="id"> bV0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_prod</span><span class="id"> !card_ord</span>.<br/>
<span class="id">rewrite</span><span class="id"> /basis_of</span><span class="id"> eqxx</span>.<br/>
<span class="id">apply/freeP=&gt;</span><span class="id"> s</span><span class="id"> sb0</span><span class="id"> k;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">enum_valK</span><span class="id"> k</span>)<span class="id">;</span><span class="id"> case/enum_val:</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> j</span>.<br/>
<span class="id">have</span><span class="id"> free_baseP</span><span class="id"> :=</span><span class="id"> freeP</span> (<span class="id">basis_free</span> (<span class="id">vbasisP</span><span class="id"> _</span>)).<br/>
<span class="id">move:</span><span class="id"> j;</span><span class="id"> apply:</span> (<span class="id">free_baseP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> fullv</span>)<span class="id">;</span><span class="id"> move:</span><span class="id"> i;</span><span class="id"> apply:</span> (<span class="id">free_baseP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> V</span>).<br/>
<span class="id">transitivity</span> (<span class="id">\sum_i</span><span class="id"> \sum_j</span><span class="id"> s</span> (<span class="id">enum_rank</span> (<span class="id">i,</span><span class="id"> j</span>))<span class="id"> *:</span><span class="id"> bV0`_</span>(<span class="id">enum_rank</span> (<span class="id">i,</span><span class="id"> j</span>))).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> scaler_suml;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -F0ZEZ</span><span class="id"> nth_image</span><span class="id"> enum_rankK</span><span class="id"> -!tnth_nth</span>.<br/>
<span class="id">rewrite</span><span class="id"> pair_bigA</span> (<span class="id">reindex</span><span class="id"> _</span> (<span class="id">onW_bij</span><span class="id"> _</span> (<span class="id">enum_val_bij</span><span class="id"> _</span>)))<span class="id">;</span><span class="id"> apply:</span><span class="id"> etrans</span><span class="id"> sb0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -{5</span><span class="id"> 6}[k]</span>(<span class="id">enum_valK</span><span class="id"> k</span>)<span class="id">;</span><span class="id"> case/enum_val:</span><span class="id"> k</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> baseAspace_suproof</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :</span><span class="id"> is_aspace</span> (<span class="id">baseVspace</span><span class="id"> E</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /is_aspace</span><span class="id"> has_algid1;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_baseVspace</span> (<span class="id">mem1v</span><span class="id"> E</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/prodvP=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> !mem_baseVspace;</span><span class="id"> apply:</span><span class="id"> memvM</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> baseAspace</span><span class="id"> E</span><span class="id"> :=</span><span class="id"> ASpace</span> (<span class="id">baseAspace_suproof</span><span class="id"> E</span>).<br/>
<br/>
<span class="vernacular">End</span><span class="id"> BaseField</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> baseFieldType</span><span class="id"> [F0</span><span class="id"> F]%_type</span><span class="id"> L%_type</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">lock</span><span class="vernacular"> Definition</span><span class="id"> refBaseField</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>)<br/>
&nbsp;&nbsp;(<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span>)<span class="id"> :=</span><span class="id"> baseAspace</span> (<span class="id">1%AS</span><span class="id"> :</span><span class="id"> {aspace</span><span class="id"> L}</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> refBaseField_unlockable</span><span class="id"> :=</span><span class="id"> Unlockable</span><span class="id"> refBaseField</span>.<span class="id">unlock</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RefBaseField</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span>).<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> F1</span><span class="id"> :=</span> (<span class="id">refBaseField</span><span class="id"> L</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> F1unlock</span><span class="id"> :=</span><span class="id"> refBaseField</span>.<span class="id">unlock</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> L0</span><span class="id"> :=</span> (<span class="id">baseFieldType</span><span class="id"> L</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> \dim</span><span class="id"> {:F}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> bF</span><span class="id"> :</span><span class="id"> n</span>.<span class="id">-tuple</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> vbasis</span><span class="id"> {:F}</span>.<br/>
<span class="vernacular">Let</span><span class="id"> coordF</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> F</span>)<span class="id"> :=</span> (<span class="id">coord_vbasis</span> (<span class="id">memvf</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dim_refBaseField</span><span class="id"> :</span><span class="id"> \dim</span><span class="id"> F1</span><span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> F1unlock</span><span class="id"> dim_baseVspace</span><span class="id"> dimv1</span><span class="id"> mul1n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> baseVspace_module</span><span class="id"> V</span> (<span class="id">V0</span><span class="id"> :=</span><span class="id"> baseVspace</span><span class="id"> V</span>)<span class="id"> :</span> (<span class="id">F1</span><span class="id"> *</span><span class="id"> V0</span><span class="id"> &lt;=</span><span class="id"> V0</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/prodvP=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> F1unlock</span><span class="id"> !mem_baseVspace</span><span class="id"> =&gt;</span><span class="id"> /vlineP[x</span><span class="id"> -&gt;]</span><span class="id"> Vv</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@scalerAl</span><span class="id"> F</span><span class="id"> L</span>)<span class="id"> mul1r;</span><span class="id"> apply:</span><span class="id"> memvZ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_baseField</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :</span> (<span class="id">F1</span><span class="id"> &lt;=</span><span class="id"> baseVspace</span><span class="id"> E</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sup_field_module</span><span class="id"> baseVspace_module</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> vspaceOver_refBase</span><span class="id"> V</span><span class="id"> :</span><span class="id"> vspaceOver</span><span class="id"> F1</span> (<span class="id">baseVspace</span><span class="id"> V</span>)<span class="id"> =i</span><span class="id"> V</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> mem_vspaceOver</span><span class="id"> field_module_eq</span><span class="id"> ?baseVspace_module</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_baseVspace</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> module_baseVspace</span><span class="id"> M0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">F1</span><span class="id"> *</span><span class="id"> M0</span><span class="id"> &lt;=</span><span class="id"> M0</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> {V</span><span class="id"> |</span><span class="id"> M0</span><span class="id"> =</span><span class="id"> baseVspace</span><span class="id"> V</span><span class="id"> &amp;</span><span class="id"> M0</span><span class="id"> =i</span><span class="id"> V}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> modM0;</span><span class="id"> pose</span><span class="id"> V</span><span class="id"> :=</span><span class="id"> &lt;&lt;vbasis</span> (<span class="id">vspaceOver</span><span class="id"> F1</span><span class="id"> M0</span>)<span class="id"> :</span><span class="id"> seq</span><span class="id"> L&gt;&gt;%VS</span>.<br/>
<span class="id">suffices</span><span class="id"> memM0:</span><span class="id"> M0</span><span class="id"> =i</span><span class="id"> V</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> V</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/vspaceP=&gt;</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> mem_baseVspace</span><span class="id"> memM0</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">field_module_eq</span><span class="id"> modM0</span>)<span class="id"> -</span>(<span class="id">mem_vspaceOver</span><span class="id"> M0</span>)<span class="id"> {}/V</span>.<br/>
<span class="id">move:</span> (<span class="id">vspaceOver</span><span class="id"> F1</span><span class="id"> M0</span>)<span class="id"> =&gt;</span><span class="id"> M</span>.<br/>
<span class="id">apply/idP/idP=&gt;</span><span class="id"> [/coord_vbasis|/coord_span]-&gt;;</span><span class="id"> apply/memv_suml=&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /</span>(_<span class="id"> *:</span><span class="id"> _</span>)<span class="id"> /=</span><span class="id"> /fieldOver_scale;</span><span class="id"> case:</span> (<span class="id">coord</span><span class="id"> _</span><span class="id"> i</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1}F1unlock</span><span class="id"> mem_baseVspace</span><span class="id"> =&gt;</span><span class="id"> /vlineP[{}x</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@scalerAl</span><span class="id"> F</span><span class="id"> L</span>)<span class="id"> mul1r</span><span class="id"> memvZ</span><span class="id"> ?memv_span</span><span class="id"> ?memt_nth</span>.<br/>
<span class="id">move:</span> (<span class="id">coord</span><span class="id"> _</span><span class="id"> i</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[_`_i]mul1r</span><span class="id"> scalerAl</span><span class="id"> -tnth_nth</span>.<br/>
<span class="id">have</span><span class="id"> F1x:</span><span class="id"> x%:A</span><span class="id"> \in</span><span class="id"> F1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> F1unlock</span><span class="id"> mem_baseVspace</span> (<span class="id">@memvZ</span><span class="id"> F</span><span class="id"> L</span>)<span class="id"> //</span><span class="id"> mem1v</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> \in</span><span class="id"> M</span>)<span class="id">:</span> (<span class="id">memvZ</span> (<span class="id">Subvs</span><span class="id"> F1x</span>) (<span class="id">vbasis_mem</span> (<span class="id">mem_tnth</span><span class="id"> i</span><span class="id"> _</span>))).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> module_baseAspace</span> (<span class="id">E0</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L0}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">F1</span><span class="id"> &lt;=</span><span class="id"> E0</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> {E</span><span class="id"> |</span><span class="id"> E0</span><span class="id"> =</span><span class="id"> baseAspace</span><span class="id"> E</span><span class="id"> &amp;</span><span class="id"> E0</span><span class="id"> =i</span><span class="id"> E}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -sup_field_module</span><span class="id"> =&gt;</span><span class="id"> /module_baseVspace[E</span><span class="id"> defE0</span><span class="id"> memE0]</span>.<br/>
<span class="id">suffices</span><span class="id"> algE:</span><span class="id"> is_aspace</span><span class="id"> E</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">ASpace</span><span class="id"> algE</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> val_inj</span>.<br/>
<span class="id">rewrite</span><span class="id"> /is_aspace</span><span class="id"> has_algid1</span><span class="id"> -?memE0</span><span class="id"> ?mem1v</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/prodvP=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> -!memE0;</span><span class="id"> apply:</span><span class="id"> memvM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RefBaseField</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MoreFieldOver</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F0</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F0</span>) (<span class="id">F</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> base_vspaceOver</span><span class="id"> V</span><span class="id"> :</span><span class="id"> baseVspace</span> (<span class="id">vspaceOver</span><span class="id"> F</span><span class="id"> V</span>)<span class="id"> =i</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> V</span>)<span class="id">%VS</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> mem_baseVspace</span><span class="id"> mem_vspaceOver</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> base_moduleOver</span><span class="id"> V</span><span class="id"> :</span> (<span class="id">F</span><span class="id"> *</span><span class="id"> V</span><span class="id"> &lt;=</span><span class="id"> V</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> baseVspace</span> (<span class="id">vspaceOver</span><span class="id"> F</span><span class="id"> V</span>)<span class="id"> =i</span><span class="id"> V</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /field_module_eq</span><span class="id"> defV</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> base_vspaceOver</span><span class="id"> defV</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> base_aspaceOver</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> &lt;=</span><span class="id"> E</span>)<span class="id">%VS</span><span class="id"> -&gt;</span><span class="id"> baseVspace</span> (<span class="id">vspaceOver</span><span class="id"> F</span><span class="id"> E</span>)<span class="id"> =i</span><span class="id"> E</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sup_field_module;</span><span class="id"> apply:</span><span class="id"> base_moduleOver</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MoreFieldOver</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SubFieldExtension</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> quotient_scope</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">F</span><span class="id"> L</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">iota</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> L}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">z</span><span class="id"> :</span><span class="id"> L</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span>).<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;p ^iota&quot;</span><span class="id"> :=</span> (<span class="id">map_poly</span> (<span class="id">GRing</span>.<span class="id">RMorphism</span>.<span class="id">sort</span><span class="id"> iota</span>)<span class="id"> p</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;p ^iota&quot;</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> wf_p</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> !=</span><span class="id"> 0</span>)<span class="id"> &amp;&amp;</span><span class="id"> root</span><span class="id"> p^iota</span><span class="id"> z</span>.<br/>
<span class="vernacular">Let</span><span class="id"> p0</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> wf_p</span><span class="gallina-kwd"> then</span> (<span class="id">lead_coef</span><span class="id"> p</span>)<span class="id">^-1</span><span class="id"> *:</span><span class="id"> p</span><span class="gallina-kwd"> else</span><span class="id"> 'X</span>.<br/>
<span class="vernacular">Let</span><span class="id"> z0</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> wf_p</span><span class="gallina-kwd"> then</span><span class="id"> z</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<span class="vernacular">Let</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">size</span><span class="id"> p0</span>).<span class="id">-1</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> p0_mon</span><span class="id"> :</span><span class="id"> p0</span><span class="id"> \is</span><span class="id"> monic</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /p0;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [/andP[nz_p</span><span class="id"> _]</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> monicX</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> monicE</span><span class="id"> lead_coefZ</span><span class="id"> mulVf</span><span class="id"> ?lead_coef_eq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> nz_p0</span><span class="id"> :</span><span class="id"> p0</span><span class="id"> !=</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> monic_neq0</span><span class="id"> //</span><span class="id"> p0_mon</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> p0z0</span><span class="id"> :</span><span class="id"> root</span><span class="id"> p0^iota</span><span class="id"> z0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /p0</span><span class="id"> /z0;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [/andP[_</span><span class="id"> pz0]|];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_polyX</span><span class="id"> rootX</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_polyZ</span><span class="id"> rootE</span><span class="id"> hornerZ</span> (<span class="id">rootP</span><span class="id"> pz0</span>)<span class="id"> mulr0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> n_gt0:</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /n</span><span class="id"> -subn1</span><span class="id"> subn_gt0</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> iota</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">root_size_gt1</span><span class="id"> _</span><span class="id"> p0z0</span>)<span class="id"> ?map_poly_eq0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> z0Ciota</span><span class="id"> :</span><span class="id"> commr_rmorph</span><span class="id"> iota</span><span class="id"> z0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> mulrC</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> iotaPz</span><span class="id"> :=</span> (<span class="id">horner_morph</span><span class="id"> z0Ciota</span>).<br/>
<span class="vernacular">Let</span><span class="id"> iotaFz</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> 'rV[F]_n</span>)<span class="id"> :=</span><span class="id"> iotaPz</span> (<span class="id">rVpoly</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> equiv_subfext</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span> (<span class="id">iotaFz</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> iotaFz</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> equiv_subfext_is_equiv</span><span class="id"> :</span><span class="id"> equiv_class_of</span><span class="id"> equiv_subfext</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /equiv_subfext;</span><span class="id"> split=&gt;</span><span class="id"> x</span><span class="id"> //</span><span class="id"> y</span><span class="id"> w</span><span class="id"> /eqP-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> equiv_subfext_equiv</span><span class="id"> :=</span><span class="id"> EquivRelPack</span><span class="id"> equiv_subfext_is_equiv</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> equiv_subfext_encModRel</span><span class="id"> :=</span><span class="id"> defaultEncModRel</span><span class="id"> equiv_subfext</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subFExtend</span><span class="id"> :=</span><span class="id"> {eq_quot</span><span class="id"> equiv_subfext}</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Choice</span>.<span class="id">on</span><span class="id"> subFExtend</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Quotient</span>.<span class="id">on</span><span class="id"> subFExtend</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :</span><span class="id"> EqQuotient</span><span class="id"> 'M[F]_</span>(<span class="id">1,</span><span class="id"> n</span>)<span class="id"> equiv_subfext</span><span class="id"> subFExtend</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">EqQuotient</span>.<span class="id">on</span><span class="id"> subFExtend</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_inj</span><span class="id"> :=</span><span class="id"> lift_fun1</span><span class="id"> subFExtend</span><span class="id"> iotaFz</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> pi_subfx_inj</span><span class="id"> :</span><span class="id"> {mono</span><span class="id"> \pi</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> iotaFz</span><span class="id"> x</span><span class="id"> &gt;-&gt;</span><span class="id"> subfx_inj</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> subfx_inj</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">equiv_subfext</span><span class="id"> _</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqmodE</span><span class="id"> reprK</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pi_subfx_inj_morph</span><span class="id"> :=</span><span class="id"> PiMono1</span><span class="id"> pi_subfx_inj</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> iotaPz_repr</span><span class="id"> x</span><span class="id"> :</span><span class="id"> iotaPz</span> (<span class="id">rVpoly</span> (<span class="id">repr</span> (<span class="id">\pi_</span>(<span class="id">subFExtend</span>)<span class="id"> x</span>)))<span class="id"> =</span><span class="id"> iotaFz</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -/</span>(<span class="id">iotaFz</span><span class="id"> _</span>)<span class="id"> -!pi_subfx_inj</span><span class="id"> reprK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext0</span><span class="id"> :=</span><span class="id"> lift_cst</span><span class="id"> subFExtend</span><span class="id"> 0</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> subfext0_morph</span><span class="id"> :=</span><span class="id"> PiConst</span><span class="id"> subfext0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext_add</span><span class="id"> :=</span><span class="id"> lift_op2</span><span class="id"> subFExtend</span><span class="id"> +%R</span>.<br/>
<span class="vernacular">Fact</span><span class="id"> pi_subfext_add</span><span class="id"> :</span><span class="id"> {morph</span><span class="id"> \pi</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> +</span><span class="id"> y</span><span class="id"> &gt;-&gt;</span><span class="id"> subfext_add</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> subfext_add</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply/eqmodP/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /iotaFz</span><span class="id"> !linearD</span><span class="id"> /=</span><span class="id"> !iotaPz_repr</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pi_subfx_add_morph</span><span class="id"> :=</span><span class="id"> PiMorph2</span><span class="id"> pi_subfext_add</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext_opp</span><span class="id"> :=</span><span class="id"> lift_op1</span><span class="id"> subFExtend</span><span class="id"> -%R</span>.<br/>
<span class="vernacular">Fact</span><span class="id"> pi_subfext_opp</span><span class="id"> :</span><span class="id"> {morph</span><span class="id"> \pi</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> -</span><span class="id"> x</span><span class="id"> &gt;-&gt;</span><span class="id"> subfext_opp</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> subfext_opp</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply/eqmodP/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /iotaFz</span><span class="id"> !linearN</span><span class="id"> /=</span><span class="id"> !iotaPz_repr</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pi_subfext_opp_morph</span><span class="id"> :=</span><span class="id"> PiMorph1</span><span class="id"> pi_subfext_opp</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> addfxA</span><span class="id"> :</span><span class="id"> associative</span><span class="id"> subfext_add</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> -[x]reprK</span><span class="id"> -[y]reprK</span><span class="id"> -[t]reprK</span><span class="id"> !piE</span><span class="id"> addrA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> addfxC</span><span class="id"> :</span><span class="id"> commutative</span><span class="id"> subfext_add</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -[x]reprK</span><span class="id"> -[y]reprK</span><span class="id"> !piE</span><span class="id"> addrC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> add0fx</span><span class="id"> :</span><span class="id"> left_id</span><span class="id"> subfext0</span><span class="id"> subfext_add</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[x]reprK</span><span class="id"> !piE</span><span class="id"> add0r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> addfxN</span><span class="id"> :</span><span class="id"> left_inverse</span><span class="id"> subfext0</span><span class="id"> subfext_opp</span><span class="id"> subfext_add</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[x]reprK</span><span class="id"> !piE</span><span class="id"> addNr</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isZmodule</span>.<span class="id">Build</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">addfxA</span><span class="id"> addfxC</span><span class="id"> add0fx</span><span class="id"> addfxN</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> poly_rV_modp_K</span><span class="id"> q</span><span class="id"> :</span><span class="id"> rVpoly</span> (<span class="id">poly_rV</span> (<span class="id">q</span><span class="id"> %%</span><span class="id"> p0</span>)<span class="id"> :</span><span class="id"> 'rV[F]_n</span>)<span class="id"> =</span><span class="id"> q</span><span class="id"> %%</span><span class="id"> p0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> poly_rV_K;</span><span class="id"> rewrite</span><span class="id"> -ltnS</span><span class="id"> -polySpred</span><span class="id"> //</span><span class="id"> ltn_modp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> iotaPz_modp</span><span class="id"> q</span><span class="id"> :</span><span class="id"> iotaPz</span> (<span class="id">q</span><span class="id"> %%</span><span class="id"> p0</span>)<span class="id"> =</span><span class="id"> iotaPz</span><span class="id"> q</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> {2}</span>(<span class="id">divp_eq</span><span class="id"> q</span><span class="id"> p0</span>)<span class="id"> rmorphD</span><span class="id"> rmorphM</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [iotaPz</span><span class="id"> p0]</span>(<span class="id">rootP</span><span class="id"> p0z0</span>)<span class="id"> mulr0</span><span class="id"> add0r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_mul_rep</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> 'rV[F]_n</span>)<span class="id"> :</span><span class="id"> 'rV[F]_n</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">poly_rV</span> ((<span class="id">rVpoly</span><span class="id"> x</span>)<span class="id"> *</span> (<span class="id">rVpoly</span><span class="id"> y</span>)<span class="id"> %%</span><span class="id"> p0</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext_mul</span><span class="id"> :=</span><span class="id"> lift_op2</span><span class="id"> subFExtend</span><span class="id"> subfx_mul_rep</span>.<br/>
<span class="vernacular">Fact</span><span class="id"> pi_subfext_mul</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{morph</span><span class="id"> \pi</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> subfx_mul_rep</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &gt;-&gt;</span><span class="id"> subfext_mul</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> subfext_mul</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> apply/eqmodP/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /iotaFz</span><span class="id"> !poly_rV_modp_K</span><span class="id"> !iotaPz_modp</span><span class="id"> !rmorphM</span><span class="id"> /=</span><span class="id"> !iotaPz_repr</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pi_subfext_mul_morph</span><span class="id"> :=</span><span class="id"> PiMorph2</span><span class="id"> pi_subfext_mul</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext1</span><span class="id"> :=</span><span class="id"> lift_cst</span><span class="id"> subFExtend</span> (<span class="id">poly_rV</span><span class="id"> 1</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> subfext1_morph</span><span class="id"> :=</span><span class="id"> PiConst</span><span class="id"> subfext1</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> mulfxA</span><span class="id"> :</span><span class="id"> associative</span> (<span class="id">subfext_mul</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> y;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> w;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /subfx_mul_rep</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !poly_rV_modp_K</span><span class="id"> [_</span><span class="id"> %%</span><span class="id"> p0</span><span class="id"> *</span><span class="id"> _]mulrC</span><span class="id"> !modp_mul</span><span class="id"> //</span><span class="id"> mulrA</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> mulfxC</span><span class="id"> :</span><span class="id"> commutative</span><span class="id"> subfext_mul</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /subfx_mul_rep</span><span class="id"> /=</span><span class="id"> mulrC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> mul1fx</span><span class="id"> :</span><span class="id"> left_id</span><span class="id"> subfext1</span><span class="id"> subfext_mul</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /subfx_mul_rep</span><span class="id"> poly_rV_K</span><span class="id"> ?size_poly1</span><span class="id"> //</span><span class="id"> mul1r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> modp_small</span><span class="id"> ?rVpolyK</span><span class="id"> //</span> (<span class="id">polySpred</span><span class="id"> nz_p0</span>)<span class="id"> ltnS</span><span class="id"> size_poly</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> mulfx_addl</span><span class="id"> :</span><span class="id"> left_distributive</span><span class="id"> subfext_mul</span><span class="id"> subfext_add</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> y;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> w</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /subfx_mul_rep</span><span class="id"> linearD</span><span class="id"> /=</span><span class="id"> mulrDl</span><span class="id"> modpD</span><span class="id"> linearD</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> nonzero1fx</span><span class="id"> :</span><span class="id"> subfext1</span><span class="id"> !=</span><span class="id"> subfext0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> !piE</span><span class="id"> /equiv_subfext</span><span class="id"> /iotaFz</span><span class="id"> !linear0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> poly_rV_K</span><span class="id"> ?rmorph1</span><span class="id"> ?oner_eq0</span><span class="id"> //</span><span class="id"> size_poly1</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Zmodule_isComNzRing</span>.<span class="id">Build</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">mulfxA</span><span class="id"> mulfxC</span><span class="id"> mul1fx</span><span class="id"> mulfx_addl</span><span class="id"> nonzero1fx</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_poly_inv</span> (<span class="id">q</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span>)<span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> iotaPz</span><span class="id"> q</span><span class="id"> ==</span><span class="id"> 0</span><span class="gallina-kwd"> then</span><span class="id"> 0</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> r</span><span class="id"> :=</span><span class="id"> gdcop</span><span class="id"> q</span><span class="id"> p0</span><span class="gallina-kwd"> in</span><span class="id"> let:</span> (<span class="id">u,</span><span class="id"> v</span>)<span class="id"> :=</span><span class="id"> egcdp</span><span class="id"> q</span><span class="id"> r</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;((<span class="id">u</span><span class="id"> *</span><span class="id"> q</span><span class="id"> +</span><span class="id"> v</span><span class="id"> *</span><span class="id"> r</span>)<span class="id">`_0</span>)<span class="id">^-1</span><span class="id"> *:</span><span class="id"> u</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> subfx_poly_invE</span><span class="id"> q</span><span class="id"> :</span><span class="id"> iotaPz</span> (<span class="id">subfx_poly_inv</span><span class="id"> q</span>)<span class="id"> =</span> (<span class="id">iotaPz</span><span class="id"> q</span>)<span class="id">^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /subfx_poly_inv</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> nzq]</span><span class="id"> :=</span><span class="id"> eqVneq;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rmorph0</span><span class="id"> invr0</span>.<br/>
<span class="id">rewrite</span><span class="id"> [nth]lock</span><span class="id"> -[_^-1]mul1r;</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">mulfK</span><span class="id"> nzq</span>)<span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -rmorphM</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> rz0:</span><span class="id"> iotaPz</span> (<span class="id">gdcop</span><span class="id"> q</span><span class="id"> p0</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/rootP;</span><span class="id"> rewrite</span><span class="id"> gdcop_map</span><span class="id"> root_gdco</span><span class="id"> ?map_poly_eq0</span><span class="id"> //</span><span class="id"> p0z0</span><span class="id"> nzq</span>.<br/>
<span class="id">do</span><span class="id"> [case:</span><span class="id"> gdcopP</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> _;</span><span class="id"> rewrite</span> (<span class="id">negPf</span><span class="id"> nz_p0</span>)<span class="id"> orbF</span><span class="id"> =&gt;</span><span class="id"> co_r_q</span><span class="id"> _]</span><span class="gallina-kwd"> in</span><span class="id"> rz0</span><span class="id"> *</span>.<br/>
<span class="id">case:</span> (<span class="id">egcdp</span><span class="id"> q</span><span class="id"> r</span>) (<span class="id">egcdpE</span><span class="id"> q</span><span class="id"> r</span>)<span class="id"> =&gt;</span><span class="id"> u</span><span class="id"> v</span><span class="id"> /=/eqp_size/esym/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> coprimep_size_gcd</span><span class="id"> 1?coprimep_sym</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /size_poly1P[a</span><span class="id"> nz_a</span><span class="id"> Da]</span>.<br/>
<span class="id">rewrite</span><span class="id"> Da</span><span class="id"> -scalerAl</span> (<span class="id">canRL</span> (<span class="id">addrK</span><span class="id"> _</span>)<span class="id"> Da</span>)<span class="id"> -lock</span><span class="id"> coefC</span><span class="id"> linearZ</span><span class="id"> linearB</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> rz0</span><span class="id"> mulr0</span><span class="id"> subr0</span><span class="id"> horner_morphC</span><span class="id"> -rmorphM</span><span class="id"> mulVf</span><span class="id"> ?rmorph1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_inv_rep</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> 'rV[F]_n</span>)<span class="id"> :</span><span class="id"> 'rV[F]_n</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">poly_rV</span> (<span class="id">subfx_poly_inv</span> (<span class="id">rVpoly</span><span class="id"> x</span>)<span class="id"> %%</span><span class="id"> p0</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfext_inv</span><span class="id"> :=</span><span class="id"> lift_op1</span><span class="id"> subFExtend</span><span class="id"> subfx_inv_rep</span>.<br/>
<span class="vernacular">Fact</span><span class="id"> pi_subfext_inv</span><span class="id"> :</span><span class="id"> {morph</span><span class="id"> \pi</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> subfx_inv_rep</span><span class="id"> x</span><span class="id"> &gt;-&gt;</span><span class="id"> subfext_inv</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> subfext_inv</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> apply/eqmodP/eqP;</span><span class="id"> rewrite</span><span class="id"> /iotaFz</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> 2!{1}poly_rV_modp_K</span><span class="id"> 2!{1}iotaPz_modp</span><span class="id"> !subfx_poly_invE</span><span class="id"> iotaPz_repr</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> pi_subfext_inv_morph</span><span class="id"> :=</span><span class="id"> PiMorph1</span><span class="id"> pi_subfext_inv</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_fieldAxiom</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> subfext_inv</span><span class="id"> x</span><span class="id"> *</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> contraNeq;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /equiv_subfext</span><span class="id"> /iotaFz</span><span class="id"> !linear0</span>.<br/>
<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> nz_x;</span><span class="id"> rewrite</span><span class="id"> poly_rV_K</span><span class="id"> ?size_poly1</span><span class="id"> //</span><span class="id"> !poly_rV_modp_K</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> iotaPz_modp</span><span class="id"> rmorph1</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> iotaPz_modp</span><span class="id"> subfx_poly_invE</span><span class="id"> mulVf</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_inv0</span><span class="id"> :</span><span class="id"> subfext_inv</span> (<span class="id">0</span><span class="id"> :</span><span class="id"> subFExtend</span>)<span class="id"> =</span> (<span class="id">0</span><span class="id"> :</span><span class="id"> subFExtend</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /equiv_subfext</span><span class="id"> /iotaFz</span><span class="id"> /subfx_inv_rep</span><span class="id"> !linear0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /subfx_poly_inv</span><span class="id"> rmorph0</span><span class="id"> eqxx</span><span class="id"> mod0p</span><span class="id"> !linear0</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">ComNzRing_isField</span>.<span class="id">Build</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">subfx_fieldAxiom</span><span class="id"> subfx_inv0</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_inj_is_additive</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> subfx_inj</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim/quotW</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> elim/quotW</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /iotaFz</span><span class="id"> linearB</span><span class="id"> rmorphB</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_inj_is_multiplicative</span><span class="id"> :</span><span class="id"> multiplicative</span><span class="id"> subfx_inj</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> piE</span><span class="id"> /iotaFz</span><span class="id"> poly_rV_K</span><span class="id"> ?rmorph1</span><span class="id"> ?size_poly1</span>.<br/>
<span class="id">elim/quotW=&gt;</span><span class="id"> x;</span><span class="id"> elim/quotW=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !piE</span><span class="id"> /subfx_mul_rep</span><span class="id"> /iotaFz</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> poly_rV_modp_K</span><span class="id"> iotaPz_modp</span><span class="id"> rmorphM</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isAdditive</span>.<span class="id">Build</span><span class="id"> subFExtend</span><span class="id"> L</span><span class="id"> subfx_inj</span><br/>
&nbsp;&nbsp;<span class="id">subfx_inj_is_additive</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> subFExtend</span><span class="id"> L</span><span class="id"> subfx_inj</span><br/>
&nbsp;&nbsp;<span class="id">subfx_inj_is_multiplicative</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_eval</span><span class="id"> :=</span><span class="id"> lift_embed</span><span class="id"> subFExtend</span> (<span class="gallina-kwd">fun</span><span class="id"> q</span><span class="id"> =&gt;</span><span class="id"> poly_rV</span> (<span class="id">q</span><span class="id"> %%</span><span class="id"> p0</span>)).<br/>
<span class="vernacular">Canonical</span><span class="id"> subfx_eval_morph</span><span class="id"> :=</span><span class="id"> PiEmbed</span><span class="id"> subfx_eval</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_root</span><span class="id"> :=</span><span class="id"> subfx_eval</span><span class="id"> 'X</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_eval_is_additive</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> subfx_eval</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> piE</span><span class="id"> -linearB</span><span class="id"> modpD</span><span class="id"> modNp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_eval_is_multiplicative</span><span class="id"> :</span><span class="id"> multiplicative</span><span class="id"> subfx_eval</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [x</span><span class="id"> y|];</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> piE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /subfx_mul_rep</span><span class="id"> !poly_rV_modp_K</span><span class="id"> !</span>(<span class="id">modp_mul,</span><span class="id"> mulrC</span><span class="id"> _</span><span class="id"> y</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> modp_small</span><span class="id"> //</span><span class="id"> size_poly1</span><span class="id"> -subn_gt0</span><span class="id"> subn1</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isAdditive</span>.<span class="id">Build</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> subFExtend</span><span class="id"> subfx_eval</span><span class="id"> subfx_eval_is_additive</span>.<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> subFExtend</span><span class="id"> subfx_eval</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">subfx_eval_is_multiplicative</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> inj_subfx</span><span class="id"> :=</span> (<span class="id">subfx_eval</span><span class="id"> \o</span><span class="id"> polyC</span>).<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">RMorphism</span>.<span class="id">on</span><span class="id"> inj_subfx</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfxE</span><span class="id"> x:</span><span class="gallina-kwd"> exists</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> =</span><span class="id"> subfx_eval</span><span class="id"> p</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/quotW:</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span> (<span class="id">rVpoly</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> piE</span><span class="id"> /equiv_subfext</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /iotaFz</span><span class="id"> poly_rV_modp_K</span><span class="id"> iotaPz_modp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subfx_scale</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> inj_subfx</span><span class="id"> a</span><span class="id"> *</span><span class="id"> x</span>.<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_scalerA</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subfx_scale</span><span class="id"> a</span> (<span class="id">subfx_scale</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> subfx_scale</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /subfx_scale</span><span class="id"> rmorphM</span><span class="id"> mulrA</span>. Qed.</div></details>
<span class="vernacular">Fact</span><span class="id"> subfx_scaler1r</span><span class="id"> :</span><span class="id"> left_id</span><span class="id"> 1</span><span class="id"> subfx_scale</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /subfx_scale</span><span class="id"> rmorph1</span><span class="id"> mul1r</span>. Qed.</div></details>
<span class="vernacular">Fact</span><span class="id"> subfx_scalerDr</span><span class="id"> :</span><span class="id"> right_distributive</span><span class="id"> subfx_scale</span><span class="id"> +%R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a;</span><span class="id"> apply:</span><span class="id"> mulrDr</span>. Qed.</div></details>
<span class="vernacular">Fact</span><span class="id"> subfx_scalerDl</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {morph</span><span class="id"> subfx_scale^~</span><span class="id"> x</span><span class="id"> :</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /</span><span class="id"> a</span><span class="id"> +</span><span class="id"> b}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> /subfx_scale</span><span class="id"> rmorphD</span><span class="id"> mulrDl</span>. Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Zmodule_isLmodule</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">subfx_scalerA</span><span class="id"> subfx_scaler1r</span><span class="id"> subfx_scalerDr</span><span class="id"> subfx_scalerDl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_scaleAl</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> subfx_scale</span><span class="id"> a</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span> (<span class="id">subfx_scale</span><span class="id"> a</span><span class="id"> u</span>)<span class="id"> *</span><span class="id"> v</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrA</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lmodule_isLalgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">subfx_scaleAl</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_scaleAr</span><span class="id"> a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :</span><span class="id"> subfx_scale</span><span class="id"> a</span> (<span class="id">u</span><span class="id"> *</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> u</span><span class="id"> *</span> (<span class="id">subfx_scale</span><span class="id"> a</span><span class="id"> v</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mulrCA</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Lalgebra_isAlgebra</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> subFExtend</span><br/>
&nbsp;&nbsp;<span class="id">subfx_scaleAr</span>.<br/>
<br/>
<span class="vernacular">Fact</span><span class="id"> subfx_evalZ</span><span class="id"> :</span><span class="id"> scalable</span><span class="id"> subfx_eval</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> q;</span><span class="id"> rewrite</span><span class="id"> -mul_polyC</span><span class="id"> rmorphM</span>. Qed.</div></details>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">GRing</span>.<span class="id">isScalable</span>.<span class="id">Build</span><span class="id"> F</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> subFExtend</span><span class="id"> *:%R</span><span class="id"> subfx_eval</span><span class="id"> subfx_evalZ</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span> (<span class="id">pz0</span><span class="id"> :</span><span class="id"> root</span><span class="id"> p^iota</span><span class="id"> z</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> NonZero</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> nz_p</span><span class="id"> :</span><span class="id"> p</span><span class="id"> !=</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_inj_eval</span><span class="id"> q</span><span class="id"> :</span><span class="id"> subfx_inj</span> (<span class="id">subfx_eval</span><span class="id"> q</span>)<span class="id"> =</span><span class="id"> q^iota</span>.<span class="id">[z]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> piE</span><span class="id"> /iotaFz</span><span class="id"> poly_rV_modp_K</span><span class="id"> iotaPz_modp</span><span class="id"> /iotaPz</span><span class="id"> /z0</span><span class="id"> /wf_p</span><span class="id"> nz_p</span><span class="id"> pz0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_inj_root</span><span class="id"> :</span><span class="id"> subfx_inj</span><span class="id"> subfx_root</span><span class="id"> =</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subfx_inj_eval</span><span class="id"> //</span><span class="id"> map_polyX</span><span class="id"> hornerX</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_injZ</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><span class="id"> subfx_inj</span> (<span class="id">b</span><span class="id"> *:</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> iota</span><span class="id"> b</span><span class="id"> *</span><span class="id"> subfx_inj</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> subfx_inj_eval</span><span class="id"> //</span><span class="id"> map_polyC</span><span class="id"> hornerC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_inj_base</span><span class="id"> b</span><span class="id"> :</span><span class="id"> subfx_inj</span><span class="id"> b%:A</span><span class="id"> =</span><span class="id"> iota</span><span class="id"> b</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subfx_injZ</span><span class="id"> rmorph1</span><span class="id"> mulr1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfxEroot</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {q</span><span class="id"> |</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">map_poly</span> (<span class="id">in_alg</span><span class="id"> subFExtend</span>)<span class="id"> q</span>).<span class="id">[subfx_root]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /sig_eqW[q</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> subfxE</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span><span class="id"> q</span>.<br/>
<span class="id">apply:</span> (<span class="id">fmorph_inj</span><span class="id"> subfx_inj</span>).<br/>
<span class="id">rewrite</span><span class="id"> -horner_map</span><span class="id"> /=</span><span class="id"> subfx_inj_root</span><span class="id"> subfx_inj_eval</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -map_poly_comp</span> (<span class="id">eq_map_poly</span><span class="id"> subfx_inj_base</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subfx_irreducibleP</span><span class="id"> :</span><br/>
&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> q,</span><span class="id"> root</span><span class="id"> q^iota</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> q</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> p</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> q</span>)<span class="id"> &lt;-&gt;</span><span class="id"> irreducible_poly</span><span class="id"> p</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [min_p</span><span class="id"> |</span><span class="id"> irr_p</span><span class="id"> q</span><span class="id"> qz0</span><span class="id"> nz_q]</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [|q</span><span class="id"> nonC_q</span><span class="id"> q_dv_p]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> iota</span>) (<span class="id">root_size_gt1</span><span class="id"> _</span><span class="id"> pz0</span>)<span class="id"> ?map_poly_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /dvdpP[r</span><span class="id"> Dp]</span><span class="id"> :=</span><span class="id"> q_dv_p;</span><span class="id"> rewrite</span><span class="id"> -dvdp_size_eqp</span><span class="id"> //</span><span class="id"> eqn_leq</span><span class="id"> dvdp_leq</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [nz_r</span><span class="id"> nz_q]:</span><span class="id"> r</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> /\</span><span class="id"> q</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply/norP;</span><span class="id"> rewrite</span><span class="id"> -mulf_eq0</span><span class="id"> -Dp</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> root</span><span class="id"> r^iota</span><span class="id"> z</span><span class="id"> ||</span><span class="id"> root</span><span class="id"> q^iota</span><span class="id"> z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -rootM</span><span class="id"> -rmorphM</span><span class="id"> -Dp</span>.<br/>
&nbsp;&nbsp;<span class="id">case/orP=&gt;</span><span class="id"> /min_p;</span><span class="id"> [case/</span>(_<span class="id"> _</span>)<span class="id">/idPn=&gt;</span><span class="id"> //</span><span class="id"> |</span><span class="id"> exact]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> polySpred</span><span class="id"> //</span><span class="id"> -leqNgt</span><span class="id"> Dp</span><span class="id"> size_mul</span><span class="id"> //=</span><span class="id"> polySpred</span><span class="id"> //</span><span class="id"> -subn2</span><span class="id"> ltn_subRL</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addSnnS</span><span class="id"> addnC</span><span class="id"> ltn_add2l</span><span class="id"> ltn_neqAle</span><span class="id"> eq_sym</span><span class="id"> nonC_q</span><span class="id"> size_poly_gt0</span>.<br/>
<span class="id">pose</span><span class="id"> r</span><span class="id"> :=</span><span class="id"> gcdp</span><span class="id"> p</span><span class="id"> q;</span><span class="id"> have</span><span class="id"> nz_r:</span><span class="id"> r</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gcdp_eq0</span> (<span class="id">negPf</span><span class="id"> nz_p</span>).<br/>
<span class="id">suffices</span><span class="id"> /eqp_size</span><span class="id"> &lt;-:</span><span class="id"> r</span><span class="id"> %=</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> dvdp_leq</span><span class="id"> ?dvdp_gcdr</span>.<br/>
<span class="id">rewrite</span> (<span class="id">irr_p</span><span class="id"> _</span>)<span class="id"> ?dvdp_gcdl</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> iota</span>)<span class="id"> gtn_eqF</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">@root_size_gt1</span><span class="id"> _</span><span class="id"> z</span>)<span class="id"> ?map_poly_eq0</span><span class="id"> //</span><span class="id"> gcdp_map</span><span class="id"> root_gcd</span><span class="id"> pz0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> NonZero</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Irreducible</span>.<br/>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> irr_p</span><span class="id"> :</span><span class="id"> irreducible_poly</span><span class="id"> p</span>.<br/>
<span class="vernacular">Let</span><span class="id"> nz_p</span><span class="id"> :</span><span class="id"> p</span><span class="id"> !=</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> irredp_neq0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> min_subfx_vect</span><span class="id"> :</span><span class="id"> Vector</span>.<span class="id">axiom</span> (<span class="id">size</span><span class="id"> p</span>).<span class="id">-1</span><span class="id"> subFExtend</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/subfx_irreducibleP:</span><span class="id"> irr_p</span><span class="id"> =&gt;</span><span class="id"> /=/</span>(_<span class="id"> nz_p</span>)<span class="id"> min_p;</span><span class="id"> set</span><span class="id"> d</span><span class="id"> :=</span> (<span class="id">size</span><span class="id"> p</span>).<span class="id">-1</span>.<br/>
<span class="id">have</span><span class="id"> Dd:</span><span class="id"> d</span>.<span class="id">+1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> polySpred</span>.<br/>
<span class="id">pose</span><span class="id"> Fz2v</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'rV_d</span><span class="id"> :=</span><span class="id"> poly_rV</span> (<span class="id">sval</span> (<span class="id">sig_eqW</span> (<span class="id">subfxE</span><span class="id"> x</span>))<span class="id"> %%</span><span class="id"> p</span>).<br/>
<span class="id">pose</span><span class="id"> vFz</span><span class="id"> :</span><span class="id"> 'rV_d</span><span class="id"> -&gt;</span><span class="id"> subFExtend</span><span class="id"> :=</span><span class="id"> subfx_eval</span><span class="id"> \o</span><span class="id"> rVpoly</span>.<br/>
<span class="id">have</span><span class="id"> FLinj:</span><span class="id"> injective</span><span class="id"> subfx_inj</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> fmorph_inj</span>.<br/>
<span class="id">have</span><span class="id"> Fz2vK:</span><span class="id"> cancel</span><span class="id"> Fz2v</span><span class="id"> vFz</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /vFz</span><span class="id"> /Fz2v;</span><span class="id"> case:</span> (<span class="id">sig_eqW</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> q</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> FLinj;</span><span class="id"> rewrite</span><span class="id"> !subfx_inj_eval</span><span class="id"> //</span><span class="id"> {2}</span>(<span class="id">divp_eq</span><span class="id"> q</span><span class="id"> p</span>)<span class="id"> rmorphD</span><span class="id"> rmorphM</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !hornerE</span> (<span class="id">eqP</span><span class="id"> pz0</span>)<span class="id"> mulr0</span><span class="id"> add0r</span><span class="id"> poly_rV_K</span><span class="id"> //</span><span class="id"> -ltnS</span><span class="id"> Dd</span><span class="id"> ltn_modpN0</span>.<br/>
<span class="id">suffices</span><span class="id"> vFzK:</span><span class="id"> cancel</span><span class="id"> vFz</span><span class="id"> Fz2v</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> Fz2v;</span><span class="id"> [apply:</span><span class="id"> can2_linear</span><span class="id"> Fz2vK</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> vFz]</span>.<br/>
<span class="id">apply:</span><span class="id"> inj_can_sym</span><span class="id"> Fz2vK</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> v1</span><span class="id"> v2</span><span class="id"> /</span>(<span class="id">congr1</span><span class="id"> subfx_inj</span>)<span class="id">/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> -subr_eq0</span><span class="id"> -!raddfB</span><span class="id"> /=</span><span class="id"> subfx_inj_eval</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /min_p/implyP</span>.<br/>
<span class="id">rewrite</span><span class="id"> leqNgt</span><span class="id"> implybNN</span><span class="id"> -Dd</span><span class="id"> ltnS</span><span class="id"> size_poly</span><span class="id"> linearB</span><span class="id"> subr_eq0</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/eqP/</span>(<span class="id">can_inj</span><span class="id"> rVpolyK</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> SubfxVect</span><span class="id"> :=</span><span class="id"> Lmodule_hasFinDim</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> subFExtend</span><span class="id"> min_subfx_vect</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> SubFieldExtType</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> subFExtend</span><span class="id"> SubfxVect</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Irreducible</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> SubFieldExtension</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> subfx_inj</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> irredp_FAdjoin</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">irreducible_poly</span><span class="id"> p</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> \dim</span><span class="id"> {:L}</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> p</span>).<span class="id">-1</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{z</span><span class="id"> |</span><span class="id"> root</span> (<span class="id">map_poly</span> (<span class="id">in_alg</span><span class="id"> L</span>)<span class="id"> p</span>)<span class="id"> z</span><span class="id"> &amp;</span><span class="id"> &lt;&lt;1;</span><span class="id"> z&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> fullv}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case=&gt;</span><span class="id"> p_gt1</span><span class="id"> irr_p;</span><span class="id"> set</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">size</span><span class="id"> p</span>).<span class="id">-1;</span><span class="id"> pose</span><span class="id"> vL</span><span class="id"> :</span><span class="id"> vectType</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> 'rV_n</span>.<br/>
<span class="id">have</span><span class="id"> Dn:</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> ltn_predK</span><span class="id"> p_gt1</span>.<br/>
<span class="id">have</span><span class="id"> nz_p:</span><span class="id"> p</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_poly_eq0</span><span class="id"> -Dn</span>.<br/>
<span class="id">suffices</span><span class="id"> [L</span><span class="id"> dimL</span><span class="id"> [toPF</span><span class="id"> [toL</span><span class="id"> toPF_K</span><span class="id"> toL_K]]]:</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">{L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span><span class="id"> &amp;</span><span class="id"> \dim</span><span class="id"> {:L}</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> p</span>).<span class="id">-1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {toPF</span><span class="id"> :</span><span class="id"> {linear</span><span class="id"> L</span><span class="id"> -&gt;</span><span class="id"> {poly</span><span class="id"> F}}</span><span class="id"> &amp;</span><span class="id"> {toL</span><span class="id"> :</span><span class="id"> {lrmorphism</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> -&gt;</span><span class="id"> L}</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">cancel</span><span class="id"> toPF</span><span class="id"> toL</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> q,</span><span class="id"> toPF</span> (<span class="id">toL</span><span class="id"> q</span>)<span class="id"> =</span><span class="id"> q</span><span class="id"> %%</span><span class="id"> p}}}</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> exists</span><span class="id"> L</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> pose</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> toL</span><span class="id"> 'X;</span><span class="id"> set</span><span class="id"> iota</span><span class="id"> :=</span><span class="id"> in_alg</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> q_z</span><span class="id"> q:</span><span class="id"> toPF</span> (<span class="id">map_poly</span><span class="id"> iota</span><span class="id"> q</span>).<span class="id">[z]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> %%</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /root</span><span class="id"> -</span>(<span class="id">can_eq</span><span class="id"> toPF_K</span>)<span class="id"> q_z</span><span class="id"> modpp</span><span class="id"> linear0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/vspaceP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> memvf;</span><span class="id"> apply/Fadjoin_polyP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">map_poly</span><span class="id"> iota</span> (<span class="id">toPF</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/polyOverP=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> coef_map</span><span class="id"> memvZ</span><span class="id"> ?mem1v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">can_inj</span><span class="id"> toPF_K</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> q_z</span><span class="id"> -toL_K</span><span class="id"> toPF_K</span>.<br/>
&nbsp;&nbsp;<span class="id">elim/poly_ind:</span><span class="id"> q</span><span class="id"> =&gt;</span><span class="id"> [|a</span><span class="id"> q</span><span class="id"> IHq]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_poly0</span><span class="id"> horner0</span><span class="id"> linear0</span><span class="id"> mod0p</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rmorphD</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> map_polyX</span><span class="id"> map_polyC</span><span class="id"> hornerMXaddC</span><span class="id"> linearD</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> linearZ</span><span class="id"> /=</span><span class="id"> -</span>(<span class="id">rmorph1</span><span class="id"> toL</span>)<span class="id"> toL_K</span><span class="id"> -modpZl</span><span class="id"> alg_polyC</span><span class="id"> modpD</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -toL_K</span><span class="id"> rmorphM</span><span class="id"> -/z;</span><span class="id"> congr</span> (<span class="id">toPF</span> (_<span class="id"> *</span><span class="id"> z</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">can_inj</span><span class="id"> toPF_K</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> toL_K</span>.<br/>
<span class="id">pose</span><span class="id"> toL</span><span class="id"> q</span><span class="id"> :</span><span class="id"> vL</span><span class="id"> :=</span><span class="id"> poly_rV</span> (<span class="id">q</span><span class="id"> %%</span><span class="id"> p</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> toPF</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> vL</span>)<span class="id"> :=</span><span class="id"> rVpoly</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> toL_K</span><span class="id"> q</span><span class="id"> :</span><span class="id"> toPF</span> (<span class="id">toL</span><span class="id"> q</span>)<span class="id"> =</span><span class="id"> q</span><span class="id"> %%</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /toPF</span><span class="id"> poly_rV_K</span><span class="id"> //</span><span class="id"> -ltnS</span><span class="id"> Dn</span><span class="id"> ?ltn_modp</span><span class="id"> -?Dn</span>.<br/>
<span class="id">have</span><span class="id"> toPF_K:</span><span class="id"> cancel</span><span class="id"> toPF</span><span class="id"> toL</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /toL</span><span class="id"> modp_small</span><span class="id"> ?rVpolyK</span><span class="id"> //</span><span class="id"> -Dn</span><span class="id"> ltnS</span><span class="id"> size_poly</span>.<br/>
<span class="id">have</span><span class="id"> toPinj</span><span class="id"> :=</span><span class="id"> can_inj</span><span class="id"> toPF_K</span>.<br/>
<span class="id">pose</span><span class="id"> mul</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> toL</span> (<span class="id">toPF</span><span class="id"> x</span><span class="id"> *</span><span class="id"> toPF</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> L1</span><span class="id"> :=</span><span class="id"> toL</span><span class="id"> 1</span>.<br/>
<span class="id">have</span><span class="id"> L1K:</span><span class="id"> toPF</span><span class="id"> L1</span><span class="id"> =</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> toL_K</span><span class="id"> modp_small</span><span class="id"> ?size_poly1</span>.<br/>
<span class="id">have</span><span class="id"> mulC:</span><span class="id"> commutative</span><span class="id"> mul</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mul</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
<span class="id">have</span><span class="id"> mulA:</span><span class="id"> associative</span><span class="id"> mul</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> toPinj;</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">mulC</span><span class="id"> z</span>)<span class="id"> !toL_K</span><span class="id"> !modp_mul</span><span class="id"> mulrCA</span>.<br/>
<span class="id">have</span><span class="id"> mul1:</span><span class="id"> left_id</span><span class="id"> L1</span><span class="id"> mul</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> toPinj;</span><span class="id"> rewrite</span><span class="id"> mulC</span><span class="id"> !toL_K</span><span class="id"> modp_mul</span><span class="id"> mulr1</span><span class="id"> -toL_K</span><span class="id"> toPF_K</span>.<br/>
<span class="id">have</span><span class="id"> mulD:</span><span class="id"> left_distributive</span><span class="id"> mul</span><span class="id"> +%R</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> toPinj;</span><span class="id"> rewrite</span><span class="id"> /toPF</span><span class="id"> raddfD</span><span class="id"> /=</span><span class="id"> -!/</span>(<span class="id">toPF</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !toL_K</span><span class="id"> /toPF</span><span class="id"> raddfD</span><span class="id"> mulrDl</span><span class="id"> modpD</span>.<br/>
<span class="id">have</span><span class="id"> nzL1:</span><span class="id"> L1</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">inj_eq</span><span class="id"> toPinj</span>)<span class="id"> L1K</span><span class="id"> /toPF</span><span class="id"> raddf0</span><span class="id"> oner_eq0</span>.<br/>
<span class="id">pose</span><span class="id"> mulM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">Zmodule_isComNzRing</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> mulA</span><span class="id"> mulC</span><span class="id"> mul1</span><span class="id"> mulD</span><span class="id"> nzL1</span>.<br/>
<span class="id">pose</span><span class="id"> rL</span><span class="id"> :</span><span class="id"> comNzRingType</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> vL</span><span class="id"> mulM</span>.<br/>
<span class="id">have</span><span class="id"> mulZlM</span><span class="id"> :</span><span class="id"> GRing</span>.<span class="id">Lmodule_isLalgebra</span><span class="id"> F</span><span class="id"> rL</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> apply:</span><span class="id"> toPinj</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> toL_K</span><span class="id"> /toPF</span><span class="id"> !linearZ</span><span class="id"> /=</span><span class="id"> -!/</span>(<span class="id">toPF</span><span class="id"> _</span>)<span class="id"> toL_K</span><span class="id"> -scalerAl</span><span class="id"> modpZl</span>.<br/>
<span class="id">pose</span><span class="id"> laL</span><span class="id"> :</span><span class="id"> lalgType</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> rL</span><span class="id"> mulZlM</span>.<br/>
<span class="id">have</span><span class="id"> mulZrM</span><span class="id"> :</span><span class="id"> GRing</span>.<span class="id">Lalgebra_isAlgebra</span><span class="id"> F</span><span class="id"> laL</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> constructor</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">mulrC</span><span class="id"> x</span>)<span class="id"> scalerAl</span>.<br/>
<span class="id">pose</span><span class="id"> aL</span><span class="id"> :</span><span class="id"> algType</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> laL</span><span class="id"> mulZrM</span>.<br/>
<span class="id">pose</span><span class="id"> uLM</span><span class="id"> :=</span><span class="id"> Algebra_isFalgebra</span>.<span class="id">Build</span><span class="id"> F</span><span class="id"> aL</span>.<br/>
<span class="id">pose</span><span class="id"> cuL</span><span class="id"> :</span><span class="id"> comUnitRingType</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> aL</span><span class="id"> uLM</span>.<br/>
<span class="id">have</span><span class="id"> unitM</span><span class="id"> :</span><span class="id"> GRing</span>.<span class="id">ComUnitRing_isField</span><span class="id"> cuL</span>.<br/>
&nbsp;&nbsp;<span class="id">constructor</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> nz_x;</span><span class="id"> apply/unitrP;</span><span class="id"> set</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> toPF</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nz_q:</span><span class="id"> q</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">inj_eq</span><span class="id"> toPinj</span>)<span class="id"> /toPF</span><span class="id"> raddf0</span><span class="gallina-kwd"> in</span><span class="id"> nz_x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Bezout_eq1_coprimepP[u</span><span class="id"> upq1]:</span><span class="id"> coprimep</span><span class="id"> p</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraLR</span> (<span class="id">leq_gcdpr</span><span class="id"> p</span><span class="id"> nz_q</span>)<span class="id"> =&gt;</span><span class="id"> /irr_p/implyP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dvdp_gcdl</span><span class="id"> -ltnNge</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> /eqp_size-&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">polySpred</span><span class="id"> nz_p</span>)<span class="id"> ltnS</span><span class="id"> size_poly</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices:</span><span class="id"> x</span><span class="id"> *</span><span class="id"> toL</span><span class="id"> u</span>.<span class="id">2</span><span class="id"> =</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">toL</span><span class="id"> u</span>.<span class="id">2</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> mulrC</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> toPinj;</span><span class="id"> rewrite</span><span class="id"> !toL_K</span><span class="id"> -upq1</span><span class="id"> modp_mul</span><span class="id"> modpD</span><span class="id"> mulrC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> modp_mull</span><span class="id"> add0r</span>.<br/>
<span class="id">pose</span><span class="id"> feL</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> vL</span><span class="id"> aL</span><span class="id"> cuL</span><span class="id"> unitM</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> feL;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> dimvf;</span><span class="id"> apply:</span><span class="id"> mul1n</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> toPF</span>.<br/>
<span class="id">have</span><span class="id"> tol_lin:</span><span class="id"> linear</span><span class="id"> toL</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> q1</span><span class="id"> q2;</span><span class="id"> rewrite</span><span class="id"> -linearP</span><span class="id"> -modpZl</span><span class="id"> -modpD</span>.<br/>
<span class="id">have</span><span class="id"> tol_mul</span><span class="id"> :</span><span class="id"> multiplicative</span> (<span class="id">toL</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> F}</span><span class="id"> -&gt;</span><span class="id"> aL</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [q</span><span class="id"> r|];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> toPinj;</span><span class="id"> rewrite</span><span class="id"> !toL_K</span><span class="id"> //</span><span class="id"> modp_mul</span><span class="id"> -!</span>(<span class="id">mulrC</span><span class="id"> r</span>)<span class="id"> modp_mul</span>.<br/>
<span class="id">pose</span><span class="id"> toLlM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isLinear</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> toL</span><span class="id"> tol_lin</span>.<br/>
<span class="id">pose</span><span class="id"> toLmM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> tol_mul</span>.<br/>
<span class="id">pose</span><span class="id"> toLLRM</span><span class="id"> :</span><span class="id"> {lrmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> feL}</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> toL</span><span class="id"> toLlM</span><span class="id"> toLmM</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> toLLRM</span>.<br/>
Qed.</div></details>
<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
