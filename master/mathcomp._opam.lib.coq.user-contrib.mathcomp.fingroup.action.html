
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.mathcomp.fingroup.action</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.mathcomp.fingroup.action" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.ssrnum.html">ssrnum</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
<li><a href="mathcomp.ssreflect.bigop.html">bigop</a></li>
<li><a href="mathcomp.ssreflect.binomial.html">binomial</a></li>
<li><a href="mathcomp.ssreflect.choice.html">choice</a></li>
<li><a href="mathcomp.ssreflect.div.html">div</a></li>
<li><a href="mathcomp.ssreflect.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.ssreflect.finfun.html">finfun</a></li>
<li><a href="mathcomp.ssreflect.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.ssreflect.finset.html">finset</a></li>
<li><a href="mathcomp.ssreflect.fintype.html">fintype</a></li>
<li><a href="mathcomp.ssreflect.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.ssreflect.order.html">order</a></li>
<li><a href="mathcomp.ssreflect.path.html">path</a></li>
<li><a href="mathcomp.ssreflect.prime.html">prime</a></li>
<li><a href="mathcomp.ssreflect.seq.html">seq</a></li>
<li><a href="mathcomp.ssreflect.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.ssreflect.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.ssreflect.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.ssreflect.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.ssreflect.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.ssreflect.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.ssreflect.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.ssreflect.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.mathcomp.fingroup.action</h1>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrbool</span><span class="id"> ssrfun</span><span class="id"> ssrnotations</span><span class="id"> eqtype</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssrnat</span><span class="id"> div</span><span class="id"> seq</span><span class="id"> prime</span><span class="id"> fintype</span><span class="id"> bigop</span><span class="id"> finset</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> fingroup</span><span class="id"> morphism</span><span class="id"> perm</span><span class="id"> automorphism</span><span class="id"> quotient</span>.<br/>
<br/>
<pre class="ssrdoc">
Group action: orbits, stabilisers, transitivity.
       is_action D to == the function to : T -&gt; aT -&gt; T defines an action
                         of D : {set aT} on T.
           action D T == structure for a function defining an action of D.
           act_dom to == the domain D of to : action D rT.
   {action: aT &amp;-&gt; T} == structure for a total action.
                      := action [set: aT] T
  TotalAction to1 toM == the constructor for total actions; to1 and toM
                         are the proofs of the action identities for 1 and
                         a * b, respectively.
  is_groupAction R to == to is a group action on range R: for all a in D,
                         the permutation induced by to a is in Aut R. Thus
                         the action of D must be trivial outside R.
      groupAction D R == the structure for group actions of D on R. This
                         is a telescope on action D rT.
        gact_range to == the range R of to : groupAction D R.
    GroupAction toAut == constructs a groupAction for action to from
                         toAut : actm to @* D \subset Aut R (actm to is
                         the morphism to {perm rT} associated to 'to').
     orbit to A x == the orbit of x under the action of A via to.
orbit_transversal to A S == a transversal of the partition orbit to A @: S
                     of S, provided A acts on S via to.
   amove to A x y == the set of a in A whose action sends x to y.
     'C_A[x | to] == the stabiliser of x : rT in A :&amp;: D.
     'C_A(S | to) == the pointwise stabiliser of S : {set rT} in D :&amp;: A.
     'N_A(S | to) == the global stabiliser of S : {set rT} in D :&amp;: A.
 'Fix_(S | to)[a] == the set of fixpoints of a in S.
 'Fix_(S | to)(A) == the set of fixpoints of A in S.
In the first three _A can be omitted and defaults to the domain D of to;
in the last two S can be omitted and defaults to [set: T], so 'Fix_to[a]
is the set of all fixpoints of a.
  The domain restriction ensures that stabilisers have a canonical group
structure, but note that 'Fix sets are generally not groups. Indeed, we
provide alternative definitions when to is a group action on R:
     'C_(G | to)(A) == the centraliser in R :&amp;: G of the group action of
                       D :&amp;: A via to
     'C_(G | to)[a] == the centraliser in R :&amp;: G of a \in D, via to.
  These sets are groups when G is; G can be omitted: 'C(|to)(A) is the
centraliser in R of the action of D :&amp;: A via to.
         [acts A, on S | to] == A \subset D acts on the set S via to.
         {acts A, on S | to} == A acts on the set S (Prop statement).
   {acts A, on group G | to} == [acts A, on S | to] /\ G \subset R, i.e.,
                                A \subset D acts on G \subset R, via
                                to : groupAction D R.
   [transitive A, on S | to] == A acts transitively on S.
     [faithful A, on S | to] == A acts faithfully on S.
     acts_irreducibly to A G == A acts irreducibly via the groupAction to
                                on the nontrivial group G, i.e., A does
                                not act on any nontrivial subgroup of G.
Important caveat: the definitions of orbit, amove, 'Fix_(S | to)(A),
transitive and faithful assume that A is a subset of the domain D. As most
of the permutation actions we consider are total this is usually harmless.
(Note that the theory of partial actions is only partially developed.)
  In all of the above, to is expected to be the actual action structure,
not merely the function. There is a special scope %act for actions, and
constructions and notations for many classical actions:
      'P == natural action of a permutation group via aperm.
      'J == internal group action (conjugation) via conjg (_ ^ _).
      'R == regular group action (right translation) via mulg (_ * _).
           (However, to limit ambiguity, _ * _ is NOT a canonical action.)
    to^* == the action induced by to on {set rT} via to^* (== setact to).
     'Js == the internal action on subsets via _ :^ _, equivalent to 'J^*.
     'Rs == the regular action on subsets via rcoset, equivalent to 'R^*.
     'JG == the conjugation action on {group rT} via (_ :^ _)%G.
  to / H == the action induced by to on coset_of H via qact to H, and
            restricted to (qact_dom to H) == 'N(rcosets H 'N(H) | to^* ).
      'Q == the action induced to cosets by conjugation; the domain is
            qact_dom 'J H, which is provably equal to 'N(H).
 to %% A == the action of coset_of A via modact to A, with domain D / A
            and support restricted to 'C(D :&amp;: A | to).
to \ sAD == the action of A via ract to sAD == to, if sAD : A \subset D.
 [Aut G] == the permutation action restricted to Aut G, via autact G.
 &lt;[nRA]&gt; == the action of A on R via actby nRA == to in A and on R, and
            the trivial action elsewhere; here nRA : [acts A, on R | to]
            or nRA : {acts A, on group R | to}.
    to^? == the action induced by to on sT : @subType rT P, via subact to
            with domain subact_dom P to == 'N([set x | P x] | to).
 &lt;&lt;phi&gt;&gt; == the action of phi : D &gt;-&gt; {perm rT}, via mact phi.
 to \o f == the composite action (with domain f @*^-1 D) of the action to
            with f : {morphism G &gt;-&gt; aT}, via comp_act to f. Here f must
            be the actual morphism object (e.g., coset_morphism H), not
            the underlying function (e.g., coset H).
The explicit application of an action to is usually written (to%act x a),
but %act can be omitted if to is an abstract action or a set action to^*.
Note that this form will simplify and expose the acting function.
  There is a %gact scope for group actions; the notations above are
recognised in %gact when they denote canonical group actions.
  Actions can be used to define morphisms:
actperm to == the morphism D &gt;-&gt; {perm rT} induced by to.
 actm to a == if a \in D the function on D induced by the action to, else
              the identity function. If to is a group action with range R
              then actm to a is canonically a morphism on R.
We also define here the restriction operation on permutations (the domain
of this operations is a stabiliser), and local automorphism groups:
 restr_perm S p == if p acts on S, the permutation with support in S that
                   coincides with p on S; else the identity. Note that
                   restr_perm is a permutation group morphism that maps
                   Aut G to Aut S when S is a subgroup of G.
     Aut_in A G == the local permutation group 'N_A(G | 'P) / 'C_A(G | 'P)
                   Usually A is an automorphism group, and then Aut_in A G
                   is isomorphic to a subgroup of Aut G, specifically
                   restr_perm @* A.
 Finally, gproduct.v will provide a semi-direct group construction that
maps an external group action to an internal one; the theory of morphisms
between such products makes use of the following definition:
 morph_act to to' f fA &lt;=&gt; the action of to' on the images of f and fA is
                  the image of the action of to, i.e., for all x and a we
                  have f (to x a) = to' (f x) (fA a). Note that there is
                  no mention of the domains of to and to'; if needed, this
                  predicate should be restricted via the {in ...} notation
                  and domain conditions should be added.
</pre>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> groupAction_scope</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> GroupScope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActionDef</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> aT</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> x</span><span class="id"> :</span><span class="id"> rT</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> act_morph</span><span class="id"> to</span><span class="id"> x</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> a</span><span class="id"> b,</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id"> =</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> b</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> is_action</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">left_injective</span><span class="id"> to</span><span class="id"> /\</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> {in</span><span class="id"> D</span><span class="id"> &amp;,</span><span class="id"> act_morph</span><span class="id"> to</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Record</span><span class="id"> action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> {act</span><span class="id"> :&gt;</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> act}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> clone_action</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> Action</span><span class="id"> _</span><span class="id"> toP</span><span class="id"> :=</span><span class="id"> to</span><span class="gallina-kwd"> return</span><span class="id"> {type</span><span class="id"> of</span><span class="id"> Action</span><span class="gallina-kwd"> for</span><span class="id"> to}</span><span class="id"> -&gt;</span><span class="id"> action</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> toP</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ActionDef</span>.<br/>
<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> action_scope</span><span class="gallina-kwd"> with</span><span class="id"> act</span>.<br/>
<span class="vernacular">Bind</span><span class="vernacular"> Scope</span><span class="id"> action_scope</span><span class="gallina-kwd"> with</span><span class="id"> action</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> act_morph</span><span class="id"> {aT</span><span class="id"> rT%_type}</span><span class="id"> to</span><span class="id"> x%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> is_action</span><span class="id"> {aT}</span><span class="id"> D%_g</span><span class="id"> {rT}</span><span class="id"> to</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> act</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT%_type}</span><span class="id"> to%_act</span><span class="id"> x%_g</span><span class="id"> a%_g</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> clone_action</span><span class="id"> [aT</span><span class="id"> D%_g</span><span class="id"> rT%_type</span><span class="id"> to%_act]</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'action' aT &amp;-&gt; T }&quot;</span><span class="id"> :=</span> (<span class="id">action</span><span class="id"> [set:</span><span class="id"> aT]</span><span class="id"> T</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'action'  aT  &amp;-&gt;  T }&quot;</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'action' 'of' to ]&quot;</span><span class="id"> :=</span> (<span class="id">clone_action</span> (<span class="id">@Action</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'action'  'of'  to ]&quot;</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> act_dom</span><span class="id"> aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> of</span><span class="id"> @action</span><span class="id"> aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> :=</span><span class="id"> D</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> TotalAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">to1</span><span class="id"> :</span><span class="id"> to^~</span><span class="id"> 1</span><span class="id"> =1</span><span class="id"> id</span>) (<span class="id">toM</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> act_morph</span><span class="id"> to</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> is_total_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> setT</span><span class="id"> to</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [a</span><span class="id"> |</span><span class="id"> x</span><span class="id"> a</span><span class="id"> b</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> /=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> toM</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> can_inj</span> (<span class="id">to^~</span><span class="id"> a^-1</span>)<span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -toM</span><span class="id"> ?mulgV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> TotalAction</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> is_total_action</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> TotalAction</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActionDefs</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> aT'</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">D'</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT'}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> morph_act</span><span class="id"> rT</span><span class="id"> rT'</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>) (<span class="id">to'</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D'</span><span class="id"> rT'</span>)<span class="id"> f</span><span class="id"> fA</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> a,</span><span class="id"> f</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> to'</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">fA</span><span class="id"> a</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finType</span>. <br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="gallina-kwd"> then</span><span class="id"> to^~</span><span class="id"> a</span><span class="gallina-kwd"> else</span><span class="id"> id</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> setact</span><span class="id"> to</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> S]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> to</span><span class="id"> x</span><span class="id"> @:</span><span class="id"> A</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> amove</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> a</span><span class="gallina-kwd"> in</span><span class="id"> A</span><span class="id"> |</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> ==</span><span class="id"> y]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> afix</span><span class="id"> to</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> [set</span><span class="id"> a</span><span class="id"> |</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> ==</span><span class="id"> x]]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> astab</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> D</span><span class="id"> :&amp;:</span><span class="id"> [set</span><span class="id"> a</span><span class="id"> |</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> [set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> ==</span><span class="id"> x]]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> astabs</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> D</span><span class="id"> :&amp;:</span><span class="id"> [set</span><span class="id"> a</span><span class="id"> |</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> @^-1:</span><span class="id"> S]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> acts_on</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> A,</span><span class="gallina-kwd"> forall</span><span class="id"> a</span><span class="id"> x,</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id">}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> atrans</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> S</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> @:</span><span class="id"> S</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> faithful</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> A</span><span class="id"> :&amp;:</span><span class="id"> astab</span><span class="id"> S</span><span class="id"> to</span><span class="id"> \subset</span><span class="id"> [1]</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> ActionDefs</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> setact</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> to%_act</span><span class="id"> S%_g</span><span class="id"> a%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> orbit</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> to%_act</span><span class="id"> A%_g</span><span class="id"> x%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> amove</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> to%_act</span><span class="id"> A%_g</span><span class="id"> x%_g</span><span class="id"> y%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> afix</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> to%_act</span><span class="id"> A%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> astab</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> S%_g</span><span class="id"> to%_act</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> astabs</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> S%_g</span><span class="id"> to%_act</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> acts_on</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> A%_g</span><span class="id"> S%_g</span><span class="id"> to%_act</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> atrans</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> A%_g</span><span class="id"> S%_g</span><span class="id"> to%_act</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> faithful</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> A%_g</span><span class="id"> S%_g</span><span class="id"> to%_act</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to ^*&quot;</span><span class="id"> :=</span> (<span class="id">setact</span><span class="id"> to</span>)<span class="id"> :</span><span class="id"> function_scope</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> orbit</span><span class="id"> amove</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Fix_' to ( A )&quot;</span><span class="id"> :=</span> (<span class="id">afix</span><span class="id"> to</span><span class="id"> A</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> to</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''Fix_' to ( A )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Fix_' ( to ) ( A )&quot;</span><span class="id"> :=</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Fix_' ( S | to ) ( A )&quot;</span><span class="id"> :=</span> (<span class="id">S</span><span class="id"> :&amp;:</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>))<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''Fix_' ( S  |  to ) ( A )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Fix_' to [ a ]&quot;</span><span class="id"> :=</span> (<span class="id">'Fix_to</span>(<span class="id">[set</span><span class="id"> a]</span>))<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> to</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''Fix_' to [ a ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Fix_' ( S | to ) [ a ]&quot;</span><span class="id"> :=</span> (<span class="id">S</span><span class="id"> :&amp;:</span><span class="id"> 'Fix_to[a]</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''Fix_' ( S  |  to ) [ a ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C' ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">astab</span><span class="id"> S</span><span class="id"> to</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C' ( S  |  to )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' A ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''C_' A ( S  |  to )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( A ) ( S | to )&quot;</span><span class="id"> :=</span><span class="id"> 'C_A</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C' [ x | to ]&quot;</span><span class="id"> :=</span> (<span class="id">'C</span>(<span class="id">[set</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> to</span>))<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C' [ x  |  to ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' A [ x | to ]&quot;</span><span class="id"> :=</span> (<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''C_' A [ x  |  to ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( A ) [ x | to ]&quot;</span><span class="id"> :=</span><span class="id"> 'C_A[x</span><span class="id"> |</span><span class="id"> to]</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''N' ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">astabs</span><span class="id"> S</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''N' ( S  |  to )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''N_' A ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> A</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''N_' A ( S  |  to )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'acts' A , 'on' S | to ]&quot;</span><span class="id"> :=</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> pred_of_set</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'acts'  A ,  'on'  S  |  to ]&quot;</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'acts' A , 'on' S | to }&quot;</span><span class="id"> :=</span> (<span class="id">acts_on</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'acts'  A ,  'on'  S  |  to }&quot;</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'transitive' A , 'on' S | to ]&quot;</span><span class="id"> :=</span> (<span class="id">atrans</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'transitive'  A ,  'on'  S  |  to ]&quot;</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'faithful' A , 'on' S | to ]&quot;</span><span class="id"> :=</span> (<span class="id">faithful</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'faithful'  A ,  'on'  S  |  to ]&quot;</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RawAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> aT</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> rT</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> act_inj</span><span class="id"> :</span><span class="id"> left_injective</span><span class="id"> to</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> to</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> act_inj</span><span class="id"> :</span><span class="id"> clear</span><span class="id"> implicits</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actMin</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D</span><span class="id"> &amp;,</span><span class="id"> act_morph</span><span class="id"> to</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> to</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actmEfun</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> =</span><span class="id"> to^~</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /actm</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actmE</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> =1</span><span class="id"> to^~</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> actmEfun</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setactE</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> to^*</span><span class="id"> S</span><span class="id"> a</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> |</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> S]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_setact</span><span class="id"> S</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> to^*</span><span class="id"> S</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> imset_f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_setact</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> #|to^*</span><span class="id"> S</span><span class="id"> a|</span><span class="id"> =</span><span class="id"> #|S|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> card_imset;</span><span class="id"> apply:</span><span class="id"> act_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setact_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> D</span><span class="id"> to^*</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [a</span><span class="id"> R</span><span class="id"> S</span><span class="id"> eqRS</span><span class="id"> |</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Da</span><span class="id"> Db</span><span class="id"> S];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /setact</span><span class="id"> /=</span><span class="id"> -imset_comp;</span><span class="id"> apply:</span><span class="id"> eq_imset</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> actMin</span>.<br/>
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> /</span>(<span class="id">mem_setact</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqRS</span><span class="id"> =&gt;</span><span class="id"> /imsetP[y</span><span class="id"> Sy</span><span class="id"> /act_inj-&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqRS</span><span class="id"> =&gt;</span><span class="id"> /imsetP[y</span><span class="id"> Sy</span><span class="id"> /act_inj-&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> set_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> setact_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitE</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> @:</span><span class="id"> A</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitP</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> y</span>) (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> imsetP</span>)<span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> [a];</span><span class="gallina-kwd"> exists</span><span class="id"> a</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_orbit</span><span class="id"> A</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> imset_f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixP</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> subsetP</span>)<span class="id"> =&gt;</span><span class="id"> [xfix</span><span class="id"> a</span><span class="id"> /xfix</span><span class="id"> |</span><span class="id"> xfix</span><span class="id"> a</span><span class="id"> Aa]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> xfix</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixS</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> 'Fix_to</span>(<span class="id">B</span>)<span class="id"> \subset</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAB;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> u</span><span class="id"> /[!inE];</span><span class="id"> apply:</span><span class="id"> subset_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixU</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">A</span><span class="id"> :|:</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)<span class="id"> :&amp;:</span><span class="id"> 'Fix_to</span>(<span class="id">B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> subUset</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix1P</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'Fix_to[a]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> sub1set</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabIdom</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C_D</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span><span class="id"> setIid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_dom</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> &lt;=</span><span class="id"> D}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> /setIP[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_act</span><span class="id"> S</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> 2!inE</span><span class="id"> =&gt;</span><span class="id"> /andP[_</span><span class="id"> cSa]</span><span class="id"> Sx;</span><span class="id"> apply/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /[1!inE]</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> cSa</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabS</span><span class="id"> S1</span><span class="id"> S2</span><span class="id"> :</span><span class="id"> S1</span><span class="id"> \subset</span><span class="id"> S2</span><span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">S2</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S1</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sS12;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> /[!inE]</span><span class="id"> /andP[-&gt;];</span><span class="id"> apply:</span><span class="id"> subset_trans</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsIdom</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N_D</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span><span class="id"> setIid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_dom</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> &lt;=</span><span class="id"> D}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> /setIdP[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_act</span><span class="id"> S</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> 2!inE</span><span class="id"> subEproper</span><span class="id"> properEcard</span><span class="id"> =&gt;</span><span class="id"> /andP[_]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_preimset</span><span class="id"> _</span> (<span class="id">act_inj</span><span class="id"> _</span>))<span class="id"> ltnn</span><span class="id"> andbF</span><span class="id"> orbF</span><span class="id"> =&gt;</span><span class="id"> /eqP{2}-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_sub</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> cSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">astab_dom</span><span class="id"> cSa</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> inE</span> (<span class="id">astab_act</span><span class="id"> cSa</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsC</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">~:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> nSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">astabs_dom</span><span class="id"> nSa</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -setCS</span><span class="id"> -preimsetC;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> astabs_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> preimsetC</span><span class="id"> setCS;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> astabs_act</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsI</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">T</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> :&amp;:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -!andbA</span><span class="id"> preimsetI</span><span class="id"> =&gt;</span><span class="id"> /and4P[-&gt;</span><span class="id"> nSa</span><span class="id"> _</span><span class="id"> nTa]</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setISS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_setact</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> to^*</span><span class="id"> S</span><span class="id"> a</span><span class="id"> =</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nSa;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> card_setact</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> astabs_act</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1_set</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C[S</span><span class="id"> |</span><span class="id"> set_action]</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> nSa</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setIdP:</span><span class="id"> nSa</span><span class="id"> =&gt;</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span><span class="id"> sub1set</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> defS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -defS</span><span class="id"> mem_setact</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">astabs_dom</span><span class="id"> nSa</span>)<span class="id"> sub1set</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> astabs_setact</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_set1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">[set</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> astab_sub</span><span class="id"> andbC</span><span class="id"> setIS</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">inE,sub1set</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_dom</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> nSA;</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> nSA</span>)<span class="id"> ?subsetIl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_act</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> {acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> nAS</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> astabs_act</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> nAS</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabCin</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<span class="id"> =</span> (<span class="id">S</span><span class="id"> \subset</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD;</span><span class="id"> apply/subsetP/subsetP=&gt;</span><span class="id"> [sAC</span><span class="id"> x</span><span class="id"> xS</span><span class="id"> |</span><span class="id"> sSF</span><span class="id"> a</span><span class="id"> aA]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/afixP=&gt;</span><span class="id"> a</span><span class="id"> aA;</span><span class="id"> apply:</span><span class="id"> astab_act</span> (<span class="id">sAC</span><span class="id"> _</span><span class="id"> aA</span>)<span class="id"> xS</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span> (<span class="id">subsetP</span><span class="id"> sAD</span><span class="id"> _</span><span class="id"> aA</span>)<span class="id">;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> xS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/afixP/</span>(_<span class="id"> _</span><span class="id"> aA</span>)<span class="id">:</span> (<span class="id">sSF</span><span class="id"> _</span><span class="id"> xS</span>)<span class="id"> =&gt;</span><span class="id"> /[1!inE]</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ActsSetop</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">AactS</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>) (<span class="id">AactT</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to]</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabU</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> :|:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :&amp;:</span><span class="id"> 'C</span>(<span class="id">T</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> subUset;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> D</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsU</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">T</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> :|:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">astabsC</span><span class="id"> S</span>)<span class="id"> -</span>(<span class="id">astabsC</span><span class="id"> T</span>)<span class="id"> -</span>(<span class="id">astabsC</span> (<span class="id">S</span><span class="id"> :|:</span><span class="id"> T</span>))<span class="id"> setCU</span><span class="id"> astabsI</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsD</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">T</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> :\:</span><span class="id"> T|</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setDE</span><span class="id"> -</span>(<span class="id">astabsC</span><span class="id"> T</span>)<span class="id"> astabsI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsI</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> :&amp;:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_trans</span> (<span class="id">astabsI</span><span class="id"> S</span><span class="id"> T</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> AactS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsU</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> :|:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> astabsU;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> AactS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsD</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> :\:</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> astabsD;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> AactS</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ActsSetop</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_in_orbit</span><span class="id"> A</span><span class="id"> S</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nSA/imsetP[a</span><span class="id"> Aa</span><span class="id"> -&gt;{y}]</span><span class="id"> Sx;</span><span class="id"> rewrite</span> (<span class="id">astabs_act</span><span class="id"> _</span> (<span class="id">subsetP</span><span class="id"> nSA</span><span class="id"> a</span><span class="id"> Aa</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_faithful</span><span class="id"> A</span><span class="id"> B</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">B</span><span class="id"> \subset</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> [faithful</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [faithful</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAB;</span><span class="id"> apply:</span><span class="id"> subset_trans;</span><span class="id"> apply:</span><span class="id"> setSI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Reindex</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">vT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">idx</span><span class="id"> :</span><span class="id"> vT</span>) (<span class="id">op</span><span class="id"> :</span><span class="id"> Monoid</span>.<span class="id">com_law</span><span class="id"> idx</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_astabs</span><span class="id"> a</span><span class="id"> F</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> F</span> (<span class="id">to</span><span class="id"> i</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nSa;</span><span class="id"> rewrite</span> (<span class="id">reindex_inj</span> (<span class="id">act_inj</span><span class="id"> a</span>))<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_bigl</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">exact:</span><span class="id"> astabs_act</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reindex_acts</span><span class="id"> A</span><span class="id"> a</span><span class="id"> F</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\big[op/idx]_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> F</span><span class="id"> i</span><span class="id"> =</span><span class="id"> \big[op/idx]_</span>(<span class="id">i</span><span class="gallina-kwd"> in</span><span class="id"> S</span>)<span class="id"> F</span> (<span class="id">to</span><span class="id"> i</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> nSA</span><span class="id"> /</span>(<span class="id">subsetP</span><span class="id"> nSA</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> reindex_astabs</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Reindex</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> RawAction</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> act_inj</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT}</span><span class="id"> to</span><span class="id"> a</span><span class="id"> [x1</span><span class="id"> x2]</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to ^*&quot;</span><span class="id"> :=</span> (<span class="id">set_action</span><span class="id"> to</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> orbitP</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> afixP</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> afix1P</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> a</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> reindex_astabs</span><span class="id"> [aT</span><span class="id"> D</span><span class="id"> rT]</span><span class="id"> to</span><span class="id"> [vT</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> S]</span><span class="id"> a</span><span class="id"> [F]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> reindex_acts</span><span class="id"> [aT</span><span class="id"> D</span><span class="id"> rT]</span><span class="id"> to</span><span class="id"> [vT</span><span class="id"> idx</span><span class="id"> op</span><span class="id"> S</span><span class="id"> A</span><span class="id"> a</span><span class="id"> F]</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PartialAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> a</span><span class="id"> :</span><span class="id"> aT</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> rT</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> act1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> to</span><span class="id"> x</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">act_inj</span><span class="id"> to</span><span class="id"> 1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -actMin</span><span class="id"> ?mulg1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actKin</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="id"> right_loop</span><span class="id"> invg</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -actMin</span><span class="id"> ?groupV</span><span class="id"> //</span><span class="id"> mulgV</span><span class="id"> act1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actKVin</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="id"> rev_right_loop</span><span class="id"> invg</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">invgK</span><span class="id"> a</span>)<span class="id"> actKin</span><span class="id"> ?groupV</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setactVin</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> to^*</span><span class="id"> S</span><span class="id"> a^-1</span><span class="id"> =</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> @^-1:</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Da;</span><span class="id"> apply:</span><span class="id"> can2_imset_pre;</span><span class="id"> [apply:</span><span class="id"> actKVin</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> actKin]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actXin</span><span class="id"> x</span><span class="id"> a</span><span class="id"> i</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">a</span><span class="id"> ^+</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> iter</span><span class="id"> i</span> (<span class="id">to^~</span><span class="id"> a</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Da;</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|i</span><span class="id"> &lt;-];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> act1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expgSr</span><span class="id"> actMin</span><span class="id"> ?groupX</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix1</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> setT</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> sub1set</span><span class="id"> inE</span><span class="id"> act1</span><span class="id"> eqxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixD1</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">G^#</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">setD1K</span> (<span class="id">group1</span><span class="id"> G</span>))<span class="id"> afixU</span><span class="id"> afix1</span><span class="id"> setTI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_refl</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{1}[x]act1</span><span class="id"> mem_orbit</span>. Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> orbit_rel</span><span class="id"> A</span><span class="id"> :=</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> y</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> contra_orbit</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> contraNneq</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> orbit_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_in_sym</span><span class="id"> G</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> symmetric</span> (<span class="id">orbit_rel</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD;</span><span class="id"> apply:</span><span class="id"> symmetric_from_pre</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /imsetP[a</span><span class="id"> Ga]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">canLR</span> (<span class="id">actKin</span> (<span class="id">subsetP</span><span class="id"> sGD</span><span class="id"> a</span><span class="id"> Ga</span>)))<span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> mem_orbit</span><span class="id"> ?groupV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_in_trans</span><span class="id"> G</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> transitive</span> (<span class="id">orbit_rel</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD</span><span class="id"> _</span><span class="id"> _</span><span class="id"> z</span><span class="id"> /imsetP[a</span><span class="id"> Ga</span><span class="id"> -&gt;]</span><span class="id"> /imsetP[b</span><span class="id"> Gb</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -actMin</span><span class="id"> ?mem_orbit</span><span class="id"> ?groupM</span><span class="id"> //</span> (<span class="id">subsetP</span><span class="id"> sGD</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_in_eqP</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> reflect</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [yGx|&lt;-];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> orbit_refl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/setP=&gt;</span><span class="id"> z;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> /orbit_in_trans-&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> orbit_in_sym</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_in_transl</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> Gxy;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">orbit_in_sym</span><span class="id"> sGD</span><span class="id"> _</span><span class="id"> z</span>) (<span class="id">orbit_in_eqP</span><span class="id"> y</span><span class="id"> x</span><span class="id"> sGD</span><span class="id"> Gxy</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_act_in</span><span class="id"> x</span><span class="id"> a</span><span class="id"> G</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> /mem_orbit/orbit_in_eqP-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_actr_in</span><span class="id"> x</span><span class="id"> a</span><span class="id"> G</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> /mem_orbit/orbit_in_transl-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_inv_in</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A^-1</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/subsetP=&gt;</span><span class="id"> sAD;</span><span class="id"> apply/imsetP/imsetP=&gt;</span><span class="id"> []</span><span class="id"> [a</span><span class="id"> Aa</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> a^-1;</span><span class="id"> rewrite</span><span class="id"> -?mem_invg</span><span class="id"> ?actKin</span><span class="id"> //</span><span class="id"> -groupV</span><span class="id"> sAD</span><span class="id"> -?mem_invg</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> a^-1;</span><span class="id"> rewrite</span><span class="id"> ?memV_invg</span><span class="id"> ?actKin</span><span class="id"> //</span><span class="id"> sAD</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_lcoset_in</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">orbit</span><span class="id"> to</span> (<span class="id">a</span><span class="id"> *:</span><span class="id"> A</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/subsetP=&gt;</span><span class="id"> sAD</span><span class="id"> Da;</span><span class="id"> apply/setP=&gt;</span><span class="id"> y;</span><span class="id"> apply/imsetP/imsetP=&gt;</span><span class="id"> []</span><span class="id"> [b</span><span class="id"> Ab</span><span class="id"> -&gt;{y}]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">a^-1</span><span class="id"> *</span><span class="id"> b</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -?actMin</span><span class="id"> ?mulKVg</span><span class="id"> //</span><span class="id"> ?sAD</span><span class="id"> -?mem_lcoset</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?mem_mulg</span><span class="id"> ?set11</span><span class="id"> ?actMin</span><span class="id"> //</span><span class="id"> sAD</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_rcoset_in</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">A</span><span class="id"> :*</span><span class="id"> a</span>)<span class="id"> x</span>)<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> -orbit_inv_in</span><span class="id"> ?mul_subG</span><span class="id"> ?sub1set</span><span class="id"> //</span><span class="id"> invMg</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invg_set1</span><span class="id"> orbit_lcoset_in</span><span class="id"> ?inv_subG</span><span class="id"> ?groupV</span><span class="id"> ?actKin</span><span class="id"> ?orbit_inv_in</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_conjsg_in</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">A</span><span class="id"> :^</span><span class="id"> a</span>) (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>))<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> conjsgE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> orbit_lcoset_in</span><span class="id"> ?groupV</span><span class="id"> ?mul_subG</span><span class="id"> ?sub1set</span><span class="id"> ?actKin</span><span class="id"> ?orbit_rcoset_in</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit1P</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'Fix_to</span>(<span class="id">G</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> afixP</span>)<span class="id"> =&gt;</span><span class="id"> [xfix</span><span class="id"> |</span><span class="id"> xfix</span><span class="id"> a</span><span class="id"> Ga]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEsubset</span><span class="id"> sub1set</span><span class="id"> -{1}[x]act1</span><span class="id"> imset_f</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> y;</span><span class="id"> case/imsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> xfix</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/set1P;</span><span class="id"> rewrite</span><span class="id"> -xfix</span><span class="id"> imset_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_orbit1</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> #|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> =</span><span class="id"> 1%N</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> orb1;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> {}orb1</span><span class="id"> cards1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sub1set</span><span class="id"> orbit_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_partition</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> partition</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> @:</span><span class="id"> S</span>)<span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> actsGS;</span><span class="id"> have</span><span class="id"> sGD</span><span class="id"> :=</span><span class="id"> acts_dom</span><span class="id"> actsGS</span>.<br/>
<span class="id">have</span><span class="id"> eqiG:</span><span class="id"> {in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> equivalence_rel</span><span class="id"> [rel</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x]}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> *</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> orbit_refl;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> /orbit_in_eqP-&gt;</span>.<br/>
<span class="id">congr</span> (<span class="id">partition</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">:</span> (<span class="id">equivalence_partitionP</span><span class="id"> eqiG</span>).<br/>
<span class="id">apply:</span><span class="id"> eq_in_imset</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> apply/setP=&gt;</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> andb_idl</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /acts_in_orbit-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> orbit_transversal</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> transversal</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> @:</span><span class="id"> S</span>)<span class="id"> S</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_transversalP</span><span class="id"> G</span><span class="id"> S</span> (<span class="id">P</span><span class="id"> :=</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> @:</span><span class="id"> S</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">X</span><span class="id"> :=</span><span class="id"> orbit_transversal</span><span class="id"> G</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;<span class="id">[/\</span><span class="id"> is_transversal</span><span class="id"> X</span><span class="id"> P</span><span class="id"> S,</span><span class="id"> X</span><span class="id"> \subset</span><span class="id"> S,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> X</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> X]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/orbit_partition;</span><span class="id"> rewrite</span><span class="id"> -/P</span><span class="id"> =&gt;</span><span class="id"> partP</span>.<br/>
<span class="id">have</span><span class="id"> [/eqP</span><span class="id"> defS</span><span class="id"> tiP</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> and3P</span><span class="id"> partP</span>.<br/>
<span class="id">have</span><span class="id"> trXP:</span><span class="id"> is_transversal</span><span class="id"> X</span><span class="id"> P</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> transversalP</span><span class="id"> partP</span>.<br/>
<span class="id">have</span><span class="id"> sXS:</span><span class="id"> X</span><span class="id"> \subset</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> transversal_sub</span><span class="id"> trXP</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> //</span><span class="id"> [x</span><span class="id"> y</span><span class="id"> Xx</span><span class="id"> Xy</span><span class="id"> /=</span><span class="id"> |</span><span class="id"> x</span><span class="id"> Sx]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Sx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sXS</span><span class="id"> x</span><span class="id"> Xx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">inj_in_eq</span> (<span class="id">pblock_inj</span><span class="id"> trXP</span>))<span class="id"> //</span><span class="id"> eq_pblock</span><span class="id"> ?defS</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">def_pblock</span><span class="id"> tiP</span> (<span class="id">imset_f</span><span class="id"> _</span><span class="id"> Sx</span>))<span class="id"> ?orbit_refl</span>.<br/>
<span class="id">have</span><span class="id"> /imsetP[y</span><span class="id"> Xy</span><span class="id"> defxG]:</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> pblock</span><span class="id"> P</span><span class="id"> @:</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">pblock_transversal</span><span class="id"> trXP</span>)<span class="id"> ?imset_f</span>.<br/>
<span class="id">suffices</span><span class="id"> /orbitP[a</span><span class="id"> Ga</span><span class="id"> def_y]:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> ?def_y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defxG</span><span class="id"> mem_pblock</span><span class="id"> defS</span> (<span class="id">subsetP</span><span class="id"> sXS</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> group_set_astab</span><span class="id"> S</span><span class="id"> :</span><span class="id"> group_set</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/group_setP;</span><span class="id"> split=&gt;</span><span class="id"> [|a</span><span class="id"> b</span><span class="id"> cSa</span><span class="id"> cSb]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> group1;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> act1</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> groupM</span><span class="id"> ?</span>(<span class="id">@astab_dom</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> actMin</span><span class="id"> ?</span>(<span class="id">@astab_dom</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> ?</span>(<span class="id">astab_act</span><span class="id"> _</span><span class="id"> Sx</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> astab_group</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> group</span> (<span class="id">group_set_astab</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_gen_in</span><span class="id"> A</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'Fix_to</span>(<span class="id">&lt;&lt;A&gt;&gt;</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> afixS</span><span class="id"> ?sub_gen</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -astabCin</span><span class="id"> gen_subG</span><span class="id"> ?astabCin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_cycle_in</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'Fix_to</span>(<span class="id">&lt;[a]&gt;</span>)<span class="id"> =</span><span class="id"> 'Fix_to[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> afix_gen_in</span><span class="id"> ?sub1set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixYin</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'Fix_to</span>(<span class="id">A</span><span class="id"> &lt;*&gt;</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)<span class="id"> :&amp;:</span><span class="id"> 'Fix_to</span>(<span class="id">B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAD</span><span class="id"> sBD;</span><span class="id"> rewrite</span><span class="id"> afix_gen_in</span><span class="id"> ?afixU</span><span class="id"> //</span><span class="id"> subUset</span><span class="id"> sAD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixMin</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'Fix_to</span>(<span class="id">G</span><span class="id"> *</span><span class="id"> H</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">G</span>)<span class="id"> :&amp;:</span><span class="id"> 'Fix_to</span>(<span class="id">H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> sHD;</span><span class="id"> rewrite</span><span class="id"> -afix_gen_in</span><span class="id"> ?mul_subG</span><span class="id"> //</span><span class="id"> genM_join</span><span class="id"> afixYin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_astab1_in</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAD;</span><span class="id"> rewrite</span><span class="id"> astabCin</span><span class="id"> ?sub1set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> group_set_astabs</span><span class="id"> S</span><span class="id"> :</span><span class="id"> group_set</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/group_setP;</span><span class="id"> split=&gt;</span><span class="id"> [|a</span><span class="id"> b</span><span class="id"> cSa</span><span class="id"> cSb]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> group1;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> act1</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> groupM</span><span class="id"> ?</span>(<span class="id">@astabs_dom</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> actMin</span><span class="id"> ?</span>(<span class="id">@astabs_dom</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> ?astabs_act</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> astabs_group</span><span class="id"> S</span><span class="id"> :=</span><span class="id"> group</span> (<span class="id">group_set_astabs</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_norm</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> nSa;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> sub_conjg;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> b</span><span class="id"> cSb</span>.<br/>
<span class="id">have</span><span class="id"> [Da</span><span class="id"> Db]</span><span class="id"> :=</span> (<span class="id">astabs_dom</span><span class="id"> nSa,</span><span class="id"> astab_dom</span><span class="id"> cSb</span>).<br/>
<span class="id">rewrite</span><span class="id"> mem_conjgV</span><span class="id"> !inE</span><span class="id"> groupJ</span><span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> !actMin</span><span class="id"> ?groupM</span><span class="id"> ?groupV</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">astab_act</span><span class="id"> cSb</span>)<span class="id"> ?actKVin</span><span class="id"> ?astabs_act</span><span class="id"> ?groupV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_normal</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> &lt;|</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /normal</span><span class="id"> astab_sub</span><span class="id"> astab_norm</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_sub_orbit</span><span class="id"> G</span><span class="id"> S</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> \subset</span><span class="id"> S</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/acts_act=&gt;</span><span class="id"> GactS</span>.<br/>
<span class="id">apply/subsetP/idP=&gt;</span><span class="id"> [|</span><span class="id"> Sx</span><span class="id"> y];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply;</span><span class="id"> apply:</span><span class="id"> orbit_refl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/orbitP=&gt;</span><span class="id"> a</span><span class="id"> Ga</span><span class="id"> &lt;-{y};</span><span class="id"> rewrite</span><span class="id"> GactS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_orbit</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/subsetP=&gt;</span><span class="id"> sGD;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> sGD</span><span class="id"> //</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[b</span><span class="id"> Gb</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -actMin</span><span class="id"> ?sGD</span><span class="id"> //</span><span class="id"> imset_f</span><span class="id"> ?groupM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_subnorm_fix</span><span class="id"> A</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> 'N_D</span>(<span class="id">A</span>)<span class="id">,</span><span class="id"> on</span><span class="id"> 'Fix_to</span>(<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> A</span>)<span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> nAa;</span><span class="id"> have</span><span class="id"> [Da</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setIP</span><span class="id"> nAa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Cx</span><span class="id"> /[1!inE];</span><span class="id"> apply/afixP=&gt;</span><span class="id"> b</span><span class="id"> DAb</span>.<br/>
<span class="id">have</span><span class="id"> [Db</span><span class="id"> _]:=</span><span class="id"> setIP</span><span class="id"> DAb;</span><span class="id"> rewrite</span><span class="id"> -actMin</span><span class="id"> //</span><span class="id"> conjgCV</span> <span class="id"> actMin</span><span class="id"> ?groupJ</span><span class="id"> ?groupV</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span> (<span class="id">afixP</span><span class="id"> Cx</span>)<span class="id"> //</span><span class="id"> memJ_norm</span><span class="id"> //</span><span class="id"> groupV</span> (<span class="id">subsetP</span> (<span class="id">normsGI</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> _</span><span class="id"> nAa</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_orbit</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> imset_f;</span><span class="id"> apply:</span><span class="id"> orbit_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> OrbitStabilizer</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> sGD</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span>.<br/>
<span class="vernacular">Let</span><span class="id"> ssGD</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sGD</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> amove_act</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> amove</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> :*</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ga;</span><span class="id"> apply/setP=&gt;</span><span class="id"> b;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> ssGD</span><span class="id"> Ga</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_rcoset</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> sub1set</span>)<span class="id"> !groupMr</span><span class="id"> ?groupV</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> Gb:</span> (<span class="id">b</span><span class="id"> \in</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> actMin</span><span class="id"> ?groupV</span><span class="id"> ?ssGD</span><span class="id"> ?</span>(<span class="id">canF_eq</span> (<span class="id">actKVin</span><span class="id"> Da</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> amove_orbit</span><span class="id"> :</span><span class="id"> amove</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> @:</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> rcosets</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP</span><span class="id"> =&gt;</span><span class="id"> Ha;</span><span class="id"> apply/imsetP/rcosetsP=&gt;</span><span class="id"> [[y]</span><span class="id"> |</span><span class="id"> [a</span><span class="id"> Ga</span><span class="id"> -&gt;]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> b</span><span class="id"> Gb</span><span class="id"> -&gt;</span><span class="id"> -&gt;{Ha</span><span class="id"> y};</span><span class="gallina-kwd"> exists</span><span class="id"> b</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> amove_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -amove_act</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> mem_orbit</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> amoveK</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x,</span><span class="id"> cancel</span> (<span class="id">amove</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>) (<span class="gallina-kwd">fun</span><span class="id"> Ca</span><span class="id"> =&gt;</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">repr</span><span class="id"> Ca</span>))<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> /orbitP[a</span><span class="id"> Ga</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> amove_act</span><span class="id"> //=</span><span class="id"> -[G</span><span class="id"> :&amp;:</span><span class="id"> _]/</span>(<span class="id">gval</span><span class="id"> _</span>).<br/>
<span class="id">case:</span><span class="id"> repr_rcosetP</span><span class="id"> =&gt;</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> sub1set</span>)<span class="id">=&gt;</span><span class="id"> /and3P[Gb</span><span class="id"> _</span><span class="id"> xbx]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> actMin</span><span class="id"> ?ssGD</span><span class="id"> ?</span>(<span class="id">eqP</span><span class="id"> xbx</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_stabilizer</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">repr</span><span class="id"> Ca</span>)<span class="id"> |</span><span class="id"> Ca</span><span class="gallina-kwd"> in</span><span class="id"> rcosets</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> G]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -amove_orbit</span><span class="id"> -imset_comp</span><span class="id"> /=;</span><span class="id"> apply/setP=&gt;</span><span class="id"> z</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/imsetP=&gt;</span><span class="id"> [xGz</span><span class="id"> |</span><span class="id"> [y</span><span class="id"> xGy</span><span class="id"> -&gt;]];</span><span class="id"> first</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?amoveK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> act_reprK</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> rcosets</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> G,</span><span class="id"> cancel</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> \o</span><span class="id"> repr</span>) (<span class="id">amove</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>)<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> /rcosetsP[a</span><span class="id"> Ga</span><span class="id"> -&gt;]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> amove_act</span><span class="id"> ?rcoset_repr</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[G</span><span class="id"> :&amp;:</span><span class="id"> _]/</span>(<span class="id">gval</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> case:</span><span class="id"> repr_rcosetP</span><span class="id"> =&gt;</span><span class="id"> b</span><span class="id"> /setIP[Gb</span><span class="id"> _]</span>.<br/>
<span class="id">exact:</span><span class="id"> groupM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> OrbitStabilizer</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_orbit_in</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> #|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> =</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD;</span><span class="id"> rewrite</span><span class="id"> orbit_stabilizer</span><span class="id"> 1?card_in_imset</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> can_in_inj</span> (<span class="id">act_reprK</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_orbit_in_stab</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="id">#|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> *</span><span class="id"> #|'C_G[x</span><span class="id"> |</span><span class="id"> to]|</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD;</span><span class="id"> rewrite</span><span class="id"> mulnC</span><span class="id"> card_orbit_in</span><span class="id"> ?Lagrange</span><span class="id"> ?subsetIl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_sum_card_orbit</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> \sum_</span>(<span class="id">T</span><span class="gallina-kwd"> in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> @:</span><span class="id"> S</span>)<span class="id"> #|T|</span><span class="id"> =</span><span class="id"> #|S|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/orbit_partition/card_partition</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_setact_in</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">to^*</span><span class="id"> S</span><span class="id"> a</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :^</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Da;</span><span class="id"> apply/setP=&gt;</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> mem_conjg</span><span class="id"> !inE</span><span class="id"> -mem_conjg</span><span class="id"> conjGid</span><span class="id"> //</span>.<br/>
<span class="id">apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> Db;</span><span class="id"> rewrite</span><span class="id"> sub_imset_pre;</span><span class="id"> apply:</span><span class="id"> eq_subset_r</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> !actMin</span><span class="id"> ?groupM</span><span class="id"> ?groupV</span><span class="id"> //</span><span class="id"> invgK</span> (<span class="id">canF_eq</span> (<span class="id">actKVin</span><span class="id"> Da</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1_act_in</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C[to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> =</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> :^</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> -astab_setact_in</span><span class="id"> //</span><span class="id"> /setact</span><span class="id"> imset_set1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Frobenius_Cauchy</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">\sum_</span>(<span class="id">a</span><span class="gallina-kwd"> in</span><span class="id"> G</span>)<span class="id"> #|'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">[a]|</span><span class="id"> =</span> (<span class="id">#|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> @:</span><span class="id"> S|</span><span class="id"> *</span><span class="id"> #|G|</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> GactS;</span><span class="id"> have</span><span class="id"> sGD</span><span class="id"> :=</span><span class="id"> acts_dom</span><span class="id"> GactS</span>.<br/>
<span class="id">transitivity</span> (<span class="id">\sum_</span>(<span class="id">a</span><span class="gallina-kwd"> in</span><span class="id"> G</span>)<span class="id"> \sum_</span>(<span class="id">x</span><span class="gallina-kwd"> in</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">[a]</span>)<span class="id"> 1%N</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -sum1_card</span>.<br/>
<span class="id">rewrite</span> (<span class="id">exchange_big_dep</span><span class="id"> [in</span><span class="id"> S]</span>)<span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [|a</span><span class="id"> x</span><span class="id"> _];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> case/setIP</span>.<br/>
<span class="id">rewrite</span> (<span class="id">set_partition_big</span><span class="id"> _</span> (<span class="id">orbit_partition</span><span class="id"> GactS</span>))<span class="id"> -sum_nat_const</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">card_orbit_in_stab</span><span class="id"> x</span><span class="id"> sGD</span>)<span class="id"> -sum_nat_const</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> orbit_in_sym</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /imsetP[a</span><span class="id"> Ga</span><span class="id"> defx]</span>.<br/>
<span class="id">rewrite</span><span class="id"> defx</span><span class="id"> astab1_act_in</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sGD</span>)<span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -{2}</span>(<span class="id">conjGid</span><span class="id"> Ga</span>)<span class="id"> -conjIg</span><span class="id"> cardJg</span><span class="id"> -sum1_card</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sGD</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_bigl</span><span class="id"> =&gt;</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">sub1set,</span><span class="id"> inE</span>)<span class="id"> -</span>(<span class="id">acts_act</span><span class="id"> GactS</span><span class="id"> Ga</span>)<span class="id"> -defx</span><span class="id"> Sx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_dvd_index_in</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> #|S|</span><span class="id"> %|</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'C_G</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> {1}-&gt;];</span><span class="id"> rewrite</span><span class="id"> card_orbit_in</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> indexgS</span><span class="id"> //</span><span class="id"> setIS</span><span class="id"> //</span><span class="id"> astabS</span><span class="id"> //</span><span class="id"> sub1set</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_dvd_in</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> #|S|</span><span class="id"> %|</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD</span><span class="id"> transG;</span><span class="id"> apply:</span><span class="id"> dvdn_trans</span> (<span class="id">atrans_dvd_index_in</span><span class="id"> sGD</span><span class="id"> transG</span>)<span class="id"> _</span>.<br/>
<span class="id">exact:</span><span class="id"> dvdn_indexg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atransPin</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> /imsetP[y</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> x;</span><span class="id"> apply/orbit_in_eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atransP2in</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> S</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="gallina-kwd"> exists2</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> transG</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span>(<span class="id">atransPin</span><span class="id"> sGD</span><span class="id"> transG</span>)<span class="id"> &lt;-</span><span class="id"> /imsetP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_acts_in</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD</span><span class="id"> transG;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">subsetP</span><span class="id"> sGD</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> /</span>(<span class="id">atransPin</span><span class="id"> sGD</span><span class="id"> transG</span>)<span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> imset_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subgroup_transitivePin</span><span class="id"> G</span><span class="id"> H</span><span class="id"> S</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> *</span><span class="id"> H</span><span class="id"> =</span><span class="id"> G</span>)<span class="id"> [transitive</span><span class="id"> H,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Sx</span><span class="id"> sHG</span><span class="id"> sGD</span><span class="id"> trG;</span><span class="id"> have</span><span class="id"> sHD</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sHG</span><span class="id"> sGD</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [trH</span><span class="id"> |</span><span class="id"> defG]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> group_modr</span><span class="id"> //;</span><span class="id"> apply/setIidPl/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Sxa:</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> S</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">acts_act</span> (<span class="id">atrans_acts_in</span><span class="id"> sGD</span><span class="id"> trG</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [b</span><span class="id"> Hb</span><span class="id"> xab]:=</span><span class="id"> atransP2in</span><span class="id"> sHD</span><span class="id"> trH</span><span class="id"> Sxa</span><span class="id"> Sx</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sGD</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> have</span><span class="id"> Db</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sHD</span><span class="id"> b</span><span class="id"> Hb</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">mulgK</span><span class="id"> b</span><span class="id"> a</span>)<span class="id"> mem_mulg</span><span class="id"> ?groupV</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> groupM</span><span class="id"> //=</span><span class="id"> sub1set</span><span class="id"> inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> actMin</span><span class="id"> -?xab</span>.<br/>
<span class="id">apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/setP=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">atransPin</span><span class="id"> sGD</span><span class="id"> trG</span><span class="id"> Sx</span>).<br/>
<span class="id">apply/imsetP/imsetP=&gt;</span><span class="id"> []</span><span class="id"> [a];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> a;</span><span class="id"> first</span><span class="id"> apply:</span> (<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
<span class="id">rewrite</span><span class="id"> -defG</span><span class="id"> =&gt;</span><span class="id"> /imset2P[c</span><span class="id"> b</span><span class="id"> /setIP[_</span><span class="id"> cxc]</span><span class="id"> Hb</span><span class="id"> -&gt;]</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> ?actMin</span><span class="id"> ?</span>(<span class="id">astab_dom</span><span class="id"> cxc</span>)<span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHD</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">astab_act</span><span class="id"> cxc</span>)<span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> PartialAction</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> orbit_transversal</span><span class="id"> {aT</span><span class="id"> D%_g</span><span class="id"> rT}</span><span class="id"> to%_act</span><span class="id"> A%_g</span><span class="id"> S%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> orbit_in_eqP</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> orbit1P</span><span class="id"> {aT</span><span class="id"> D</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> contra_orbit</span><span class="id"> [aT</span><span class="id"> D</span><span class="id"> rT]</span><span class="id"> to</span><span class="id"> G</span><span class="id"> [x</span><span class="id"> y]</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C' ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">astab_group</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' A ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">setI_group</span><span class="id"> A</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( A ) ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">setI_group</span><span class="id"> A</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<br/>
&nbsp;&nbsp;(<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C' [ x | to ]&quot;</span><span class="id"> :=</span> (<span class="id">astab_group</span><span class="id"> to</span><span class="id"> [set</span><span class="id"> x%g]</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' A [ x | to ]&quot;</span><span class="id"> :=</span> (<span class="id">setI_group</span><span class="id"> A</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( A ) [ x | to ]&quot;</span><span class="id"> :=</span> (<span class="id">setI_group</span><span class="id"> A</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>)<br/>
&nbsp;&nbsp;(<span class="id">only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''N' ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">astabs_group</span><span class="id"> to</span><span class="id"> S</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''N_' A ( S | to )&quot;</span><span class="id"> :=</span> (<span class="id">setI_group</span><span class="id"> A</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> TotalActions</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> {action</span><span class="id"> aT</span><span class="id"> &amp;-&gt;</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> aT</span>) (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> rT</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actM</span><span class="id"> x</span><span class="id"> a</span><span class="id"> b</span><span class="id"> :</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id"> =</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> b</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> actMin</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actK</span><span class="id"> :</span><span class="id"> right_loop</span><span class="id"> invg</span><span class="id"> to</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a;</span><span class="id"> apply:</span><span class="id"> actKin;</span><span class="id"> rewrite</span><span class="id"> inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actKV</span><span class="id"> :</span><span class="id"> rev_right_loop</span><span class="id"> invg</span><span class="id"> to</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a;</span><span class="id"> apply:</span><span class="id"> actKVin;</span><span class="id"> rewrite</span><span class="id"> inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actX</span><span class="id"> x</span><span class="id"> a</span><span class="id"> n</span><span class="id"> :</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">a</span><span class="id"> ^+</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> iter</span><span class="id"> n</span> (<span class="id">to^~</span><span class="id"> a</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> /=</span><span class="id"> &lt;-];</span><span class="id"> rewrite</span><span class="id"> ?act1</span><span class="id"> //</span><span class="id"> -actM</span><span class="id"> expgSr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actCJ</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> b</span><span class="id"> =</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> b</span>) (<span class="id">a</span><span class="id"> ^</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !actM</span><span class="id"> actK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actCJV</span><span class="id"> a</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> b</span><span class="id"> =</span><span class="id"> to</span> (<span class="id">to</span><span class="id"> x</span> (<span class="id">b</span><span class="id"> ^</span><span class="id"> a^-1</span>))<span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">actCJ</span><span class="id"> _</span><span class="id"> a</span>)<span class="id"> conjgKV</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_sym</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/orbit_in_sym/subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_trans</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/orbit_in_trans/subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_eqP</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/orbit_in_eqP/subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_transl</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> -&gt;</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> z</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/orbit_in_transl/subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_act</span><span class="id"> G</span><span class="id"> a</span><span class="id"> x:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/orbit_act_in/subsetT</span>. Qed.</div></details>
&nbsp;&nbsp;<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_actr</span><span class="id"> G</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/mem_orbit/orbit_transl;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_eq_mem</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> sameP</span><span class="id"> eqP</span> (<span class="id">orbit_eqP</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_inv</span><span class="id"> A</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A^-1</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orbit_inv_in</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_lcoset</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">a</span><span class="id"> *:</span><span class="id"> A</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orbit_lcoset_in</span><span class="id"> ?subsetT</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_rcoset</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">A</span><span class="id"> :*</span><span class="id"> a</span>)<span class="id"> x</span>)<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orbit_rcoset_in</span><span class="id"> ?subsetT</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_conjsg</span><span class="id"> A</span><span class="id"> a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">to</span><span class="id"> y</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">A</span><span class="id"> :^</span><span class="id"> a</span>) (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>))<span class="id"> =</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orbit_conjsg_in</span><span class="id"> ?subsetT</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabP</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [cSa</span><span class="id"> x|cSa];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> astab_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> cSa</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1P</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> sub1set</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_astab1</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sub_astab1_in</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabC</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>))<span class="id"> =</span> (<span class="id">S</span><span class="id"> \subset</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabCin</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_cycle</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">&lt;[a]&gt;</span>)<span class="id"> =</span><span class="id"> 'Fix_to[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> afix_cycle_in</span><span class="id"> ?inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_gen</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">&lt;&lt;A&gt;&gt;</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> afix_gen_in</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixM</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> 'Fix_to</span>(<span class="id">G</span><span class="id"> *</span><span class="id"> H</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">G</span>)<span class="id"> :&amp;:</span><span class="id"> 'Fix_to</span>(<span class="id">H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> afixMin</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsP</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span>)) (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [nSa</span><span class="id"> x|nSa];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> astabs_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> nSa</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_orbit</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> #|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> =</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_orbit_in</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dvdn_orbit</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> #|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> %|</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_orbit</span><span class="id"> dvdn_indexg</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_orbit_stab</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">#|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x|</span><span class="id"> *</span><span class="id"> #|'C_G[x</span><span class="id"> |</span><span class="id"> to]|</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulnC</span><span class="id"> card_orbit</span><span class="id"> Lagrange</span><span class="id"> ?subsetIl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsP</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to}</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [nSA</span><span class="id"> x|nSA];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> acts_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> /[!inE];</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> nSA</span>.<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> actsP</span><span class="id"> {A</span><span class="id"> S}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setact_orbit</span><span class="id"> A</span><span class="id"> x</span><span class="id"> b</span><span class="id"> :</span><span class="id"> to^*</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> A</span><span class="id"> x</span>)<span class="id"> b</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> to</span> (<span class="id">A</span><span class="id"> :^</span><span class="id"> b</span>) (<span class="id">to</span><span class="id"> x</span><span class="id"> b</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> /imsetP[_</span><span class="id"> /imsetP[a</span><span class="id"> Aa</span><span class="id"> -&gt;]</span><span class="id"> -&gt;{y}]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> actCJ</span><span class="id"> mem_orbit</span><span class="id"> ?memJ_conjg</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -actCJ</span><span class="id"> mem_setact</span><span class="id"> ?mem_orbit</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_setact</span><span class="id"> S</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">to^*</span><span class="id"> S</span><span class="id"> a</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :^</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> mem_conjg</span>.<br/>
<span class="id">apply/astabP/astabP=&gt;</span><span class="id"> stab</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [Sx|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgE</span><span class="id"> invgK</span><span class="id"> !actM</span><span class="id"> stab</span><span class="id"> ?actK</span><span class="id"> //;</span><span class="id"> apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> y</span><span class="id"> Sy</span><span class="id"> -&gt;{x};</span><span class="id"> rewrite</span><span class="id"> -actM</span><span class="id"> conjgCV</span><span class="id"> actM</span><span class="id"> stab</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1_act</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'C[to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> =</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> :^</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -astab_setact</span><span class="id"> /setact</span><span class="id"> imset_set1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atransP</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> y;</span><span class="id"> apply/orbit_eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atransP2</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> S</span><span class="id"> &amp;,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="gallina-kwd"> exists2</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> GtrS</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span>(<span class="id">atransP</span><span class="id"> GtrS</span>)<span class="id"> &lt;-</span><span class="id"> /imsetP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_acts</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> GtrS;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> /</span>(<span class="id">atransP</span><span class="id"> GtrS</span>)<span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> imset_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_supgroup</span><span class="id"> G</span><span class="id"> H</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> H</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[transitive</span><span class="id"> H,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> =</span><span class="id"> [acts</span><span class="id"> H,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGH</span><span class="id"> trG;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [|actH];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> atrans_acts</span>.<br/>
<span class="id">case/imsetP:</span><span class="id"> trG</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Sx</span><span class="id"> defS;</span><span class="id"> apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> acts_sub_orbit</span><span class="id"> ?Sx</span><span class="id"> //</span><span class="id"> defS</span><span class="id"> imsetS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_acts_card</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> &amp;&amp;</span> (<span class="id">#|orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> @:</span><span class="id"> S|</span><span class="id"> ==</span><span class="id"> 1%N</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/idP/andP=&gt;</span><span class="id"> [GtrS</span><span class="id"> |</span><span class="id"> [nSG]]</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> atrans_acts</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> ((_<span class="id"> @:</span><span class="id"> S</span><span class="id"> =P</span><span class="id"> [set</span><span class="id"> S]</span>)<span class="id"> _</span>)<span class="id"> ?cards1</span><span class="id"> //</span><span class="id"> eqEsubset</span><span class="id"> sub1set</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/andP;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span> (<span class="id">atransP</span><span class="id"> GtrS</span>).<br/>
<span class="id">rewrite</span><span class="id"> eqn_leq</span><span class="id"> andbC</span><span class="id"> lt0n</span><span class="id"> =&gt;</span><span class="id"> /andP[/existsP[X</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> X_Gx]]]</span>.<br/>
<span class="id">rewrite</span> (<span class="id">cardD1</span><span class="id"> X</span>)<span class="id"> {X}X_Gx</span><span class="id"> imset_f</span><span class="id"> //</span><span class="id"> ltnS</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> GtrS</span>.<br/>
<span class="id">apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> acts_sub_orbit</span><span class="id"> //</span><span class="id"> Sx</span><span class="id"> andbT</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> y</span><span class="id"> Sy;</span><span class="id"> have:=</span><span class="id"> card0_eq</span><span class="id"> GtrS</span> (<span class="id">orbit</span><span class="id"> to</span><span class="id"> G</span><span class="id"> y</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> imset_f</span><span class="id"> //</span><span class="id"> andbT</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> orbit_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atrans_dvd</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> #|S|</span><span class="id"> %|</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> dvdn_orbit</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_fix_norm</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">B</span>)<span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> 'Fix_to</span>(<span class="id">B</span>)<span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nAB;</span><span class="id"> have:=</span><span class="id"> acts_subnorm_fix</span><span class="id"> to</span><span class="id"> B;</span><span class="id"> rewrite</span><span class="id"> !setTI</span>.<br/>
<span class="id">exact:</span><span class="id"> subset_trans</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> faithfulP</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> a,</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> S,</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> =1</span><span class="id"> id}</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> =</span><span class="id"> 1</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[faithful</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> subsetP</span>)<span class="id"> =&gt;</span><span class="id"> [Cto1</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> Ca</span><span class="id"> |</span><span class="id"> Cto1</span><span class="id"> a]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/set1P;</span><span class="id"> rewrite</span><span class="id"> Cto1</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> Aa;</span><span class="id"> apply/astabP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/setIP=&gt;</span><span class="id"> Aa</span><span class="id"> /astabP</span><span class="id"> Ca;</span><span class="id"> apply/set1P;</span><span class="id"> apply:</span><span class="id"> Cto1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_trans_gcore</span><span class="id"> G</span><span class="id"> S</span><span class="id"> u</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> gcore</span><span class="id"> 'C[u</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> transG</span><span class="id"> Su;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span>.<br/>
<span class="id">rewrite</span><span class="id"> gcore_max</span><span class="id"> ?astabS</span><span class="id"> ?sub1set</span><span class="id"> //=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> subset_trans</span> (<span class="id">atrans_acts</span><span class="id"> transG</span>) (<span class="id">astab_norm</span><span class="id"> _</span><span class="id"> _</span>).<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> cSx;</span><span class="id"> apply/astabP=&gt;</span><span class="id"> uy</span>.<br/>
<span class="id">case/</span>(<span class="id">atransP2</span><span class="id"> transG</span><span class="id"> Su</span>)<span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> Gy</span><span class="id"> -&gt;{uy}</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/astab1P;</span><span class="id"> rewrite</span><span class="id"> astab1_act</span> (<span class="id">bigcapP</span><span class="id"> cSx</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> subgroup_transitiveP</span><span class="id"> G</span><span class="id"> H</span><span class="id"> S</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> *</span><span class="id"> H</span><span class="id"> =</span><span class="id"> G</span>)<span class="id"> [transitive</span><span class="id"> H,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Sx</span><span class="id"> sHG;</span><span class="id"> apply:</span><span class="id"> subgroup_transitivePin</span> (<span class="id">subsetT</span><span class="id"> G</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> trans_subnorm_fixP</span><span class="id"> x</span><span class="id"> G</span><span class="id"> H</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> 'C_G[x</span><span class="id"> |</span><span class="id"> to]</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">H</span>)<span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> C</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> ((<span class="id">H</span><span class="id"> :^:</span><span class="id"> G</span>)<span class="id"> ::&amp;:</span><span class="id"> C</span><span class="id"> =</span><span class="id"> H</span><span class="id"> :^:</span><span class="id"> C</span>)<span class="id"> [transitive</span><span class="id"> 'N_G</span>(<span class="id">H</span>)<span class="id">,</span><span class="id"> on</span><span class="id"> T</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> C</span><span class="id"> T</span><span class="id"> trGS</span><span class="id"> Sx</span><span class="id"> sHC;</span><span class="id"> have</span><span class="id"> actGS</span><span class="id"> :=</span><span class="id"> acts_act</span> (<span class="id">atrans_acts</span><span class="id"> trGS</span>).<br/>
<span class="id">have:=</span><span class="id"> sHC;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> sub_astab1</span><span class="id"> =&gt;</span><span class="id"> /andP[sHG</span><span class="id"> cHx]</span>.<br/>
<span class="id">have</span><span class="id"> Tx:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> T</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Sx</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [trN</span><span class="id"> |</span><span class="id"> trC]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> Ha;</span><span class="id"> apply/setIdP/imsetP=&gt;</span><span class="id"> [[]|[a</span><span class="id"> Ca</span><span class="id"> -&gt;{Ha}]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conj_subG</span><span class="id"> //;</span><span class="id"> case/setIP:</span><span class="id"> Ca</span><span class="id"> =&gt;</span><span class="id"> Ga</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> imset_f</span>.<br/>
&nbsp;&nbsp;<span class="id">case/imsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga</span><span class="id"> -&gt;{Ha};</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> !sub_conjg</span><span class="id"> =&gt;</span><span class="id"> /andP[_</span><span class="id"> sHCa]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Txa:</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a^-1</span><span class="id"> \in</span><span class="id"> T</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -sub_astab1</span><span class="id"> astab1_act</span><span class="id"> actGS</span><span class="id"> ?Sx</span><span class="id"> ?groupV</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [b]</span><span class="id"> :=</span><span class="id"> atransP2</span><span class="id"> trN</span><span class="id"> Tx</span><span class="id"> Txa;</span><span class="id"> case/setIP=&gt;</span><span class="id"> Gb</span><span class="id"> nHb</span><span class="id"> cxba</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">b</span><span class="id"> *</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> conjsgM</span> (<span class="id">normP</span><span class="id"> nHb</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> groupM</span><span class="id"> //;</span><span class="id"> apply/astab1P;</span><span class="id"> rewrite</span><span class="id"> actM</span><span class="id"> -cxba</span><span class="id"> actKV</span>.<br/>
<span class="id">apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/setP=&gt;</span><span class="id"> y;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [Ty|]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [Sy</span><span class="id"> cHy]:=</span><span class="id"> setIP</span><span class="id"> Ty;</span><span class="id"> have</span><span class="id"> [a</span><span class="id"> Ga</span><span class="id"> defy]</span><span class="id"> :=</span><span class="id"> atransP2</span><span class="id"> trGS</span><span class="id"> Sx</span><span class="id"> Sy</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> H</span><span class="id"> :^</span><span class="id"> a^-1</span><span class="id"> \in</span><span class="id"> H</span><span class="id"> :^:</span><span class="id"> C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -trC</span><span class="id"> inE</span><span class="id"> subsetI</span><span class="id"> imset_f</span><span class="id"> 1?conj_subG</span><span class="id"> ?groupV</span><span class="id"> //</span><span class="id"> sub_conjgV</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -astab1_act</span><span class="id"> -defy</span><span class="id"> sub_astab1</span>.<br/>
&nbsp;&nbsp;<span class="id">case/imsetP=&gt;</span><span class="id"> b</span><span class="id"> /setIP[Gb</span><span class="id"> /astab1P</span><span class="id"> cxb]</span><span class="id"> defHb</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defy</span><span class="id"> -{1}cxb</span><span class="id"> -actM</span><span class="id"> mem_orbit</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> groupM</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/normP;</span><span class="id"> rewrite</span><span class="id"> conjsgM</span><span class="id"> -defHb</span><span class="id"> conjsgKV</span>.<br/>
<span class="id">case/imsetP=&gt;</span><span class="id"> a</span><span class="id"> /setIP[Ga</span><span class="id"> nHa]</span><span class="id"> -&gt;{y}</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> actGS</span><span class="id"> //</span><span class="id"> Sx</span> (<span class="id">acts_act</span> (<span class="id">acts_fix_norm</span><span class="id"> _</span>)<span class="id"> nHa</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> TotalActions</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> astabP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> S</span><span class="id"> a}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> orbit_eqP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> astab1P</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> astabsP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> S</span><span class="id"> a}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> atransP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> G</span><span class="id"> S}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> actsP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> A</span><span class="id"> S}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> faithfulP</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> to</span><span class="id"> A</span><span class="id"> S}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Restrict</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> ract</span><span class="id"> of</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> :=</span><span class="id"> act</span><span class="id"> to</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> sAD</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ract_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> A</span> (<span class="id">ract</span><span class="id"> sAD</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /ract;</span><span class="id"> case:</span><span class="id"> to</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> [injf</span><span class="id"> fM]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x;</span><span class="id"> apply:</span> (<span class="id">sub_in2</span> (<span class="id">subsetP</span><span class="id"> sAD</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> raction</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> ract_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ractE</span><span class="id"> :</span><span class="id"> raction</span><span class="id"> =1</span><span class="id"> to</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Restrict</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to \ sAD&quot;</span><span class="id"> :=</span> (<span class="id">raction</span><span class="id"> to</span><span class="id"> sAD</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 50</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActBy</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> actby_cond</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>)<span class="id"> R</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> R</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> actby</span><span class="id"> A</span><span class="id"> R</span><span class="id"> to</span><span class="id"> of</span><span class="id"> actby_cond</span><span class="id"> A</span><span class="id"> R</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id"> &amp;&amp;</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> A</span>)<span class="gallina-kwd"> then</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="gallina-kwd"> else</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> nRA</span><span class="id"> :</span><span class="id"> actby_cond</span><span class="id"> A</span><span class="id"> R</span><span class="id"> to</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actby_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> A</span> (<span class="id">actby</span><span class="id"> nRA</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /actby;</span><span class="id"> split=&gt;</span><span class="id"> [a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Aa</span><span class="id"> Ab</span><span class="id"> /=];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Aa</span><span class="id"> Ab</span><span class="id"> groupM</span><span class="id"> //</span><span class="id"> !andbT</span><span class="id"> actMin</span><span class="id"> ?</span>(<span class="id">subsetP</span> (<span class="id">acts_dom</span><span class="id"> nRA</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> Rx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">acts_act</span><span class="id"> nRA</span>)<span class="id"> ?Rx</span>.<br/>
<span class="id">case</span><span class="id"> Aa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?andbF</span><span class="id"> ?andbT</span><span class="id"> //</span>.<br/>
<span class="id">case</span><span class="id"> Rx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> case</span><span class="id"> Ry:</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> eqxy;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> act_inj</span><span class="id"> eqxy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqxy</span> (<span class="id">acts_act</span><span class="id"> nRA</span><span class="id"> Aa</span>)<span class="id"> Rx</span><span class="gallina-kwd"> in</span><span class="id"> Ry</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqxy</span> (<span class="id">acts_act</span><span class="id"> nRA</span><span class="id"> Aa</span>)<span class="id"> Ry</span><span class="gallina-kwd"> in</span><span class="id"> Rx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> action_by</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> actby_is_action</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;&lt;[nRA]&gt;&quot;</span><span class="id"> :=</span><span class="id"> action_by</span><span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actbyE</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> -&gt;</span><span class="id"> &lt;[nRA]&gt;%act</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /actby</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_actby</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 'Fix_&lt;[nRA]&gt;</span>(<span class="id">B</span>)<span class="id"> =</span><span class="id"> ~:</span><span class="id"> R</span><span class="id"> :|:</span><span class="id"> 'Fix_to</span>(<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> /actby</span>.<br/>
<span class="id">case:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> _</span><span class="id"> /[!inE]</span>.<br/>
<span class="id">apply/subsetP/subsetP=&gt;</span><span class="id"> [cBx</span><span class="id"> a</span><span class="id"> |</span><span class="id"> cABx</span><span class="id"> a</span><span class="id"> Ba]</span><span class="id"> /[!inE]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/andP=&gt;</span><span class="id"> Aa</span><span class="id"> /cBx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Aa</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> Aa;</span><span class="id"> have:=</span><span class="id"> cABx</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Aa</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_actby</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> &lt;[nRA]&gt;</span>)<span class="id"> =</span><span class="id"> 'C_A</span>(<span class="id">R</span><span class="id"> :&amp;:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span> (<span class="id">acts_dom</span><span class="id"> nRA</span>))<span class="id"> !inE</span>.<br/>
<span class="id">case</span><span class="id"> Aa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply/subsetP/subsetP=&gt;</span><span class="id"> cRSa</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|Sx]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setIP=&gt;</span><span class="id"> Rx</span><span class="id"> /cRSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> actbyE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> cRSa</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> /actby</span><span class="id"> Aa</span><span class="id"> Sx;</span><span class="id"> case:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_actby</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> &lt;[nRA]&gt;</span>)<span class="id"> =</span><span class="id"> 'N_A</span>(<span class="id">R</span><span class="id"> :&amp;:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span> (<span class="id">acts_dom</span><span class="id"> nRA</span>))<span class="id"> !inE</span>.<br/>
<span class="id">case</span><span class="id"> Aa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> A</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply/subsetP/subsetP=&gt;</span><span class="id"> nRSa</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|Sx]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setIP=&gt;</span><span class="id"> Rx</span><span class="id"> /nRSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> actbyE</span><span class="id"> ?</span>(<span class="id">acts_act</span><span class="id"> nRA</span>)<span class="id"> ?Rx</span>.<br/>
<span class="id">have:=</span><span class="id"> nRSa</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> /actby</span><span class="id"> Aa</span><span class="id"> Sx</span><span class="id"> ?</span>(<span class="id">acts_act</span><span class="id"> nRA</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_actby</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>)<span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> &lt;[nRA]&gt;]</span><span class="id"> =</span> (<span class="id">B</span><span class="id"> \subset</span><span class="id"> A</span>)<span class="id"> &amp;&amp;</span><span class="id"> [acts</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> R</span><span class="id"> :&amp;:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabs_actby</span><span class="id"> subsetI</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ActBy</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;&lt;[ nRA ] &gt;&quot;</span><span class="id"> :=</span> (<span class="id">action_by</span><span class="id"> nRA</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SubAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">sP</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> rT</span>) (<span class="id">sT</span><span class="id"> :</span><span class="id"> subFinType</span><span class="id"> sP</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> u</span><span class="id"> :</span><span class="id"> sT</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> sT}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> subact_dom</span><span class="id"> :=</span><span class="id"> 'N</span>(<span class="id">[set</span><span class="id"> x</span><span class="id"> |</span><span class="id"> sP</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> subact_dom_group</span><span class="id"> :=</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> subact_dom]</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> Na</span><span class="id"> :</span><span class="id"> {a</span><span class="id"> |</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> subact_dom}</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_act_proof</span><span class="id"> u</span><span class="id"> Na</span><span class="id"> :</span><span class="id"> sP</span> (<span class="id">to</span> (<span class="id">val</span><span class="id"> u</span>) (<span class="id">val</span><span class="id"> Na</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> Na</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> /=</span><span class="id"> /</span>(<span class="id">astabs_act</span> (<span class="id">val</span><span class="id"> u</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> valP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> subact</span><span class="id"> u</span><span class="id"> a</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> insub</span><span class="id"> a</span><span class="id"> is</span><span class="id"> Some</span><span class="id"> Na</span><span class="gallina-kwd"> then</span><span class="id"> Sub</span><span class="id"> _</span> (<span class="id">sub_act_proof</span><span class="id"> u</span><span class="id"> Na</span>)<span class="gallina-kwd"> else</span><span class="id"> u</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> val_subact</span><span class="id"> u</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">val</span> (<span class="id">subact</span><span class="id"> u</span><span class="id"> a</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> subact_dom</span><span class="gallina-kwd"> then</span><span class="id"> to</span> (<span class="id">val</span><span class="id"> u</span>)<span class="id"> a</span><span class="gallina-kwd"> else</span><span class="id"> val</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /subact</span><span class="id"> -if_neg;</span><span class="id"> case:</span><span class="id"> insubP</span><span class="id"> =&gt;</span><span class="id"> [Na|]</span><span class="id"> -&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> SubK</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subact_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> subact_dom</span><span class="id"> subact</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [a</span><span class="id"> u</span><span class="id"> v</span><span class="id"> eq_uv</span><span class="id"> |</span><span class="id"> u</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Na</span><span class="id"> Nb];</span><span class="id"> apply:</span><span class="id"> val_inj</span>.<br/>
&nbsp;&nbsp;<span class="id">move/</span>(<span class="id">congr1</span><span class="id"> val</span>)<span class="id">:</span><span class="id"> eq_uv;</span><span class="id"> rewrite</span><span class="id"> !val_subact</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> move/act_inj</span>.<br/>
<span class="id">have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> Na;</span><span class="id"> have</span><span class="id"> Db</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> Nb</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !val_subact</span><span class="id"> Na</span><span class="id"> Nb</span><span class="id"> groupM</span><span class="id"> ?actMin</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> subaction</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> subact_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_subact</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> subaction</span>)<span class="id"> =</span><span class="id"> subact_dom</span><span class="id"> :&amp;:</span><span class="id"> 'C</span>(<span class="id">val</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> in_setI;</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> sDa</span>.<br/>
<span class="id">have</span><span class="id"> [Da</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setIP</span><span class="id"> sDa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP/subsetP=&gt;</span><span class="id"> [cSa</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> cSa</span><span class="id"> x</span><span class="id"> Sx]</span><span class="id"> /[!inE]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> cSa</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -val_eqE</span><span class="id"> val_subact</span><span class="id"> sDa</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> cSa</span><span class="id"> _</span> (<span class="id">imset_f</span><span class="id"> val</span><span class="id"> Sx</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -val_eqE</span><span class="id"> val_subact</span><span class="id"> sDa</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_subact</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> subaction</span>)<span class="id"> =</span><span class="id"> subact_dom</span><span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">val</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> in_setI;</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> sDa</span>.<br/>
<span class="id">have</span><span class="id"> [Da</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setIP</span><span class="id"> sDa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP/subsetP=&gt;</span><span class="id"> [nSa</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Sx</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> nSa</span><span class="id"> x</span><span class="id"> Sx]</span><span class="id"> /[!inE]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /[1!inE]/</span>(<span class="id">imset_f</span><span class="id"> val</span>)<span class="id"> :=</span><span class="id"> nSa</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> val_subact</span><span class="id"> sDa</span>.<br/>
<span class="id">have</span><span class="id"> /[1!inE]/imsetP[y</span><span class="id"> Sy</span><span class="id"> def_y]</span><span class="id"> :=</span><span class="id"> nSa</span><span class="id"> _</span> (<span class="id">imset_f</span><span class="id"> val</span><span class="id"> Sx</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> ((_<span class="id"> a</span><span class="id"> =P</span><span class="id"> y</span>)<span class="id"> _</span>)<span class="id"> //</span><span class="id"> -val_eqE</span><span class="id"> val_subact</span><span class="id"> sDa</span><span class="id"> def_y</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_subact</span><span class="id"> A</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> subact_dom</span><span class="id"> -&gt;</span><span class="id"> 'Fix_subaction</span>(<span class="id">A</span>)<span class="id"> =</span><span class="id"> val</span><span class="id"> @^-1:</span><span class="id"> 'Fix_to</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/subsetP=&gt;</span><span class="id"> sAD;</span><span class="id"> apply/setP=&gt;</span><span class="id"> u</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> !</span>(<span class="id">sameP</span><span class="id"> setIidPl</span><span class="id"> eqP</span>)<span class="id">;</span><span class="id"> congr</span> (_<span class="id"> ==</span><span class="id"> A</span>).<br/>
<span class="id">apply/setP=&gt;</span><span class="id"> a</span><span class="id"> /[!inE];</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> Aa</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -val_eqE</span><span class="id"> val_subact</span><span class="id"> sAD</span>.<br/>
<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SubAction</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to ^?&quot;</span><span class="id"> :=</span> (<span class="id">subaction</span><span class="id"> _</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;to ^?&quot;</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> QuotientAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finGroupType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>) (<span class="id">H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> qact_dom</span><span class="id"> :=</span><span class="id"> 'N</span>(<span class="id">rcosets</span><span class="id"> H</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> |</span><span class="id"> to^*</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> qact_dom_group</span><span class="id"> :=</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> qact_dom]</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> subdom</span><span class="id"> :=</span> (<span class="id">subact_dom</span> (<span class="id">coset_range</span><span class="id"> H</span>) <span class="id"> to^*</span>).<br/>
<span class="vernacular">Fact</span><span class="id"> qact_subdomE</span><span class="id"> :</span><span class="id"> subdom</span><span class="id"> =</span><span class="id"> qact_dom</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> congr</span><span class="id"> 'N</span>(<span class="id">_|_</span>)<span class="id">;</span><span class="id"> apply/setP=&gt;</span><span class="id"> Hx;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> genGid</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> qact_proof</span><span class="id"> :</span><span class="id"> qact_dom</span><span class="id"> \subset</span><span class="id"> subdom</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> qact_subdomE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> qact</span><span class="id"> :</span><span class="id"> coset_of</span><span class="id"> H</span><span class="id"> -&gt;</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> coset_of</span><span class="id"> H</span><span class="id"> :=</span><span class="id"> act</span> (<span class="id">to^*^?</span><span class="id"> \</span><span class="id"> qact_proof</span>).<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> quotient_action</span><span class="id"> :=</span><span class="id"> [action</span><span class="id"> of</span><span class="id"> qact]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_qact_dom</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> qact_dom,</span><span class="id"> on</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> nNa;</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">astabs_dom</span><span class="id"> nNa</span>)<span class="id">;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Nx</span>.<br/>
<span class="id">have:</span><span class="id"> H</span><span class="id"> :*</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> rcosets</span><span class="id"> H</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -rcosetE</span><span class="id"> imset_f</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> -</span>(<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nNa</span>)<span class="id"> =&gt;</span><span class="id"> /rcosetsP[y</span><span class="id"> Ny</span><span class="id"> defHy]</span>.<br/>
<span class="id">have:</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> H</span><span class="id"> :*</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defHy</span> (<span class="id">imset_f</span> (<span class="id">to^~a</span>))<span class="id"> ?rcoset_refl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> rewrite</span><span class="id"> mul_subG</span><span class="id"> ?sub1set</span><span class="id"> ?normG</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> qactEcond</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">quotient_action</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> x</span>)<span class="id"> a</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">=</span><span class="id"> coset</span><span class="id"> H</span> (<span class="gallina-kwd">if</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> qact_dom</span><span class="gallina-kwd"> then</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="gallina-kwd"> else</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Nx;</span><span class="id"> apply:</span><span class="id"> val_inj;</span><span class="id"> rewrite</span><span class="id"> val_subact</span><span class="id"> //=</span><span class="id"> qact_subdomE</span>.<br/>
<span class="id">have:</span><span class="id"> H</span><span class="id"> :*</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> rcosets</span><span class="id"> H</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -rcosetE</span><span class="id"> imset_f</span>.<br/>
<span class="id">case</span><span class="id"> nNa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nNa</span>).<br/>
<span class="id">rewrite</span><span class="id"> !val_coset</span><span class="id"> ?</span>(<span class="id">acts_act</span><span class="id"> acts_qact_dom</span><span class="id"> nNa</span>)<span class="id"> //=</span>.<br/>
<span class="id">case/rcosetsP=&gt;</span><span class="id"> y</span><span class="id"> Ny</span><span class="id"> defHy;</span><span class="id"> rewrite</span><span class="id"> defHy;</span><span class="id"> apply:</span><span class="id"> rcoset_eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rcoset_sym</span><span class="id"> -defHy</span> (<span class="id">imset_f</span> (<span class="id">_^~_</span>))<span class="id"> ?rcoset_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> qactE</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> qact_dom</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">quotient_action</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> x</span>)<span class="id"> a</span><span class="id"> =</span><span class="id"> coset</span><span class="id"> H</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Nx</span><span class="id"> nNa;</span><span class="id"> rewrite</span><span class="id"> qactEcond</span><span class="id"> ?nNa</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_quotient</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'N_qact_dom</span>(<span class="id">B</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> B</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> quotient_action]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nBA;</span><span class="id"> apply:</span><span class="id"> subset_trans</span><span class="id"> {A}nBA</span><span class="id"> _;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> /setIP[dHa</span><span class="id"> nBa]</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> dHa</span><span class="id"> inE;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /morphimP[x</span><span class="id"> nHx</span><span class="id"> Bx</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> qactE</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_morphim</span><span class="id"> ?</span>(<span class="id">acts_act</span><span class="id"> acts_qact_dom</span>)<span class="id"> ?</span>(<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nBa</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_quotient</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">H</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> 'N</span>(<span class="id">G</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> quotient_action</span>)<span class="id"> =</span><span class="id"> 'N_qact_dom</span>(<span class="id">G</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nsHG;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> nHG]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsHG</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> acts_quotient</span><span class="id"> //</span><span class="id"> andbT</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> nGa;</span><span class="id"> have</span><span class="id"> dHa</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> nGa;</span><span class="id"> have</span><span class="id"> [Da</span><span class="id"> _]:=</span><span class="id"> setIdP</span><span class="id"> dHa</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> dHa</span><span class="id"> 2!inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Gx;</span><span class="id"> have</span><span class="id"> nHx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> nHG</span><span class="id"> x</span><span class="id"> Gx</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">quotientGK</span><span class="id"> nsHG</span>)<span class="id"> 2!inE</span> (<span class="id">acts_act</span><span class="id"> acts_qact_dom</span>)<span class="id"> ?nHx</span><span class="id"> //=</span><span class="id"> inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -qactE</span><span class="id"> //</span> (<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nGa</span>)<span class="id"> mem_morphim</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> QuotientAction</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to / H&quot;</span><span class="id"> :=</span> (<span class="id">quotient_action</span><span class="id"> to</span><span class="id"> H</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ModAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> GenericMod</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> dom</span><span class="id"> :=</span><span class="id"> 'N_D</span>(<span class="id">H</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> range</span><span class="id"> :=</span><span class="id"> 'Fix_to</span>(<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> H</span>).<br/>
<span class="vernacular">Let</span><span class="id"> acts_dom</span><span class="id"> :</span><span class="id"> {acts</span><span class="id"> dom,</span><span class="id"> on</span><span class="id"> range</span><span class="id"> |</span><span class="id"> to}</span><span class="id"> :=</span><span class="id"> acts_act</span> (<span class="id">acts_subnorm_fix</span><span class="id"> to</span><span class="id"> H</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> modact</span><span class="id"> x</span> (<span class="id">Ha</span><span class="id"> :</span><span class="id"> coset_of</span><span class="id"> H</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> range</span><span class="gallina-kwd"> then</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">repr</span> (<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> Ha</span>))<span class="gallina-kwd"> else</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modactEcond</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> dom</span><span class="id"> -&gt;</span><span class="id"> modact</span><span class="id"> x</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> a</span>)<span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> range</span><span class="gallina-kwd"> then</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="gallina-kwd"> else</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/setIP=&gt;</span><span class="id"> Da</span><span class="id"> Na;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> Cx;</span><span class="id"> rewrite</span><span class="id"> /modact</span><span class="id"> Cx</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> val_coset</span><span class="id"> //</span><span class="id"> -group_modr</span><span class="id"> ?sub1set</span><span class="id"> //</span>.<br/>
<span class="id">case:</span> (<span class="id">repr</span><span class="id"> _</span>)<span class="id"> /</span> (<span class="id">repr_rcosetP</span> (<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> H</span>)<span class="id"> a</span>)<span class="id"> =&gt;</span><span class="id"> a'</span><span class="id"> Ha'</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> actMin</span><span class="id"> ?</span>(<span class="id">afixP</span><span class="id"> Cx</span><span class="id"> _</span><span class="id"> Ha'</span>)<span class="id"> //;</span><span class="id"> case/setIP:</span><span class="id"> Ha'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modactE</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> range</span><span class="id"> -&gt;</span> <span class="id"> modact</span><span class="id"> x</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da</span><span class="id"> Na</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> modactEcond</span><span class="id"> ?Rx</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> Da</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modact_is_action</span><span class="id"> :</span><span class="id"> is_action</span> (<span class="id">D</span><span class="id"> /</span><span class="id"> H</span>)<span class="id"> modact</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [Ha</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> Ha</span><span class="id"> Hb];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">case/morphimP=&gt;</span><span class="id"> a</span><span class="id"> Na</span><span class="id"> Da</span><span class="id"> -&gt;{Ha};</span><span class="id"> case/morphimP=&gt;</span><span class="id"> b</span><span class="id"> Nb</span><span class="id"> Db</span><span class="id"> -&gt;{Hb}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -morphM</span><span class="id"> //=</span><span class="id"> !modactEcond</span><span class="id"> //</span><span class="id"> ?groupM</span><span class="id"> ?</span>(<span class="id">introT</span><span class="id"> setIP</span><span class="id"> _</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> Cx;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">acts_dom,</span><span class="id"> Cx,</span><span class="id"> actMin,</span><span class="id"> introT</span><span class="id"> setIP</span><span class="id"> _</span>).<br/>
<span class="id">case:</span> (<span class="id">set_0Vmem</span> (<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> Ha</span>))<span class="id"> =&gt;</span><span class="id"> [Da0</span><span class="id"> |</span><span class="id"> [a</span><span class="id"> /setIP[Da</span><span class="id"> NHa]]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /modact</span><span class="id"> Da0</span><span class="id"> repr_set0</span><span class="id"> !act1</span><span class="id"> !if_same</span>.<br/>
<span class="id">have</span><span class="id"> Na</span><span class="id"> :=</span><span class="id"> subsetP</span> (<span class="id">coset_norm</span><span class="id"> _</span>)<span class="id"> _</span><span class="id"> NHa</span>.<br/>
<span class="id">have</span><span class="id"> NDa:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N_D</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Da</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">coset_mem</span><span class="id"> NHa</span>)<span class="id"> !modactEcond</span><span class="id"> //</span>.<br/>
<span class="id">do</span><span class="id"> 2![case:</span><span class="id"> ifP]=&gt;</span><span class="id"> Cy</span><span class="id"> Cx</span><span class="id"> //</span><span class="id"> eqxy;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> act_inj</span><span class="id"> eqxy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqxy</span><span class="id"> acts_dom</span><span class="id"> ?Cx</span><span class="gallina-kwd"> in</span><span class="id"> Cy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqxy</span><span class="id"> acts_dom</span><span class="id"> ?Cy</span><span class="gallina-kwd"> in</span><span class="id"> Cx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> mod_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> modact_is_action</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Stabilizers</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cSH</span><span class="id"> :</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> fixSH</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> 'Fix_to</span>(<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -astabCin</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> subIset</span><span class="id"> ?cSH</span><span class="id"> ?orbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_mod</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> mod_action</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> /</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> Ha;</span><span class="id"> apply/idP/morphimP=&gt;</span><span class="id"> [nSa</span><span class="id"> |</span><span class="id"> [a</span><span class="id"> nHa</span><span class="id"> nSa</span><span class="id"> -&gt;]]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/morphimP:</span> (<span class="id">astabs_dom</span><span class="id"> nSa</span>)<span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> nHa</span><span class="id"> Da</span><span class="id"> defHa</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">astabs_act</span><span class="id"> x</span><span class="id"> nSa</span>)<span class="id"> defHa</span><span class="id"> /=</span><span class="id"> modactE</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> fixSH</span>).<br/>
<span class="id">have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> nSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> mem_quotient</span><span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> modactE</span><span class="id"> ?</span>(<span class="id">astabs_act</span><span class="id"> x</span><span class="id"> nSa</span>)<span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> fixSH</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_mod</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> mod_action</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> /</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> Ha;</span><span class="id"> apply/idP/morphimP=&gt;</span><span class="id"> [cSa</span><span class="id"> |</span><span class="id"> [a</span><span class="id"> nHa</span><span class="id"> cSa</span><span class="id"> -&gt;]]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/morphimP:</span> (<span class="id">astab_dom</span><span class="id"> cSa</span>)<span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> nHa</span><span class="id"> Da</span><span class="id"> defHa</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}[x]</span>(<span class="id">astab_act</span><span class="id"> cSa</span>)<span class="id"> //</span><span class="id"> defHa</span><span class="id"> /=</span><span class="id"> modactE</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> fixSH</span>).<br/>
<span class="id">have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astab_dom</span><span class="id"> cSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> mem_quotient</span><span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> modactE</span><span class="id"> ?</span>(<span class="id">astab_act</span><span class="id"> cSa</span>)<span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> fixSH</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Stabilizers</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_mod</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N_D</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> mod_action</span>)(<span class="id">G</span><span class="id"> /</span><span class="id"> H</span>)<span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cSH</span><span class="id"> /subsetIP[sGD</span><span class="id"> nHG]</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> !subsetI</span><span class="id"> !subsetIl</span><span class="id"> /=</span><span class="id"> -!astabCin</span><span class="id"> ?quotientS</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> cfixH</span><span class="id"> F:</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> :&amp;:</span><span class="id"> F</span><span class="id"> |</span><span class="id"> to</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> cSH</span>)<span class="id"> //</span><span class="id"> astabS</span><span class="id"> ?subsetIl</span>.<br/>
<span class="id">rewrite</span><span class="id"> andbC</span><span class="id"> astab_mod</span><span class="id"> ?quotientS</span><span class="id"> //=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabCin</span><span class="id"> ?subsetIr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">quotientSGK</span><span class="id"> nHG</span>)<span class="id"> //=</span><span class="id"> -astab_mod</span><span class="id"> //</span><span class="id"> astabCin</span><span class="id"> ?quotientS</span><span class="id"> ?subsetIr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> GenericMod</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modact_faithful</span><span class="id"> G</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[faithful</span><span class="id"> G</span><span class="id"> /</span><span class="id"> 'C_G</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> mod_action</span><span class="id"> 'C_G</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /faithful</span><span class="id"> astab_mod</span><span class="id"> ?subsetIr</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -quotientIG</span><span class="id"> ?subsetIr</span><span class="id"> ?trivg_quotient</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ModAction</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to %% H&quot;</span><span class="id"> :=</span> (<span class="id">mod_action</span><span class="id"> to</span><span class="id"> H</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActPerm</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> actperm</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> perm</span> (<span class="id">act_inj</span><span class="id"> to</span><span class="id"> a</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actpermM</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> actperm</span><span class="id"> :</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /</span><span class="id"> a</span><span class="id"> *</span><span class="id"> b}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Da</span><span class="id"> Db;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> permM</span><span class="id"> !permE</span><span class="id"> actMin</span>. Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> actperm_morphism</span><span class="id"> :=</span><span class="id"> Morphism</span><span class="id"> actpermM</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actpermE</span><span class="id"> a</span><span class="id"> x</span><span class="id"> :</span><span class="id"> actperm</span><span class="id"> a</span><span class="id"> x</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> permE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actpermK</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> aperm</span><span class="id"> x</span> (<span class="id">actperm</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> actpermE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ker_actperm</span><span class="id"> :</span><span class="id"> 'ker</span><span class="id"> actperm</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">setT</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">congr</span> (_<span class="id"> :&amp;:</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/setP=&gt;</span><span class="id"> a</span><span class="id"> /[!inE]/=</span>.<br/>
<span class="id">apply/eqP/subsetP=&gt;</span><span class="id"> [a1</span><span class="id"> x</span><span class="id"> _</span><span class="id"> |</span><span class="id"> a1];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -actpermE</span><span class="id"> a1</span><span class="id"> perm1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> apply/eqP;</span><span class="id"> have:=</span><span class="id"> a1</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> actpermE</span><span class="id"> perm1</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ActPerm</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RestrictActionTheory</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> faithful_isom</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>)<span class="id"> S</span> (<span class="id">nSA</span><span class="id"> :</span><span class="id"> actby_cond</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[faithful</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> isom</span><span class="id"> A</span> (<span class="id">actperm</span><span class="id"> &lt;[nSA]&gt;</span><span class="id"> @*</span><span class="id"> A</span>) (<span class="id">actperm</span><span class="id"> &lt;[nSA]&gt;</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ffulAS;</span><span class="id"> apply/isomP;</span><span class="id"> rewrite</span><span class="id"> ker_actperm</span><span class="id"> astab_actby</span><span class="id"> setIT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">sAD</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ractpermE</span><span class="id"> :</span><span class="id"> actperm</span> (<span class="id">to</span><span class="id"> \</span><span class="id"> sAD</span>)<span class="id"> =1</span><span class="id"> actperm</span><span class="id"> to</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !permE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_ract</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 'Fix_</span>(<span class="id">to</span><span class="id"> \</span><span class="id"> sAD</span>)(<span class="id">B</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">B</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_ract</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span><span class="id"> \</span><span class="id"> sAD</span>)<span class="id"> =</span><span class="id"> 'C_A</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_ract</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span><span class="id"> \</span><span class="id"> sAD</span>)<span class="id"> =</span><span class="id"> 'N_A</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_ract</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>)<span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to</span><span class="id"> \</span><span class="id"> sAD]</span><span class="id"> =</span> (<span class="id">B</span><span class="id"> \subset</span><span class="id"> A</span>)<span class="id"> &amp;&amp;</span><span class="id"> [acts</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabs_ract</span><span class="id"> subsetI</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RestrictActionTheory</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MorphAct</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> phi</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> D</span><span class="id"> &gt;-&gt;</span><span class="id"> {perm</span><span class="id"> rT}}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mact</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> phi</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mact_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> D</span><span class="id"> mact</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [a</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Da</span><span class="id"> Db];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> perm_inj</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /mact</span><span class="id"> morphM</span><span class="id"> //=</span><span class="id"> permM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> morph_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> mact_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mactE</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> morph_action</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> phi</span><span class="id"> a</span><span class="id"> x</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injm_faithful</span><span class="id"> :</span><span class="id"> 'injm</span><span class="id"> phi</span><span class="id"> -&gt;</span><span class="id"> [faithful</span><span class="id"> D,</span><span class="id"> on</span><span class="id"> setT</span><span class="id"> |</span><span class="id"> morph_action]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/injmP=&gt;</span><span class="id"> phi_inj;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> /setIP[Da</span><span class="id"> /astab_act</span><span class="id"> a1]</span>.<br/>
<span class="id">apply/set1P/phi_inj</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> morph1</span><span class="id"> perm1</span><span class="id"> -mactE</span><span class="id"> a1</span><span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_mact</span><span class="id"> a</span><span class="id"> :</span><span class="id"> actperm</span><span class="id"> morph_action</span><span class="id"> a</span><span class="id"> =</span><span class="id"> phi</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> permE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MorphAct</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;&lt;&lt; phi &gt;&gt;&quot;</span><span class="id"> :=</span> (<span class="id">morph_action</span><span class="id"> phi</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> CompAct</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">gT</span><span class="id"> aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> B</span><span class="id"> &gt;-&gt;</span><span class="id"> aT}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> comp_act</span><span class="id"> x</span><span class="id"> e</span><span class="id"> :=</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">f</span><span class="id"> e</span>).<br/>
<span class="vernacular">Lemma</span><span class="id"> comp_is_action</span><span class="id"> :</span><span class="id"> is_action</span> (<span class="id">f</span><span class="id"> @*^-1</span><span class="id"> D</span>)<span class="id"> comp_act</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [e</span><span class="id"> |</span><span class="id"> x</span><span class="id"> e1</span><span class="id"> e2];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> act_inj</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /morphpreP[Be1</span><span class="id"> Dfe1]</span><span class="id"> /morphpreP[Be2</span><span class="id"> Dfe2]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /comp_act</span><span class="id"> morphM</span><span class="id"> ?actMin</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> comp_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> comp_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> comp_actE</span><span class="id"> x</span><span class="id"> e</span><span class="id"> :</span><span class="id"> comp_action</span><span class="id"> x</span><span class="id"> e</span><span class="id"> =</span><span class="id"> to</span><span class="id"> x</span> (<span class="id">f</span><span class="id"> e</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afix_comp</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> 'Fix_comp_action</span>(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'Fix_to</span>(<span class="id">f</span><span class="id"> @*</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAB;</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /morphim</span> (<span class="id">setIidPr</span><span class="id"> sAB</span>).<br/>
<span class="id">apply/subsetP/subsetP;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> _</span><span class="id"> /imsetP[a</span><span class="id"> +</span><span class="id"> -&gt;]</span><span class="id"> =&gt;</span><span class="id"> /[apply]/[!inE]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> =&gt;</span><span class="id"> /</span>(_ (<span class="id">f</span><span class="id"> a</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> imset_f//</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_comp</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> comp_action</span>)<span class="id"> =</span><span class="id"> f</span><span class="id"> @*^-1</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -andbA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_comp</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> comp_action</span>)<span class="id"> =</span><span class="id"> f</span><span class="id"> @*^-1</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -andbA</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> CompAct</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to \o f&quot;</span><span class="id"> :=</span> (<span class="id">comp_action</span><span class="id"> to</span><span class="id"> f</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PermAction</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finType</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> gT</span><span class="id"> :=</span><span class="id"> {perm</span><span class="id"> rT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> a</span><span class="id"> b</span><span class="id"> c</span><span class="id"> :</span><span class="id"> gT</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> aperm_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> setT</span> (<span class="id">@aperm</span><span class="id"> rT</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> is_total_action</span><span class="id"> =&gt;</span><span class="id"> [x|x</span><span class="id"> a</span><span class="id"> b];</span><span class="id"> rewrite</span><span class="id"> apermE</span> (<span class="id">perm1,</span><span class="id"> permM</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> perm_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> aperm_is_action</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> porbitE</span><span class="id"> a</span><span class="id"> :</span><span class="id"> porbit</span><span class="id"> a</span><span class="id"> =</span><span class="id"> orbit</span><span class="id"> perm_action</span><span class="id"> &lt;[a]&gt;%g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> unlock</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_act1P</span><span class="id"> a</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> aperm</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">a</span><span class="id"> ==</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> eqP</span>)<span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> x</span><span class="id"> |</span><span class="id"> a1];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> act1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -apermE</span><span class="id"> a1</span><span class="id"> perm1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_faithful</span><span class="id"> A</span><span class="id"> :</span><span class="id"> [faithful</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> setT</span><span class="id"> |</span><span class="id"> perm_action]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> /setIP[Da</span><span class="id"> crTa]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/set1P;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -apermE</span><span class="id"> perm1</span> (<span class="id">astabP</span><span class="id"> crTa</span>)<span class="id"> ?inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actperm_id</span><span class="id"> p</span><span class="id"> :</span><span class="id"> actperm</span><span class="id"> perm_action</span><span class="id"> p</span><span class="id"> =</span><span class="id"> p</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> permE</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> PermAction</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> perm_act1P</span><span class="id"> {rT</span><span class="id"> a}</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'P&quot;</span><span class="id"> :=</span> (<span class="id">perm_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActpermOrbits</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">rT</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D</span><span class="id"> rT</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbit_morphim_actperm</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> orbit</span><span class="id"> 'P</span> (<span class="id">actperm</span><span class="id"> to</span><span class="id"> @*</span><span class="id"> A</span>)<span class="id"> =1</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> A</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> morphimEsub</span><span class="id"> //</span><span class="id"> /orbit</span><span class="id"> -imset_comp</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_imset</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> actpermK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> porbit_actperm</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> aT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> porbit</span> (<span class="id">actperm</span><span class="id"> to</span><span class="id"> a</span>)<span class="id"> =1</span><span class="id"> orbit</span><span class="id"> to</span><span class="id"> &lt;[a]&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Da</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> porbitE</span><span class="id"> -orbit_morphim_actperm</span><span class="id"> ?cycle_subG</span><span class="id"> ?morphim_cycle</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ActpermOrbits</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RestrictPerm</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> T}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> restr_perm</span><span class="id"> :=</span><span class="id"> actperm</span> (<span class="id">&lt;[subxx</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> 'P</span>)<span class="id">]&gt;</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> restr_perm_morphism</span><span class="id"> :=</span><span class="id"> [morphism</span><span class="id"> of</span><span class="id"> restr_perm]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restr_perm_on</span><span class="id"> p</span><span class="id"> :</span><span class="id"> perm_on</span><span class="id"> S</span> (<span class="id">restr_perm</span><span class="id"> p</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> notSx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> permE</span><span class="id"> /=</span><span class="id"> /actby</span> (<span class="id">negPf</span><span class="id"> notSx</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> triv_restr_perm</span><span class="id"> p</span><span class="id"> :</span><span class="id"> p</span><span class="id"> \notin</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> 'P</span>)<span class="id"> -&gt;</span><span class="id"> restr_perm</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> not_nSp;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !permE</span><span class="id"> /=</span><span class="id"> /actby</span> (<span class="id">negPf</span><span class="id"> not_nSp</span>)<span class="id"> andbF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restr_permE</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> 'P</span>)<span class="id"> &amp;</span><span class="id"> S,</span><span class="gallina-kwd"> forall</span><span class="id"> p,</span><span class="id"> restr_perm</span><span class="id"> p</span><span class="id"> =1</span><span class="id"> p}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> x</span><span class="id"> nSp</span><span class="id"> Sx;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> actpermE</span><span class="id"> actbyE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ker_restr_perm</span><span class="id"> :</span><span class="id"> 'ker</span><span class="id"> restr_perm</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> 'P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ker_actperm</span><span class="id"> astab_actby</span><span class="id"> setIT</span> (<span class="id">setIidPr</span> (<span class="id">astab_sub</span><span class="id"> _</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> im_restr_perm</span><span class="id"> p</span><span class="id"> :</span><span class="id"> restr_perm</span><span class="id"> p</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> =</span><span class="id"> S</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> im_perm_on</span> (<span class="id">restr_perm_on</span><span class="id"> p</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restr_perm_commute</span><span class="id"> s</span><span class="id"> :</span><span class="id"> commute</span> (<span class="id">restr_perm</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [sC|/triv_restr_perm-&gt;]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">s</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> 'P</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">commute_sym</span> (<span class="id">commute1</span><span class="id"> _</span>)).<br/>
<span class="id">apply/permP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> /=</span><span class="id"> xsS</span><span class="id"> :=</span><span class="id"> astabsP</span><span class="id"> sC</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !permM</span>.<br/>
<span class="id">have</span><span class="id"> [xS|xNS]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">restr_permE</span>)<span class="id"> ?xsS</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">out_perm</span> (<span class="id">restr_perm_on</span><span class="id"> _</span>))<span class="id"> ?xsS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RestrictPerm</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Symmetry</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> T}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> SymE</span><span class="id"> :</span><span class="id"> Sym</span><span class="id"> S</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">~:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> 'P</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP</span><span class="id"> =&gt;</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply/idP/astabP</span><span class="id"> =&gt;</span><span class="id"> [sS</span><span class="id"> x|/=</span><span class="id"> S_id]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> apermE</span><span class="id"> =&gt;</span><span class="id"> /out_perm-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> move=&gt;</span><span class="id"> /</span>(<span class="id">contra_neqN</span> (<span class="id">S_id</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> negbK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Symmetry</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> AutIn</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> gT</span><span class="id"> :</span><span class="id"> finGroupType</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> Aut_in</span><span class="id"> A</span> (<span class="id">B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>)<span class="id"> :=</span><span class="id"> 'N_A</span>(<span class="id">B</span><span class="id"> |</span><span class="id"> 'P</span>)<span class="id"> /</span><span class="id"> 'C_A</span>(<span class="id">B</span><span class="id"> |</span><span class="id"> 'P</span>).<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> sHG:</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> G</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Aut_restr_perm</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> restr_perm</span><span class="id"> H</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AutGa</span>.<br/>
<span class="id">case</span><span class="id"> nHa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span><span class="id"> |</span><span class="id"> 'P</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> triv_restr_perm</span><span class="id"> ?nHa</span><span class="id"> ?group1</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> restr_perm_on;</span><span class="id"> apply/morphicP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> Hx</span><span class="id"> Hy</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !restr_permE</span><span class="id"> ?groupM</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">autmE</span><span class="id"> AutGa</span>)<span class="id"> morphM</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restr_perm_Aut</span><span class="id"> :</span><span class="id"> restr_perm</span><span class="id"> H</span><span class="id"> @*</span><span class="id"> Aut</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> Aut</span><span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a';</span><span class="id"> case/morphimP=&gt;</span><span class="id"> a</span><span class="id"> _</span><span class="id"> AutGa</span><span class="id"> -&gt;{a'};</span><span class="id"> apply:</span><span class="id"> Aut_restr_perm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Aut_in_isog</span><span class="id"> :</span><span class="id"> Aut_in</span> (<span class="id">Aut</span><span class="id"> G</span>)<span class="id"> H</span><span class="id"> \isog</span><span class="id"> restr_perm</span><span class="id"> H</span><span class="id"> @*</span><span class="id"> Aut</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /Aut_in</span><span class="id"> -ker_restr_perm</span><span class="id"> kerE</span><span class="id"> -morphpreIdom</span><span class="id"> -morphimIdom</span><span class="id"> -kerE</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIC</span><span class="id"> _</span> (<span class="id">Aut</span><span class="id"> G</span>))<span class="id"> first_isog_loc</span><span class="id"> ?subsetIr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Aut_sub_fullP</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> h</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> H</span><span class="id"> &gt;-&gt;</span><span class="id"> gT},</span><span class="id"> 'injm</span><span class="id"> h</span><span class="id"> -&gt;</span><span class="id"> h</span><span class="id"> @*</span><span class="id"> H</span><span class="id"> =</span><span class="id"> H</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> g</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> G</span><span class="id"> &gt;-&gt;</span><span class="id"> gT},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'injm</span><span class="id"> g,</span><span class="id"> g</span><span class="id"> @*</span><span class="id"> G</span><span class="id"> =</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> H,</span><span class="id"> g</span><span class="id"> =1</span><span class="id"> h}]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Aut_in</span> (<span class="id">Aut</span><span class="id"> G</span>)<span class="id"> H</span><span class="id"> \isog</span><span class="id"> Aut</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span> (<span class="id">isog_transl</span><span class="id"> _</span><span class="id"> Aut_in_isog</span>)<span class="id"> /=;</span><span class="id"> set</span><span class="id"> rG</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> @*</span><span class="id"> _</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [iso_rG</span><span class="id"> h</span><span class="id"> injh</span><span class="id"> hH|</span><span class="id"> AutHinG]</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> aut</span><span class="id"> injh</span><span class="id"> hH</span><span class="id"> \in</span><span class="id"> rG;</span><span class="id"> last</span><span class="id"> case/morphimP=&gt;</span><span class="id"> g</span><span class="id"> nHg</span><span class="id"> AutGg</span><span class="id"> def_g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> rG</span><span class="id"> =</span><span class="id"> Aut</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> Aut_aut</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> restr_perm_Aut</span><span class="id"> /=</span> (<span class="id">card_isog</span><span class="id"> iso_rG</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">autm_morphism</span><span class="id"> AutGg</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> injm_autm</span><span class="id"> im_autm;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> Hx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">autE</span><span class="id"> injh</span><span class="id"> hH</span><span class="id"> Hx</span>)<span class="id"> def_g</span><span class="id"> actpermE</span><span class="id"> actbyE</span>.<br/>
<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> rG</span><span class="id"> =</span><span class="id"> Aut</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> isog_refl</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> restr_perm_Aut</span><span class="id"> /=</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> h</span><span class="id"> AutHh;</span><span class="id"> have</span><span class="id"> hH</span><span class="id"> :=</span><span class="id"> im_autm</span><span class="id"> AutHh</span>.<br/>
<span class="id">have</span><span class="id"> [g</span><span class="id"> [injg</span><span class="id"> gG</span><span class="id"> eq_gh]]</span><span class="id"> :=</span><span class="id"> AutHinG</span><span class="id"> _</span> (<span class="id">injm_autm</span><span class="id"> AutHh</span>)<span class="id"> hH</span>.<br/>
<span class="id">have</span><span class="id"> [Ng</span><span class="id"> AutGg]:</span><span class="id"> aut</span><span class="id"> injg</span><span class="id"> gG</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span><span class="id"> |</span><span class="id"> 'P</span>)<span class="id"> /\</span><span class="id"> aut</span><span class="id"> injg</span><span class="id"> gG</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Aut_aut</span><span class="id"> !inE;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Hx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> /aperm</span><span class="id"> autE</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHG</span>)<span class="id"> //</span><span class="id"> -hH</span><span class="id"> eq_gh</span><span class="id"> ?mem_morphim</span>.<br/>
<span class="id">apply/morphimP;</span><span class="gallina-kwd"> exists</span> (<span class="id">aut</span><span class="id"> injg</span><span class="id"> gG</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span> (<span class="id">eq_Aut</span><span class="id"> AutHh</span>)<span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> Hx]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span><span class="id"> restr_perm_Aut</span>)<span class="id"> //</span><span class="id"> mem_morphim</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> restr_permE</span><span class="id"> //=</span><span class="id"> /aperm</span><span class="id"> autE</span><span class="id"> ?eq_gh</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> AutIn</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> Aut_in</span><span class="id"> {gT}</span><span class="id"> A%_g</span><span class="id"> B%_g</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> InjmAutIn</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">gT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> D</span><span class="id"> &gt;-&gt;</span><span class="id"> rT}</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">injf</span><span class="id"> :</span><span class="id"> 'injm</span><span class="id"> f</span>) (<span class="id">sGD</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span>) (<span class="id">sHG</span><span class="id"> :</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> G</span>).<br/>
<span class="vernacular">Let</span><span class="id"> sHD</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sHG</span><span class="id"> sGD</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> fGisom</span><span class="id"> :=</span> (<span class="id">Aut_isom</span><span class="id"> injf</span><span class="id"> sGD</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> fHisom</span><span class="id"> :=</span> (<span class="id">Aut_isom</span><span class="id"> injf</span><span class="id"> sHD</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> inH</span><span class="id"> :=</span> (<span class="id">restr_perm</span><span class="id"> H</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> infH</span><span class="id"> :=</span> (<span class="id">restr_perm</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> H</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_Aut_isom</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="id">fGisom</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">f</span><span class="id"> @*</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'P</span>))<span class="id"> =</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span><span class="id"> |</span><span class="id"> 'P</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AutGa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> sub_morphim_pre</span><span class="id"> //</span><span class="id"> subsetI</span><span class="id"> sHD</span><span class="id"> /=</span><span class="id"> /aperm</span>.<br/>
<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">sameP</span><span class="id"> setIidPl</span><span class="id"> eqP</span>)<span class="id"> !eqEsubset</span><span class="id"> !subsetIl;</span><span class="id"> apply:</span><span class="id"> eq_subset_r</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE;</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> Hx;</span><span class="id"> have</span><span class="id"> Gx:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sHG</span><span class="id"> x</span><span class="id"> Hx</span>.<br/>
<span class="id">have</span><span class="id"> Dax:</span><span class="id"> a</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span><span class="id"> sGD</span>)<span class="id"> //</span><span class="id"> Aut_closed</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Aut_isomE</span><span class="id"> //</span><span class="id"> -!sub1set</span><span class="id"> -morphim_set1</span><span class="id"> //</span><span class="id"> injmSK</span><span class="id"> ?sub1set</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> isom_restr_perm</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> fHisom</span> (<span class="id">inH</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> infH</span> (<span class="id">fGisom</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> AutGa;</span><span class="id"> case</span><span class="id"> nHa:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span><span class="id"> |</span><span class="id"> 'P</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !triv_restr_perm</span><span class="id"> ?astabs_Aut_isom</span><span class="id"> ?nHa</span><span class="id"> ?morph1</span>.<br/>
<span class="id">apply:</span> (<span class="id">eq_Aut</span> (<span class="id">Aut_Aut_isom</span><span class="id"> injf</span><span class="id"> sHD</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> [|fx</span><span class="id"> Hfx</span><span class="id"> /=]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Aut_restr_perm</span> (<span class="id">morphimS</span><span class="id"> f</span><span class="id"> sHG</span>))<span class="id"> ?Aut_Aut_isom</span>.<br/>
<span class="id">have</span><span class="id"> [x</span><span class="id"> Dx</span><span class="id"> Hx</span><span class="id"> def_fx]</span><span class="id"> :=</span><span class="id"> morphimP</span><span class="id"> Hfx;</span><span class="id"> have</span><span class="id"> Gx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sHG</span><span class="id"> x</span><span class="id"> Hx</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}def_fx</span><span class="id"> Aut_isomE</span><span class="id"> ?</span>(<span class="id">Aut_restr_perm</span><span class="id"> sHG</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !restr_permE</span><span class="id"> ?astabs_Aut_isom</span><span class="id"> //</span><span class="id"> def_fx</span><span class="id"> Aut_isomE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> restr_perm_isom</span><span class="id"> :</span><span class="id"> isom</span> (<span class="id">inH</span><span class="id"> @*</span><span class="id"> Aut</span><span class="id"> G</span>) (<span class="id">infH</span><span class="id"> @*</span><span class="id"> Aut</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> G</span>))<span class="id"> fHisom</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> sub_isom;</span><span class="id"> rewrite</span><span class="id"> ?restr_perm_Aut</span><span class="id"> ?injm_Aut_isom</span><span class="id"> //=</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">im_Aut_isom</span><span class="id"> injf</span><span class="id"> sGD</span>)<span class="id"> -!morphim_comp</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_in_morphim;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> isom_restr_perm</span>.<br/>
<span class="comment">(*&nbsp;TODO:&nbsp;investigate&nbsp;why&nbsp;rewrite&nbsp;does&nbsp;not&nbsp;match&nbsp;in&nbsp;the&nbsp;same&nbsp;order&nbsp;*)</span><br/>
<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> in_setI</span><span class="id"> [in</span><span class="id"> RHS]in_setI;</span><span class="id"> apply:</span><span class="id"> andb_id2r</span><span class="id"> =&gt;</span><span class="id"> AutGa</span>.<br/>
<span class="comment">(*&nbsp;the&nbsp;middle&nbsp;rewrite&nbsp;was&nbsp;rewrite&nbsp;2!in_setI&nbsp;*)</span><br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> inE</span><span class="id"> andbC</span><span class="id"> inE</span> (<span class="id">Aut_restr_perm</span><span class="id"> sHG</span>)<span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> symmetry;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> AutGa</span><span class="id"> inE</span><span class="id"> astabs_Aut_isom</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injm_Aut_sub</span><span class="id"> :</span><span class="id"> Aut_in</span> (<span class="id">Aut</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> G</span>)) (<span class="id">f</span><span class="id"> @*</span><span class="id"> H</span>)<span class="id"> \isog</span><span class="id"> Aut_in</span> (<span class="id">Aut</span><span class="id"> G</span>)<span class="id"> H</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">do</span><span class="id"> 2!rewrite</span><span class="id"> isog_sym</span> (<span class="id">isog_transl</span><span class="id"> _</span> (<span class="id">Aut_in_isog</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> isog_sym</span> (<span class="id">isom_isog</span><span class="id"> _</span><span class="id"> _</span><span class="id"> restr_perm_isom</span>)<span class="id"> //</span><span class="id"> restr_perm_Aut</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injm_Aut_full</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">Aut_in</span> (<span class="id">Aut</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> G</span>)) (<span class="id">f</span><span class="id"> @*</span><span class="id"> H</span>)<span class="id"> \isog</span><span class="id"> Aut</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> H</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">=</span> (<span class="id">Aut_in</span> (<span class="id">Aut</span><span class="id"> G</span>)<span class="id"> H</span><span class="id"> \isog</span><span class="id"> Aut</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">isog_transl</span><span class="id"> _</span><span class="id"> injm_Aut_sub</span>) (<span class="id">isog_transr</span><span class="id"> _</span> (<span class="id">injm_Aut</span><span class="id"> injf</span><span class="id"> sHD</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> InjmAutIn</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> GroupAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> actT</span><span class="id"> :=</span> (<span class="id">action</span><span class="id"> D</span><span class="id"> rT</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> is_groupAction</span> (<span class="id">to</span><span class="id"> :</span><span class="id"> actT</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> actperm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> R}</span>.<br/>
<br/>
<span class="vernacular">Structure</span><span class="id"> groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> {gact</span><span class="id"> :&gt;</span><span class="id"> actT;</span><span class="id"> _</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> gact}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> clone_groupAction</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span><span class="id"> GroupAction</span><span class="id"> _</span><span class="id"> toA</span><span class="id"> :=</span><span class="id"> to</span><span class="gallina-kwd"> return</span><span class="id"> {type</span><span class="id"> of</span><span class="id"> GroupAction</span><span class="gallina-kwd"> for</span><span class="id"> to}</span><span class="id"> -&gt;</span><span class="id"> _</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> toA</span><span class="id"> :</span><span class="id"> groupAction</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> GroupAction</span>.<br/>
<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> groupAction_scope</span><span class="gallina-kwd"> with</span><span class="id"> gact</span>.<br/>
<span class="vernacular">Bind</span><span class="vernacular"> Scope</span><span class="id"> groupAction_scope</span><span class="gallina-kwd"> with</span><span class="id"> groupAction</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> is_groupAction</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> D%_g}</span><span class="id"> R%_g</span><span class="id"> to%_act</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> groupAction</span><span class="id"> {aT</span><span class="id"> rT}</span><span class="id"> D%_g</span><span class="id"> R%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> gact</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> D%_g</span><span class="id"> R%_g}</span><span class="id"> to%_gact</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'groupAction' 'of' to ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">clone_groupAction</span> (<span class="id">@GroupAction</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> to</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ 'groupAction'  'of'  to ]&quot;</span>)<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> GroupActionDefs</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> to</span><span class="id"> :</span><span class="id"> groupAction</span><span class="id"> D</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> gact_range</span><span class="id"> of</span><span class="id"> groupAction</span><span class="id"> D</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> gacent</span><span class="id"> to</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> 'Fix_</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> acts_on_group</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> /\</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Coercion</span><span class="id"> actby_cond_group</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :</span><span class="id"> acts_on_group</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> -&gt;</span><span class="id"> actby_cond</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">@proj1</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> acts_irreducibly</span><span class="id"> A</span><span class="id"> S</span><span class="id"> to</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[min</span><span class="id"> S</span><span class="id"> of</span><span class="id"> G</span><span class="id"> |</span><span class="id"> G</span><span class="id"> :!=:</span><span class="id"> 1</span><span class="id"> &amp;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> G</span><span class="id"> |</span><span class="id"> to]]</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> GroupActionDefs</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> gacent</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> D%_g</span><span class="id"> R%_g}</span><span class="id"> to%_gact</span><span class="id"> A%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> acts_on_group</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> D%_g</span><span class="id"> R%_g}</span><span class="id"> A%_g</span><span class="id"> S%_g</span><span class="id"> to%_gact</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> acts_irreducibly</span><span class="id"> {aT</span><span class="id"> rT</span><span class="id"> D%_g</span><span class="id"> R%_g}</span><span class="id"> A%_g</span><span class="id"> S%_g</span><span class="id"> to%_gact</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( | to ) ( A )&quot;</span><span class="id"> :=</span> (<span class="id">gacent</span><span class="id"> to</span><span class="id"> A</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C_' ( | to ) ( A )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( G | to ) ( A )&quot;</span><span class="id"> :=</span> (<span class="id">G</span><span class="id"> :&amp;:</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C_' ( G  |  to ) ( A )&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( | to ) [ a ]&quot;</span><span class="id"> :=</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">[set</span><span class="id"> a]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C_' ( | to ) [ a ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( G | to ) [ a ]&quot;</span><span class="id"> :=</span><span class="id"> 'C_</span>(<span class="id">G</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">[set</span><span class="id"> a]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8,</span><span class="id"> format</span> <span class="id">&quot;''C_' ( G  |  to ) [ a ]&quot;</span>)<span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;{ 'acts' A , 'on' 'group' G | to }&quot;</span><span class="id"> :=</span> (<span class="id">acts_on_group</span><span class="id"> A</span><span class="id"> G</span><span class="id"> to</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;{ 'acts'  A ,  'on'  'group'  G  |  to }&quot;</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RawGroupAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">D</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<span class="vernacular">Variable</span><span class="id"> to</span><span class="id"> :</span><span class="id"> groupAction</span><span class="id"> D</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actperm_Aut</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> R</span><span class="id"> to</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> to</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> im_actperm_Aut</span><span class="id"> :</span><span class="id"> actperm</span><span class="id"> to</span><span class="id"> @*</span><span class="id"> D</span><span class="id"> \subset</span><span class="id"> Aut</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /morphimP[a</span><span class="id"> _</span><span class="id"> Da</span><span class="id"> -&gt;];</span><span class="id"> apply:</span><span class="id"> actperm_Aut</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gact_out</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> -actpermE</span> (<span class="id">out_Aut</span><span class="id"> _</span><span class="id"> Rx</span>)<span class="id"> ?actperm_Aut</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gactM</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> {in</span><span class="id"> R</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y}}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">actpermE</span><span class="id"> to</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> morphicP</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Aut_morphic</span><span class="id"> ?actperm_Aut</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actmM</span><span class="id"> a</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> R</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /actm;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> gactM</span>. Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> act_morphism</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> Morphism</span> (<span class="id">actmM</span><span class="id"> a</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morphim_actm</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>)<span class="id">,</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> @*</span><span class="id"> S</span><span class="id"> =</span><span class="id"> to^*</span><span class="id"> S</span><span class="id"> a}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> S</span><span class="id"> sSR;</span><span class="id"> rewrite</span><span class="id"> /morphim</span><span class="id"> /=</span><span class="id"> actmEfun</span><span class="id"> ?</span>(<span class="id">setIidPr</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Variables</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> aT</span>) (<span class="id">A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentIdom</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">D</span><span class="id"> :&amp;:</span><span class="id"> A</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /gacent</span><span class="id"> setIA</span><span class="id"> setIid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentIim</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span><span class="id"> setIid</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentS</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> B</span><span class="id"> -&gt;</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">B</span>)<span class="id"> \subset</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAB;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">setIS,</span><span class="id"> afixS</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentU</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span><span class="id"> :|:</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>)<span class="id"> :&amp;:</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setIIr</span><span class="id"> -afixU</span><span class="id"> -setIUr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">Da</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span>) (<span class="id">sAD</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span>) (<span class="id">sSR</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentE</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">setIidPr</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent1E</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)<span class="id">[a]</span><span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /gacent</span><span class="id"> [D</span><span class="id"> :&amp;:</span><span class="id"> _]</span>(<span class="id">setIidPr</span><span class="id"> _</span>)<span class="id"> ?sub1set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subgacentE</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gacentE</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sSR</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subgacent1E</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">[a]</span><span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)<span class="id">[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gacent1E</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sSR</span>). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RawGroupAction</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> GroupActionTheory</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> finGroupType</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">D</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>) (<span class="id">to</span><span class="id"> :</span><span class="id"> groupAction</span><span class="id"> D</span><span class="id"> R</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> M</span><span class="id"> N</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gact1</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> to</span><span class="id"> 1</span><span class="id"> a</span><span class="id"> =</span><span class="id"> 1}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -actmE</span><span class="id"> ?morph1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gactV</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> {in</span><span class="id"> R,</span><span class="id"> {morph</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> x^-1}}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x</span><span class="id"> Rx;</span><span class="id"> move;</span><span class="id"> rewrite</span><span class="id"> -!actmE</span><span class="id"> ?morphV</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gactX</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a</span><span class="id"> n,</span><span class="id"> {in</span><span class="id"> R,</span><span class="id"> {morph</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> /</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> n}}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> n</span><span class="id"> x</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> -!actmE</span><span class="id"> //</span><span class="id"> morphX</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gactJ</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> {in</span><span class="id"> R</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y}}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x</span><span class="id"> Rx</span><span class="id"> y</span><span class="id"> Ry;</span><span class="id"> rewrite</span><span class="id"> -!actmE</span><span class="id"> //</span><span class="id"> morphJ</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gactR</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> D,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> {in</span><span class="id"> R</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> :</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /</span><span class="id"> [~</span><span class="id"> x,</span><span class="id"> y]}}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Da</span><span class="id"> /=</span><span class="id"> x</span><span class="id"> Rx</span><span class="id"> y</span><span class="id"> Ry;</span><span class="id"> rewrite</span><span class="id"> -!actmE</span><span class="id"> //</span><span class="id"> morphR</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gact_stable</span><span class="id"> :</span><span class="id"> {acts</span><span class="id"> D,</span><span class="id"> on</span><span class="id"> R</span><span class="id"> |</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> acts_act;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply:</span><span class="id"> contraLR</span><span class="id"> =&gt;</span><span class="id"> R'xa</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">actKin</span><span class="id"> to</span><span class="id"> Da</span><span class="id"> x</span>)<span class="id"> gact_out</span><span class="id"> ?groupV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> group_set_gacent</span><span class="id"> A</span><span class="id"> :</span><span class="id"> group_set</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/group_setP;</span><span class="id"> split=&gt;</span><span class="id"> [|x</span><span class="id"> y]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> group1;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> /setIP[Da</span><span class="id"> _];</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> gact1</span>.<br/>
<span class="id">case/setIP=&gt;</span><span class="id"> Rx</span><span class="id"> /afixP</span><span class="id"> cAx</span><span class="id"> /setIP[Ry</span><span class="id"> /afixP</span><span class="id"> cAy]</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> groupM</span><span class="id"> //;</span><span class="id"> apply/afixP=&gt;</span><span class="id"> a</span><span class="id"> Aa</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gactM</span><span class="id"> ?cAx</span><span class="id"> ?cAy</span><span class="id"> //;</span><span class="id"> case/setIP:</span><span class="id"> Aa</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> gacent_group</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> Group</span> (<span class="id">group_set_gacent</span><span class="id"> A</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent1</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">1</span>)<span class="id"> =</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /gacent</span> (<span class="id">setIidPr</span> (<span class="id">sub1G</span><span class="id"> _</span>))<span class="id"> afix1</span><span class="id"> setIT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_gen</span><span class="id"> A</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">&lt;&lt;A&gt;&gt;</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sAD;</span><span class="id"> rewrite</span><span class="id"> /gacent</span><span class="id"> ![D</span><span class="id"> :&amp;:</span><span class="id"> _]</span>(<span class="id">setIidPr</span><span class="id"> _</span>)<span class="id"> ?gen_subG</span><span class="id"> ?afix_gen_in</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentD1</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A^#</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -gacentIdom</span><span class="id"> -gacent_gen</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> setIDA</span><span class="id"> genD1</span><span class="id"> ?group1</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gacent_gen</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> gacentIdom</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_cycle</span><span class="id"> a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">&lt;[a]&gt;</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)<span class="id">[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> gacent_gen</span><span class="id"> ?sub1set</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentY</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span><span class="id"> &lt;*&gt;</span><span class="id"> B</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>)<span class="id"> :&amp;:</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAD</span><span class="id"> sBD;</span><span class="id"> rewrite</span><span class="id"> gacent_gen</span><span class="id"> ?gacentU</span><span class="id"> //</span><span class="id"> subUset</span><span class="id"> sAD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentM</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">G</span><span class="id"> *</span><span class="id"> H</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">G</span>)<span class="id"> :&amp;:</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> sHB;</span><span class="id"> rewrite</span><span class="id"> -gacent_gen</span><span class="id"> ?mul_subG</span><span class="id"> //</span><span class="id"> genM_join</span><span class="id"> gacentY</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">1</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">inE,</span><span class="id"> sub1set</span>)<span class="id"> andb_idr</span><span class="id"> //;</span><span class="id"> move/gact1=&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_range</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">setT</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> andbC</span><span class="id"> astabS</span><span class="id"> ?subsetT</span><span class="id"> //=</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> cRa;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astab_dom</span><span class="id"> cRa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setUCr</span><span class="id"> R</span>)<span class="id"> !inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/orP=&gt;</span><span class="id"> ?;</span><span class="id"> [rewrite</span> (<span class="id">astab_act</span><span class="id"> cRa</span>)<span class="id"> |</span><span class="id"> rewrite</span><span class="id"> gact_out]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentC</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">S</span><span class="id"> \subset</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>))<span class="id"> =</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAD</span><span class="id"> sSR;</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> sSR</span><span class="id"> astabCin</span><span class="id"> //</span> (<span class="id">setIidPr</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab_gen</span><span class="id"> S</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">&lt;&lt;S&gt;&gt;</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sSR;</span><span class="id"> apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> case</span><span class="id"> Da:</span> (<span class="id">a</span><span class="id"> \in</span><span class="id"> D</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!sub1set</span><span class="id"> -!gacentC</span><span class="id"> ?sub1set</span><span class="id"> ?gen_subG</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabM</span><span class="id"> M</span><span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">M</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> N</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">M</span><span class="id"> *</span><span class="id"> N</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> :&amp;:</span><span class="id"> 'C</span>(<span class="id">N</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sMR</span><span class="id"> sNR;</span><span class="id"> rewrite</span><span class="id"> -astabU</span><span class="id"> -astab_gen</span><span class="id"> ?mul_subG</span><span class="id"> //</span><span class="id"> genM_join</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> astab_gen</span><span class="id"> //</span><span class="id"> subUset</span><span class="id"> sMR</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs1</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">1</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabs_set1</span><span class="id"> astab1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabs_range</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> D</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setIidPl;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> gact_stable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsD1</span><span class="id"> S</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">S^#</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case</span><span class="id"> S1:</span> (<span class="id">1</span><span class="id"> \in</span><span class="id"> S</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">setDidPl</span><span class="id"> _</span>)<span class="id"> //</span><span class="id"> disjoint_sym</span><span class="id"> disjoints_subset</span><span class="id"> sub1set</span><span class="id"> inE</span><span class="id"> S1</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> andbC</span><span class="id"> -{1}astabsIdom</span><span class="id"> -{1}astabs1</span><span class="id"> setIC</span><span class="id"> astabsD</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">setD1K</span><span class="id"> S1</span>)<span class="id"> -astabsIdom</span><span class="id"> -{1}astabs1</span><span class="id"> astabsU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacts_range</span><span class="id"> A</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> {acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> group</span><span class="id"> R</span><span class="id"> |</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sAD;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?astabs_range</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_subnorm_gacent</span><span class="id"> A</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> 'N_D</span>(<span class="id">A</span>)<span class="id">,</span><span class="id"> on</span><span class="id"> 'C_</span>(<span class="id">|</span><span class="id"> to</span>)(<span class="id">A</span>)<span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD;</span><span class="id"> rewrite</span><span class="id"> gacentE</span><span class="id"> //</span><span class="id"> actsI</span><span class="id"> ?astabs_range</span><span class="id"> ?subsetIl</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">setIidPr</span><span class="id"> sAD</span>)<span class="id"> acts_subnorm_fix</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_subnorm_subgacent</span><span class="id"> A</span><span class="id"> B</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> B,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> 'N_B</span>(<span class="id">A</span>)<span class="id">,</span><span class="id"> on</span><span class="id"> 'C_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span>)<span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD</span><span class="id"> actsB;</span><span class="id"> rewrite</span><span class="id"> actsI</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subIset</span><span class="id"> ?actsB</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> _</span> (<span class="id">acts_subnorm_gacent</span><span class="id"> sAD</span>))<span class="id"> ?setSI</span><span class="id"> ?</span>(<span class="id">acts_dom</span><span class="id"> actsB</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_gen</span><span class="id"> A</span><span class="id"> S</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">S</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> &lt;&lt;S&gt;&gt;</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sSR</span><span class="id"> actsA;</span><span class="id"> apply:</span><span class="id"> {A}subset_trans</span><span class="id"> actsA</span><span class="id"> _</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> nSa;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> nSa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply:</span><span class="id"> subset_trans</span> (_<span class="id"> :</span><span class="id"> &lt;&lt;S&gt;&gt;</span><span class="id"> \subset</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> @*^-1</span><span class="id"> &lt;&lt;S&gt;&gt;</span>)<span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> gen_subG</span><span class="id"> subsetI</span><span class="id"> sSR;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Sx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> actmE</span><span class="id"> ?mem_gen</span><span class="id"> //</span><span class="id"> astabs_act</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> /[!inE];</span><span class="id"> case/andP=&gt;</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> actmE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_joing</span><span class="id"> A</span><span class="id"> M</span><span class="id"> N</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">M</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> N</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> M</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> N</span><span class="id"> |</span><span class="id"> to]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> M</span><span class="id"> &lt;*&gt;</span><span class="id"> N</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sMR</span><span class="id"> sNR</span><span class="id"> nMA</span><span class="id"> nNA;</span><span class="id"> rewrite</span><span class="id"> acts_gen</span><span class="id"> ?actsU</span><span class="id"> //</span><span class="id"> subUset</span><span class="id"> sMR</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> injm_actm</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'injm</span> (<span class="id">actm</span><span class="id"> to</span><span class="id"> a</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/injmP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> Rx</span><span class="id"> Ry;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /actm;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> Da</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> act_inj</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> im_actm</span><span class="id"> a</span><span class="id"> :</span><span class="id"> actm</span><span class="id"> to</span><span class="id"> a</span><span class="id"> @*</span><span class="id"> R</span><span class="id"> =</span><span class="id"> R</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span> (<span class="id">card_injm</span> (<span class="id">injm_actm</span><span class="id"> a</span>))<span class="id"> //</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /morphimP[x</span><span class="id"> Rx</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /actm;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Da;</span><span class="id"> rewrite</span><span class="id"> gact_stable</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_char</span><span class="id"> G</span><span class="id"> M</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> \char</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> M</span><span class="id"> |</span><span class="id"> to]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sGD</span><span class="id"> /charP[sMR</span><span class="id"> charM]</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sGD</span><span class="id"> a</span><span class="id"> Ga;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> Da</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Mx;</span><span class="id"> have</span><span class="id"> Rx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sMR</span><span class="id"> x</span><span class="id"> Mx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -</span>(<span class="id">charM</span><span class="id"> _</span> (<span class="id">injm_actm</span><span class="id"> a</span>) (<span class="id">im_actm</span><span class="id"> a</span>))<span class="id"> -actmE</span><span class="id"> //</span><span class="id"> mem_morphim</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacts_char</span><span class="id"> G</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">G</span><span class="id"> \subset</span><span class="id"> D</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> \char</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> {acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> group</span><span class="id"> M</span><span class="id"> |</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sGD</span><span class="id"> charM;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?acts_char//</span><span class="id"> char_sub</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Restrict</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">sAD</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ract_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> R</span> (<span class="id">to</span><span class="id"> \</span><span class="id"> sAD</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ractpermE</span><span class="id"> actperm_Aut</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> ract_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> ract_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_ract</span><span class="id"> B</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|ract_groupAction</span>)(<span class="id">B</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /gacent</span><span class="id"> afix_ract</span><span class="id"> setIA</span> (<span class="id">setIidPr</span><span class="id"> sAD</span>). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Restrict</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ActBy</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>) (<span class="id">nGAg</span><span class="id"> :</span><span class="id"> {acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> group</span><span class="id"> G</span><span class="id"> |</span><span class="id"> to}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actby_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> G</span><span class="id"> &lt;[nGAg]&gt;</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> Aa;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> Gx</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> actpermE</span><span class="id"> /=</span><span class="id"> /actby</span> (<span class="id">negbTE</span><span class="id"> Gx</span>).<br/>
<span class="id">apply/morphicP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> Gx</span><span class="id"> Gy;</span><span class="id"> rewrite</span><span class="id"> !actpermE</span><span class="id"> /=</span><span class="id"> /actby</span><span class="id"> Aa</span><span class="id"> groupM</span><span class="id"> ?Gx</span><span class="id"> ?Gy</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> nGAg;</span><span class="id"> move/acts_dom;</span><span class="id"> do</span><span class="id"> 2!move/subsetP=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> gactM;</span><span class="id"> auto</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> actby_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> actby_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_actby</span><span class="id"> B</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">'C_</span>(<span class="id">|actby_groupAction</span>)(<span class="id">B</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">G</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">A</span><span class="id"> :&amp;:</span><span class="id"> B</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /gacent</span><span class="id"> afix_actby</span><span class="id"> !setIA</span><span class="id"> setIid</span><span class="id"> setIUr</span><span class="id"> setICr</span><span class="id"> set0U</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [nAG</span><span class="id"> sGR]</span><span class="id"> :=</span><span class="id"> nGAg;</span><span class="id"> rewrite</span> (<span class="id">setIidPr</span> (<span class="id">acts_dom</span><span class="id"> nAG</span>)) (<span class="id">setIidPl</span><span class="id"> sGR</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ActBy</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Quotient</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_qact_dom_norm</span><span class="id"> :</span><span class="id"> {acts</span><span class="id"> qact_dom</span><span class="id"> to</span><span class="id"> H,</span><span class="id"> on</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> |</span><span class="id"> to}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> HDa</span><span class="id"> /=</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> {2}</span>((<span class="id">'N</span>(<span class="id">H</span>)<span class="id"> =P</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> @^-1:</span><span class="id"> 'N</span>(<span class="id">H</span>))<span class="id"> _</span>)<span class="id"> ?inE</span><span class="id"> {x}//</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEcard</span> (<span class="id">card_preimset</span><span class="id"> _</span> (<span class="id">act_inj</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Nx;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> move/</span>(<span class="id">astabs_act</span> (<span class="id">H</span><span class="id"> :*</span><span class="id"> x</span>))<span class="id">:</span><span class="id"> HDa</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_rcosets</span><span class="id"> mulSGid</span><span class="id"> ?normG</span><span class="id"> //</span><span class="id"> Nx</span><span class="id"> =&gt;</span><span class="id"> /rcosetsP[y</span><span class="id"> Ny</span><span class="id"> defHy]</span>.<br/>
<span class="id">suffices:</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> H</span><span class="id"> :*</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> rewrite</span><span class="id"> mul_subG</span><span class="id"> ?sub1set</span><span class="id"> ?normG</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defHy;</span><span class="id"> apply:</span><span class="id"> imset_f;</span><span class="id"> apply:</span><span class="id"> rcoset_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> qact_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span> (<span class="id">R</span><span class="id"> /</span><span class="id"> H</span>) (<span class="id">to</span><span class="id"> /</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> HDa</span><span class="id"> /=;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> HDa</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> Hx</span><span class="id"> /=;</span><span class="id"> case:</span> (<span class="id">cosetP</span><span class="id"> Hx</span>)<span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Nx</span><span class="id"> -&gt;{Hx}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> R'Hx;</span><span class="id"> rewrite</span><span class="id"> actpermE</span><span class="id"> qactE</span><span class="id"> //</span><span class="id"> gact_out</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> R'Hx;</span><span class="id"> apply:</span><span class="id"> mem_morphim</span>.<br/>
<span class="id">apply/morphicP=&gt;</span><span class="id"> Hx</span><span class="id"> Hy;</span><span class="id"> rewrite</span><span class="id"> !actpermE</span>.<br/>
<span class="id">case/morphimP=&gt;</span><span class="id"> x</span><span class="id"> Nx</span><span class="id"> Gx</span><span class="id"> -&gt;{Hx};</span><span class="id"> case/morphimP=&gt;</span><span class="id"> y</span><span class="id"> Ny</span><span class="id"> Gy</span><span class="id"> -&gt;{Hy}</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -morphM</span><span class="id"> ?qactE</span><span class="id"> ?groupM</span><span class="id"> ?gactM</span><span class="id"> //</span><span class="id"> morphM</span><span class="id"> ?acts_qact_dom_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> quotient_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> qact_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> qact_domE</span><span class="id"> :</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> qact_dom</span><span class="id"> to</span><span class="id"> H</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">H</span><span class="id"> |</span><span class="id"> to</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sHR;</span><span class="id"> apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> nHa;</span><span class="id"> have</span><span class="id"> Da</span><span class="id"> :=</span><span class="id"> astabs_dom</span><span class="id"> nHa</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Hx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -</span>(<span class="id">rcoset1</span><span class="id"> H</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /rcosetsP[y</span><span class="id"> Ny</span><span class="id"> defHy]:</span><span class="id"> to^~</span><span class="id"> a</span><span class="id"> @:</span><span class="id"> H</span><span class="id"> \in</span><span class="id"> rcosets</span><span class="id"> H</span><span class="id"> 'N</span>(<span class="id">H</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nHa</span>)<span class="id">;</span><span class="id"> apply/rcosetsP;</span><span class="gallina-kwd"> exists</span><span class="id"> 1;</span><span class="id"> rewrite</span><span class="id"> ?mulg1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">rcoset_eqP</span> (_<span class="id"> :</span><span class="id"> 1</span><span class="id"> \in</span><span class="id"> H</span><span class="id"> :*</span><span class="id"> y</span>))<span class="id"> -defHy</span><span class="id"> -1?</span>(<span class="id">gact1</span><span class="id"> Da</span>)<span class="id"> mem_setact</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> Hx</span><span class="id"> /[1!inE]</span><span class="id"> /rcosetsP[x</span><span class="id"> Nx</span><span class="id"> -&gt;{Hx}]</span>.<br/>
<span class="id">apply/imsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">to</span><span class="id"> x</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Rx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gact_out</span><span class="id"> ?Rx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[y</span><span class="id"> Hy</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">actKVin</span><span class="id"> to</span><span class="id"> Da</span><span class="id"> y</span>)<span class="id"> -gactJ</span><span class="id"> //</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHR,</span><span class="id"> astabs_act,</span><span class="id"> groupV</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memJ_norm</span><span class="id"> //</span><span class="id"> astabs_act</span><span class="id"> ?groupV</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> rcosetE</span><span class="id"> eqEcard</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_imset</span><span class="id"> _</span> (<span class="id">act_inj</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> !card_rcoset</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[y</span><span class="id"> Hxy</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> !mem_rcoset</span><span class="gallina-kwd"> in</span><span class="id"> Hxy</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> Rxy</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sHR</span><span class="id"> _</span><span class="id"> Hxy;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mulgKV</span><span class="id"> x</span><span class="id"> y</span>).<br/>
<span class="id">case</span><span class="id"> Rx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !gact_out</span><span class="id"> ?mulgK</span><span class="id"> //</span><span class="id"> 1?groupMl</span><span class="id"> ?Rx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -gactV</span><span class="id"> //</span><span class="id"> -gactM</span><span class="id"> 1?groupMr</span><span class="id"> ?groupV</span><span class="id"> //</span><span class="id"> mulgK</span><span class="id"> astabs_act</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Quotient</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Mod</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modact_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">H</span>) (<span class="id">to</span><span class="id"> %%</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ha</span><span class="id"> /morphimP[a</span><span class="id"> Na</span><span class="id"> Da</span><span class="id"> -&gt;];</span><span class="id"> have</span><span class="id"> NDa:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N_D</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> apply/setIP</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> 2!inE</span><span class="id"> andbC</span><span class="id"> actpermE</span><span class="id"> /=</span><span class="id"> modactEcond</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraR;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> E</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> gact_out</span>.<br/>
<span class="id">apply/morphicP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /setIP[Rx</span><span class="id"> cHx]</span><span class="id"> /setIP[Ry</span><span class="id"> cHy]</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> !actpermE</span><span class="id"> /=</span><span class="id"> !modactE</span><span class="id"> ?gactM</span><span class="id"> //</span>.<br/>
<span class="id">suffices:</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> case/setIP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> groupM</span><span class="id"> //;</span><span class="id"> apply/setIP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> mod_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> modact_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modgactE</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> 'N_D</span>(<span class="id">H</span>)<span class="id"> -&gt;</span> (<span class="id">to</span><span class="id"> %%</span><span class="id"> H</span>)<span class="id">%act</span><span class="id"> x</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cRH</span><span class="id"> NDa</span><span class="id"> /=;</span><span class="id"> have</span><span class="id"> [Da</span><span class="id"> Na]</span><span class="id"> :=</span><span class="id"> setIP</span><span class="id"> NDa</span>.<br/>
<span class="id">have</span><span class="id"> [Rx</span><span class="id"> |</span><span class="id"> notRx]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> R</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> modactE</span><span class="id"> //;</span><span class="id"> apply/afixP=&gt;</span><span class="id"> b</span><span class="id"> /setIP[_</span><span class="id"> /</span>(<span class="id">subsetP</span><span class="id"> cRH</span>)<span class="id">/astab_act-&gt;]</span>.<br/>
<span class="id">rewrite</span><span class="id"> gact_out</span><span class="id"> //=</span><span class="id"> /modact;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gact_out</span><span class="id"> //</span>.<br/>
<span class="id">suffices:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> :&amp;:</span><span class="id"> coset</span><span class="id"> H</span><span class="id"> a</span><span class="gallina-kwd"> by</span><span class="id"> case/mem_repr/setIP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Da</span><span class="id"> val_coset</span><span class="id"> //</span><span class="id"> rcoset_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_mod</span><span class="id"> G</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><br/>
&nbsp;<span class="id">'C_</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> mod_groupAction</span>)(<span class="id">G</span><span class="id"> /</span><span class="id"> H</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> to</span>)(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cMH</span><span class="id"> nHG;</span><span class="id"> rewrite</span><span class="id"> -gacentIdom</span><span class="id"> gacentE</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> setICA</span>.<br/>
<span class="id">have</span><span class="id"> sHD:</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> D</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> cMH</span>)<span class="id"> ?subsetIl</span>.<br/>
<span class="id">rewrite</span><span class="id"> -quotientGI</span><span class="id"> //</span><span class="id"> afix_mod</span><span class="id"> ?setIS</span><span class="id"> //</span><span class="id"> setICA</span><span class="id"> -gacentIim</span> (<span class="id">setIC</span><span class="id"> R</span>)<span class="id"> -setIA</span>.<br/>
<span class="id">rewrite</span><span class="id"> -gacentE</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> gacentIdom</span><span class="id"> setICA</span> (<span class="id">setIidPr</span><span class="id"> _</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gacentC</span><span class="id"> //</span><span class="id"> ?</span>(<span class="id">subset_trans</span><span class="id"> cMH</span>)<span class="id"> ?astabS</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> setICA</span><span class="id"> subsetIl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_irr_mod</span><span class="id"> G</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> to</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> acts_irreducibly</span><span class="id"> G</span><span class="id"> M</span><span class="id"> to</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">acts_irreducibly</span> (<span class="id">G</span><span class="id"> /</span><span class="id"> H</span>)<span class="id"> M</span><span class="id"> mod_groupAction</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cMH</span><span class="id"> nHG</span><span class="id"> /mingroupP[/andP[ntM</span><span class="id"> nMG]</span><span class="id"> minM]</span>.<br/>
<span class="id">apply/mingroupP;</span><span class="id"> rewrite</span><span class="id"> ntM</span><span class="id"> astabs_mod</span><span class="id"> ?quotientS</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> L</span><span class="id"> modL</span><span class="id"> ntL</span>.<br/>
<span class="id">have</span><span class="id"> cLH:</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">L</span><span class="id"> |</span><span class="id"> to</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> cMH</span>)<span class="id"> ?astabS</span><span class="id"> //</span>.<br/>
<span class="id">apply:</span><span class="id"> minM</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case/andP:</span><span class="id"> modL</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> astabs_mod</span><span class="id"> ?quotientSGK</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> cLH</span>)<span class="id"> ?astab_sub</span>.<br/>
Qed.</div></details>
&nbsp;&nbsp;<br/>
<span class="vernacular">End</span><span class="id"> Mod</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modact_coset_astab</span><span class="id"> x</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">a</span><span class="id"> \in</span><span class="id"> D</span><span class="id"> -&gt;</span> (<span class="id">to</span><span class="id"> %%</span><span class="id"> 'C</span>(<span class="id">R</span><span class="id"> |</span><span class="id"> to</span>))<span class="id">%act</span><span class="id"> x</span> (<span class="id">coset</span><span class="id"> _</span><span class="id"> a</span>)<span class="id"> =</span><span class="id"> to</span><span class="id"> x</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Da;</span><span class="id"> apply:</span><span class="id"> modgactE</span><span class="id"> =&gt;</span><span class="id"> {x}//</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> Da;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[c</span><span class="id"> Cc</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">have</span><span class="id"> Dc</span><span class="id"> :=</span><span class="id"> astab_dom</span><span class="id"> Cc;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> groupJ</span><span class="id"> //</span>.<br/>
<span class="id">apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> Rx;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> conjgE</span><span class="id"> !actMin</span><span class="id"> ?groupM</span><span class="id"> ?groupV</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">astab_act</span><span class="id"> Cc</span>)<span class="id"> ?actKVin</span><span class="id"> //</span><span class="id"> gact_stable</span><span class="id"> ?groupV</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> acts_irr_mod_astab</span><span class="id"> G</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">acts_irreducibly</span><span class="id"> G</span><span class="id"> M</span><span class="id"> to</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">acts_irreducibly</span> (<span class="id">G</span><span class="id"> /</span><span class="id"> 'C_G</span>(<span class="id">M</span><span class="id"> |</span><span class="id"> to</span>))<span class="id"> M</span> (<span class="id">mod_groupAction</span><span class="id"> _</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> irrG;</span><span class="id"> have</span><span class="id"> /andP[_</span><span class="id"> nMG]</span><span class="id"> :=</span><span class="id"> mingroupp</span><span class="id"> irrG</span>.<br/>
<span class="id">apply:</span><span class="id"> acts_irr_mod</span><span class="id"> irrG;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subsetIr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normsI</span><span class="id"> ?normG</span><span class="id"> //</span> (<span class="id">subset_trans</span><span class="id"> nMG</span>)<span class="id"> //</span><span class="id"> astab_norm</span>.<br/>
Qed.</div></details>
&nbsp;&nbsp;<br/>
<span class="vernacular">Section</span><span class="id"> CompAct</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> G</span><span class="id"> &gt;-&gt;</span><span class="id"> aT}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> comp_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> R</span> (<span class="id">comp_action</span><span class="id"> to</span><span class="id"> f</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> /morphpreP[Ba</span><span class="id"> Dfa];</span><span class="id"> apply:</span><span class="id"> etrans</span> (<span class="id">actperm_Aut</span><span class="id"> to</span><span class="id"> Dfa</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> \in</span><span class="id"> Aut</span><span class="id"> R</span>)<span class="id">;</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !actpermE</span>.<br/>
Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> comp_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> comp_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacent_comp</span><span class="id"> U</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|comp_groupAction</span>)(<span class="id">U</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">f</span><span class="id"> @*</span><span class="id"> U</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /gacent</span><span class="id"> afix_comp</span><span class="id"> ?subIset</span><span class="id"> ?subxx</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setIC</span><span class="id"> U</span>) (<span class="id">setIC</span><span class="id"> D</span>)<span class="id"> morphim_setIpre</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> CompAct</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> GroupActionTheory</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( | to ) ( A )&quot;</span><span class="id"> :=</span> (<span class="id">gacent_group</span><span class="id"> to</span><span class="id"> A</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( G | to ) ( A )&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">setI_group</span><span class="id"> G</span><span class="id"> 'C_</span>(<span class="id">|to</span>)(<span class="id">A</span>))<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( | to ) [ a ]&quot;</span><span class="id"> :=</span> (<span class="id">gacent_group</span><span class="id"> to</span><span class="id"> [set</span><span class="id"> a%g]</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''C_' ( G | to ) [ a ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">setI_group</span><span class="id"> G</span><span class="id"> 'C_</span>(<span class="id">|to</span>)<span class="id">[a]</span>)<span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to \ sAD&quot;</span><span class="id"> :=</span> (<span class="id">ract_groupAction</span><span class="id"> to</span><span class="id"> sAD</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;&lt;[ nGA ] &gt;&quot;</span><span class="id"> :=</span> (<span class="id">actby_groupAction</span><span class="id"> nGA</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to / H&quot;</span><span class="id"> :=</span> (<span class="id">quotient_groupAction</span><span class="id"> to</span><span class="id"> H</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to %% H&quot;</span><span class="id"> :=</span> (<span class="id">mod_groupAction</span><span class="id"> to</span><span class="id"> H</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;to \o f&quot;</span><span class="id"> :=</span> (<span class="id">comp_groupAction</span><span class="id"> to</span><span class="id"> f</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MorphAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT1</span><span class="id"> aT2</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">rT1</span><span class="id"> rT2</span><span class="id"> :</span><span class="id"> finType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">D1</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT1}</span>) (<span class="id">D2</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT2}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">to1</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D1</span><span class="id"> rT1</span>) (<span class="id">to2</span><span class="id"> :</span><span class="id"> action</span><span class="id"> D2</span><span class="id"> rT2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT1}</span>) (<span class="id">R</span><span class="id"> S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT1}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> rT1</span><span class="id"> -&gt;</span><span class="id"> rT2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> D1</span><span class="id"> &gt;-&gt;</span><span class="id"> aT2}</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">actsDR</span><span class="id"> :</span><span class="id"> {acts</span><span class="id"> D1,</span><span class="id"> on</span><span class="id"> R</span><span class="id"> |</span><span class="id"> to1}</span>) (<span class="id">injh</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> R</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> h}</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> defD2</span><span class="id"> :</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> D1</span><span class="id"> =</span><span class="id"> D2</span>.<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">sSR</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R</span>) (<span class="id">sAD1</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D1</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> hfJ</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> D1,</span><span class="id"> morph_act</span><span class="id"> to1</span><span class="id"> to2</span><span class="id"> h</span><span class="id"> f}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_astabs</span><span class="id"> :</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to1</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">h</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> fx;</span><span class="id"> apply/morphimP/idP=&gt;</span><span class="id"> [[x</span><span class="id"> D1x</span><span class="id"> nSx</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> nSx]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2!inE</span><span class="id"> -{1}defD2</span><span class="id"> mem_morphim</span><span class="id"> //=;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[u</span><span class="id"> Su</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -hfJ</span><span class="id"> ?imset_f</span><span class="id"> //</span> (<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nSx</span>).<br/>
<span class="id">have</span><span class="id"> [|x</span><span class="id"> D1x</span><span class="id"> _</span><span class="id"> def_fx]</span><span class="id"> :=</span><span class="id"> morphimP</span> (_<span class="id"> :</span><span class="id"> fx</span><span class="id"> \in</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> D1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defD2</span> (<span class="id">astabs_dom</span><span class="id"> nSx</span>).<br/>
<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> D1x;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> u</span><span class="id"> Su</span>.<br/>
<span class="id">have</span><span class="id"> /imsetP[u'</span><span class="id"> Su'</span><span class="id"> /injh</span><span class="id"> def_u']:</span><span class="id"> h</span> (<span class="id">to1</span><span class="id"> u</span><span class="id"> x</span>)<span class="id"> \in</span><span class="id"> h</span><span class="id"> @:</span><span class="id"> S</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> hfJ</span><span class="id"> //</span><span class="id"> -def_fx</span> (<span class="id">astabs_act</span><span class="id"> _</span><span class="id"> nSx</span>)<span class="id"> imset_f</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> def_u'</span><span class="id"> ?actsDR</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sSR</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_astab</span><span class="id"> :</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to1</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">h</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> fx;</span><span class="id"> apply/morphimP/idP=&gt;</span><span class="id"> [[x</span><span class="id"> D1x</span><span class="id"> cSx</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> cSx]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2!inE</span><span class="id"> -{1}defD2</span><span class="id"> mem_morphim</span><span class="id"> //=;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[u</span><span class="id"> Su</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -hfJ</span><span class="id"> //</span> (<span class="id">astab_act</span><span class="id"> cSx</span>).<br/>
<span class="id">have</span><span class="id"> [|x</span><span class="id"> D1x</span><span class="id"> _</span><span class="id"> def_fx]</span><span class="id"> :=</span><span class="id"> morphimP</span> (_<span class="id"> :</span><span class="id"> fx</span><span class="id"> \in</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> D1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defD2</span> (<span class="id">astab_dom</span><span class="id"> cSx</span>).<br/>
<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> D1x;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> u</span><span class="id"> Su</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> -</span>(<span class="id">inj_in_eq</span><span class="id"> injh</span>)<span class="id"> ?actsDR</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sSR</span>)<span class="id"> ?hfJ</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def_fx</span> (<span class="id">astab_act</span><span class="id"> cSx</span>)<span class="id"> ?imset_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_afix</span><span class="id"> :</span><span class="id"> h</span><span class="id"> @:</span><span class="id"> 'Fix_</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to1</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'Fix_</span>(<span class="id">h</span><span class="id"> @:</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to2</span>)(<span class="id">f</span><span class="id"> @*</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> hu;</span><span class="id"> apply/imsetP/setIP=&gt;</span><span class="id"> [[u</span><span class="id"> /setIP[Su</span><span class="id"> cAu]</span><span class="id"> -&gt;]|]</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> imset_f</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/afixP=&gt;</span><span class="id"> _</span><span class="id"> /morphimP[x</span><span class="id"> D1x</span><span class="id"> Ax</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> -hfJ</span><span class="id"> ?</span>(<span class="id">afixP</span><span class="id"> cAu</span>).<br/>
<span class="id">case=&gt;</span><span class="id"> /imsetP[u</span><span class="id"> Su</span><span class="id"> -&gt;]</span><span class="id"> /afixP</span><span class="id"> c_hu_fA;</span><span class="gallina-kwd"> exists</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> Su</span>.<br/>
<span class="id">apply/afixP=&gt;</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> have</span><span class="id"> Dx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sAD1</span><span class="id"> x</span><span class="id"> Ax</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> injh;</span><span class="id"> rewrite</span><span class="id"> ?actsDR</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sSR</span>)<span class="id"> ?hfJ</span><span class="id"> //</span><span class="id"> c_hu_fA</span><span class="id"> ?mem_morphim</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MorphAction</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MorphGroupAction</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT1</span><span class="id"> aT2</span><span class="id"> rT1</span><span class="id"> rT2</span><span class="id"> :</span><span class="id"> finGroupType</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">D1</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT1}</span>) (<span class="id">D2</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> aT2}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">R1</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT1}</span>) (<span class="id">R2</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT2}</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">to1</span><span class="id"> :</span><span class="id"> groupAction</span><span class="id"> D1</span><span class="id"> R1</span>) (<span class="id">to2</span><span class="id"> :</span><span class="id"> groupAction</span><span class="id"> D2</span><span class="id"> R2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">h</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> R1</span><span class="id"> &gt;-&gt;</span><span class="id"> rT2}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> D1</span><span class="id"> &gt;-&gt;</span><span class="id"> aT2}</span>).<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">iso_h</span><span class="id"> :</span><span class="id"> isom</span><span class="id"> R1</span><span class="id"> R2</span><span class="id"> h</span>) (<span class="id">iso_f</span><span class="id"> :</span><span class="id"> isom</span><span class="id"> D1</span><span class="id"> D2</span><span class="id"> f</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> hfJ</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> R1</span><span class="id"> &amp;</span><span class="id"> D1,</span><span class="id"> morph_act</span><span class="id"> to1</span><span class="id"> to2</span><span class="id"> h</span><span class="id"> f}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> aT1}</span>) (<span class="id">S</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> rT1}</span>) (<span class="id">M</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> rT1}</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_gastabs</span><span class="id"> S</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R1</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> 'N</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to1</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">h</span><span class="id"> @*</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [[_</span><span class="id"> defD2]</span><span class="id"> [injh</span><span class="id"> _]]</span><span class="id"> :=</span> (<span class="id">isomP</span><span class="id"> iso_f,</span><span class="id"> isomP</span><span class="id"> iso_h</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> sSR1;</span><span class="id"> rewrite</span> (<span class="id">morphimEsub</span><span class="id"> _</span><span class="id"> sSR1</span>).<br/>
<span class="id">apply:</span> (<span class="id">morph_astabs</span> (<span class="id">gact_stable</span><span class="id"> to1</span>) (<span class="id">injmP</span><span class="id"> injh</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> u</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">subsetP</span><span class="id"> sSR1</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> hfJ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_gastab</span><span class="id"> S</span><span class="id"> :</span><span class="id"> S</span><span class="id"> \subset</span><span class="id"> R1</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> 'C</span>(<span class="id">S</span><span class="id"> |</span><span class="id"> to1</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">h</span><span class="id"> @*</span><span class="id"> S</span><span class="id"> |</span><span class="id"> to2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [[_</span><span class="id"> defD2]</span><span class="id"> [injh</span><span class="id"> _]]</span><span class="id"> :=</span> (<span class="id">isomP</span><span class="id"> iso_f,</span><span class="id"> isomP</span><span class="id"> iso_h</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> sSR1;</span><span class="id"> rewrite</span> (<span class="id">morphimEsub</span><span class="id"> _</span><span class="id"> sSR1</span>).<br/>
<span class="id">apply:</span> (<span class="id">morph_astab</span> (<span class="id">gact_stable</span><span class="id"> to1</span>) (<span class="id">injmP</span><span class="id"> injh</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> u</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">subsetP</span><span class="id"> sSR1</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> hfJ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_gacent</span><span class="id"> A</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> D1</span><span class="id"> -&gt;</span><span class="id"> h</span><span class="id"> @*</span><span class="id"> 'C_</span>(<span class="id">|to1</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'C_</span>(<span class="id">|to2</span>)(<span class="id">f</span><span class="id"> @*</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [[_</span><span class="id"> defD2]</span><span class="id"> [injh</span><span class="id"> defR2]]</span><span class="id"> :=</span> (<span class="id">isomP</span><span class="id"> iso_f,</span><span class="id"> isomP</span><span class="id"> iso_h</span>).<br/>
<span class="id">move=&gt;</span><span class="id"> sAD1;</span><span class="id"> rewrite</span><span class="id"> !gacentE</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defD2</span><span class="id"> morphimS</span>.<br/>
<span class="id">rewrite</span><span class="id"> morphimEsub</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> -{1}defR2</span><span class="id"> morphimEdom</span>.<br/>
<span class="id">exact:</span> (<span class="id">morph_afix</span> (<span class="id">gact_stable</span><span class="id"> to1</span>) (<span class="id">injmP</span><span class="id"> injh</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> morph_gact_irr</span><span class="id"> A</span><span class="id"> M</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> D1</span><span class="id"> -&gt;</span><span class="id"> M</span><span class="id"> \subset</span><span class="id"> R1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">acts_irreducibly</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> A</span>) (<span class="id">h</span><span class="id"> @*</span><span class="id"> M</span>)<span class="id"> to2</span><span class="id"> =</span><span class="id"> acts_irreducibly</span><span class="id"> A</span><span class="id"> M</span><span class="id"> to1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sAD1</span><span class="id"> sMR1</span>.<br/>
<span class="id">have</span><span class="id"> [[injf</span><span class="id"> defD2]</span><span class="id"> [injh</span><span class="id"> defR2]]</span><span class="id"> :=</span> (<span class="id">isomP</span><span class="id"> iso_f,</span><span class="id"> isomP</span><span class="id"> iso_h</span>).<br/>
<span class="id">have</span><span class="id"> h_eq1</span><span class="id"> :=</span><span class="id"> morphim_injm_eq1</span><span class="id"> injh</span>.<br/>
<span class="id">apply/mingroupP/mingroupP=&gt;</span><span class="id"> []</span><span class="id"> [/andP[ntM</span><span class="id"> actAM]</span><span class="id"> minM]</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [|U];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -h_eq1</span><span class="id"> //</span><span class="id"> ntM</span><span class="id"> -</span>(<span class="id">injmSK</span><span class="id"> injf</span>)<span class="id"> ?morph_gastabs</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP=&gt;</span><span class="id"> ntU</span><span class="id"> acts_fAU</span><span class="id"> sUM;</span><span class="id"> have</span><span class="id"> sUR1</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sUM</span><span class="id"> sMR1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">injm_morphim_inj</span><span class="id"> injh</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> minM;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> morphimS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> h_eq1</span><span class="id"> //</span><span class="id"> ntU</span><span class="id"> -morph_gastabs</span><span class="id"> ?morphimS</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> [|U];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> h_eq1</span><span class="id"> //</span><span class="id"> ntM</span><span class="id"> -morph_gastabs</span><span class="id"> ?morphimS</span>.<br/>
<span class="id">case/andP=&gt;</span><span class="id"> ntU</span><span class="id"> acts_fAU</span><span class="id"> sUhM</span>.<br/>
<span class="id">have</span><span class="id"> sUhR1</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sUhM</span> (<span class="id">morphimS</span><span class="id"> h</span><span class="id"> sMR1</span>).<br/>
<span class="id">have</span><span class="id"> sU'M:</span><span class="id"> h</span><span class="id"> @*^-1</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sub_morphpre_injm</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -</span>(<span class="id">minM</span><span class="id"> _</span><span class="id"> _</span><span class="id"> sU'M</span>)<span class="id"> ?morphpreK</span><span class="id"> //</span><span class="id"> -h_eq1</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">injmSK</span><span class="id"> injf</span>)<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> morph_gastabs</span><span class="id"> ?</span>(<span class="id">subset_trans</span><span class="id"> sU'M</span>)<span class="id"> //</span><span class="id"> morphpreK</span><span class="id"> ?ntU</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MorphGroupAction</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> InternalActionDefs</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> gT</span><span class="id"> :</span><span class="id"> finGroupType</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mulgr_action</span><span class="id"> :=</span><span class="id"> TotalAction</span> (<span class="id">@mulg1</span><span class="id"> gT</span>) (<span class="id">@mulgA</span><span class="id"> gT</span>).<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> conjg_action</span><span class="id"> :=</span><span class="id"> TotalAction</span> (<span class="id">@conjg1</span><span class="id"> gT</span>) (<span class="id">@conjgM</span><span class="id"> gT</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> conjg_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> setT</span><span class="id"> conjg_action</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> apply/andP;</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> x</span><span class="id"> /[1!inE]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/morphicP=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> !actpermE</span><span class="id"> /=</span><span class="id"> conjMg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> conjg_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> conjg_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcoset_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> setT</span> (<span class="id">@rcoset</span><span class="id"> gT</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> is_total_action</span><span class="id"> =&gt;</span><span class="id"> [A|A</span><span class="id"> x</span><span class="id"> y];</span><span class="id"> rewrite</span><span class="id"> !rcosetE</span> (<span class="id">mulg1,</span><span class="id"> rcosetM</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Canonical</span><span class="id"> rcoset_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> rcoset_is_action</span>.<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> conjsg_action</span><span class="id"> :=</span><span class="id"> TotalAction</span> (<span class="id">@conjsg1</span><span class="id"> gT</span>) (<span class="id">@conjsgM</span><span class="id"> gT</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> conjG_is_action</span><span class="id"> :</span><span class="id"> is_action</span><span class="id"> setT</span> (<span class="id">@conjG_group</span><span class="id"> gT</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span><span class="id"> is_total_action</span><span class="id"> =&gt;</span><span class="id"> [G</span><span class="id"> |</span><span class="id"> G</span><span class="id"> x</span><span class="id"> y];</span><span class="id"> apply:</span><span class="id"> val_inj;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?act1</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> actM</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> conjG_action</span><span class="id"> :=</span><span class="id"> Action</span><span class="id"> conjG_is_action</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> InternalActionDefs</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'R&quot;</span><span class="id"> :=</span> (<span class="id">@mulgr_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'Rs&quot;</span><span class="id"> :=</span> (<span class="id">@rcoset_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'J&quot;</span><span class="id"> :=</span> (<span class="id">@conjg_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'J&quot;</span><span class="id"> :=</span> (<span class="id">@conjg_groupAction</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'Js&quot;</span><span class="id"> :=</span> (<span class="id">@conjsg_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'JG&quot;</span><span class="id"> :=</span> (<span class="id">@conjG_action</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'Q&quot;</span><span class="id"> :=</span> (<span class="id">'J</span><span class="id"> /</span><span class="id"> _</span>)<span class="id">%act</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'Q&quot;</span><span class="id"> :=</span> (<span class="id">'J</span><span class="id"> /</span><span class="id"> _</span>)<span class="id">%gact</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 8</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> InternalGroupAction</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> gT</span><span class="id"> :</span><span class="id"> finGroupType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> A</span><span class="id"> B</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> x</span><span class="id"> :</span><span class="id"> gT</span>.<br/>
<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitR</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'R</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> x</span><span class="id"> *:</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -lcosetE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1R</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'C[x</span><span class="id"> |</span><span class="id"> 'R]</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/trivgP/subsetP=&gt;</span><span class="id"> y</span><span class="id"> cxy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mulKg</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> [x</span><span class="id"> *</span><span class="id"> y]</span>(<span class="id">astab1P</span><span class="id"> cxy</span>)<span class="id"> mulVg</span><span class="id"> set11</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabR</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">G</span><span class="id"> |</span><span class="id"> 'R</span>)<span class="id"> =</span><span class="id"> 1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/trivgP/subsetP=&gt;</span><span class="id"> x</span><span class="id"> cGx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mul1g</span><span class="id"> x</span>)<span class="id"> [1</span><span class="id"> *</span><span class="id"> x]</span>(<span class="id">astabP</span><span class="id"> cGx</span>)<span class="id"> group1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsR</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">G</span><span class="id"> |</span><span class="id"> 'R</span>)<span class="id"> =</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -setactVin</span><span class="id"> ?inE</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -groupV</span><span class="id"> -{1</span><span class="id"> 3}</span>(<span class="id">mulg1</span><span class="id"> G</span>)<span class="id"> rcoset_sym</span><span class="id"> -sub1set</span><span class="id"> -mulGS</span><span class="id"> -!rcosetE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> atransR</span><span class="id"> G</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> G</span><span class="id"> |</span><span class="id"> 'R]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /atrans</span><span class="id"> -{1}</span>(<span class="id">mul1g</span><span class="id"> G</span>)<span class="id"> -orbitR</span><span class="id"> imset_f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> faithfulR</span><span class="id"> G</span><span class="id"> :</span><span class="id"> [faithful</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> G</span><span class="id"> |</span><span class="id"> 'R]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /faithful</span><span class="id"> astabR</span><span class="id"> subsetIr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> Cayley_repr</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> actperm</span><span class="id"> &lt;[atrans_acts</span> (<span class="id">atransR</span><span class="id"> G</span>)<span class="id">]&gt;</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Cayley_isom</span><span class="id"> G</span><span class="id"> :</span><span class="id"> isom</span><span class="id"> G</span> (<span class="id">Cayley_repr</span><span class="id"> G</span><span class="id"> @*</span><span class="id"> G</span>) (<span class="id">Cayley_repr</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> faithful_isom</span> (<span class="id">faithfulR</span><span class="id"> G</span>). Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Cayley_isog</span><span class="id"> G</span><span class="id"> :</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> Cayley_repr</span><span class="id"> G</span><span class="id"> @*</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> isom_isog</span> (<span class="id">Cayley_isom</span><span class="id"> G</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitJ</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'J</span><span class="id"> G</span><span class="id"> x</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^:</span><span class="id"> G</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixJ</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'Fix_</span>(<span class="id">'J</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> apply/afixP/centP=&gt;</span><span class="id"> cAx</span><span class="id"> y</span><span class="id"> Ay</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /commute</span><span class="id"> conjgC</span><span class="id"> cAx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgE</span><span class="id"> cAx</span><span class="id"> ?mulKg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabJ</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">A</span><span class="id"> |'J</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> apply/astabP/centP=&gt;</span><span class="id"> cAx</span><span class="id"> y</span><span class="id"> Ay</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> esym;</span><span class="id"> rewrite</span><span class="id"> conjgC</span><span class="id"> cAx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgE</span><span class="id"> -cAx</span><span class="id"> ?mulKg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1J</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'C[x</span><span class="id"> |'J]</span><span class="id"> =</span><span class="id"> 'C[x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabJ</span><span class="id"> cent_set1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsJ</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'N</span>(<span class="id">A</span><span class="id"> |</span><span class="id"> 'J</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -2!groupV</span><span class="id"> !inE</span><span class="id"> -conjg_preim</span><span class="id"> -sub_conjg</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> setactJ</span><span class="id"> A</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'J^*%act</span><span class="id"> A</span><span class="id"> x</span><span class="id"> =</span><span class="id"> A</span><span class="id"> :^</span><span class="id"> x</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentJ</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'C_</span>(<span class="id">|'J</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> gacentE</span><span class="id"> ?setTI</span><span class="id"> ?subsetT</span><span class="id"> ?afixJ</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitRs</span><span class="id"> G</span><span class="id"> A</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'Rs</span><span class="id"> G</span><span class="id"> A</span><span class="id"> =</span><span class="id"> rcosets</span><span class="id"> A</span><span class="id"> G</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_afixRs_norms</span><span class="id"> G</span><span class="id"> x</span><span class="id"> A</span><span class="id"> :</span> (<span class="id">G</span><span class="id"> :*</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> 'Fix_</span>(<span class="id">'Rs</span>)(<span class="id">A</span>))<span class="id"> =</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> :^</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /=;</span><span class="id"> apply:</span><span class="id"> eq_subset_r</span><span class="id"> =&gt;</span><span class="id"> a</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> rcosetE</span><span class="id"> -</span>(<span class="id">can2_eq</span> (<span class="id">rcosetKV</span><span class="id"> x</span>) (<span class="id">rcosetK</span><span class="id"> x</span>))<span class="id"> -!rcosetM</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqEcard</span><span class="id"> card_rcoset</span><span class="id"> leqnn</span><span class="id"> andbT</span><span class="id"> mulgA</span> (<span class="id">conjgCV</span><span class="id"> x</span>)<span class="id"> mulgK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2</span><span class="id"> 3}</span>(<span class="id">mulGid</span><span class="id"> G</span>)<span class="id"> mulGS</span><span class="id"> sub1set</span><span class="id"> -mem_conjg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_afixRs_norm</span><span class="id"> G</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">G</span><span class="id"> :*</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> 'Fix_</span>(<span class="id">'Rs</span>)(<span class="id">G</span>))<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">G</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sub_afixRs_norms</span><span class="id"> -groupV</span><span class="id"> inE</span><span class="id"> sub_conjgV</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixRs_rcosets</span><span class="id"> A</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'Fix_</span>(<span class="id">rcosets</span><span class="id"> G</span><span class="id"> A</span><span class="id"> |</span><span class="id"> 'Rs</span>)(<span class="id">G</span>)<span class="id"> =</span><span class="id"> rcosets</span><span class="id"> G</span><span class="id"> 'N_A</span>(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> Gx;</span><span class="id"> apply/setIP/rcosetsP=&gt;</span><span class="id"> [[/rcosetsP[x</span><span class="id"> Ax</span><span class="id"> -&gt;]]|[x]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sub_afixRs_norm</span><span class="id"> =&gt;</span><span class="id"> Nx;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> Ax</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/setIP=&gt;</span><span class="id"> Ax</span><span class="id"> Nx</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -{1}rcosetE</span><span class="id"> imset_f</span><span class="id"> //</span><span class="id"> sub_afixRs_norm</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1Rs</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'C[G</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span><span class="id"> |</span><span class="id"> 'Rs]</span><span class="id"> =</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/astab1P/idP=&gt;</span><span class="id"> /=</span><span class="id"> [&lt;-</span><span class="id"> |</span><span class="id"> Gx];</span><span class="id"> rewrite</span><span class="id"> rcosetE</span><span class="id"> ?rcoset_refl</span><span class="id"> ?rcoset_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsRs_rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> :</span><span class="id"> [acts</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> |</span><span class="id"> 'Rs]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orbitRs</span><span class="id"> acts_orbit</span><span class="id"> ?subsetT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> transRs_rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> G,</span><span class="id"> on</span><span class="id"> rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> |</span><span class="id"> 'Rs]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orbitRs</span><span class="id"> atrans_orbit</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabRs_rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">rcosets</span><span class="id"> H</span><span class="id"> G</span><span class="id"> |</span><span class="id"> 'Rs</span>)<span class="id"> =</span><span class="id"> gcore</span><span class="id"> H</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> transGH</span><span class="id"> :=</span><span class="id"> transRs_rcosets</span><span class="id"> H</span><span class="id"> G</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">astab_trans_gcore</span><span class="id"> transGH</span> (<span class="id">orbit_refl</span><span class="id"> _</span><span class="id"> G</span><span class="id"> _</span>))<span class="id"> astab1Rs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> orbitJs</span><span class="id"> G</span><span class="id"> A</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'Js</span><span class="id"> G</span><span class="id"> A</span><span class="id"> =</span><span class="id"> A</span><span class="id"> :^:</span><span class="id"> G</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1Js</span><span class="id"> A</span><span class="id"> :</span><span class="id"> 'C[A</span><span class="id"> |</span><span class="id"> 'Js]</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> apply/astab1P/normP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_conjugates</span><span class="id"> A</span><span class="id"> G</span><span class="id"> :</span><span class="id"> #|A</span><span class="id"> :^:</span><span class="id"> G|</span><span class="id"> =</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'N_G</span>(<span class="id">A</span>)<span class="id">|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_orbit</span><span class="id"> astab1Js</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> afixJG</span><span class="id"> G</span><span class="id"> A</span><span class="id"> :</span> (<span class="id">G</span><span class="id"> \in</span><span class="id"> 'Fix_</span>(<span class="id">'JG</span>)(<span class="id">A</span>))<span class="id"> =</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">G</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/afixP/normsP=&gt;</span><span class="id"> nG</span><span class="id"> x</span><span class="id"> Ax;</span><span class="id"> apply/eqP;</span><span class="id"> move/eqP:</span> (<span class="id">nG</span><span class="id"> x</span><span class="id"> Ax</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astab1JG</span><span class="id"> G</span><span class="id"> :</span><span class="id"> 'C[G</span><span class="id"> |</span><span class="id"> 'JG]</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> apply/astab1P/normP=&gt;</span><span class="id"> [/congr_group</span><span class="id"> |</span><span class="id"> /group_inj]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dom_qactJ</span><span class="id"> H</span><span class="id"> :</span><span class="id"> qact_dom</span><span class="id"> 'J</span><span class="id"> H</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> qact_domE</span><span class="id"> ?subsetT</span><span class="id"> ?astabsJ</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> qactJ</span><span class="id"> H</span> (<span class="id">Hy</span><span class="id"> :</span><span class="id"> coset_of</span><span class="id"> H</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">'Q%act</span><span class="id"> Hy</span><span class="id"> x</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="gallina-kwd"> then</span><span class="id"> Hy</span><span class="id"> ^</span><span class="id"> coset</span><span class="id"> H</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> Hy</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span> (<span class="id">cosetP</span><span class="id"> Hy</span>)<span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> Ny</span><span class="id"> -&gt;{Hy}</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> qactEcond</span><span class="id"> //</span><span class="id"> dom_qactJ;</span><span class="id"> case</span><span class="id"> Nx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?morphJ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> actsQ</span><span class="id"> A</span><span class="id"> B</span><span class="id"> H</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">B</span>)<span class="id"> -&gt;</span><span class="id"> [acts</span><span class="id"> A,</span><span class="id"> on</span><span class="id"> B</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nHA</span><span class="id"> nBA;</span><span class="id"> rewrite</span><span class="id"> acts_quotient</span><span class="id"> //</span><span class="id"> subsetI</span><span class="id"> dom_qactJ</span><span class="id"> nHA</span><span class="id"> astabsJ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabsQ</span><span class="id"> G</span><span class="id"> H</span><span class="id"> :</span><span class="id"> H</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> 'N</span>(<span class="id">G</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q</span>)<span class="id"> =</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> :&amp;:</span><span class="id"> 'N</span>(<span class="id">G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> nsHG;</span><span class="id"> rewrite</span><span class="id"> astabs_quotient</span><span class="id"> //</span><span class="id"> dom_qactJ</span><span class="id"> astabsJ</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabQ</span><span class="id"> H</span><span class="id"> Abar</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">Abar</span><span class="id"> |'Q</span>)<span class="id"> =</span><span class="id"> coset</span><span class="id"> H</span><span class="id"> @*^-1</span><span class="id"> 'C</span>(<span class="id">Abar</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> dom_qactJ</span><span class="id"> morphpreE</span><span class="id"> in_setI</span><span class="id"> /=</span>.<br/>
<span class="id">apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> Nx;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -sub1set</span><span class="id"> centsC</span><span class="id"> cent_set1</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_subset_r</span><span class="id"> =&gt;</span><span class="id"> {Abar}</span><span class="id"> Hy;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> qactJ</span><span class="id"> Nx</span> (<span class="id">sameP</span><span class="id"> eqP</span><span class="id"> conjg_fixP</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">sameP</span><span class="id"> cent1P</span><span class="id"> eqP</span>) (<span class="id">sameP</span><span class="id"> commgP</span><span class="id"> eqP</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_astabQ</span><span class="id"> A</span><span class="id"> H</span><span class="id"> Bbar</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">Bbar</span><span class="id"> |</span><span class="id"> 'Q</span>))<span class="id"> =</span> (<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>))<span class="id"> &amp;&amp;</span> (<span class="id">A</span><span class="id"> /</span><span class="id"> H</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">Bbar</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> astabQ</span><span class="id"> -morphpreIdom</span><span class="id"> subsetI;</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> nHA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -sub_quotient_pre</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_astabQR</span><span class="id"> A</span><span class="id"> B</span><span class="id"> H</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> B</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">A</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">B</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q</span>))<span class="id"> =</span> (<span class="id">[~:</span><span class="id"> A,</span><span class="id"> B]</span><span class="id"> \subset</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nHA</span><span class="id"> nHB;</span><span class="id"> rewrite</span><span class="id"> sub_astabQ</span><span class="id"> nHA</span><span class="id"> /=</span> (<span class="id">sameP</span><span class="id"> commG1P</span><span class="id"> eqP</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> sub1G</span><span class="id"> andbT</span><span class="id"> -quotientR</span><span class="id"> //</span><span class="id"> quotient_sub1</span><span class="id"> //</span><span class="id"> comm_subG</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> astabQR</span><span class="id"> A</span><span class="id"> H</span><span class="id"> :</span><span class="id"> A</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">'C</span>(<span class="id">A</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q</span>)<span class="id"> =</span><span class="id"> [set</span><span class="id"> x</span><span class="gallina-kwd"> in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> |</span><span class="id"> [~:</span><span class="id"> [set</span><span class="id"> x],</span><span class="id"> A]</span><span class="id"> \subset</span><span class="id"> H]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nHA;</span><span class="id"> apply/setP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> astabQ</span><span class="id"> -morphpreIdom</span><span class="id"> 2!inE</span><span class="id"> -astabQ</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> nHx:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> -sub1set</span><span class="id"> sub_astabQR</span><span class="id"> ?sub1set</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> quotient_astabQ</span><span class="id"> H</span><span class="id"> Abar</span><span class="id"> :</span><span class="id"> 'C</span>(<span class="id">Abar</span><span class="id"> |</span><span class="id"> 'Q</span>)<span class="id"> /</span><span class="id"> H</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">Abar</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> astabQ</span><span class="id"> cosetpreK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> conj_astabQ</span><span class="id"> A</span><span class="id"> H</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="id"> -&gt;</span><span class="id"> 'C</span>(<span class="id">A</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q</span>)<span class="id"> :^</span><span class="id"> x</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">A</span><span class="id"> :^</span><span class="id"> x</span><span class="id"> /</span><span class="id"> H</span><span class="id"> |</span><span class="id"> 'Q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nHx;</span><span class="id"> apply/setP=&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> !astabQ</span><span class="id"> mem_conjg</span><span class="id"> !in_setI</span><span class="id"> -mem_conjg</span>.<br/>
<span class="id">rewrite</span><span class="id"> -normJ</span> (<span class="id">normP</span><span class="id"> nHx</span>)<span class="id"> quotientJ</span><span class="id"> //;</span><span class="id"> apply/andb_id2l</span><span class="id"> =&gt;</span><span class="id"> nHy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> centJ</span><span class="id"> morphJ</span><span class="id"> ?groupV</span><span class="id"> ?morphV</span><span class="id"> //</span><span class="id"> -mem_conjg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> CardClass</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_cent1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'C_G[x]|</span><span class="id"> =</span><span class="id"> #|x</span><span class="id"> ^:</span><span class="id"> G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -astab1J</span><span class="id"> -card_orbit</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> classes_partition</span><span class="id"> :</span><span class="id"> partition</span> (<span class="id">classes</span><span class="id"> G</span>)<span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> orbit_partition;</span><span class="id"> apply/actsP=&gt;</span><span class="id"> x</span><span class="id"> Gx</span><span class="id"> y;</span><span class="id"> apply:</span><span class="id"> groupJr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sum_card_class</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">C</span><span class="gallina-kwd"> in</span><span class="id"> classes</span><span class="id"> G</span>)<span class="id"> #|C|</span><span class="id"> =</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> acts_sum_card_orbit;</span><span class="id"> apply/actsP=&gt;</span><span class="id"> x</span><span class="id"> Gx</span><span class="id"> y;</span><span class="id"> apply:</span><span class="id"> groupJr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> class_formula</span><span class="id"> :</span><span class="id"> \sum_</span>(<span class="id">C</span><span class="gallina-kwd"> in</span><span class="id"> classes</span><span class="id"> G</span>)<span class="id"> #|G</span><span class="id"> :</span><span class="id"> 'C_G[repr</span><span class="id"> C]|</span><span class="id"> =</span><span class="id"> #|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -sum_card_class;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Gx</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">have:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> x</span><span class="id"> ^:</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">conjg1</span><span class="id"> x</span>)<span class="id"> imset_f</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/mem_repr/imsetP=&gt;</span><span class="id"> y</span><span class="id"> Gy</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> index_cent1</span><span class="id"> classGidl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> abelian_classP</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> x]}</span> (<span class="id">abelian</span><span class="id"> G</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /abelian</span><span class="id"> -astabJ</span><span class="id"> astabC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> subsetP</span>)<span class="id"> =&gt;</span><span class="id"> cGG</span><span class="id"> x</span><span class="id"> Gx;</span><span class="id"> apply/orbit1P;</span><span class="id"> apply:</span><span class="id"> cGG</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_classes_abelian</span><span class="id"> :</span><span class="id"> abelian</span><span class="id"> G</span><span class="id"> =</span> (<span class="id">#|classes</span><span class="id"> G|</span><span class="id"> ==</span><span class="id"> #|G|</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> cGgt0</span><span class="id"> C:</span><span class="id"> C</span><span class="id"> \in</span><span class="id"> classes</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> 1</span><span class="id"> &lt;=</span><span class="id"> #|C|</span><span class="id"> ?=</span><span class="id"> iff</span> (<span class="id">#|C|</span><span class="id"> ==</span><span class="id"> 1</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> -index_cent1</span>.<br/>
<span class="id">rewrite</span><span class="id"> -sum_card_class</span><span class="id"> -sum1_card</span> (<span class="id">leqif_sum</span><span class="id"> cGgt0</span>).<br/>
<span class="id">apply/abelian_classP/forall_inP=&gt;</span><span class="id"> [cGG</span><span class="id"> _</span><span class="id"> /imsetP[x</span><span class="id"> Gx</span><span class="id"> -&gt;]|</span><span class="id"> cGG</span><span class="id"> x</span><span class="id"> Gx]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cGG</span><span class="id"> ?cards1</span>.<br/>
<span class="id">apply/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> sub1set</span><span class="id"> cards1</span><span class="id"> class_refl</span><span class="id"> leq_eqVlt</span><span class="id"> cGG</span><span class="id"> //</span>.<br/>
<span class="id">exact:</span><span class="id"> imset_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> CardClass</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> InternalGroupAction</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> gacentQ</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">'C_</span>(<span class="id">|'Q</span>)(<span class="id">A</span>)<span class="id"> =</span><span class="id"> 'C</span>(<span class="id">A</span><span class="id"> /</span><span class="id"> H</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/setP=&gt;</span><span class="id"> Hx;</span><span class="id"> case:</span> (<span class="id">cosetP</span><span class="id"> Hx</span>)<span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> Nx</span><span class="id"> -&gt;{Hx}</span>.<br/>
<span class="id">rewrite</span><span class="id"> -sub_cent1</span><span class="id"> -astab1J</span><span class="id"> astabC</span><span class="id"> sub1set</span><span class="id"> -</span>(<span class="id">quotientInorm</span><span class="id"> H</span><span class="id"> A</span>).<br/>
<span class="id">have</span><span class="id"> defD:</span><span class="id"> qact_dom</span><span class="id"> 'J</span><span class="id"> H</span><span class="id"> =</span><span class="id"> 'N</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> qact_domE</span><span class="id"> ?subsetT</span><span class="id"> ?astabsJ</span>.<br/>
<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">inE,</span><span class="id"> mem_quotient</span>)<span class="id"> //=</span><span class="id"> defD</span><span class="id"> setIC</span>.<br/>
<span class="id">apply/subsetP/subsetP=&gt;</span><span class="id"> [cAx</span><span class="id"> _</span><span class="id"> /morphimP[a</span><span class="id"> Na</span><span class="id"> Aa</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> cAx</span><span class="id"> a</span><span class="id"> Aa]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/cAx:</span><span class="id"> Aa;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> qactE</span><span class="id"> ?defD</span><span class="id"> ?morphJ</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> Na]</span><span class="id"> :=</span><span class="id"> setIP</span><span class="id"> Aa;</span><span class="id"> move/implyP:</span> (<span class="id">cAx</span> (<span class="id">coset</span><span class="id"> H</span><span class="id"> a</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> mem_morphim</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> qactE</span><span class="id"> ?defD</span><span class="id"> ?morphJ</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> AutAct</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> autact</span><span class="id"> :=</span><span class="id"> act</span> (<span class="id">'P</span><span class="id"> \</span><span class="id"> subsetT</span> (<span class="id">Aut</span><span class="id"> G</span>)).<br/>
<span class="vernacular">Canonical</span><span class="id"> aut_action</span><span class="id"> :=</span><span class="id"> [action</span><span class="id"> of</span><span class="id"> autact]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> autactK</span><span class="id"> a</span><span class="id"> :</span><span class="id"> actperm</span><span class="id"> aut_action</span><span class="id"> a</span><span class="id"> =</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permP=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> permE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> autact_is_groupAction</span><span class="id"> :</span><span class="id"> is_groupAction</span><span class="id"> G</span><span class="id"> aut_action</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> autactK</span>. Qed.</div></details>
<span class="vernacular">Canonical</span><span class="id"> aut_groupAction</span><span class="id"> :=</span><span class="id"> GroupAction</span><span class="id"> autact_is_groupAction</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> perm_prime_orbit</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> finType</span>) (<span class="id">c</span><span class="id"> :</span><span class="id"> {perm</span><span class="id"> T}</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> Tp</span><span class="id"> :</span> <span class="id"> prime</span><span class="id"> #|T|</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> cc</span><span class="id"> :</span><span class="id"> #[c]%g</span><span class="id"> =</span><span class="id"> #|T|</span>.<br/>
<span class="vernacular">Let</span><span class="id"> cp</span><span class="id"> :</span><span class="id"> prime</span><span class="id"> #[c]%g</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cc</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_prime_atrans</span><span class="id"> :</span><span class="id"> [transitive</span><span class="id"> &lt;[c]&gt;,</span><span class="id"> on</span><span class="id"> setT</span><span class="id"> |</span><span class="id"> 'P]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/imsetP;</span><span class="id"> suff</span><span class="id"> /existsP[x]</span><span class="id"> :</span><span class="id"> [exists</span><span class="id"> x,</span><span class="id"> ~~</span> (<span class="id">#|orbit</span><span class="id"> 'P</span><span class="id"> &lt;[c]&gt;</span><span class="id"> x|</span><span class="id"> &lt;</span><span class="id"> #[c]</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> oxT;</span><span class="id"> suff</span><span class="id"> /eqP</span><span class="id"> orbit_x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'P</span><span class="id"> &lt;[c]&gt;</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> setT</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> subsetT</span><span class="id"> cardsT</span><span class="id"> -cc</span><span class="id"> leqNgt</span>.<br/>
<span class="id">apply/forallP</span><span class="id"> =&gt;</span><span class="id"> olT;</span><span class="id"> have</span><span class="id"> o1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> #|orbit</span><span class="id"> 'P</span><span class="id"> &lt;[c]&gt;</span><span class="id"> x|</span><span class="id"> ==</span><span class="id"> 1%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/primeP:</span><span class="id"> cp</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /</span>(_<span class="id"> _</span> (<span class="id">dvdn_orbit</span><span class="id"> 'P</span><span class="id"> _</span><span class="id"> x</span>))<span class="id">/orP[]//;</span><span class="id"> rewrite</span><span class="id"> ltn_eqF</span>.<br/>
<span class="id">suff</span><span class="id"> c1</span><span class="id"> :</span><span class="id"> c</span><span class="id"> =</span><span class="id"> 1%g</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> c1</span><span class="id"> ?order1</span><span class="gallina-kwd"> in</span> (<span class="id">cp</span>).<br/>
<span class="id">apply/permP</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> perm1;</span><span class="id"> apply/set1P</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_orbit1</span> (<span class="id">eqP</span> (<span class="id">o1</span><span class="id"> _</span>))) (<span class="id">mem_orbit</span><span class="id"> 'P</span>)<span class="id"> ?cycle_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_prime_orbit</span><span class="id"> x</span><span class="id"> :</span><span class="id"> orbit</span><span class="id"> 'P</span><span class="id"> &lt;[c]&gt;</span><span class="id"> x</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> T]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> atransP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> perm_prime_atrans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_prime_astab</span><span class="id"> x</span><span class="id"> :</span><span class="id"> 'C_&lt;[c]&gt;[x</span><span class="id"> |</span><span class="id"> 'P]%g</span><span class="id"> =</span><span class="id"> 1%g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/card1_trivg/eqP;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@eqn_pmul2l</span><span class="id"> #|orbit</span><span class="id"> 'P</span><span class="id"> &lt;[c]&gt;</span><span class="id"> x|</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">?card_orbit_stab</span><span class="id"> ?perm_prime_orbit</span><span class="id"> ?cardsT</span><span class="id"> ?muln1</span><span class="id"> ?prime_gt0//</span><span class="id"> -cc</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> perm_prime_orbit</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> AutAct</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> autact</span><span class="id"> {gT}</span><span class="id"> G%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> aut_action</span><span class="id"> {gT}</span><span class="id"> G%_g</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> aut_groupAction</span><span class="id"> {gT}</span><span class="id"> G%_g</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'Aut' G ]&quot;</span><span class="id"> :=</span> (<span class="id">aut_action</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> action_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'Aut' G ]&quot;</span><span class="id"> :=</span> (<span class="id">aut_groupAction</span><span class="id"> G</span>)<span class="id"> :</span><span class="id"> groupAction_scope</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
