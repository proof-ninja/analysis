
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.Stdlib.Reals.RiemannInt</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.Stdlib.Reals.RiemannInt" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.ssrnum.html">ssrnum</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
<li><a href="mathcomp.ssreflect.bigop.html">bigop</a></li>
<li><a href="mathcomp.ssreflect.binomial.html">binomial</a></li>
<li><a href="mathcomp.ssreflect.choice.html">choice</a></li>
<li><a href="mathcomp.ssreflect.div.html">div</a></li>
<li><a href="mathcomp.ssreflect.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.ssreflect.finfun.html">finfun</a></li>
<li><a href="mathcomp.ssreflect.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.ssreflect.finset.html">finset</a></li>
<li><a href="mathcomp.ssreflect.fintype.html">fintype</a></li>
<li><a href="mathcomp.ssreflect.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.ssreflect.order.html">order</a></li>
<li><a href="mathcomp.ssreflect.path.html">path</a></li>
<li><a href="mathcomp.ssreflect.prime.html">prime</a></li>
<li><a href="mathcomp.ssreflect.seq.html">seq</a></li>
<li><a href="mathcomp.ssreflect.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.ssreflect.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.ssreflect.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.ssreflect.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.ssreflect.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.ssreflect.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.ssreflect.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.ssreflect.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.Stdlib.Reals.RiemannInt</h1>
<pre class="ssrdoc">
        *      The Rocq Prover / The Rocq Development Team
 v      *         Copyright INRIA, CNRS and contributors
&lt;O___,, * (see version control and CREDITS file for authors &amp; dates)
  \VV/  *************************************************************
   //   *    This file is distributed under the terms of the
        *     GNU Lesser General Public License Version 2.1
        *     (see LICENSE file for the text of the license)
</pre>
<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> Rfunctions</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> SeqSeries</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> Ranalysis_reg</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> Rbase</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> RiemannInt_SF</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> RList</span>.<br/>
<span class="vernacular">From</span><span class="id"> Stdlib</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> Lra</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> R_scope</span>.<br/>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<br/>
<pre class="ssrdoc">
(**           Riemann's Integral
</pre>
<br/>
<span class="vernacular">Definition</span><span class="id"> Riemann_integrable</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>)<span class="id"> :</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> eps:posreal,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> phi:StepFun</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> psi:StepFun</span><span class="id"> a</span><span class="id"> b</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t:R,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> Rabs</span> (<span class="id">f</span><span class="id"> t</span><span class="id"> -</span><span class="id"> phi</span><span class="id"> t</span>)<span class="id"> &lt;=</span><span class="id"> psi</span><span class="id"> t</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi</span>)<span class="id"> &lt;</span><span class="id"> eps</span><span class="id"> }</span><span class="id"> }</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> phi_sequence</span> (<span class="id">un:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>) (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;(<span class="id">a</span><span class="id"> b:R</span>) (<span class="id">pr:Rie</span><span class="id"><a href="elpi.elpi.html">mann</a></span><span class="id">_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span>) (<span class="id">n:nat</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">projT1</span> (<span class="id">pr</span> (<span class="id">un</span><span class="id"> n</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> phi_sequence_prop</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">un:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>) (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>) (<span class="id">pr:Riemann_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">N:nat</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> psi:StepFun</span><span class="id"> a</span><span class="id"> b</span><span class="id"> |</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t:R,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">f</span><span class="id"> t</span><span class="id"> -</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr</span><span class="id"> N</span><span class="id"> t</span>)<span class="id"> &lt;=</span><span class="id"> psi</span><span class="id"> t</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi</span>)<span class="id"> &lt;</span><span class="id"> un</span><span class="id"> N</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> apply</span> (<span class="id">projT2</span> (<span class="id">pr</span> (<span class="id">un</span><span class="id"> N</span>))).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RiemannInt_P1</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Riemann_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> Riemann_integrable</span><span class="id"> f</span><span class="id"> b</span><span class="id"> a</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Riemann_integrable;</span><span class="id"> intros;</span><span class="id"> elim</span> (<span class="id">X</span><span class="id"> eps</span>)<span class="id">;</span><span class="id"> clear</span><span class="id"> X;</span><span class="id"> intros</span>.<br/>
&nbsp;&nbsp;<span class="id">elim</span><span class="id"> p;</span><span class="id"> clear</span><span class="id"> p;</span><span class="id"> intros</span><span class="id"> x0</span><span class="id"> p;</span><span class="gallina-kwd"> exists</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span><span class="id"> x</span>)))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span><span class="id"> x0</span>)))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span><span class="id"> p;</span><span class="id"> clear</span><span class="id"> p;</span><span class="id"> intros;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> intros;</span><span class="id"> apply</span> (<span class="id">H</span><span class="id"> t</span>)<span class="id">;</span><span class="id"> elim</span><span class="id"> H1;</span><span class="id"> clear</span><span class="id"> H1;</span><span class="id"> intros;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rmin</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> try</span><span class="id"> assumption;</span><span class="id"> right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Rmin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rmax</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> try</span><span class="id"> assumption;</span><span class="id"> right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Rmax</span><span class="id"> ];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">case</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="id">;</span><span class="id"> case</span> (<span class="id">Rle_dec</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">try</span><span class="id"> reflexivity</span><span class="id"> ||</span><span class="id"> apply</span><span class="id"> Rle_antisym;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> assumption</span><span class="id"> |</span><span class="id"> assumption</span><span class="id"> |</span><span class="id"> auto</span><span class="gallina-kwd"> with</span><span class="id"> real</span><span class="id"> |</span><span class="id"> auto</span><span class="gallina-kwd"> with</span><span class="id"> real</span><span class="id"> ]</span>).<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> generalize</span><span class="id"> H0;</span><span class="id"> unfold</span><span class="id"> RiemannInt_SF;</span><span class="id"> case</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case</span> (<span class="id">Rle_dec</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">replace</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int_SF</span> (<span class="id">subdivision_val</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span><span class="id"> x0</span>))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">subdivision</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span><span class="id"> x0</span>)))))<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int_SF</span> (<span class="id">subdivision_val</span><span class="id"> x0</span>) (<span class="id">subdivision</span><span class="id"> x0</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> StepFun_P17</span><span class="gallina-kwd"> with</span> (<span class="id">fe</span><span class="id"> x0</span>)<span class="id"> a</span><span class="id"> b;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> StepFun_P1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> StepFun_P2;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> (<span class="id">StepFun_P1</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span><span class="id"> x0</span>))))<span class="id"> ]</span><span class="id"> ]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply</span><span class="id"> H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> Rabs_Ropp;</span><span class="id"> apply</span><span class="id"> H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> rewrite</span><span class="id"> Rabs_Ropp</span><span class="gallina-kwd"> in</span><span class="id"> H1;</span><span class="id"> apply</span><span class="id"> H1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply</span><span class="id"> H1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RiemannInt_P2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>) (<span class="id">un:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>) (<span class="id">vn</span><span class="id"> wn:nat</span><span class="id"> -&gt;</span><span class="id"> StepFun</span><span class="id"> a</span><span class="id"> b</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span><span class="id"> un</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">a</span><span class="id"> &lt;=</span><span class="id"> b</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n:nat,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t:R,</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> Rabs</span> (<span class="id">f</span><span class="id"> t</span><span class="id"> -</span><span class="id"> vn</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> &lt;=</span><span class="id"> wn</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">wn</span><span class="id"> n</span>))<span class="id"> &lt;</span><span class="id"> un</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> l:R</span><span class="id"> |</span><span class="id"> Un_cv</span> (<span class="gallina-kwd">fun</span><span class="id"> N:nat</span><span class="id"> =&gt;</span><span class="id"> RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> N</span>))<span class="id"> l</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> apply</span><span class="id"> R_complete;</span><span class="id"> unfold</span><span class="id"> Un_cv</span><span class="gallina-kwd"> in</span><span class="id"> H;</span><span class="id"> unfold</span><span class="id"> Cauchy_crit;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> assert</span> (<span class="id">H3</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> eps</span><span class="id"> /</span><span class="id"> 2</span>)<span class="gallina-kwd"> by</span><span class="id"> lra</span>.<br/>
&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">H</span><span class="id"> _</span><span class="id"> H3</span>)<span class="id">;</span><span class="id"> intros</span><span class="id"> N0</span><span class="id"> H4;</span><span class="gallina-kwd"> exists</span><span class="id"> N0;</span><span class="id"> intros;</span><span class="id"> unfold</span><span class="id"> Rdist;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Rdist</span><span class="gallina-kwd"> in</span><span class="id"> H4;</span><span class="id"> elim</span> (<span class="id">H1</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> elim</span> (<span class="id">H1</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> n</span>)<span class="id"> -</span><span class="id"> RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> m</span>))<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> n</span>)<span class="id"> +</span><span class="id"> -1</span><span class="id"> *</span><span class="id"> RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> m</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> idtac</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ];</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> StepFun_P30;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span> (<span class="id">StepFun_P32</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P28</span> (<span class="id">-1</span>) (<span class="id">vn</span><span class="id"> n</span>) (<span class="id">vn</span><span class="id"> m</span>)))))).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P34;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P28</span><span class="id"> 1</span> (<span class="id">wn</span><span class="id"> n</span>) (<span class="id">wn</span><span class="id"> m</span>)))).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P37;</span><span class="id"> try</span><span class="id"> assumption</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> simpl;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">vn</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> +</span><span class="id"> Rabs</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> vn</span><span class="id"> m</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> replace</span> (<span class="id">vn</span><span class="id"> n</span><span class="id"> x</span><span class="id"> +</span><span class="id"> -1</span><span class="id"> *</span><span class="id"> vn</span><span class="id"> m</span><span class="id"> x</span>)<span class="gallina-kwd"> with</span> (<span class="id">vn</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span><span class="id"> +</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> vn</span><span class="id"> m</span><span class="id"> x</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rabs_triang</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H12</span><span class="id"> :</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmin;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> H0;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H13</span><span class="id"> :</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmax;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> H0;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-</span><span class="id"> H12</span><span class="gallina-kwd"> in</span><span class="id"> H11;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> H13</span><span class="gallina-kwd"> in</span><span class="id"> H11</span><span class="gallina-kwd"> at</span><span class="id"> 2;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Rmult_1_l;</span><span class="id"> apply</span><span class="id"> Rplus_le_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><span class="id"> rewrite</span><span class="id"> Ropp_minus_distr;</span><span class="id"> apply</span><span class="id"> H9</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span><span class="id"> H11;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> H7</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span><span class="id"> H11;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> StepFun_P30;</span><span class="id"> rewrite</span><span class="id"> Rmult_1_l;</span><span class="id"> apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">un</span><span class="id"> n</span><span class="id"> +</span><span class="id"> un</span><span class="id"> m</span>).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">wn</span><span class="id"> n</span>))<span class="id"> +</span><span class="id"> Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">wn</span><span class="id"> m</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rplus_le_compat;</span><span class="id"> apply</span><span class="id"> RRle_abs</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_lt_compat;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">un</span><span class="id"> n</span>)<span class="id"> +</span><span class="id"> Rabs</span> (<span class="id">un</span><span class="id"> m</span>)).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rplus_le_compat;</span><span class="id"> apply</span><span class="id"> RRle_abs</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span> (<span class="id">un</span><span class="id"> n</span><span class="id"> -</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> [</span><span class="id"> idtac</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> m</span>))<span class="gallina-kwd"> with</span> (<span class="id">un</span><span class="id"> m</span><span class="id"> -</span><span class="id"> 0</span>)<span class="id">;</span><span class="id"> [</span><span class="id"> idtac</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-</span>(<span class="id">Rplus_half_diag</span><span class="id"> eps</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> Rplus_lt_compat;</span><span class="id"> apply</span><span class="id"> H4;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RiemannInt_P3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>) (<span class="id">un:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>) (<span class="id">vn</span><span class="id"> wn:nat</span><span class="id"> -&gt;</span><span class="id"> StepFun</span><span class="id"> a</span><span class="id"> b</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span><span class="id"> un</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> n:nat,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t:R,</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> Rabs</span> (<span class="id">f</span><span class="id"> t</span><span class="id"> -</span><span class="id"> vn</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> &lt;=</span><span class="id"> wn</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">wn</span><span class="id"> n</span>))<span class="id"> &lt;</span><span class="id"> un</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> l:R</span><span class="id"> |</span><span class="id"> Un_cv</span> (<span class="gallina-kwd">fun</span><span class="id"> N:nat</span><span class="id"> =&gt;</span><span class="id"> RiemannInt_SF</span> (<span class="id">vn</span><span class="id"> N</span>))<span class="id"> l</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> destruct</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hle|Hnle]</span>.<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> RiemannInt_P2</span><span class="gallina-kwd"> with</span><span class="id"> f</span><span class="id"> un</span><span class="id"> wn;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H1</span><span class="id"> :</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> auto</span><span class="gallina-kwd"> with</span><span class="id"> real</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span> (<span class="id">vn'</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n:nat</span><span class="id"> =&gt;</span><span class="id"> mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">vn</span><span class="id"> n</span>))))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set</span> (<span class="id">wn'</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> n:nat</span><span class="id"> =&gt;</span><span class="id"> mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">wn</span><span class="id"> n</span>))))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">H2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> n:nat,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> t:R,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rmin</span><span class="id"> b</span><span class="id"> a</span><span class="id"> &lt;=</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> b</span><span class="id"> a</span><span class="id"> -&gt;</span><span class="id"> Rabs</span> (<span class="id">f</span><span class="id"> t</span><span class="id"> -</span><span class="id"> vn'</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> &lt;=</span><span class="id"> wn'</span><span class="id"> n</span><span class="id"> t</span>)<span class="id"> /\</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">wn'</span><span class="id"> n</span>))<span class="id"> &lt;</span><span class="id"> un</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> intro;</span><span class="id"> elim</span> (<span class="id">H0</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> intros;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> intros</span><span class="id"> t</span> (<span class="id">H4,H5</span>)<span class="id">;</span><span class="id"> apply</span> (<span class="id">H2</span><span class="id"> t</span>)<span class="id">;</span><span class="id"> split;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rmin</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> try</span><span class="id"> assumption;</span><span class="id"> right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Rmin</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rmax</span><span class="id"> b</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> try</span><span class="id"> assumption;</span><span class="id"> right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Rmax</span><span class="id"> ];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> Hnle;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> b</span><span class="id"> a</span>)<span class="gallina-kwd"> with</span><span class="id"> H1;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">generalize</span><span class="id"> H3;</span><span class="id"> unfold</span><span class="id"> RiemannInt_SF;</span><span class="id"> destruct</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hleab|Hnleab];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">Rle_dec</span><span class="id"> b</span><span class="id"> a</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hle'|Hnle'];</span><span class="id"> unfold</span><span class="id"> wn';</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">replace</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int_SF</span> (<span class="id">subdivision_val</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">wn</span><span class="id"> n</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">subdivision</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">wn</span><span class="id"> n</span>))))))<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int_SF</span> (<span class="id">subdivision_val</span> (<span class="id">wn</span><span class="id"> n</span>)) (<span class="id">subdivision</span> (<span class="id">wn</span><span class="id"> n</span>)))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> StepFun_P17</span><span class="gallina-kwd"> with</span> (<span class="id">fe</span> (<span class="id">wn</span><span class="id"> n</span>))<span class="id"> a</span><span class="id"> b;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> StepFun_P1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> StepFun_P2;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> (<span class="id">StepFun_P1</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">wn</span><span class="id"> n</span>)))))<span class="id"> ]</span><span class="id"> ]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply</span><span class="id"> H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> Rabs_Ropp;</span><span class="id"> apply</span><span class="id"> H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> Rabs_Ropp</span><span class="gallina-kwd"> in</span><span class="id"> H4;</span><span class="id"> apply</span><span class="id"> H4</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply</span><span class="id"> H4</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H3</span><span class="id"> :=</span><span class="id"> RiemannInt_P2</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> H</span><span class="id"> H1</span><span class="id"> H2</span>)<span class="id">;</span><span class="id"> elim</span><span class="id"> H3;</span><span class="id"> intros</span><span class="id"> x</span><span class="id"> p;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">-</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> unfold</span><span class="id"> Un_cv;</span><span class="id"> unfold</span><span class="id"> Un_cv</span><span class="gallina-kwd"> in</span><span class="id"> p;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> elim</span> (<span class="id">p</span><span class="id"> _</span><span class="id"> H4</span>)<span class="id">;</span><span class="id"> intros;</span><span class="gallina-kwd"> exists</span><span class="id"> x0;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">generalize</span> (<span class="id">H5</span><span class="id"> _</span><span class="id"> H6</span>)<span class="id">;</span><span class="id"> unfold</span><span class="id"> Rdist,</span><span class="id"> RiemannInt_SF;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">Rle_dec</span><span class="id"> b</span><span class="id"> a</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hle'|Hnle'];</span><span class="id"> destruct</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hle''|Hnle''];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros</span>.<br/>
&nbsp;&nbsp;<span class="id">1,3,4:</span><span class="id"> lra</span>.<br/>
&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> vn'</span><span class="gallina-kwd"> in</span><span class="id"> H7;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">Int_SF</span> (<span class="id">subdivision_val</span> (<span class="id">vn</span><span class="id"> n</span>)) (<span class="id">subdivision</span> (<span class="id">vn</span><span class="id"> n</span>)))<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Int_SF</span> (<span class="id">subdivision_val</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">vn</span><span class="id"> n</span>)))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">subdivision</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">vn</span><span class="id"> n</span>))))))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_involutive;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Ropp_plus_distr;</span><span class="id"> rewrite</span><span class="id"> Ropp_involutive;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> H7</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> symmetry</span><span class="id"> ;</span><span class="id"> apply</span><span class="id"> StepFun_P17</span><span class="gallina-kwd"> with</span> (<span class="id">fe</span> (<span class="id">vn</span><span class="id"> n</span>))<span class="id"> a</span><span class="id"> b;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> StepFun_P1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> apply</span><span class="id"> StepFun_P2;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span> (<span class="id">StepFun_P1</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">vn</span><span class="id"> n</span>)))))<span class="id"> ]</span><span class="id"> ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RiemannInt_exists</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b:R</span>) (<span class="id">pr:Riemann_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">un:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span><span class="id"> un</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> l:R</span><span class="id"> |</span><span class="id"> Un_cv</span> (<span class="gallina-kwd">fun</span><span class="id"> N:nat</span><span class="id"> =&gt;</span><span class="id"> RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr</span><span class="id"> N</span>))<span class="id"> l</span><span class="id"> }</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">intros</span><span class="id"> f;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> RiemannInt_P3</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">f</span><span class="id"> un</span> (<span class="gallina-kwd">fun</span><span class="id"> n:nat</span><span class="id"> =&gt;</span><span class="id"> proj1_sig</span> (<span class="id">phi_sequence_prop</span><span class="id"> un</span><span class="id"> pr</span><span class="id"> n</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> H</span><span class="id"> |</span><span class="id"> intro;</span><span class="id"> apply</span> (<span class="id">proj2_sig</span> (<span class="id">phi_sequence_prop</span><span class="id"> un</span><span class="id"> pr</span><span class="id"> n</span>))<span class="id"> ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RiemannInt_P4</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span> (<span class="id">f:R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">a</span><span class="id"> b</span><span class="id"> l:R</span>) (<span class="id">pr1</span><span class="id"> pr2:Riemann_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">un</span><span class="id"> vn:nat</span><span class="id"> -&gt;</span><span class="id"> posreal</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span><span class="id"> un</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span><span class="id"> vn</span><span class="id"> 0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span> (<span class="gallina-kwd">fun</span><span class="id"> N:nat</span><span class="id"> =&gt;</span><span class="id"> RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> N</span>))<span class="id"> l</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Un_cv</span> (<span class="gallina-kwd">fun</span><span class="id"> N:nat</span><span class="id"> =&gt;</span><span class="id"> RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> N</span>))<span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Un_cv;</span><span class="id"> unfold</span><span class="id"> Rdist;</span><span class="id"> intros</span><span class="id"> f;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H3</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> eps</span><span class="id"> /</span><span class="id"> 3</span>).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rdiv;</span><span class="id"> apply</span><span class="id"> Rmult_lt_0_compat;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> assumption</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Rinv_0_lt_compat;</span><span class="id"> prove_sup0</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">H</span><span class="id"> _</span><span class="id"> H3</span>)<span class="id">;</span><span class="id"> clear</span><span class="id"> H;</span><span class="id"> intros</span><span class="id"> N0</span><span class="id"> H;</span><span class="id"> elim</span> (<span class="id">H0</span><span class="id"> _</span><span class="id"> H3</span>)<span class="id">;</span><span class="id"> clear</span><span class="id"> H0;</span><span class="id"> intros</span><span class="id"> N1</span><span class="id"> H0;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">H1</span><span class="id"> _</span><span class="id"> H3</span>)<span class="id">;</span><span class="id"> clear</span><span class="id"> H1;</span><span class="id"> intros</span><span class="id"> N2</span><span class="id"> H1;</span><span class="id"> set</span> (<span class="id">N</span><span class="id"> :=</span><span class="id"> max</span> (<span class="id">max</span><span class="id"> N0</span><span class="id"> N1</span>)<span class="id"> N2</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> N;</span><span class="id"> intros;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Rabs</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id"> -</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>))<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>)<span class="id"> -</span><span class="id"> l</span>)).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> replace</span> (<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id"> -</span><span class="id"> l</span>)<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id"> -</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>)<span class="id"> -</span><span class="id"> l</span>))<span class="id">;</span><span class="id"> [</span><span class="id"> apply</span><span class="id"> Rabs_triang</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">replace</span><span class="id"> eps</span><span class="gallina-kwd"> with</span> (<span class="id">2</span><span class="id"> *</span> (<span class="id">eps</span><span class="id"> /</span><span class="id"> 3</span>)<span class="id"> +</span><span class="id"> eps</span><span class="id"> /</span><span class="id"> 3</span>)<span class="gallina-kwd"> by</span><span class="id"> lra</span>.<br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_lt_compat</span>.<br/>
&nbsp;&nbsp;<span class="id">2:{</span><span class="id"> apply</span><span class="id"> H1;</span><span class="id"> unfold</span><span class="id"> ge;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span><span class="id"> N;</span><span class="id"> try</span><span class="id"> assumption;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> N;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_max_r</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">phi_sequence_prop</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> intros</span><span class="id"> psi_vn</span><span class="id"> H5;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">phi_sequence_prop</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> intros</span><span class="id"> psi_un</span><span class="id"> H6;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id"> -</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">-1</span><span class="id"> *</span><span class="id"> RiemannInt_SF</span> (<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>))<span class="id">;</span><span class="id"> [</span><span class="id"> idtac</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ];</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-</span><span class="id"> StepFun_P30</span>.<br/>
&nbsp;&nbsp;<span class="id">destruct</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> as</span><span class="id"> [Hle|Hnle]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P32</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P28</span> (<span class="id">-1</span>) (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>)))))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P34;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P28</span><span class="id"> 1</span><span class="id"> psi_un</span><span class="id"> psi_vn</span>))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P37;</span><span class="id"> try</span><span class="id"> assumption;</span><span class="id"> intros;</span><span class="id"> simpl;</span><span class="id"> rewrite</span><span class="id"> Rmult_1_l;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Rabs</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> replace</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> +</span><span class="id"> -1</span><span class="id"> *</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>)<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span><span class="id"> +</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rabs_triang</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H10</span><span class="id"> :</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmin;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> Hle;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H11</span><span class="id"> :</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmax;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> Hle;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">Rplus_comm</span> (<span class="id">psi_un</span><span class="id"> x</span>))<span class="id">;</span><span class="id"> apply</span><span class="id"> Rplus_le_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><span class="id"> rewrite</span><span class="id"> Ropp_minus_distr;</span><span class="id"> destruct</span><span class="id"> H5</span><span class="gallina-kwd"> as</span> (<span class="id">H8,H9</span>)<span class="id">;</span><span class="id"> apply</span><span class="id"> H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> H10;</span><span class="id"> rewrite</span><span class="id"> H11;</span><span class="id"> elim</span><span class="id"> H7;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span><span class="id"> H6;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> H10;</span><span class="id"> rewrite</span><span class="id"> H11;</span><span class="id"> elim</span><span class="id"> H7;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> StepFun_P30;</span><span class="id"> rewrite</span><span class="id"> Rmult_1_l;</span><span class="id"> rewrite</span><span class="id"> &lt;-Rplus_diag;</span><span class="id"> apply</span><span class="id"> Rplus_lt_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> elim</span><span class="id"> H6;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi_un</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> RRle_abs</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">un</span><span class="id"> n</span><span class="id"> -</span><span class="id"> 0</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> H;</span><span class="id"> unfold</span><span class="id"> ge;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span><span class="id"> N;</span><span class="id"> try</span><span class="id"> assumption;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> N;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span> (<span class="id">max</span><span class="id"> N0</span><span class="id"> N1</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Nat</span>.<span class="id">le_max_l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_0;</span><span class="id"> rewrite</span><span class="id"> Rplus_0_r;</span><span class="id"> apply</span><span class="id"> Rabs_right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_ge;</span><span class="id"> left;</span><span class="id"> apply</span> (<span class="id">cond_pos</span> (<span class="id">un</span><span class="id"> n</span>))<span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">pos</span> (<span class="id">vn</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> elim</span><span class="id"> H5;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi_vn</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> RRle_abs;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">vn</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">vn</span><span class="id"> n</span><span class="id"> -</span><span class="id"> 0</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> H0;</span><span class="id"> unfold</span><span class="id"> ge;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span><span class="id"> N;</span><span class="id"> try</span><span class="id"> assumption;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> N;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span> (<span class="id">max</span><span class="id"> N0</span><span class="id"> N1</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_max_r</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_max_l</span><span class="id"> ]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_0;</span><span class="id"> rewrite</span><span class="id"> Rplus_0_r;</span><span class="id"> apply</span><span class="id"> Rabs_right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_ge;</span><span class="id"> left;</span><span class="id"> apply</span> (<span class="id">cond_pos</span> (<span class="id">vn</span><span class="id"> n</span>))<span class="id"> ]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> StepFun_P39;</span><span class="id"> rewrite</span><span class="id"> Rabs_Ropp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P32</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P6</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pre</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P28</span> (<span class="id">-1</span>) (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span>))))))))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P34;</span><span class="id"> try</span><span class="id"> auto</span><span class="gallina-kwd"> with</span><span class="id"> real</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span> (<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P28</span><span class="id"> 1</span><span class="id"> psi_vn</span><span class="id"> psi_un</span>)))))).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> StepFun_P37</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> auto</span><span class="gallina-kwd"> with</span><span class="id"> real</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">intros;</span><span class="id"> simpl;</span><span class="id"> rewrite</span><span class="id"> Rmult_1_l;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_trans</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Rabs</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span>)<span class="id"> +</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Rabs</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> replace</span> (<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> +</span><span class="id"> -1</span><span class="id"> *</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>)<span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">phi_sequence</span><span class="id"> vn</span><span class="id"> pr2</span><span class="id"> n</span><span class="id"> x</span><span class="id"> -</span><span class="id"> f</span><span class="id"> x</span><span class="id"> +</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> -</span><span class="id"> phi_sequence</span><span class="id"> un</span><span class="id"> pr1</span><span class="id"> n</span><span class="id"> x</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rabs_triang</span><span class="id"> |</span><span class="id"> ring</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H10</span><span class="id"> :</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmin;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> Hnle;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assert</span> (<span class="id">H11</span><span class="id"> :</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> =</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> unfold</span><span class="id"> Rmax;</span><span class="id"> decide</span> (<span class="id">Rle_dec</span><span class="id"> a</span><span class="id"> b</span>)<span class="gallina-kwd"> with</span><span class="id"> Hnle;</span><span class="id"> reflexivity</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_le_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><span class="id"> rewrite</span><span class="id"> Ropp_minus_distr;</span><span class="id"> elim</span><span class="id"> H5;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> H10;</span><span class="id"> rewrite</span><span class="id"> H11;</span><span class="id"> elim</span><span class="id"> H7;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim</span><span class="id"> H6;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> H8</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> H10;</span><span class="id"> rewrite</span><span class="id"> H11;</span><span class="id"> elim</span><span class="id"> H7;</span><span class="id"> intros;</span><span class="id"> split;</span><span class="id"> left;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">Ropp_involutive</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">RiemannInt_SF</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">mkStepFun</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">StepFun_P6</span> (<span class="id">pre</span> (<span class="id">mkStepFun</span> (<span class="id">StepFun_P28</span><span class="id"> 1</span><span class="id"> psi_vn</span><span class="id"> psi_un</span>)))))))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> StepFun_P39;</span><span class="id"> rewrite</span><span class="id"> StepFun_P30;</span><span class="id"> rewrite</span><span class="id"> Rmult_1_l;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-Rplus_diag;</span><span class="id"> rewrite</span><span class="id"> Ropp_plus_distr;</span><span class="id"> apply</span><span class="id"> Rplus_lt_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">pos</span> (<span class="id">vn</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> elim</span><span class="id"> H5;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi_vn</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><span class="id"> apply</span><span class="id"> RRle_abs</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">vn</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">vn</span><span class="id"> n</span><span class="id"> -</span><span class="id"> 0</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> H0;</span><span class="id"> unfold</span><span class="id"> ge;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span><span class="id"> N;</span><span class="id"> try</span><span class="id"> assumption;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> N;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span> (<span class="id">max</span><span class="id"> N0</span><span class="id"> N1</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_max_r</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_max_l</span><span class="id"> ]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> unfold</span><span class="id"> Rdist;</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_0;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Rplus_0_r;</span><span class="id"> apply</span><span class="id"> Rabs_right;</span><span class="id"> apply</span><span class="id"> Rle_ge;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left;</span><span class="id"> apply</span> (<span class="id">cond_pos</span> (<span class="id">vn</span><span class="id"> n</span>))<span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> elim</span><span class="id"> H6;</span><span class="id"> intros;</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">RiemannInt_SF</span><span class="id"> psi_un</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rabs_Ropp;</span><span class="id"> apply</span><span class="id"> RRle_abs;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">replace</span> (<span class="id">pos</span> (<span class="id">un</span><span class="id"> n</span>))<span class="gallina-kwd"> with</span> (<span class="id">Rabs</span> (<span class="id">un</span><span class="id"> n</span><span class="id"> -</span><span class="id"> 0</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> H;</span><span class="id"> unfold</span><span class="id"> ge;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span><span class="id"> N;</span><span class="id"> try</span><span class="id"> assumption;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> N;</span><span class="id"> apply</span><span class="id"> Nat</span>.<span class="id">le_trans</span><span class="gallina-kwd"> with</span> (<span class="id">max</span><span class="id"> N0</span><span class="id"> N1</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Nat</span>.<span class="id">le_max_l</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_0;</span><span class="id"> rewrite</span><span class="id"> Rplus_0_r;</span><span class="id"> apply</span><span class="id"> Rabs_right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rle_ge;</span><span class="id"> left;</span><span class="id"> apply</span> (<span class="id">cond_pos</span> (<span class="id">un</span><span class="id"> n</span>))<span class="id"> ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RinvN_pos</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n:nat,</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> /</span> (<span class="id">INR</span><span class="id"> n</span><span class="id"> +</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">intro;</span><span class="id"> apply</span><span class="id"> Rinv_0_lt_compat;</span><span class="id"> apply</span><span class="id"> Rplus_le_lt_0_compat;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> pos_INR</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Rlt_0_1</span><span class="id"> ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> RinvN</span> (<span class="id">N:nat</span>)<span class="id"> :</span><span class="id"> posreal</span><span class="id"> :=</span><span class="id"> mkposreal</span><span class="id"> _</span> (<span class="id">RinvN_pos</span><span class="id"> N</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> RinvN_cv</span><span class="id"> :</span><span class="id"> Un_cv</span><span class="id"> RinvN</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
&nbsp;&nbsp;<span class="id">unfold</span><span class="id"> Un_cv;</span><span class="id"> intros;</span><span class="id"> assert</span> (<span class="id">H0</span><span class="id"> :=</span><span class="id"> archimed</span> (<span class="id">/</span><span class="id"> eps</span>))<span class="id">;</span><span class="id"> elim</span><span class="id"> H0;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">clear</span><span class="id"> H0;</span><span class="id"> intros;</span><span class="id"> assert</span> (<span class="id">H2</span><span class="id"> :</span> (<span class="id">0</span><span class="id"> &lt;=</span><span class="id"> up</span> (<span class="id">/</span><span class="id"> eps</span>))<span class="id">%Z</span>).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> le_IZR;</span><span class="id"> left;</span><span class="id"> apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">/</span><span class="id"> eps</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> apply</span><span class="id"> Rinv_0_lt_compat;</span><span class="id"> assumption</span><span class="id"> |</span><span class="id"> assumption</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">elim</span> (<span class="id">IZN</span><span class="id"> _</span><span class="id"> H2</span>)<span class="id">;</span><span class="id"> intros;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> intros;</span><span class="id"> unfold</span><span class="id"> Rdist;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">simpl;</span><span class="id"> unfold</span><span class="id"> Rminus;</span><span class="id"> rewrite</span><span class="id"> Ropp_0;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Rplus_0_r;</span><span class="id"> assert</span> (<span class="id">H5</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> INR</span><span class="id"> n</span><span class="id"> +</span><span class="id"> 1</span>).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rplus_le_lt_0_compat;</span><span class="id"> [</span><span class="id"> apply</span><span class="id"> pos_INR</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Rlt_0_1</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Rabs_right;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> idtac</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> left;</span><span class="id"> change</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> /</span> (<span class="id">INR</span><span class="id"> n</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id">;</span><span class="id"> apply</span><span class="id"> Rinv_0_lt_compat;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">assumption</span><span class="id"> ];</span><span class="id"> apply</span><span class="id"> Rle_lt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">/</span> (<span class="id">INR</span><span class="id"> x</span><span class="id"> +</span><span class="id"> 1</span>)).<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rinv_le_contravar</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rplus_le_lt_0_compat;</span><span class="id"> [</span><span class="id"> apply</span><span class="id"> pos_INR</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Rlt_0_1</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_le_compat_r;</span><span class="id"> apply</span><span class="id"> le_INR;</span><span class="id"> apply</span><span class="id"> H4</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> &lt;-</span> (<span class="id">Rinv_inv</span><span class="id"> eps</span>).<br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rinv_lt_contravar</span>.<br/>
&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rmult_lt_0_compat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{</span><span class="id"> apply</span><span class="id"> Rinv_0_lt_compat;</span><span class="id"> assumption</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_le_lt_0_compat;</span><span class="id"> [</span><span class="id"> apply</span><span class="id"> pos_INR</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> Rlt_0_1</span><span class="id"> ]</span>. <span class="id">}</span><br/>
&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rlt_trans</span><span class="gallina-kwd"> with</span> (<span class="id">INR</span><span class="id"> x</span>)<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[</span><span class="id"> rewrite</span><span class="id"> INR_IZR_INZ;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> H3;</span><span class="id"> apply</span><span class="id"> H0</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">|</span><span class="id"> pattern</span> (<span class="id">INR</span><span class="id"> x</span>)<span class="gallina-kwd"> at</span><span class="id"> 1;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> Rplus_0_r;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> Rplus_lt_compat_l;</span><span class="id"> apply</span><span class="id"> Rlt_0_1</span><span class="id"> ]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Riemann_integrable_ext</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> f</span><span class="id"> g</span><span class="id"> a</span><span class="id"> b,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> Rmin</span><span class="id"> a</span><span class="id"> b</span><span class="id"> &lt;=</span><span class="id"> x</span><span class="id"> &lt;=</span><span class="id"> Rmax</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> =</span><span class="id"> g</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Riemann_integrable</span><span class="id"> f</span><span class="id"> a</span><span class="id"> b</span><span class="id"> -&gt;</span><span class="id"> Riemann_integrable</span><span class="id"> g</span><span class="id"> a</span><span class="id"> b</span>.<br/>
<span class="id">intros</span><span class="id"> f</span><span class="id"> g</span><span class="id"> a</span><span class="id"> b</span><span class="id"> fg</span><span class="id"> rif</span><span class="id"> eps;</span><span class="id"> destruct</span> (<span class="id">rif</span><span class="id"> eps</span>)<span class="gallina-kwd"> as</span><span class="id"> [phi</span><span class="id"> [psi</span><span class="id"> [P1</span><span class="id"> P2]]]</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> phi;</span><span class="gallina-kwd"> exists</span><span class="id"> psi;split;[</span><span class="id"> |</span><span class="id"> assumption</span><span class="id"> ]</span>.<br/>
<span class="id">intros</span><span class="id"> t</span><span class="id"> intt;</span><span class="id"> rewrite</span><span class="id"> &lt;-</span><span class="id"> fg;[</span><span class="id"> |</span><span class="id"> assumption]</span>.<br/>
<span class="id">apply</span><span class="id"> P1;</span><span class="id"> assumption</span>.<br/>
<pre class="ssrdoc">
Definition RiemannInt (f:R -&gt; R) (a b:R) (pr:Riemann_integrable f a b) : R :=
  let (a,_) := RiemannInt_exists pr RinvN RinvN_cv in a.
Lemma RiemannInt_P5 :
  forall (f:R -&gt; R) (a b:R) (pr1 pr2:Riemann_integrable f a b),
    RiemannInt pr1 = RiemannInt pr2.
Proof.
  intros; unfold RiemannInt;
    case (RiemannInt_exists pr1 RinvN RinvN_cv) as (x,HUn);
    case (RiemannInt_exists pr2 RinvN RinvN_cv) as (x0,HUn0);
      eapply UL_sequence;
        [ apply HUn
          | apply RiemannInt_P4 with pr2 RinvN; apply RinvN_cv || assumption ].
Qed.
</pre>
<div class="doc">C(<code class="bracket"><span class="id">a</span>,<span class="id">b</span></code>) is included in L1(<code class="bracket"><span class="id">a</span>,<span class="id">b</span></code>) </div>
<pre class="ssrdoc">
Lemma maxN :
  forall (a b:R) (del:posreal),
    a &lt; b -&gt; { n:nat | a + INR n * del &lt; b /\ b &lt;= a + INR (S n) * del }.
Proof.
  intros; set (I := fun n:nat =&gt; a + INR n * del &lt; b);
    assert (H0 :  exists n : nat, I n).
  { exists 0%nat; unfold I; rewrite Rmult_0_l; rewrite Rplus_0_r;
      assumption. }
  cut (Nbound I).
  { intro; assert (H2 := Nzorn H0 H1); elim H2; intros x p; exists x; elim p; intros;
      split.
    { apply H3. }
    destruct (total_order_T (a + INR (S x) * del) b) as [[Hlt|Heq]|Hgt].
    { assert (H5 := H4 (S x) Hlt); elim (Nat.nle_succ_diag_l _ H5). }
    { right; symmetry ; assumption. }
    left; apply Hgt. }
  assert (H1 : 0 &lt;= (b - a) / del).
  { unfold Rdiv; apply Rmult_le_pos;
      [ apply Rge_le; apply Rge_minus; apply Rle_ge; left; apply H
      | left; apply Rinv_0_lt_compat; apply (cond_pos del) ]. }
  elim (archimed ((b - a) / del)); intros;
    assert (H4 : (0 &lt;= up ((b - a) / del))%Z).
  { apply le_IZR; simpl; left; apply Rle_lt_trans with ((b - a) / del);
      assumption. }
  assert (H5 := IZN _ H4); elim H5; clear H5; intros N H5;
    unfold Nbound; exists N; intros; unfold I in H6;
    apply INR_le; rewrite H5 in H2; rewrite &lt;- INR_IZR_INZ in H2;
    left; apply Rle_lt_trans with ((b - a) / del); try assumption;
    apply Rmult_le_reg_l with (pos del);
    [ apply (cond_pos del)
    | unfold Rdiv; rewrite &lt;- (Rmult_comm (/ del));
      rewrite &lt;- Rmult_assoc; rewrite Rinv_r;
      [ rewrite Rmult_1_l; rewrite Rmult_comm; apply Rplus_le_reg_l with a;
        replace (a + (b - a)) with b; [ left; assumption | ring ]
      | assert (H7 := cond_pos del); red; intro; rewrite H8 in H7;
        elim (Rlt_irrefl _ H7) ] ].
Qed.
Fixpoint SubEquiN (N:nat) (x y:R) (del:posreal) : list R :=
  match N with
    | O =&gt; cons y nil
    | S p =&gt; cons x (SubEquiN p (x + del) y del)
  end.
Definition max_N (a b:R) (del:posreal) (h:a &lt; b) : nat :=
  let (N,_) := maxN del h in N.
Definition SubEqui (a b:R) (del:posreal) (h:a &lt; b) : list R :=
  SubEquiN (S (max_N del h)) a b del.
Lemma Heine_cor1 :
  forall (f:R -&gt; R) (a b:R),
    a &lt; b -&gt;
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt;
    forall eps:posreal,
      { delta:posreal |
        delta &lt;= b - a /\
          (forall x y:R,
              a &lt;= x &lt;= b -&gt;
              a &lt;= y &lt;= b -&gt; Rabs (x - y) &lt; delta -&gt; Rabs (f x - f y) &lt; eps) }.
Proof.
  intro f; intros;
    set
      (E :=
         fun l:R =&gt;
           0 &lt; l &lt;= b - a /\
             (forall x y:R,
                 a &lt;= x &lt;= b -&gt;
                 a &lt;= y &lt;= b -&gt; Rabs (x - y) &lt; l -&gt; Rabs (f x - f y) &lt; eps));
    assert (H1 : bound E).
  { unfold bound; exists (b - a); unfold is_upper_bound; intros;
      unfold E in H1; elim H1; clear H1; intros H1 _; elim H1;
      intros; assumption. }
  assert (H2 :  exists x : R, E x).
  { assert (H2 := Heine f (fun x:R =&gt; a &lt;= x &lt;= b) (compact_P3 a b) H0 eps);
      elim H2; intros; exists (Rmin x (b - a)); unfold E;
      split;
      [ split;
        [ unfold Rmin; case (Rle_dec x (b - a)); intro;
          [ apply (cond_pos x) | apply Rlt_0_minus; assumption ]
        | apply Rmin_r ]
      | intros; apply H3; try assumption; apply Rlt_le_trans with (Rmin x (b - a));
        [ assumption | apply Rmin_l ] ]. }
  assert (H3 := completeness E H1 H2); elim H3; intros x p; cut (0 &lt; x &lt;= b - a).
  { intro; elim H4; clear H4; intros; exists (mkposreal _ H4); split.
    { apply H5. }
    unfold is_lub in p; elim p; intros; unfold is_upper_bound in H6;
      set (D := Rabs (x0 - y)).
    assert (H11: ((exists y : R, D &lt; y /\ E y) \/ (forall y : R, not (D &lt; y /\ E y)) -&gt; False) -&gt; False).
    { clear; intros H; apply H.
      right; intros y0 H0; apply H.
      left; now exists y0. }
    apply Rnot_le_lt; intros H30.
    apply H11; clear H11; intros H11.
    revert H30; apply Rlt_not_le.
    destruct H11 as [H11|H12].
    { elim H11; intros; elim H12; clear H12; intros; unfold E in H13; elim H13;
        intros; apply H15; assumption. }
    assert (H13 : is_upper_bound E D).
    { unfold is_upper_bound; intros; assert (H14 := H12 x1);
        apply Rnot_lt_le; contradict H14; now split. }
    assert (H14 := H7 _ H13); elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H14 H10)). }
  unfold is_lub in p; unfold is_upper_bound in p; elim p; clear p; intros;
    split.
  { elim H2; intros; assert (H7 := H4 _ H6); unfold E in H6; elim H6; clear H6;
      intros H6 _; elim H6; intros; apply Rlt_le_trans with x0;
      assumption. }
  apply H5; intros; unfold E in H6; elim H6; clear H6; intros H6 _; elim H6;
    intros; assumption.
Qed.
Lemma Heine_cor2 :
  forall (f:R -&gt; R) (a b:R),
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt;
    forall eps:posreal,
      { delta:posreal |
        forall x y:R,
          a &lt;= x &lt;= b -&gt;
          a &lt;= y &lt;= b -&gt; Rabs (x - y) &lt; delta -&gt; Rabs (f x - f y) &lt; eps }.
Proof.
  intro f; intros; destruct (total_order_T a b) as [[Hlt|Heq]|Hgt].
  - assert (H0 := Heine_cor1 Hlt H eps); elim H0; intros x p; exists x;
    elim p; intros; apply H2; assumption.
  - exists (mkposreal _ Rlt_0_1); intros; assert (H3 : x = y);
    [ elim H0; elim H1; intros; rewrite Heq in H3, H5;
      apply Rle_antisym; apply Rle_trans with b; assumption
      | rewrite H3; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
        apply (cond_pos eps) ].
  - exists (mkposreal _ Rlt_0_1); intros; elim H0; intros;
    elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ (Rle_trans _ _ _ H3 H4) Hgt)).
Qed.
Lemma SubEqui_P1 :
  forall (a b:R) (del:posreal) (h:a &lt; b), pos_Rl (SubEqui del h) 0 = a.
Proof.
  intros; unfold SubEqui; case (maxN del h); intros; reflexivity.
Qed.
Lemma SubEqui_P2 :
  forall (a b:R) (del:posreal) (h:a &lt; b),
    pos_Rl (SubEqui del h) (pred (length (SubEqui del h))) = b.
Proof.
  intros; unfold SubEqui; destruct (maxN del h)as (x,_).
    cut
      (forall (x:nat) (a:R) (del:posreal),
        pos_Rl (SubEquiN (S x) a b del)
        (pred (length (SubEquiN (S x) a b del))) = b);
      [ intro; apply H
        | simple induction x0;
          [ intros; reflexivity
            | intros;
              change
                (pos_Rl (SubEquiN (S n) (a0 + del0) b del0)
                  (pred (length (SubEquiN (S n) (a0 + del0) b del0))) = b)
               ; apply H ] ].
Qed.
Lemma SubEqui_P3 :
  forall (N:nat) (a b:R) (del:posreal), length (SubEquiN N a b del) = S N.
Proof.
  simple induction N; intros;
    [ reflexivity | simpl; rewrite H; reflexivity ].
Qed.
Lemma SubEqui_P4 :
  forall (N:nat) (a b:R) (del:posreal) (i:nat),
    (i &lt; S N)%nat -&gt; pos_Rl (SubEquiN (S N) a b del) i = a + INR i * del.
Proof.
  simple induction N;
    [ intros; inversion H; [ simpl; ring | elim (Nat.nle_succ_0 _ H1) ]
      | intros; induction  i as [| i Hreci];
        [ simpl; ring
          | change
            (pos_Rl (SubEquiN (S n) (a + del) b del) i = a + INR (S i) * del)
           ; rewrite H; [ rewrite S_INR; ring | apply Nat.succ_lt_mono; apply H0 ] ] ].
Qed.
Lemma SubEqui_P5 :
  forall (a b:R) (del:posreal) (h:a &lt; b),
    length (SubEqui del h) = S (S (max_N del h)).
Proof.
  intros; unfold SubEqui; apply SubEqui_P3.
Qed.
Lemma SubEqui_P6 :
  forall (a b:R) (del:posreal) (h:a &lt; b) (i:nat),
    (i &lt; S (max_N del h))%nat -&gt; pos_Rl (SubEqui del h) i = a + INR i * del.
Proof.
  intros; unfold SubEqui; apply SubEqui_P4; assumption.
Qed.
Lemma SubEqui_P7 :
  forall (a b:R) (del:posreal) (h:a &lt; b), ordered_Rlist (SubEqui del h).
Proof.
  intros; unfold ordered_Rlist; intros; rewrite SubEqui_P5 in H;
    simpl in H; inversion H.
  { rewrite (SubEqui_P6 del h (i:=(max_N del h))).
    { replace (S (max_N del h)) with (pred (length (SubEqui del h))).
      { rewrite SubEqui_P2; unfold max_N; case (maxN del h) as (?&amp;?&amp;?); left;
          assumption. }
      rewrite SubEqui_P5; reflexivity. }
    apply Nat.lt_succ_diag_r. }
  repeat rewrite SubEqui_P6.
  3: assumption.
  2: apply Nat.lt_succ_r; assumption.
  apply Rplus_le_compat_l; rewrite S_INR; rewrite Rmult_plus_distr_r;
    pattern (INR i * del) at 1; rewrite &lt;- Rplus_0_r;
    apply Rplus_le_compat_l; rewrite Rmult_1_l; left;
    apply (cond_pos del).
Qed.
Lemma SubEqui_P8 :
  forall (a b:R) (del:posreal) (h:a &lt; b) (i:nat),
    (i &lt; length (SubEqui del h))%nat -&gt; a &lt;= pos_Rl (SubEqui del h) i &lt;= b.
Proof.
  intros; split.
  { pattern a at 1; rewrite &lt;- (SubEqui_P1 del h); apply RList_P5.
    { apply SubEqui_P7. }
    elim (RList_P3 (SubEqui del h) (pos_Rl (SubEqui del h) i)); intros; apply H1;
      exists i; split; [ reflexivity | assumption ]. }
  pattern b at 2; rewrite &lt;- (SubEqui_P2 del h); apply RList_P7;
    [ apply SubEqui_P7
    | elim (RList_P3 (SubEqui del h) (pos_Rl (SubEqui del h) i)); intros;
      apply H1; exists i; split; [ reflexivity | assumption ] ].
Qed.
Lemma SubEqui_P9 :
  forall (a b:R) (del:posreal) (f:R -&gt; R) (h:a &lt; b),
    { g:StepFun a b |
      g b = f b /\
      (forall i:nat,
        (i &lt; pred (length (SubEqui del h)))%nat -&gt;
        constant_D_eq g
        (co_interval (pos_Rl (SubEqui del h) i)
          (pos_Rl (SubEqui del h) (S i)))
        (f (pos_Rl (SubEqui del h) i))) }.
Proof.
  intros; apply StepFun_P38;
    [ apply SubEqui_P7 | apply SubEqui_P1 | apply SubEqui_P2 ].
Qed.
Lemma RiemannInt_P6 :
  forall (f:R -&gt; R) (a b:R),
    a &lt; b -&gt;
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt; Riemann_integrable f a b.
Proof.
  intros; unfold Riemann_integrable; intro;
    assert (H1 : 0 &lt; eps / (2 * (b - a))).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ apply (cond_pos eps)
      | apply Rinv_0_lt_compat; apply Rmult_lt_0_compat;
        [ prove_sup0 | apply Rlt_0_minus; assumption ] ]. }
  assert (H2 : Rmin a b = a).
  { apply Rlt_le in H.
    unfold Rmin; decide (Rle_dec a b) with H; reflexivity. }
  assert (H3 : Rmax a b = b).
  { apply Rlt_le in H.
    unfold Rmax; decide (Rle_dec a b) with H; reflexivity. }
  elim (Heine_cor2 H0 (mkposreal _ H1)); intros del H4;
    elim (SubEqui_P9 del f H); intros phi [H5 H6]; split with phi;
    split with (mkStepFun (StepFun_P4 a b (eps / (2 * (b - a)))));
    split.
  2: rewrite StepFun_P18; unfold Rdiv; rewrite Rinv_mult.
  2: do 2 rewrite Rmult_assoc; rewrite Rinv_l.
  2: rewrite Rmult_1_r; rewrite Rabs_right.
  2: apply Rmult_lt_reg_l with 2.
  2: prove_sup0.
  2: rewrite &lt;- (Rmult_comm (/ 2)); rewrite &lt;- Rmult_assoc;
  rewrite Rinv_r.
  2: rewrite Rmult_1_l; pattern (pos eps) at 1; rewrite &lt;- Rplus_0_r;
  rewrite &lt;-Rplus_diag; apply Rplus_lt_compat_l; apply (cond_pos eps).
  2: discrR.
  2: apply Rle_ge; left; apply Rmult_lt_0_compat.
  2: apply (cond_pos eps).
  2: apply Rinv_0_lt_compat; prove_sup0.
  2: apply Rminus_eq_contra; red; intro; clear H6; rewrite H7 in H;
  elim (Rlt_irrefl _ H).
  intros; rewrite H2 in H7; rewrite H3 in H7; simpl;
    unfold fct_cte;
    cut
      (forall t:R,
          a &lt;= t &lt;= b -&gt;
          t = b \/
            (exists i : nat,
                (i &lt; pred (length (SubEqui del H)))%nat /\
                  co_interval (pos_Rl (SubEqui del H) i) (pos_Rl (SubEqui del H) (S i))
                              t)).
  { intro; elim (H8 _ H7); intro.
    { rewrite H9; rewrite H5; unfold Rminus; rewrite Rplus_opp_r;
        rewrite Rabs_R0; left; assumption. }
    elim H9; clear H9; intros I [H9 H10]; assert (H11 := H6 I H9 t H10);
      rewrite H11; left; apply H4.
    - assumption.
    - apply SubEqui_P8; apply Nat.lt_trans with (pred (length (SubEqui del H))).
      { assumption. }
      apply Nat.lt_pred_l; red; intro; rewrite H12 in H9;
        elim (Nat.nlt_0_r _ H9).
    - unfold co_interval in H10; elim H10; clear H10; intros; rewrite Rabs_right.
      { rewrite SubEqui_P5 in H9; simpl in H9; inversion H9.
        { apply Rplus_lt_reg_l with (pos_Rl (SubEqui del H) (max_N del H)).
          replace
            (pos_Rl (SubEqui del H) (max_N del H) +
               (t - pos_Rl (SubEqui del H) (max_N del H))) with t;
            [ idtac | ring ]; apply Rlt_le_trans with b.
          { rewrite H14 in H12;
              assert (H13 : S (max_N del H) = pred (length (SubEqui del H))).
            { rewrite SubEqui_P5; reflexivity. }
            rewrite H13 in H12; rewrite SubEqui_P2 in H12; apply H12. }
          rewrite SubEqui_P6.
          2: apply Nat.lt_succ_diag_r.
          unfold max_N; destruct (maxN del H) as (?&amp;?&amp;H13);
            replace (a + INR x * del + del) with (a + INR (S x) * del);
            [ assumption | rewrite S_INR; ring ]. }
        apply Rplus_lt_reg_l with (pos_Rl (SubEqui del H) I);
          replace (pos_Rl (SubEqui del H) I + (t - pos_Rl (SubEqui del H) I)) with t;
          [ idtac | ring ];
          replace (pos_Rl (SubEqui del H) I + del) with (pos_Rl (SubEqui del H) (S I)).
        { assumption. }
        repeat rewrite SubEqui_P6.
        - rewrite S_INR; ring.
        - assumption.
        - apply Nat.lt_succ_r; assumption. }
      apply Rge_minus; apply Rle_ge; assumption. }
  intros; clear H0 H1 H4 phi H5 H6 t H7; case (Req_dec t0 b); intro.
  { left; assumption. }
  right; set (I := fun j:nat =&gt; a + INR j * del &lt;= t0);
    assert (H1 :  exists n : nat, I n).
  { exists 0%nat; unfold I; rewrite Rmult_0_l; rewrite Rplus_0_r; elim H8;
      intros; assumption. }
  assert (H4 : Nbound I).
  { unfold Nbound; exists (S (max_N del H)); intros; unfold max_N;
      destruct (maxN del H) as (?&amp;_&amp;H5);
      apply INR_le; apply Rmult_le_reg_l with (pos del).
    { apply (cond_pos del). }
    apply Rplus_le_reg_l with a; do 2 rewrite (Rmult_comm del);
      apply Rle_trans with t0; unfold I in H4; try assumption;
      apply Rle_trans with b; try assumption; elim H8; intros;
      assumption. }
  elim (Nzorn H1 H4); intros N [H5 H6]; assert (H7 : (N &lt; S (max_N del H))%nat).
  { unfold max_N; case (maxN del H) as (?&amp;?&amp;?); apply INR_lt;
      apply Rmult_lt_reg_l with (pos del).
    { apply (cond_pos del). }
    apply Rplus_lt_reg_l with a; do 2 rewrite (Rmult_comm del);
      apply Rle_lt_trans with t0; unfold I in H5; try assumption;
      apply Rlt_le_trans with b; try assumption;
      elim H8; intros.
    elim H11; intro.
    { assumption. }
    elim H0; assumption. }
  exists N; split.
  { rewrite SubEqui_P5; simpl; assumption. }
  unfold co_interval; split.
  { rewrite SubEqui_P6.
    { apply H5. }
    assumption. }
  inversion H7.
  { replace (S (max_N del H)) with (pred (length (SubEqui del H))).
    { rewrite (SubEqui_P2 del H); elim H8; intros.
      elim H11; intro.
      { assumption. }
      elim H0; assumption. }
    rewrite SubEqui_P5; reflexivity. }
  rewrite SubEqui_P6.
  { destruct (Rle_dec (a + INR (S N) * del) t0) as [Hle|Hnle].
    { assert (H11 := H6 (S N) Hle); elim (Nat.nle_succ_diag_l _ H11). }
    auto with real. }
  apply Nat.lt_succ_r; assumption.
Qed.
Lemma RiemannInt_P7 : forall (f:R -&gt; R) (a:R), Riemann_integrable f a a.
Proof.
  unfold Riemann_integrable; intro f; intros;
    split with (mkStepFun (StepFun_P4 a a (f a)));
      split with (mkStepFun (StepFun_P4 a a 0)); split.
  - intros; simpl; unfold fct_cte; replace t with a.
    + unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; right;
        reflexivity.
    + generalize H; unfold Rmin, Rmax; decide (Rle_dec a a) with (Rle_refl a).
      intros (?,?); apply Rle_antisym; assumption.
  - rewrite StepFun_P18; rewrite Rmult_0_l; rewrite Rabs_R0; apply (cond_pos eps).
Qed.
Lemma continuity_implies_RiemannInt :
  forall (f:R -&gt; R) (a b:R),
    a &lt;= b -&gt;
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt; Riemann_integrable f a b.
Proof.
  intros; destruct (total_order_T a b) as [[Hlt| -&gt; ]|Hgt];
      [ apply RiemannInt_P6; assumption | apply RiemannInt_P7
      | elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H Hgt)) ].
Qed.
Lemma RiemannInt_P8 :
  forall (f:R -&gt; R) (a b:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable f b a), RiemannInt pr1 = - RiemannInt pr2.
Proof.
  intro f; intros; eapply UL_sequence.
  { unfold RiemannInt; destruct (RiemannInt_exists pr1 RinvN RinvN_cv) as (?,HUn);
      apply HUn. }
  unfold RiemannInt; destruct (RiemannInt_exists pr2 RinvN RinvN_cv) as (?,HUn);
    intros;
    cut
      (exists psi1 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (f t - phi_sequence RinvN pr1 n t) &lt;= psi1 n t) /\
                Rabs (RiemannInt_SF (psi1 n)) &lt; RinvN n)).
  2:{ split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr1 n)). }
  cut
    (exists psi2 : nat -&gt; StepFun b a,
        (forall n:nat,
            (forall t:R,
                Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                Rabs (f t - phi_sequence RinvN pr2 n t) &lt;= psi2 n t) /\
              Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
  2:{ split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr2 n)); intro;
      rewrite Rmin_comm; rewrite RmaxSym;
      apply (proj2_sig (phi_sequence_prop RinvN pr2 n)). }
  intros; elim H; clear H; intros psi2 H; elim H0; clear H0; intros psi1 H0;
    assert (H1 := RinvN_cv); unfold Un_cv; intros;
    assert (H3 : 0 &lt; eps / 3).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  unfold Un_cv in H1; elim (H1 _ H3); clear H1; intros N0 H1;
    unfold Rdist in H1; simpl in H1;
    assert (H4 : forall n:nat, (n &gt;= N0)%nat -&gt; RinvN n &lt; eps / 3).
  { intros; assert (H5 := H1 _ H4);
      replace (pos (RinvN n)) with (Rabs (/ (INR n + 1) - 0));
      [ assumption
      | unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r; apply Rabs_right;
        left; apply (cond_pos (RinvN n)) ]. }
  clear H1; destruct (HUn _ H3) as (N1,H1);
    exists (max N0 N1); intros; unfold Rdist;
    apply Rle_lt_trans with
    (Rabs
       (RiemannInt_SF (phi_sequence RinvN pr1 n) +
          RiemannInt_SF (phi_sequence RinvN pr2 n)) +
       Rabs (RiemannInt_SF (phi_sequence RinvN pr2 n) - x)).
  { rewrite &lt;- (Rabs_Ropp (RiemannInt_SF (phi_sequence RinvN pr2 n) - x));
      replace (RiemannInt_SF (phi_sequence RinvN pr1 n) - - x) with
      (RiemannInt_SF (phi_sequence RinvN pr1 n) +
         RiemannInt_SF (phi_sequence RinvN pr2 n) +
       - (RiemannInt_SF (phi_sequence RinvN pr2 n) - x));
      [ apply Rabs_triang | ring ]. }
  replace eps with (2 * (eps / 3) + eps / 3) by lra.
  apply Rplus_lt_compat.
  2:{ unfold Rdist in H1; apply H1; unfold ge;
      apply Nat.le_trans with (max N0 N1); [ apply Nat.le_max_r | assumption ]. }
  rewrite (StepFun_P39 (phi_sequence RinvN pr2 n));
    replace
      (RiemannInt_SF (phi_sequence RinvN pr1 n) +
       - RiemannInt_SF (mkStepFun (StepFun_P6 (pre (phi_sequence RinvN pr2 n)))))
    with
    (RiemannInt_SF (phi_sequence RinvN pr1 n) +
     -1 *
        RiemannInt_SF (mkStepFun (StepFun_P6 (pre (phi_sequence RinvN pr2 n)))));
    [ idtac | ring ]; rewrite &lt;- StepFun_P30.
  destruct (Rle_dec a b) as [Hle|Hnle].
  { apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun
            (StepFun_P32
               (mkStepFun
                  (StepFun_P28 (-1) (phi_sequence RinvN pr1 n)
                               (mkStepFun (StepFun_P6 (pre (phi_sequence RinvN pr2 n))))))))).
    { apply StepFun_P34; assumption. }
    apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun
            (StepFun_P28 1 (psi1 n) (mkStepFun (StepFun_P6 (pre (psi2 n))))))).
    { apply StepFun_P37; try assumption.
      intros; simpl; rewrite Rmult_1_l;
        apply Rle_trans with
        (Rabs (phi_sequence RinvN pr1 n x0 - f x0) +
           Rabs (f x0 - phi_sequence RinvN pr2 n x0)).
      { replace (phi_sequence RinvN pr1 n x0 + -1 * phi_sequence RinvN pr2 n x0) with
          (phi_sequence RinvN pr1 n x0 - f x0 + (f x0 - phi_sequence RinvN pr2 n x0));
          [ apply Rabs_triang | ring ]. }
      assert (H7 : Rmin a b = a).
      { unfold Rmin; decide (Rle_dec a b) with Hle; reflexivity. }
      assert (H8 : Rmax a b = b).
      { unfold Rmax; decide (Rle_dec a b) with Hle; reflexivity. }
      apply Rplus_le_compat.
      { elim (H0 n); intros; rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; apply H9;
          rewrite H7; rewrite H8.
        elim H6; intros; split; left; assumption. }
      elim (H n); intros; apply H9; rewrite H7; rewrite H8.
      elim H6; intros; split; left; assumption. }
    rewrite StepFun_P30; rewrite Rmult_1_l; rewrite &lt;-Rplus_diag; apply Rplus_lt_compat.
    { elim (H0 n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n)));
        [ apply RRle_abs
        | apply Rlt_trans with (pos (RinvN n));
          [ assumption
          | apply H4; unfold ge; apply Nat.le_trans with (max N0 N1);
            [ apply Nat.le_max_l | assumption ] ] ]. }
    elim (H n); intros;
      rewrite &lt;-
              (Ropp_involutive (RiemannInt_SF (mkStepFun (StepFun_P6 (pre (psi2 n))))))
    ; rewrite &lt;- StepFun_P39;
      apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n)));
      [ rewrite &lt;- Rabs_Ropp; apply RRle_abs
      | apply Rlt_trans with (pos (RinvN n));
        [ assumption
        | apply H4; unfold ge; apply Nat.le_trans with (max N0 N1);
          [ apply Nat.le_max_l | assumption ] ] ]. }
  assert (Hyp : b &lt;= a).
  { auto with real. }
  rewrite StepFun_P39; rewrite Rabs_Ropp;
    apply Rle_lt_trans with
    (RiemannInt_SF
       (mkStepFun
          (StepFun_P32
             (mkStepFun
                (StepFun_P6
                   (StepFun_P28 (-1) (phi_sequence RinvN pr1 n)
                                (mkStepFun (StepFun_P6 (pre (phi_sequence RinvN pr2 n)))))))))).
  { apply StepFun_P34; assumption. }
  apply Rle_lt_trans with
    (RiemannInt_SF
       (mkStepFun
          (StepFun_P28 1 (mkStepFun (StepFun_P6 (pre (psi1 n)))) (psi2 n)))).
  { apply StepFun_P37; try assumption.
    intros; simpl; rewrite Rmult_1_l;
      apply Rle_trans with
      (Rabs (phi_sequence RinvN pr1 n x0 - f x0) +
         Rabs (f x0 - phi_sequence RinvN pr2 n x0)).
    { replace (phi_sequence RinvN pr1 n x0 + -1 * phi_sequence RinvN pr2 n x0) with
        (phi_sequence RinvN pr1 n x0 - f x0 + (f x0 - phi_sequence RinvN pr2 n x0));
        [ apply Rabs_triang | ring ]. }
    assert (H7 : Rmin a b = b).
    { unfold Rmin; decide (Rle_dec a b) with Hnle; reflexivity. }
    assert (H8 : Rmax a b = a).
    { unfold Rmax; decide (Rle_dec a b) with Hnle; reflexivity. }
    apply Rplus_le_compat.
    { elim (H0 n); intros; rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; apply H9;
        rewrite H7; rewrite H8.
      elim H6; intros; split; left; assumption. }
    elim (H n); intros; apply H9; rewrite H7; rewrite H8; elim H6; intros; split;
      left; assumption. }
  rewrite StepFun_P30; rewrite Rmult_1_l; rewrite &lt;-Rplus_diag; apply Rplus_lt_compat.
  { elim (H0 n); intros;
      rewrite &lt;-
              (Ropp_involutive (RiemannInt_SF (mkStepFun (StepFun_P6 (pre (psi1 n))))))
    ; rewrite &lt;- StepFun_P39;
      apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n)));
      [ rewrite &lt;- Rabs_Ropp; apply RRle_abs
      | apply Rlt_trans with (pos (RinvN n));
        [ assumption
        | apply H4; unfold ge; apply Nat.le_trans with (max N0 N1);
          [ apply Nat.le_max_l | assumption ] ] ]. }
  elim (H n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n)));
    [ apply RRle_abs
    | apply Rlt_trans with (pos (RinvN n));
      [ assumption
      | apply H4; unfold ge; apply Nat.le_trans with (max N0 N1);
        [ apply Nat.le_max_l | assumption ] ] ].
Qed.
Lemma RiemannInt_P9 :
  forall (f:R -&gt; R) (a:R) (pr:Riemann_integrable f a a), RiemannInt pr = 0.
Proof.
  intros; assert (H := RiemannInt_P8 pr pr); apply Rmult_eq_reg_l with 2;
  [ rewrite Rmult_0_r; rewrite &lt;-Rplus_diag; pattern (RiemannInt pr) at 2;
      rewrite H; apply Rplus_opp_r
      | discrR ].
Qed.
L1([a,b]) is a vectorial space
Lemma RiemannInt_P10 :
  forall (f g:R -&gt; R) (a b l:R),
    Riemann_integrable f a b -&gt;
    Riemann_integrable g a b -&gt;
    Riemann_integrable (fun x:R =&gt; f x + l * g x) a b.
Proof.
  unfold Riemann_integrable; intros f g; intros; destruct (Req_dec_T l 0) as [Heq|Hneq].
  { elim (X eps); intros x p; split with x; elim p; intros x0 p0; split with x0; elim p0;
      intros; split; try assumption; rewrite Heq; intros;
      rewrite Rmult_0_l; rewrite Rplus_0_r; apply H; assumption. }
  assert (H : 0 &lt; eps / 2).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ apply (cond_pos eps) | apply Rinv_0_lt_compat; prove_sup0 ]. }
  assert (H0 : 0 &lt; eps / (2 * Rabs l)).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ apply (cond_pos eps)
      | apply Rinv_0_lt_compat; apply Rmult_lt_0_compat;
        [ prove_sup0 | apply Rabs_pos_lt; assumption ] ]. }
  elim (X (mkposreal _ H)); intros x p; elim (X0 (mkposreal _ H0)); intros x0 p0;
    split with (mkStepFun (StepFun_P28 l x x0)); elim p0;
    elim p; intros x1 p1 x2 p2. split with (mkStepFun (StepFun_P28 (Rabs l) x1 x2));
    elim p1; elim p2; clear p1 p2 p0 p X X0; intros; split.
  { intros; simpl;
      apply Rle_trans with (Rabs (f t - x t) + Rabs (l * (g t - x0 t))).
    { replace (f t + l * g t - (x t + l * x0 t)) with
        (f t - x t + l * (g t - x0 t)); [ apply Rabs_triang | ring ]. }
    apply Rplus_le_compat;
      [ apply H3; assumption
      | rewrite Rabs_mult; apply Rmult_le_compat_l;
        [ apply Rabs_pos | apply H1; assumption ] ]. }
  rewrite StepFun_P30;
    apply Rle_lt_trans with
    (Rabs (RiemannInt_SF x1) + Rabs (Rabs l * RiemannInt_SF x2)).
  { apply Rabs_triang. }
  rewrite &lt;-(Rplus_half_diag eps); apply Rplus_lt_compat.
  { apply H4. }
  rewrite Rabs_mult; rewrite Rabs_Rabsolu; apply Rmult_lt_reg_l with (/ Rabs l).
  { apply Rinv_0_lt_compat; apply Rabs_pos_lt; assumption. }
  rewrite &lt;- Rmult_assoc; rewrite Rinv_l;
    [ rewrite Rmult_1_l;
      replace (/ Rabs l * (eps / 2)) with (eps / (2 * Rabs l));
      [ apply H2
      | unfold Rdiv; rewrite Rinv_mult; ring ]
    | apply Rabs_no_R0; assumption ].
Qed.
Lemma RiemannInt_P11 :
  forall (f:R -&gt; R) (a b l:R) (un:nat -&gt; posreal)
    (phi1 phi2 psi1 psi2:nat -&gt; StepFun a b),
    Un_cv un 0 -&gt;
    (forall n:nat,
        (forall t:R,
            Rmin a b &lt;= t &lt;= Rmax a b -&gt; Rabs (f t - phi1 n t) &lt;= psi1 n t) /\
          Rabs (RiemannInt_SF (psi1 n)) &lt; un n) -&gt;
    (forall n:nat,
        (forall t:R,
            Rmin a b &lt;= t &lt;= Rmax a b -&gt; Rabs (f t - phi2 n t) &lt;= psi2 n t) /\
          Rabs (RiemannInt_SF (psi2 n)) &lt; un n) -&gt;
    Un_cv (fun N:nat =&gt; RiemannInt_SF (phi1 N)) l -&gt;
    Un_cv (fun N:nat =&gt; RiemannInt_SF (phi2 N)) l.
Proof.
  unfold Un_cv; intro f; intros; intros.
  case (Rle_dec a b); intro Hyp.
  - assert (H4 : 0 &lt; eps / 3) by lra.
    elim (H _ H4); clear H; intros N0 H.
    elim (H2 _ H4); clear H2; intros N1 H2.
    set (N := max N0 N1); exists N; intros; unfold Rdist.
    apply Rle_lt_trans with
      (Rabs (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n)) +
         Rabs (RiemannInt_SF (phi1 n) - l)).
    { replace (RiemannInt_SF (phi2 n) - l) with
        (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n) +
           (RiemannInt_SF (phi1 n) - l)); [ apply Rabs_triang | ring ]. }
    replace eps with (2 * (eps / 3) + eps / 3) by lra.
    apply Rplus_lt_compat.
    2:{ unfold Rdist in H2; apply H2; unfold ge; apply Nat.le_trans with N;
        try assumption; unfold N; apply Nat.le_max_r. }
    replace (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n)) with
      (RiemannInt_SF (phi2 n) + -1 * RiemannInt_SF (phi1 n));
      [ idtac | ring ].
    rewrite &lt;- StepFun_P30.
    apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (phi2 n) (phi1 n)))))).
    { apply StepFun_P34; assumption. }
    apply Rle_lt_trans with
      (RiemannInt_SF (mkStepFun (StepFun_P28 1 (psi1 n) (psi2 n)))).
    { apply StepFun_P37; try assumption; intros; simpl; rewrite Rmult_1_l.
      apply Rle_trans with (Rabs (phi2 n x - f x) + Rabs (f x - phi1 n x)).
      { replace (phi2 n x + -1 * phi1 n x) with (phi2 n x - f x + (f x - phi1 n x));
          [ apply Rabs_triang | ring ]. }
      rewrite (Rplus_comm (psi1 n x)); apply Rplus_le_compat.
      { rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; elim (H1 n); intros; apply H7.
        assert (H10 : Rmin a b = a).
        { unfold Rmin; decide (Rle_dec a b) with Hyp; reflexivity. }
        assert (H11 : Rmax a b = b).
        { unfold Rmax; decide (Rle_dec a b) with Hyp; reflexivity. }
        rewrite H10; rewrite H11; elim H6; intros; split; left; assumption. }
      elim (H0 n); intros; apply H7; assert (H10 : Rmin a b = a).
      { unfold Rmin; decide (Rle_dec a b) with Hyp; reflexivity. }
      assert (H11 : Rmax a b = b).
      { unfold Rmax; decide (Rle_dec a b) with Hyp; reflexivity. }
      rewrite H10; rewrite H11; elim H6; intros; split; left; assumption. }
    rewrite StepFun_P30; rewrite Rmult_1_l; rewrite &lt;-Rplus_diag; apply Rplus_lt_compat.
    { apply Rlt_trans with (pos (un n)).
      { elim (H0 n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n))).
        { apply RRle_abs. }
        assumption. }
      replace (pos (un n)) with (Rdist (un n) 0).
      { apply H; unfold ge; apply Nat.le_trans with N; try assumption.
        unfold N; apply Nat.le_max_l. }
      unfold Rdist; unfold Rminus; rewrite Ropp_0;
        rewrite Rplus_0_r; apply Rabs_right.
      apply Rle_ge; left; apply (cond_pos (un n)). }
    apply Rlt_trans with (pos (un n)).
    { elim (H1 n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n))).
      { apply RRle_abs; assumption. }
      assumption. }
    replace (pos (un n)) with (Rdist (un n) 0).
    { apply H; unfold ge; apply Nat.le_trans with N; try assumption;
        unfold N; apply Nat.le_max_l. }
    unfold Rdist; unfold Rminus; rewrite Ropp_0;
      rewrite Rplus_0_r; apply Rabs_right; apply Rle_ge;
      left; apply (cond_pos (un n)).
  - assert (H4 : 0 &lt; eps / 3) by lra.
    elim (H _ H4); clear H; intros N0 H.
    elim (H2 _ H4); clear H2; intros N1 H2.
    set (N := max N0 N1); exists N; intros; unfold Rdist.
    apply Rle_lt_trans with
      (Rabs (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n)) +
         Rabs (RiemannInt_SF (phi1 n) - l)).
    { replace (RiemannInt_SF (phi2 n) - l) with
        (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n) +
           (RiemannInt_SF (phi1 n) - l)); [ apply Rabs_triang | ring ]. }
    assert (Hyp_b : b &lt;= a).
    { auto with real. }
    replace eps with (2 * (eps / 3) + eps / 3) by lra.
    apply Rplus_lt_compat.
    2:{ unfold Rdist in H2; apply H2; unfold ge; apply Nat.le_trans with N;
        try assumption; unfold N; apply Nat.le_max_r. }
    replace (RiemannInt_SF (phi2 n) - RiemannInt_SF (phi1 n)) with
      (RiemannInt_SF (phi2 n) + -1 * RiemannInt_SF (phi1 n));
      [ idtac | ring ].
    rewrite &lt;- StepFun_P30.
    rewrite StepFun_P39.
    rewrite Rabs_Ropp.
    apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun
            (StepFun_P32
               (mkStepFun
                  (StepFun_P6
                     (pre (mkStepFun (StepFun_P28 (-1) (phi2 n) (phi1 n))))))))).
    { apply StepFun_P34; try assumption. }
    apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun
            (StepFun_P6 (pre (mkStepFun (StepFun_P28 1 (psi1 n) (psi2 n))))))).
    { apply StepFun_P37; try assumption.
      intros; simpl; rewrite Rmult_1_l.
      apply Rle_trans with (Rabs (phi2 n x - f x) + Rabs (f x - phi1 n x)).
      { replace (phi2 n x + -1 * phi1 n x) with (phi2 n x - f x + (f x - phi1 n x));
          [ apply Rabs_triang | ring ]. }
      rewrite (Rplus_comm (psi1 n x)); apply Rplus_le_compat.
      { rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; elim (H1 n); intros; apply H7.
        assert (H10 : Rmin a b = b).
        { unfold Rmin; case (Rle_dec a b); intro;
            [ elim Hyp; assumption | reflexivity ]. }
        assert (H11 : Rmax a b = a).
        { unfold Rmax; case (Rle_dec a b); intro;
            [ elim Hyp; assumption | reflexivity ]. }
        rewrite H10; rewrite H11; elim H6; intros; split; left; assumption. }
      elim (H0 n); intros; apply H7; assert (H10 : Rmin a b = b).
      { unfold Rmin; case (Rle_dec a b); intro;
          [ elim Hyp; assumption | reflexivity ]. }
      assert (H11 : Rmax a b = a).
      { unfold Rmax; case (Rle_dec a b); intro;
          [ elim Hyp; assumption | reflexivity ]. }
      rewrite H10; rewrite H11; elim H6; intros; split; left; assumption. }
    rewrite &lt;- (Ropp_involutive (RiemannInt_SF (mkStepFun
                  (StepFun_P6 (pre (mkStepFun (StepFun_P28 1 (psi1 n) (psi2 n)))))))).
    rewrite &lt;- StepFun_P39.
    rewrite StepFun_P30.
    rewrite Rmult_1_l; rewrite &lt;-Rplus_diag.
    rewrite Ropp_plus_distr; apply Rplus_lt_compat.
    { apply Rlt_trans with (pos (un n)).
      { elim (H0 n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n))).
        { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
        assumption. }
      replace (pos (un n)) with (Rdist (un n) 0).
      { apply H; unfold ge; apply Nat.le_trans with N; try assumption.
        unfold N; apply Nat.le_max_l. }
      unfold Rdist; unfold Rminus; rewrite Ropp_0;
        rewrite Rplus_0_r; apply Rabs_right.
      apply Rle_ge; left; apply (cond_pos (un n)). }
    apply Rlt_trans with (pos (un n)).
    { elim (H1 n); intros; apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n))).
      { rewrite &lt;- Rabs_Ropp; apply RRle_abs; assumption. }
      assumption. }
    replace (pos (un n)) with (Rdist (un n) 0).
    { apply H; unfold ge; apply Nat.le_trans with N; try assumption;
        unfold N; apply Nat.le_max_l. }
    unfold Rdist; unfold Rminus; rewrite Ropp_0;
      rewrite Rplus_0_r; apply Rabs_right; apply Rle_ge;
      left; apply (cond_pos (un n)).
Qed.
Lemma RiemannInt_P12 :
  forall (f g:R -&gt; R) (a b l:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable g a b)
    (pr3:Riemann_integrable (fun x:R =&gt; f x + l * g x) a b),
    a &lt;= b -&gt; RiemannInt pr3 = RiemannInt pr1 + l * RiemannInt pr2.
Proof.
  intro f; intros; case (Req_dec l 0); intro.
  { pattern l at 2; rewrite H0; rewrite Rmult_0_l; rewrite Rplus_0_r;
      unfold RiemannInt; destruct (RiemannInt_exists pr3 RinvN RinvN_cv) as (?,HUn_cv);
      destruct (RiemannInt_exists pr1 RinvN RinvN_cv) as (?,HUn_cv0); intros.
    eapply UL_sequence;
      [ apply HUn_cv
      | set (psi1 := fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n));
        set (psi2 := fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr3 n));
        apply RiemannInt_P11 with f RinvN (phi_sequence RinvN pr1) psi1 psi2;
        [ apply RinvN_cv
        | intro; apply (proj2_sig (phi_sequence_prop RinvN pr1 n))
        | intro;
          assert
            (H1 :
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (f t + l * g t - phi_sequence RinvN pr3 n t) &lt;= psi2 n t) /\
                Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n);
          [ apply (proj2_sig (phi_sequence_prop RinvN pr3 n))
          | elim H1; intros; split; try assumption; intros;
            replace (f t) with (f t + l * g t);
            [ apply H2; assumption | rewrite H0; ring ] ]
        | assumption ] ]. }
  eapply UL_sequence.
  { unfold RiemannInt; destruct (RiemannInt_exists pr3 RinvN RinvN_cv) as (?,HUn_cv);
      intros; apply HUn_cv. }
  unfold Un_cv; intros; unfold RiemannInt;
    case (RiemannInt_exists pr1 RinvN RinvN_cv) as (x0,HUn_cv0);
    case (RiemannInt_exists pr2 RinvN RinvN_cv) as (x,HUn_cv); unfold Un_cv;
    intros; assert (H2 : 0 &lt; eps / 5).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  elim (HUn_cv0 _ H2); clear HUn_cv0; intros N0 H3; assert (H4 := RinvN_cv);
    unfold Un_cv in H4; elim (H4 _ H2); clear H4 H2; intros N1 H4;
    assert (H5 : 0 &lt; eps / (5 * Rabs l)).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption
      | apply Rinv_0_lt_compat; apply Rmult_lt_0_compat;
        [ prove_sup0 | apply Rabs_pos_lt; assumption ] ]. }
  elim (HUn_cv _ H5); clear HUn_cv; intros N2 H6; assert (H7 := RinvN_cv);
    unfold Un_cv in H7; elim (H7 _ H5); clear H7 H5; intros N3 H5;
    unfold Rdist in H3, H4, H5, H6; set (N := max (max N0 N1) (max N2 N3)).
  assert (H7 : forall n:nat, (n &gt;= N1)%nat -&gt; RinvN n &lt; eps / 5).
  { intros; replace (pos (RinvN n)) with (Rabs (RinvN n - 0));
      [ unfold RinvN; apply H4; assumption
      | unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r; apply Rabs_right;
        left; apply (cond_pos (RinvN n)) ]. }
  clear H4; assert (H4 := H7); clear H7;
    assert (H7 : forall n:nat, (n &gt;= N3)%nat -&gt; RinvN n &lt; eps / (5 * Rabs l)).
  { intros; replace (pos (RinvN n)) with (Rabs (RinvN n - 0));
      [ unfold RinvN; apply H5; assumption
      | unfold Rminus; rewrite Ropp_0; rewrite Rplus_0_r; apply Rabs_right;
        left; apply (cond_pos (RinvN n)) ]. }
  clear H5; assert (H5 := H7); clear H7; exists N; intros;
    unfold Rdist.
  apply Rle_lt_trans with
    (Rabs
       (RiemannInt_SF (phi_sequence RinvN pr3 n) -
          (RiemannInt_SF (phi_sequence RinvN pr1 n) +
             l * RiemannInt_SF (phi_sequence RinvN pr2 n))) +
       Rabs (RiemannInt_SF (phi_sequence RinvN pr1 n) - x0) +
       Rabs l * Rabs (RiemannInt_SF (phi_sequence RinvN pr2 n) - x)).
  { apply Rle_trans with
      (Rabs
         (RiemannInt_SF (phi_sequence RinvN pr3 n) -
            (RiemannInt_SF (phi_sequence RinvN pr1 n) +
               l * RiemannInt_SF (phi_sequence RinvN pr2 n))) +
         Rabs
           (RiemannInt_SF (phi_sequence RinvN pr1 n) - x0 +
              l * (RiemannInt_SF (phi_sequence RinvN pr2 n) - x))).
    { replace (RiemannInt_SF (phi_sequence RinvN pr3 n) - (x0 + l * x)) with
        (RiemannInt_SF (phi_sequence RinvN pr3 n) -
           (RiemannInt_SF (phi_sequence RinvN pr1 n) +
              l * RiemannInt_SF (phi_sequence RinvN pr2 n)) +
           (RiemannInt_SF (phi_sequence RinvN pr1 n) - x0 +
              l * (RiemannInt_SF (phi_sequence RinvN pr2 n) - x)));
        [ apply Rabs_triang | ring ]. }
    rewrite Rplus_assoc; apply Rplus_le_compat_l; rewrite &lt;- Rabs_mult;
      replace
        (RiemannInt_SF (phi_sequence RinvN pr1 n) - x0 +
           l * (RiemannInt_SF (phi_sequence RinvN pr2 n) - x)) with
      (RiemannInt_SF (phi_sequence RinvN pr1 n) - x0 +
         l * (RiemannInt_SF (phi_sequence RinvN pr2 n) - x));
      [ apply Rabs_triang | ring ]. }
  replace eps with (3 * (eps / 5) + eps / 5 + eps / 5) by lra.
  apply Rplus_lt_compat.
  2:{ apply Rmult_lt_reg_l with (/ Rabs l).
      { apply Rinv_0_lt_compat; apply Rabs_pos_lt; assumption. }
      rewrite &lt;- Rmult_assoc; rewrite Rinv_l.
      2:apply Rabs_no_R0; assumption.
      rewrite Rmult_1_l; replace (/ Rabs l * (eps / 5)) with (eps / (5 * Rabs l)).
      { apply H6; unfold ge; apply Nat.le_trans with (max N2 N3);
          [ apply Nat.le_max_l
          | apply Nat.le_trans with N; [ unfold N; apply Nat.le_max_r | assumption ] ]. }
      unfold Rdiv; rewrite Rinv_mult; ring. }
  apply Rplus_lt_compat.
  2:apply H3;Lia.lia.
  assert
    (H7 :
      exists psi1 : nat -&gt; StepFun a b,
        (forall n:nat,
            (forall t:R,
                Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                Rabs (f t - phi_sequence RinvN pr1 n t) &lt;= psi1 n t) /\
              Rabs (RiemannInt_SF (psi1 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr1 n0)). }
  assert
    (H8 :
      exists psi2 : nat -&gt; StepFun a b,
        (forall n:nat,
            (forall t:R,
                Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                Rabs (g t - phi_sequence RinvN pr2 n t) &lt;= psi2 n t) /\
              Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr2 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr2 n0)). }
  assert
    (H9 :
      exists psi3 : nat -&gt; StepFun a b,
        (forall n:nat,
            (forall t:R,
                Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                Rabs (f t + l * g t - phi_sequence RinvN pr3 n t) &lt;= psi3 n t) /\
              Rabs (RiemannInt_SF (psi3 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr3 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr3 n0)). }
  elim H7; clear H7; intros psi1 H7; elim H8; clear H8; intros psi2 H8; elim H9;
    clear H9; intros psi3 H9;
    replace
      (RiemannInt_SF (phi_sequence RinvN pr3 n) -
         (RiemannInt_SF (phi_sequence RinvN pr1 n) +
            l * RiemannInt_SF (phi_sequence RinvN pr2 n))) with
    (RiemannInt_SF (phi_sequence RinvN pr3 n) +
     -1 *
        (RiemannInt_SF (phi_sequence RinvN pr1 n) +
           l * RiemannInt_SF (phi_sequence RinvN pr2 n)));
    [ idtac | ring ]; do 2 rewrite &lt;- StepFun_P30; assert (H10 : Rmin a b = a).
  { unfold Rmin; decide (Rle_dec a b) with H; reflexivity. }
  assert (H11 : Rmax a b = b).
  { unfold Rmax; decide (Rle_dec a b) with H; reflexivity. }
  rewrite H10 in H7; rewrite H10 in H8; rewrite H10 in H9; rewrite H11 in H7;
    rewrite H11 in H8; rewrite H11 in H9;
    apply Rle_lt_trans with
    (RiemannInt_SF
       (mkStepFun
          (StepFun_P32
             (mkStepFun
                (StepFun_P28 (-1) (phi_sequence RinvN pr3 n)
                             (mkStepFun
                                (StepFun_P28 l (phi_sequence RinvN pr1 n)
                                             (phi_sequence RinvN pr2 n)))))))).
  { apply StepFun_P34; assumption. }
  apply Rle_lt_trans with
    (RiemannInt_SF
       (mkStepFun
          (StepFun_P28 1 (psi3 n)
                       (mkStepFun (StepFun_P28 (Rabs l) (psi1 n) (psi2 n)))))).
  { apply StepFun_P37; try assumption.
    intros; simpl; rewrite Rmult_1_l.
    apply Rle_trans with
      (Rabs (phi_sequence RinvN pr3 n x1 - (f x1 + l * g x1)) +
         Rabs
           (f x1 + l * g x1 +
            -1 * (phi_sequence RinvN pr1 n x1 + l * phi_sequence RinvN pr2 n x1))).
    { replace
        (phi_sequence RinvN pr3 n x1 +
         -1 * (phi_sequence RinvN pr1 n x1 + l * phi_sequence RinvN pr2 n x1)) with
        (phi_sequence RinvN pr3 n x1 - (f x1 + l * g x1) +
           (f x1 + l * g x1 +
            -1 * (phi_sequence RinvN pr1 n x1 + l * phi_sequence RinvN pr2 n x1)));
        [ apply Rabs_triang | ring ]. }
    rewrite Rplus_assoc; apply Rplus_le_compat.
    { elim (H9 n); intros; rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr;
        apply H13.
      elim H12; intros; split; left; assumption. }
    apply Rle_trans with
      (Rabs (f x1 - phi_sequence RinvN pr1 n x1) +
         Rabs l * Rabs (g x1 - phi_sequence RinvN pr2 n x1)).
    { rewrite &lt;- Rabs_mult;
        replace
          (f x1 +
             (l * g x1 +
              -1 * (phi_sequence RinvN pr1 n x1 + l * phi_sequence RinvN pr2 n x1)))
        with
        (f x1 - phi_sequence RinvN pr1 n x1 +
           l * (g x1 - phi_sequence RinvN pr2 n x1)); [ apply Rabs_triang | ring ]. }
    apply Rplus_le_compat.
    { elim (H7 n); intros; apply H13.
      elim H12; intros; split; left; assumption. }
    apply Rmult_le_compat_l;
      [ apply Rabs_pos
      | elim (H8 n); intros; apply H13; elim H12; intros; split; left; assumption ]. }
  do 2 rewrite StepFun_P30; rewrite Rmult_1_l;
  replace (3 * (eps / 5)) with (eps / 5 + (eps / 5 + eps / 5)) by ring.
  repeat apply Rplus_lt_compat.
  - apply Rlt_trans with (pos (RinvN n));
      [ apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi3 n)));
        [ apply RRle_abs | elim (H9 n); intros; assumption ]
      | apply H4; unfold ge; apply Nat.le_trans with N;
        [ apply Nat.le_trans with (max N0 N1);
          [ apply Nat.le_max_r | unfold N; apply Nat.le_max_l ]
        | assumption ] ].
  - apply Rlt_trans with (pos (RinvN n));
      [ apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n)));
        [ apply RRle_abs | elim (H7 n); intros; assumption ]
      | apply H4; unfold ge; apply Nat.le_trans with N;
        [ apply Nat.le_trans with (max N0 N1);
          [ apply Nat.le_max_r | unfold N; apply Nat.le_max_l ]
        | assumption ] ].
  - apply Rmult_lt_reg_l with (/ Rabs l).
    { apply Rinv_0_lt_compat; apply Rabs_pos_lt; assumption. }
    rewrite &lt;- Rmult_assoc; rewrite Rinv_l.
    { rewrite Rmult_1_l; replace (/ Rabs l * (eps / 5)) with (eps / (5 * Rabs l)).
      { apply Rlt_trans with (pos (RinvN n));
          [ apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n)));
            [ apply RRle_abs | elim (H8 n); intros; assumption ]
          | apply H5; unfold ge; apply Nat.le_trans with N;
            [ apply Nat.le_trans with (max N2 N3);
              [ apply Nat.le_max_r | unfold N; apply Nat.le_max_r ]
            | assumption ] ]. }
      unfold Rdiv; rewrite Rinv_mult; ring. }
    apply Rabs_no_R0; assumption.
Qed.
Lemma RiemannInt_P13 :
  forall (f g:R -&gt; R) (a b l:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable g a b)
    (pr3:Riemann_integrable (fun x:R =&gt; f x + l * g x) a b),
    RiemannInt pr3 = RiemannInt pr1 + l * RiemannInt pr2.
Proof.
  intros; destruct (Rle_dec a b) as [Hle|Hnle];
    [ apply RiemannInt_P12; assumption
      | assert (H : b &lt;= a);
        [ auto with real
          | replace (RiemannInt pr3) with (- RiemannInt (RiemannInt_P1 pr3));
            [ idtac | symmetry ; apply RiemannInt_P8 ];
            replace (RiemannInt pr2) with (- RiemannInt (RiemannInt_P1 pr2));
            [ idtac | symmetry ; apply RiemannInt_P8 ];
            replace (RiemannInt pr1) with (- RiemannInt (RiemannInt_P1 pr1));
            [ idtac | symmetry ; apply RiemannInt_P8 ];
            rewrite
              (RiemannInt_P12 (RiemannInt_P1 pr1) (RiemannInt_P1 pr2)
                (RiemannInt_P1 pr3) H); ring ] ].
Qed.
Lemma RiemannInt_P14 : forall a b c:R, Riemann_integrable (fct_cte c) a b.
Proof.
  unfold Riemann_integrable; intros;
    split with (mkStepFun (StepFun_P4 a b c));
      split with (mkStepFun (StepFun_P4 a b 0)); split;
        [ intros; simpl; unfold Rminus; rewrite Rplus_opp_r;
          rewrite Rabs_R0; unfold fct_cte; right;
            reflexivity
          | rewrite StepFun_P18; rewrite Rmult_0_l; rewrite Rabs_R0;
            apply (cond_pos eps) ].
Qed.
Lemma RiemannInt_P15 :
  forall (a b c:R) (pr:Riemann_integrable (fct_cte c) a b),
    RiemannInt pr = c * (b - a).
Proof.
  intros; unfold RiemannInt; destruct (RiemannInt_exists pr RinvN RinvN_cv) as (?,HUn_cv);
    intros; eapply UL_sequence.
  { apply HUn_cv. }
  set (phi1 := fun N:nat =&gt; phi_sequence RinvN pr N);
    change (Un_cv (fun N:nat =&gt; RiemannInt_SF (phi1 N)) (c * (b - a)));
    set (f := fct_cte c);
    assert
      (H1 :
        exists psi1 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (f t - phi_sequence RinvN pr n t) &lt;= psi1 n t) /\
                Rabs (RiemannInt_SF (psi1 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr n)). }
  elim H1; clear H1; intros psi1 H1;
    set (phi2 := fun n:nat =&gt; mkStepFun (StepFun_P4 a b c));
    set (psi2 := fun n:nat =&gt; mkStepFun (StepFun_P4 a b 0));
    apply RiemannInt_P11 with f RinvN phi2 psi2 psi1.
  - apply RinvN_cv.
  - intro; split.
    { intros; unfold f; simpl; unfold Rminus;
        rewrite Rplus_opp_r; rewrite Rabs_R0; unfold fct_cte;
        right; reflexivity. }
    unfold psi2; rewrite StepFun_P18; rewrite Rmult_0_l; rewrite Rabs_R0;
      apply (cond_pos (RinvN n)).
  - assumption.
  - unfold Un_cv; intros; split with 0%nat; intros; unfold Rdist;
    unfold phi2; rewrite StepFun_P18; unfold Rminus;
    rewrite Rplus_opp_r; rewrite Rabs_R0; apply H.
Qed.
Lemma RiemannInt_P16 :
  forall (f:R -&gt; R) (a b:R),
    Riemann_integrable f a b -&gt; Riemann_integrable (fun x:R =&gt; Rabs (f x)) a b.
Proof.
  unfold Riemann_integrable; intro f; intros; elim (X eps); clear X;
    intros phi [psi [H H0]]; split with (mkStepFun (StepFun_P32 phi));
      split with psi; split; try assumption; intros; simpl;
        apply Rle_trans with (Rabs (f t - phi t));
          [ apply Rabs_triang_inv2 | apply H; assumption ].
Qed.
Lemma Rle_cv_lim :
  forall (Un Vn:nat -&gt; R) (l1 l2:R),
    (forall n:nat, Un n &lt;= Vn n) -&gt; Un_cv Un l1 -&gt; Un_cv Vn l2 -&gt; l1 &lt;= l2.
Proof.
  intros; destruct (Rle_dec l1 l2) as [Hle|Hnle].
  { assumption. }
  assert (H2 : l2 &lt; l1).
  { auto with real. }
  assert (H3 : 0 &lt; (l1 - l2) / 2).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ apply Rlt_0_minus; assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  elim (H1 _ H3); elim (H0 _ H3); clear H0 H1; unfold Rdist; intros;
    set (N := max x x0); cut (Vn N &lt; Un N).
  { intro; elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ (H N) H4)). }
  apply Rlt_trans with ((l1 + l2) / 2).
  { apply Rplus_lt_reg_l with (- l2);
      replace (- l2 + (l1 + l2) / 2) with ((l1 - l2) / 2).
    { rewrite Rplus_comm; apply Rle_lt_trans with (Rabs (Vn N - l2)).
      { apply RRle_abs. }
      apply H1; unfold ge; unfold N; apply Nat.le_max_r. }
    lra. }
  apply Ropp_lt_cancel; apply Rplus_lt_reg_l with l1;
    replace (l1 + - ((l1 + l2) / 2)) with ((l1 - l2) / 2).
  { apply Rle_lt_trans with (Rabs (Un N - l1)).
    { rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; apply RRle_abs. }
    apply H0; unfold ge; unfold N; apply Nat.le_max_l. }
  lra.
Qed.
Lemma RiemannInt_P17 :
  forall (f:R -&gt; R) (a b:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable (fun x:R =&gt; Rabs (f x)) a b),
    a &lt;= b -&gt; Rabs (RiemannInt pr1) &lt;= RiemannInt pr2.
Proof.
  intro f; intros; unfold RiemannInt;
    case (RiemannInt_exists pr1 RinvN RinvN_cv) as (x0,HUn_cv0);
    case (RiemannInt_exists pr2 RinvN RinvN_cv) as (x,HUn_cv);
    set (phi1 := phi_sequence RinvN pr1) in HUn_cv0;
    set (phi2 := fun N:nat =&gt; mkStepFun (StepFun_P32 (phi1 N)));
    apply Rle_cv_lim with
    (fun N:nat =&gt; Rabs (RiemannInt_SF (phi1 N)))
    (fun N:nat =&gt; RiemannInt_SF (phi2 N)).
  { intro; unfold phi2; apply StepFun_P34; assumption. }
  { apply (continuity_seq Rabs (fun N:nat =&gt; RiemannInt_SF (phi1 N)) x0);
      try assumption.
    apply Rcontinuity_abs. }
  set (phi3 := phi_sequence RinvN pr2);
    assert
      (H0 :
        exists psi3 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (Rabs (f t) - phi3 n t) &lt;= psi3 n t) /\
                Rabs (RiemannInt_SF (psi3 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr2 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr2 n)). }
  assert
    (H1 :
      exists psi2 : nat -&gt; StepFun a b,
        (forall n:nat,
            (forall t:R,
                Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                Rabs (Rabs (f t) - phi2 n t) &lt;= psi2 n t) /\
              Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
  { assert
      (H1 :
        exists psi2 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt; Rabs (f t - phi1 n t) &lt;= psi2 n t) /\
                Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
    { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n)); intro;
        apply (proj2_sig (phi_sequence_prop RinvN pr1 n)). }
    elim H1; clear H1; intros psi2 H1; split with psi2; intros; elim (H1 n);
      clear H1; intros; split; try assumption.
    intros; unfold phi2; simpl;
      apply Rle_trans with (Rabs (f t - phi1 n t)).
    { apply Rabs_triang_inv2. }
    apply H1; assumption. }
  elim H0; clear H0; intros psi3 H0; elim H1; clear H1; intros psi2 H1;
    apply RiemannInt_P11 with (fun x:R =&gt; Rabs (f x)) RinvN phi3 psi3 psi2;
    try assumption; apply RinvN_cv.
Qed.
Lemma RiemannInt_P18 :
  forall (f g:R -&gt; R) (a b:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable g a b),
    a &lt;= b -&gt;
    (forall x:R, a &lt; x &lt; b -&gt; f x = g x) -&gt; RiemannInt pr1 = RiemannInt pr2.
Proof.
  intro f; intros; unfold RiemannInt;
    case (RiemannInt_exists pr1 RinvN RinvN_cv) as (x0,HUn_cv0);
    case (RiemannInt_exists pr2 RinvN RinvN_cv) as (x,HUn_cv);
    eapply UL_sequence.
  { apply HUn_cv0. }
  set (phi1 := fun N:nat =&gt; phi_sequence RinvN pr1 N);
    change (Un_cv (fun N:nat =&gt; RiemannInt_SF (phi1 N)) x);
    assert
      (H1 :
        exists psi1 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (f t - phi1 n t) &lt;= psi1 n t) /\
                Rabs (RiemannInt_SF (psi1 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr1 n)). }
  elim H1; clear H1; intros psi1 H1;
    set (phi2 := fun N:nat =&gt; phi_sequence RinvN pr2 N).
  set
    (phi2_aux :=
       fun (N:nat) (x:R) =&gt;
         match Req_dec_T x a with
         | left _ =&gt; f a
         | right _ =&gt;
             match Req_dec_T x b with
             | left _ =&gt; f b
             | right _ =&gt; phi2 N x
             end
         end).
  cut (forall N:nat, IsStepFun (phi2_aux N) a b).
  { intro; set (phi2_m := fun N:nat =&gt; mkStepFun (X N)).
    assert
      (H2 :
        exists psi2 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt; Rabs (g t - phi2 n t) &lt;= psi2 n t) /\
                Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
    { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr2 n)); intro;
        apply (proj2_sig (phi_sequence_prop RinvN pr2 n)). }
    elim H2; clear H2; intros psi2 H2;
      apply RiemannInt_P11 with f RinvN phi2_m psi2 psi1;
      try assumption.
    - apply RinvN_cv.
    - intro; elim (H2 n); intros; split; try assumption.
      intros; unfold phi2_m; simpl; unfold phi2_aux;
        destruct (Req_dec_T t a) as [Heqa|Hneqa]; destruct (Req_dec_T t b) as [Heqb|Hneqb].
      + rewrite Heqa; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
          apply Rle_trans with (Rabs (g t - phi2 n t)).
        { apply Rabs_pos. }
        pattern a at 3; rewrite &lt;- Heqa; apply H3; assumption.
      + rewrite Heqa; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
          apply Rle_trans with (Rabs (g t - phi2 n t)).
        { apply Rabs_pos. }
        pattern a at 3; rewrite &lt;- Heqa; apply H3; assumption.
      + rewrite Heqb; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
          apply Rle_trans with (Rabs (g t - phi2 n t)).
        { apply Rabs_pos. }
        pattern b at 3; rewrite &lt;- Heqb; apply H3; assumption.
      + replace (f t) with (g t).
        { apply H3; assumption. }
        symmetry ; apply H0; elim H5; clear H5; intros.
        assert (H7 : Rmin a b = a).
        { unfold Rmin; destruct (Rle_dec a b) as [Heqab|Hneqab];
            [ reflexivity | elim Hneqab; assumption ]. }
        assert (H8 : Rmax a b = b).
        { unfold Rmax; destruct (Rle_dec a b) as [Heqab|Hneqab];
            [ reflexivity | elim Hneqab; assumption ]. }
        rewrite H7 in H5; rewrite H8 in H6; split.
        { elim H5; intro; [ assumption | elim Hneqa; symmetry ; assumption ]. }
        elim H6; intro; [ assumption | elim Hneqb; assumption ].
    - cut (forall N:nat, RiemannInt_SF (phi2_m N) = RiemannInt_SF (phi2 N)).
      { intro; unfold Un_cv; intros; elim (HUn_cv _ H4); intros; exists x1; intros;
          rewrite (H3 n); apply H5; assumption. }
      intro; apply Rle_antisym.
      { apply StepFun_P37; try assumption.
        intros; unfold phi2_m; simpl; unfold phi2_aux;
          destruct (Req_dec_T x1 a) as [Heqa|Hneqa]; destruct (Req_dec_T x1 b) as [Heqb|Hneqb].
        + elim H3; intros; rewrite Heqa in H4; elim (Rlt_irrefl _ H4).
        + elim H3; intros; rewrite Heqa in H4; elim (Rlt_irrefl _ H4).
        + elim H3; intros; rewrite Heqb in H5; elim (Rlt_irrefl _ H5).
        + right; reflexivity. }
      apply StepFun_P37; try assumption.
      intros; unfold phi2_m; simpl; unfold phi2_aux;
        destruct (Req_dec_T x1 a) as [ -&gt; |Hneqa].
      { elim H3; intros; elim (Rlt_irrefl _ H4). }
      destruct (Req_dec_T x1 b) as [ -&gt; |Hneqb].
      { elim H3; intros; elim (Rlt_irrefl _ H5). }
      right; reflexivity. }
  intro; assert (H2 := pre (phi2 N)); unfold IsStepFun in H2;
    unfold is_subdivision in H2; elim H2; clear H2; intros l [lf H2];
    split with l; split with lf; unfold adapted_couple in H2;
    decompose [and] H2; clear H2; unfold adapted_couple;
    repeat split; try assumption.
  intros; assert (H9 := H8 i H2); unfold constant_D_eq, open_interval in H9;
    unfold constant_D_eq, open_interval; intros;
    rewrite &lt;- (H9 x1 H7); assert (H10 : a &lt;= pos_Rl l i).
  { replace a with (Rmin a b).
    { rewrite &lt;- H5; elim (RList_P6 l); intros; apply H10.
      - assumption.
      - apply Nat.le_0_l.
      - apply Nat.lt_trans with (pred (length l)); [ assumption | apply Nat.lt_pred_l ].
        intro; rewrite H12 in H6; discriminate. }
    unfold Rmin; decide (Rle_dec a b) with H; reflexivity. }
  assert (H11 : pos_Rl l (S i) &lt;= b).
  { replace b with (Rmax a b).
    { rewrite &lt;- H4; elim (RList_P6 l); intros; apply H11.
      - assumption.
      - apply Nat.le_succ_l; assumption.
      - apply Nat.lt_pred_l; intro; rewrite H13 in H6; discriminate. }
    unfold Rmax; decide (Rle_dec a b) with H; reflexivity. }
  elim H7; clear H7; intros; unfold phi2_aux; destruct (Req_dec_T x1 a) as [Heq|Hneq];
    destruct (Req_dec_T x1 b) as [Heq'|Hneq'].
  - rewrite Heq' in H12; elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H11 H12)).
  - rewrite Heq in H7; elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H10 H7)).
  - rewrite Heq' in H12; elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ H11 H12)).
  - reflexivity.
Qed.
Lemma RiemannInt_P19 :
  forall (f g:R -&gt; R) (a b:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable g a b),
    a &lt;= b -&gt;
    (forall x:R, a &lt; x &lt; b -&gt; f x &lt;= g x) -&gt; RiemannInt pr1 &lt;= RiemannInt pr2.
Proof.
  intro f; intros; apply Rplus_le_reg_l with (- RiemannInt pr1);
    rewrite Rplus_opp_l; rewrite Rplus_comm;
    apply Rle_trans with (Rabs (RiemannInt (RiemannInt_P10 (-1) pr2 pr1))).
  { apply Rabs_pos. }
  replace (RiemannInt pr2 + - RiemannInt pr1) with
    (RiemannInt (RiemannInt_P16 (RiemannInt_P10 (-1) pr2 pr1))).
  { apply
      (RiemannInt_P17 (RiemannInt_P10 (-1) pr2 pr1)
                      (RiemannInt_P16 (RiemannInt_P10 (-1) pr2 pr1)));
      assumption. }
  replace (RiemannInt pr2 + - RiemannInt pr1) with
    (RiemannInt (RiemannInt_P10 (-1) pr2 pr1)).
  { apply RiemannInt_P18; try assumption.
    intros; apply Rabs_right.
    apply Rle_ge; apply Rplus_le_reg_l with (f x); rewrite Rplus_0_r;
      replace (f x + (g x + -1 * f x)) with (g x); [ apply H0; assumption | ring ]. }
  rewrite (RiemannInt_P12 pr2 pr1 (RiemannInt_P10 (-1) pr2 pr1));
    [ ring | assumption ].
Qed.
Lemma FTC_P1 :
  forall (f:R -&gt; R) (a b:R),
    a &lt;= b -&gt;
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt;
    forall x:R, a &lt;= x -&gt; x &lt;= b -&gt; Riemann_integrable f a x.
Proof.
  intros; apply continuity_implies_RiemannInt;
    [ assumption
      | intros; apply H0; elim H3; intros; split;
        assumption || apply Rle_trans with x; assumption ].
Qed.
Definition primitive (f:R -&gt; R) (a b:R) (h:a &lt;= b)
  (pr:forall x:R, a &lt;= x -&gt; x &lt;= b -&gt; Riemann_integrable f a x)
  (x:R) : R :=
  match Rle_dec a x with
    | left r =&gt;
      match Rle_dec x b with
        | left r0 =&gt; RiemannInt (pr x r r0)
        | right _ =&gt; f b * (x - b) + RiemannInt (pr b h (Rle_refl b))
      end
    | right _ =&gt; f a * (x - a)
  end.
Lemma RiemannInt_P20 :
  forall (f:R -&gt; R) (a b:R) (h:a &lt;= b)
    (pr:forall x:R, a &lt;= x -&gt; x &lt;= b -&gt; Riemann_integrable f a x)
    (pr0:Riemann_integrable f a b),
    RiemannInt pr0 = primitive h pr b - primitive h pr a.
Proof.
  intros; replace (primitive h pr a) with 0.
  { replace (RiemannInt pr0) with (primitive h pr b).
    { ring. }
    unfold primitive; destruct (Rle_dec a b) as [Hle|[]]; destruct (Rle_dec b b) as [Hle'|Hnle'];
      [ apply RiemannInt_P5
      | destruct Hnle'; right; reflexivity
      | assumption
      | assumption]. }
  symmetry ; unfold primitive; destruct (Rle_dec a a) as [Hle|[]];
    destruct (Rle_dec a b) as [Hle'|Hnle'];
    [ apply RiemannInt_P9
    | elim Hnle'; assumption
    | right; reflexivity
    | right; reflexivity ].
Qed.
Lemma RiemannInt_P21 :
  forall (f:R -&gt; R) (a b c:R),
    a &lt;= b -&gt;
    b &lt;= c -&gt;
    Riemann_integrable f a b -&gt;
    Riemann_integrable f b c -&gt; Riemann_integrable f a c.
Proof.
  unfold Riemann_integrable; intros f a b c Hyp1 Hyp2 X X0 eps.
  assert (H : 0 &lt; eps / 2).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ apply (cond_pos eps) | apply Rinv_0_lt_compat; prove_sup0 ]. }
  elim (X (mkposreal _ H)); clear X; intros phi1 [psi1 H1];
    elim (X0 (mkposreal _ H)); clear X0; intros phi2 [psi2 H2].
  set
    (phi3 :=
       fun x:R =&gt;
         match Rle_dec a x with
         | left _ =&gt;
             match Rle_dec x b with
             | left _ =&gt; phi1 x
             | right _ =&gt; phi2 x
             end
         | right _ =&gt; 0
         end).
  set
    (psi3 :=
       fun x:R =&gt;
         match Rle_dec a x with
         | left _ =&gt;
             match Rle_dec x b with
             | left _ =&gt; psi1 x
             | right _ =&gt; psi2 x
             end
         | right _ =&gt; 0
         end).
  cut (IsStepFun phi3 a c).
  1:intro; cut (IsStepFun psi3 a b).
  1:intro; cut (IsStepFun psi3 b c).
  1:intro; assert (IsStepFun psi3 a c) by (apply StepFun_P46 with b; assumption).
  - split with (mkStepFun X); split with (mkStepFun X2); simpl;
      split.
    + intros; unfold phi3, psi3; case (Rle_dec t b) as [|Hnle]; case (Rle_dec a t) as [|Hnle'].
      * elim H1; intros; apply H3.
        replace (Rmin a b) with a.
        { replace (Rmax a b) with b.
          { split; assumption. }
          unfold Rmax; decide (Rle_dec a b) with Hyp1; reflexivity. }
        unfold Rmin; decide (Rle_dec a b) with Hyp1; reflexivity.
      * elim Hnle'; replace a with (Rmin a c).
        { elim H0; intros; assumption. }
        unfold Rmin; case (Rle_dec a c) as [|[]];
          [ reflexivity | apply Rle_trans with b; assumption ].
      * elim H2; intros; apply H3.
        replace (Rmax b c) with (Rmax a c).
        { elim H0; intros; split; try assumption.
          replace (Rmin b c) with b.
          { auto with real. }
          unfold Rmin; decide (Rle_dec b c) with Hyp2; reflexivity. }
        unfold Rmax; decide (Rle_dec b c) with Hyp2; case (Rle_dec a c) as [|[]];
          [ reflexivity | apply Rle_trans with b; assumption ].
      * elim Hnle'; replace a with (Rmin a c).
        { elim H0; intros; assumption. }
        unfold Rmin; case (Rle_dec a c) as [|[]];
          [ reflexivity | apply Rle_trans with b; assumption ].
    + rewrite &lt;- (StepFun_P43 X0 X1 X2).
      apply Rle_lt_trans with
        (Rabs (RiemannInt_SF (mkStepFun X0)) + Rabs (RiemannInt_SF (mkStepFun X1))).
      { apply Rabs_triang. }
      rewrite &lt;-(Rplus_half_diag eps);
        replace (RiemannInt_SF (mkStepFun X0)) with (RiemannInt_SF psi1).
      { replace (RiemannInt_SF (mkStepFun X1)) with (RiemannInt_SF psi2).
        { apply Rplus_lt_compat.
          { elim H1; intros; assumption. }
          elim H2; intros; assumption. }
        apply Rle_antisym.
        { apply StepFun_P37; try assumption.
          simpl; intros; unfold psi3; elim H0; clear H0; intros;
            destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle'];
            [ elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H0))
            | right; reflexivity
            | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ]
            | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ] ]. }
        apply StepFun_P37; try assumption.
        simpl; intros; unfold psi3; elim H0; clear H0; intros;
          destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle'];
          [ elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H0))
          | right; reflexivity
          | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ]
          | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ] ]. }
      apply Rle_antisym.
      { apply StepFun_P37; try assumption.
        simpl; intros; unfold psi3; elim H0; clear H0; intros;
          destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle'];
          [ right; reflexivity
          | elim Hnle'; left; assumption
          | elim Hnle; left; assumption
          | elim Hnle; left; assumption ]. }
      apply StepFun_P37; try assumption.
      simpl; intros; unfold psi3; elim H0; clear H0; intros;
        destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle'];
        [ right; reflexivity
        | elim Hnle'; left; assumption
        | elim Hnle; left; assumption
        | elim Hnle; left; assumption ].
  - assert (H3 := pre psi2); unfold IsStepFun in H3; unfold is_subdivision in H3;
      elim H3; clear H3; intros l1 [lf1 H3]; split with l1;
      split with lf1; unfold adapted_couple in H3; decompose [and] H3;
      clear H3; unfold adapted_couple; repeat split;
      try assumption.
    intros; assert (H9 := H8 i H3); unfold constant_D_eq, open_interval;
      unfold constant_D_eq, open_interval in H9; intros;
      rewrite &lt;- (H9 x H7); unfold psi3; assert (H10 : b &lt; x).
    { apply Rle_lt_trans with (pos_Rl l1 i).
      { replace b with (Rmin b c).
        { rewrite &lt;- H5; elim (RList_P6 l1); intros; apply H10; try assumption.
          { apply Nat.le_0_l. }
          apply Nat.lt_trans with (pred (length l1)); try assumption; apply Nat.lt_pred_l;
            red; intro; rewrite H12 in H6; discriminate. }
        unfold Rmin; decide (Rle_dec b c) with Hyp2;
          reflexivity. }
      elim H7; intros; assumption. }
    destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle'];
      [ elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H10))
      | reflexivity
      | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ]
      | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ] ].
  - assert (H3 := pre psi1); unfold IsStepFun in H3; unfold is_subdivision in H3;
      elim H3; clear H3; intros l1 [lf1 H3]; split with l1;
      split with lf1; unfold adapted_couple in H3; decompose [and] H3;
      clear H3; unfold adapted_couple; repeat split;
      try assumption.
    intros; assert (H9 := H8 i H3); unfold constant_D_eq, open_interval;
      unfold constant_D_eq, open_interval in H9; intros;
      rewrite &lt;- (H9 x H7); unfold psi3; assert (H10 : x &lt;= b).
    { apply Rle_trans with (pos_Rl l1 (S i)).
      { elim H7; intros; left; assumption. }
      replace b with (Rmax a b).
      { rewrite &lt;- H4; elim (RList_P6 l1); intros; apply H10; try assumption.
        apply Nat.lt_pred_l; red; intro; rewrite H12 in H6; discriminate. }
      unfold Rmax; decide (Rle_dec a b) with Hyp1; reflexivity. }
    assert (H11 : a &lt;= x).
    { apply Rle_trans with (pos_Rl l1 i).
      { replace a with (Rmin a b).
        { rewrite &lt;- H5; elim (RList_P6 l1); intros; apply H11; try assumption.
          { apply Nat.le_0_l. }
          apply Nat.lt_trans with (pred (length l1)); try assumption; apply Nat.lt_pred_l;
            red; intro; rewrite H13 in H6; discriminate. }
        unfold Rmin; decide (Rle_dec a b) with Hyp1; reflexivity. }
      left; elim H7; intros; assumption. }
    decide (Rle_dec a x) with H11; decide (Rle_dec x b) with H10; reflexivity.
  - apply StepFun_P46 with b.
    { assert (H3 := pre phi1); unfold IsStepFun in H3; unfold is_subdivision in H3;
        elim H3; clear H3; intros l1 [lf1 H3]; split with l1;
        split with lf1; unfold adapted_couple in H3; decompose [and] H3;
        clear H3; unfold adapted_couple; repeat split;
        try assumption.
      intros; assert (H9 := H8 i H3); unfold constant_D_eq, open_interval;
        unfold constant_D_eq, open_interval in H9; intros;
        rewrite &lt;- (H9 x H7); unfold psi3; assert (H10 : x &lt;= b).
      { apply Rle_trans with (pos_Rl l1 (S i)).
        { elim H7; intros; left; assumption. }
        replace b with (Rmax a b).
        { rewrite &lt;- H4; elim (RList_P6 l1); intros; apply H10; try assumption.
          apply Nat.lt_pred_l; red; intro; rewrite H12 in H6; discriminate. }
        unfold Rmax; decide (Rle_dec a b) with Hyp1; reflexivity. }
      assert (H11 : a &lt;= x).
      { apply Rle_trans with (pos_Rl l1 i).
        { replace a with (Rmin a b).
          { rewrite &lt;- H5; elim (RList_P6 l1); intros; apply H11; try assumption.
            { apply Nat.le_0_l. }
            apply Nat.lt_trans with (pred (length l1)); try assumption; apply Nat.lt_pred_l;
              red; intro; rewrite H13 in H6; discriminate. }
          unfold Rmin; decide (Rle_dec a b) with Hyp1; reflexivity. }
        left; elim H7; intros; assumption. }
      unfold phi3; decide (Rle_dec a x) with H11; decide (Rle_dec x b) with H10;
        reflexivity || elim n; assumption. }
    assert (H3 := pre phi2); unfold IsStepFun in H3; unfold is_subdivision in H3;
      elim H3; clear H3; intros l1 [lf1 H3]; split with l1;
      split with lf1; unfold adapted_couple in H3; decompose [and] H3;
      clear H3; unfold adapted_couple; repeat split;
      try assumption.
    intros; assert (H9 := H8 i H3); unfold constant_D_eq, open_interval;
      unfold constant_D_eq, open_interval in H9; intros;
      rewrite &lt;- (H9 x H7); unfold psi3; assert (H10 : b &lt; x).
    { apply Rle_lt_trans with (pos_Rl l1 i).
      { replace b with (Rmin b c).
        { rewrite &lt;- H5; elim (RList_P6 l1); intros; apply H10; try assumption.
          { apply Nat.le_0_l. }
          apply Nat.lt_trans with (pred (length l1)); try assumption; apply Nat.lt_pred_l;
            red; intro; rewrite H12 in H6; discriminate. }
        unfold Rmin; decide (Rle_dec b c) with Hyp2; reflexivity. }
      elim H7; intros; assumption. }
    unfold phi3; destruct (Rle_dec a x) as [Hle|Hnle]; destruct (Rle_dec x b) as [Hle'|Hnle']; intros;
      [ elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H10))
      | reflexivity
      | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ]
      | elim Hnle; apply Rle_trans with b; [ assumption | left; assumption ] ].
Qed.
Lemma RiemannInt_P22 :
  forall (f:R -&gt; R) (a b c:R),
    Riemann_integrable f a b -&gt; a &lt;= c &lt;= b -&gt; Riemann_integrable f a c.
Proof.
  unfold Riemann_integrable; intros; elim (X eps); clear X;
    intros phi [psi H0]; elim H; elim H0; clear H H0;
    intros; assert (H3 : IsStepFun phi a c).
  { apply StepFun_P44 with b.
    { apply (pre phi). }
    split; assumption. }
  assert (H4 : IsStepFun psi a c).
  { apply StepFun_P44 with b.
    { apply (pre psi). }
    split; assumption. }
  split with (mkStepFun H3); split with (mkStepFun H4); split.
  { simpl; intros; apply H.
    replace (Rmin a b) with (Rmin a c) by (rewrite 2!Rmin_left; eauto using Rle_trans).
    destruct H5; split; try assumption.
    apply Rle_trans with (Rmax a c); try assumption.
    apply Rle_max_compat_l; assumption. }
  rewrite Rabs_right.
  { assert (H5 : IsStepFun psi c b).
    { apply StepFun_P46 with a.
      { apply StepFun_P6; assumption. }
      apply (pre psi). }
    replace (RiemannInt_SF (mkStepFun H4)) with
      (RiemannInt_SF psi - RiemannInt_SF (mkStepFun H5)).
    { apply Rle_lt_trans with (RiemannInt_SF psi).
      { unfold Rminus; pattern (RiemannInt_SF psi) at 2;
          rewrite &lt;- Rplus_0_r; apply Rplus_le_compat_l; rewrite &lt;- Ropp_0;
          apply Ropp_ge_le_contravar; apply Rle_ge;
          replace 0 with (RiemannInt_SF (mkStepFun (StepFun_P4 c b 0))).
        { apply StepFun_P37; try assumption.
          intros; simpl; unfold fct_cte;
            apply Rle_trans with (Rabs (f x - phi x)).
          { apply Rabs_pos. }
          apply H.
          rewrite Rmin_left; eauto using Rle_trans.
          rewrite Rmax_right; eauto using Rle_trans.
          destruct H6; split; left.
          { apply Rle_lt_trans with c; assumption. }
          assumption. }
        rewrite StepFun_P18; ring. }
      apply Rle_lt_trans with (Rabs (RiemannInt_SF psi)).
      { apply RRle_abs. }
      assumption. }
    assert (H6 : IsStepFun psi a b).
    { apply (pre psi). }
    replace (RiemannInt_SF psi) with (RiemannInt_SF (mkStepFun H6)).
    { rewrite &lt;- (StepFun_P43 H4 H5 H6); ring. }
    unfold RiemannInt_SF; case (Rle_dec a b); intro.
    { eapply StepFun_P17.
      { apply StepFun_P1. }
      simpl; apply StepFun_P1. }
    apply Ropp_eq_compat; eapply StepFun_P17.
    { apply StepFun_P1. }
    simpl; apply StepFun_P1. }
  apply Rle_ge.
  replace 0 with (RiemannInt_SF (mkStepFun (StepFun_P4 a c 0))) by (rewrite StepFun_P18; ring).
  apply StepFun_P37; try assumption.
  intros; simpl; unfold fct_cte;
    apply Rle_trans with (Rabs (f x - phi x)).
  { apply Rabs_pos. }
  apply H.
  rewrite Rmin_left; eauto using Rle_trans.
  rewrite Rmax_right; eauto using Rle_trans.
  destruct H5; split; left.
  { assumption. }
  apply Rlt_le_trans with c; assumption.
Qed.
Lemma RiemannInt_P23 :
  forall (f:R -&gt; R) (a b c:R),
    Riemann_integrable f a b -&gt; a &lt;= c &lt;= b -&gt; Riemann_integrable f c b.
Proof.
  unfold Riemann_integrable; intros; elim (X eps); clear X;
    intros phi [psi H0]; elim H; elim H0; clear H H0;
    intros; assert (H3 : IsStepFun phi c b).
  { apply StepFun_P45 with a.
    { apply (pre phi). }
    split; assumption. }
  assert (H4 : IsStepFun psi c b).
  { apply StepFun_P45 with a.
    { apply (pre psi). }
    split; assumption. }
  split with (mkStepFun H3); split with (mkStepFun H4); split.
  { simpl; intros; apply H.
    replace (Rmax a b) with (Rmax c b).
    { elim H5; intros; split; try assumption.
      apply Rle_trans with (Rmin c b); try assumption.
      rewrite Rmin_left; eauto using Rle_trans.
      rewrite Rmin_left; eauto using Rle_trans. }
    rewrite Rmax_right; eauto using Rle_trans.
    rewrite Rmax_right; eauto using Rle_trans. }
  rewrite Rabs_right.
  { assert (H5 : IsStepFun psi a c).
    { apply StepFun_P46 with b.
      { apply (pre psi). }
      apply StepFun_P6; assumption. }
    replace (RiemannInt_SF (mkStepFun H4)) with
      (RiemannInt_SF psi - RiemannInt_SF (mkStepFun H5)).
    { apply Rle_lt_trans with (RiemannInt_SF psi).
      { unfold Rminus; pattern (RiemannInt_SF psi) at 2;
          rewrite &lt;- Rplus_0_r; apply Rplus_le_compat_l; rewrite &lt;- Ropp_0;
          apply Ropp_ge_le_contravar; apply Rle_ge;
          replace 0 with (RiemannInt_SF (mkStepFun (StepFun_P4 a c 0))).
        { apply StepFun_P37; try assumption.
          intros; simpl; unfold fct_cte;
            apply Rle_trans with (Rabs (f x - phi x)).
          { apply Rabs_pos. }
          apply H.
          rewrite Rmin_left; eauto using Rle_trans.
          rewrite Rmax_right; eauto using Rle_trans.
          destruct H6; split; left.
          { assumption. }
          apply Rlt_le_trans with c; assumption. }
        rewrite StepFun_P18; ring. }
      apply Rle_lt_trans with (Rabs (RiemannInt_SF psi)).
      { apply RRle_abs. }
      assumption. }
    assert (H6 : IsStepFun psi a b).
    { apply (pre psi). }
    replace (RiemannInt_SF psi) with (RiemannInt_SF (mkStepFun H6)).
    { rewrite &lt;- (StepFun_P43 H5 H4 H6); ring. }
    unfold RiemannInt_SF; case (Rle_dec a b); intro.
    { eapply StepFun_P17.
      { apply StepFun_P1. }
      simpl; apply StepFun_P1. }
    apply Ropp_eq_compat; eapply StepFun_P17.
    { apply StepFun_P1. }
    simpl; apply StepFun_P1. }
  apply Rle_ge;
  replace 0 with (RiemannInt_SF (mkStepFun (StepFun_P4 c b 0))) by (rewrite StepFun_P18; ring).
  apply StepFun_P37; try assumption.
  intros; simpl; unfold fct_cte;
    apply Rle_trans with (Rabs (f x - phi x)).
  { apply Rabs_pos. }
  apply H.
  rewrite Rmin_left; eauto using Rle_trans.
  rewrite Rmax_right; eauto using Rle_trans.
  destruct H5; split; left.
  { apply Rle_lt_trans with c; assumption. }
  assumption.
Qed.
Lemma RiemannInt_P24 :
  forall (f:R -&gt; R) (a b c:R),
    Riemann_integrable f a b -&gt;
    Riemann_integrable f b c -&gt; Riemann_integrable f a c.
Proof.
  intros; case (Rle_dec a b); case (Rle_dec b c); intros.
  - apply RiemannInt_P21 with b; assumption.
  - case (Rle_dec a c); intro.
    + apply RiemannInt_P22 with b; try assumption.
      split; [ assumption | auto with real ].
    + apply RiemannInt_P1; apply RiemannInt_P22 with b.
      * apply RiemannInt_P1; assumption.
      * split; auto with real.
  - case (Rle_dec a c); intro.
    + apply RiemannInt_P23 with b; try assumption.
      split; auto with real.
    + apply RiemannInt_P1; apply RiemannInt_P23 with b.
      * apply RiemannInt_P1; assumption.
      * split; [ assumption | auto with real ].
  - apply RiemannInt_P1; apply RiemannInt_P21 with b;
      auto with real || apply RiemannInt_P1; assumption.
Qed.
Lemma RiemannInt_P25 :
  forall (f:R -&gt; R) (a b c:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable f b c) (pr3:Riemann_integrable f a c),
    a &lt;= b -&gt; b &lt;= c -&gt; RiemannInt pr1 + RiemannInt pr2 = RiemannInt pr3.
Proof.
  intros f a b c pr1 pr2 pr3 Hyp1 Hyp2; unfold RiemannInt;
    case (RiemannInt_exists pr1 RinvN RinvN_cv) as (x1,HUn_cv1);
    case (RiemannInt_exists pr2 RinvN RinvN_cv) as (x0,HUn_cv0);
    case (RiemannInt_exists pr3 RinvN RinvN_cv) as (x,HUn_cv);
    symmetry ; eapply UL_sequence.
  { apply HUn_cv. }
  unfold Un_cv; intros; assert (H0 : 0 &lt; eps / 3).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  destruct (HUn_cv1 _ H0) as (N1,H1); clear HUn_cv1; destruct (HUn_cv0 _ H0) as (N2,H2); clear HUn_cv0;
    cut
      (Un_cv
         (fun n:nat =&gt;
            RiemannInt_SF (phi_sequence RinvN pr3 n) -
              (RiemannInt_SF (phi_sequence RinvN pr1 n) +
                 RiemannInt_SF (phi_sequence RinvN pr2 n))) 0).
  { intro; elim (H3 _ H0); clear H3; intros N3 H3;
      set (N0 := max (max N1 N2) N3); exists N0; intros;
      unfold Rdist;
      apply Rle_lt_trans with
      (Rabs
         (RiemannInt_SF (phi_sequence RinvN pr3 n) -
            (RiemannInt_SF (phi_sequence RinvN pr1 n) +
               RiemannInt_SF (phi_sequence RinvN pr2 n))) +
         Rabs
           (RiemannInt_SF (phi_sequence RinvN pr1 n) +
              RiemannInt_SF (phi_sequence RinvN pr2 n) - (x1 + x0))).
    { replace (RiemannInt_SF (phi_sequence RinvN pr3 n) - (x1 + x0)) with
        (RiemannInt_SF (phi_sequence RinvN pr3 n) -
           (RiemannInt_SF (phi_sequence RinvN pr1 n) +
              RiemannInt_SF (phi_sequence RinvN pr2 n)) +
           (RiemannInt_SF (phi_sequence RinvN pr1 n) +
              RiemannInt_SF (phi_sequence RinvN pr2 n) - (x1 + x0)));
        [ apply Rabs_triang | ring ]. }
    replace eps with (eps / 3 + eps / 3 + eps / 3) by lra.
    rewrite Rplus_assoc; apply Rplus_lt_compat.
    { unfold Rdist in H3; cut (n &gt;= N3)%nat.
      { intro; assert (H6 := H3 _ H5); unfold Rminus in H6; rewrite Ropp_0 in H6;
          rewrite Rplus_0_r in H6; apply H6. }
      unfold ge; apply Nat.le_trans with N0;
        [ unfold N0; apply Nat.le_max_r | assumption ]. }
    apply Rle_lt_trans with
      (Rabs (RiemannInt_SF (phi_sequence RinvN pr1 n) - x1) +
         Rabs (RiemannInt_SF (phi_sequence RinvN pr2 n) - x0)).
    { replace
        (RiemannInt_SF (phi_sequence RinvN pr1 n) +
           RiemannInt_SF (phi_sequence RinvN pr2 n) - (x1 + x0)) with
        (RiemannInt_SF (phi_sequence RinvN pr1 n) - x1 +
           (RiemannInt_SF (phi_sequence RinvN pr2 n) - x0));
        [ apply Rabs_triang | ring ]. }
    apply Rplus_lt_compat.
    { unfold Rdist in H1; apply H1.
      unfold ge; apply Nat.le_trans with N0;
        [ apply Nat.le_trans with (max N1 N2);
          [ apply Nat.le_max_l | unfold N0; apply Nat.le_max_l ]
        | assumption ]. }
    unfold Rdist in H2; apply H2.
    unfold ge; apply Nat.le_trans with N0;
      [ apply Nat.le_trans with (max N1 N2);
        [ apply Nat.le_max_r | unfold N0; apply Nat.le_max_l ]
      | assumption ]. }
  clear x HUn_cv x0 x1 eps H H0 N1 H1 N2 H2;
    assert
      (H1 :
        exists psi1 : nat -&gt; StepFun a b,
          (forall n:nat,
              (forall t:R,
                  Rmin a b &lt;= t /\ t &lt;= Rmax a b -&gt;
                  Rabs (f t - phi_sequence RinvN pr1 n t) &lt;= psi1 n t) /\
                Rabs (RiemannInt_SF (psi1 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr1 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr1 n)). }
  assert
    (H2 :
      exists psi2 : nat -&gt; StepFun b c,
        (forall n:nat,
            (forall t:R,
                Rmin b c &lt;= t /\ t &lt;= Rmax b c -&gt;
                Rabs (f t - phi_sequence RinvN pr2 n t) &lt;= psi2 n t) /\
              Rabs (RiemannInt_SF (psi2 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr2 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr2 n)). }
  assert
    (H3 :
      exists psi3 : nat -&gt; StepFun a c,
        (forall n:nat,
            (forall t:R,
                Rmin a c &lt;= t /\ t &lt;= Rmax a c -&gt;
                Rabs (f t - phi_sequence RinvN pr3 n t) &lt;= psi3 n t) /\
              Rabs (RiemannInt_SF (psi3 n)) &lt; RinvN n)).
  { split with (fun n:nat =&gt; proj1_sig (phi_sequence_prop RinvN pr3 n)); intro;
      apply (proj2_sig (phi_sequence_prop RinvN pr3 n)). }
  elim H1; clear H1; intros psi1 H1; elim H2; clear H2; intros psi2 H2; elim H3;
    clear H3; intros psi3 H3; assert (H := RinvN_cv);
    unfold Un_cv; intros; assert (H4 : 0 &lt; eps / 3).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  elim (H _ H4); clear H; intros N0 H;
    assert (H5 : forall n:nat, (n &gt;= N0)%nat -&gt; RinvN n &lt; eps / 3).
  { intros;
      replace (pos (RinvN n)) with
      (Rdist (mkposreal (/ (INR n + 1)) (RinvN_pos n)) 0).
    { apply H; assumption. }
    unfold Rdist; unfold Rminus; rewrite Ropp_0;
      rewrite Rplus_0_r; apply Rabs_right; apply Rle_ge;
      left; apply (cond_pos (RinvN n)). }
  exists N0; intros; elim (H1 n); elim (H2 n); elim (H3 n); clear H1 H2 H3;
    intros; unfold Rdist; unfold Rminus;
    rewrite Ropp_0; rewrite Rplus_0_r;
    set (phi1 := phi_sequence RinvN pr1 n) in H8 |- *;
    set (phi2 := phi_sequence RinvN pr2 n) in H3 |- *;
    set (phi3 := phi_sequence RinvN pr3 n) in H1 |- *;
    assert (H10 : IsStepFun phi3 a b).
  { apply StepFun_P44 with c.
    { apply (pre phi3). }
    split; assumption. }
  assert (H11 : IsStepFun (psi3 n) a b).
  { apply StepFun_P44 with c.
    { apply (pre (psi3 n)). }
    split; assumption. }
  assert (H12 : IsStepFun phi3 b c).
  { apply StepFun_P45 with a.
    { apply (pre phi3). }
    split; assumption. }
  assert (H13 : IsStepFun (psi3 n) b c).
  { apply StepFun_P45 with a.
    { apply (pre (psi3 n)). }
    split; assumption. }
  replace (RiemannInt_SF phi3) with
    (RiemannInt_SF (mkStepFun H10) + RiemannInt_SF (mkStepFun H12)).
  { apply Rle_lt_trans with
      (Rabs (RiemannInt_SF (mkStepFun H10) - RiemannInt_SF phi1) +
         Rabs (RiemannInt_SF (mkStepFun H12) - RiemannInt_SF phi2)).
    { replace
        (RiemannInt_SF (mkStepFun H10) + RiemannInt_SF (mkStepFun H12) +
         - (RiemannInt_SF phi1 + RiemannInt_SF phi2)) with
        (RiemannInt_SF (mkStepFun H10) - RiemannInt_SF phi1 +
           (RiemannInt_SF (mkStepFun H12) - RiemannInt_SF phi2)) by ring;
        apply Rabs_triang. }
    replace (RiemannInt_SF (mkStepFun H10) - RiemannInt_SF phi1) with
      (RiemannInt_SF (mkStepFun (StepFun_P28 (-1) (mkStepFun H10) phi1)))
      by (rewrite StepFun_P30; ring).
    replace (RiemannInt_SF (mkStepFun H12) - RiemannInt_SF phi2) with
      (RiemannInt_SF (mkStepFun (StepFun_P28 (-1) (mkStepFun H12) phi2)))
      by (rewrite StepFun_P30; ring).
    apply Rle_lt_trans with
      (RiemannInt_SF
         (mkStepFun
            (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (mkStepFun H10) phi1)))) +
         RiemannInt_SF
           (mkStepFun
              (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (mkStepFun H12) phi2))))).
    { apply Rle_trans with
        (Rabs (RiemannInt_SF (mkStepFun (StepFun_P28 (-1) (mkStepFun H10) phi1))) +
           RiemannInt_SF
             (mkStepFun
                (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (mkStepFun H12) phi2))))).
      { apply Rplus_le_compat_l.
        apply StepFun_P34; try assumption. }
      do 2
      rewrite &lt;-
      (Rplus_comm
         (RiemannInt_SF
            (mkStepFun
               (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (mkStepFun H12) phi2))))))
      ; apply Rplus_le_compat_l; apply StepFun_P34; try assumption. }
    apply Rle_lt_trans with
      (RiemannInt_SF (mkStepFun (StepFun_P28 1 (mkStepFun H11) (psi1 n))) +
         RiemannInt_SF (mkStepFun (StepFun_P28 1 (mkStepFun H13) (psi2 n)))).
    { apply Rle_trans with
        (RiemannInt_SF
           (mkStepFun
              (StepFun_P32 (mkStepFun (StepFun_P28 (-1) (mkStepFun H10) phi1)))) +
           RiemannInt_SF (mkStepFun (StepFun_P28 1 (mkStepFun H13) (psi2 n)))).
      { apply Rplus_le_compat_l; apply StepFun_P37; try assumption.
        intros; simpl; rewrite Rmult_1_l;
          apply Rle_trans with (Rabs (f x - phi3 x) + Rabs (f x - phi2 x)).
        { rewrite &lt;- (Rabs_Ropp (f x - phi3 x)); rewrite Ropp_minus_distr;
            replace (phi3 x + -1 * phi2 x) with (phi3 x - f x + (f x - phi2 x));
            [ apply Rabs_triang | ring ]. }
        apply Rplus_le_compat.
        { apply H1.
          elim H14; intros; split.
          { rewrite Rmin_left; eauto using Rle_trans.
            apply Rle_trans with b; try assumption.
            left; assumption. }
          rewrite Rmax_right; eauto using Rle_trans.
          left; assumption. }
        apply H3.
        elim H14; intros; split.
        { rewrite Rmin_left; eauto using Rle_trans.
          left; assumption. }
        rewrite Rmax_right; eauto using Rle_trans.
        left; assumption. }
      do 2
      rewrite &lt;-
      (Rplus_comm
         (RiemannInt_SF (mkStepFun (StepFun_P28 1 (mkStepFun H13) (psi2 n)))))
      ; apply Rplus_le_compat_l; apply StepFun_P37; try assumption.
      intros; simpl; rewrite Rmult_1_l;
        apply Rle_trans with (Rabs (f x - phi3 x) + Rabs (f x - phi1 x)).
      { rewrite &lt;- (Rabs_Ropp (f x - phi3 x)); rewrite Ropp_minus_distr;
          replace (phi3 x + -1 * phi1 x) with (phi3 x - f x + (f x - phi1 x));
          [ apply Rabs_triang | ring ]. }
      apply Rplus_le_compat.
      { apply H1.
        elim H14; intros; split.
        { rewrite Rmin_left; eauto using Rle_trans.
          left; assumption. }
        rewrite Rmax_right; eauto using Rle_trans.
        apply Rle_trans with b.
        { left; assumption. }
        assumption. }
      apply H8.
      elim H14; intros; split.
      { rewrite Rmin_left; trivial.
        left; assumption. }
      rewrite Rmax_right; trivial.
      left; assumption. }
    do 2 rewrite StepFun_P30.
    do 2 rewrite Rmult_1_l;
    replace
      (RiemannInt_SF (mkStepFun H11) + RiemannInt_SF (psi1 n) +
         (RiemannInt_SF (mkStepFun H13) + RiemannInt_SF (psi2 n))) with
      (RiemannInt_SF (psi3 n) + RiemannInt_SF (psi1 n) + RiemannInt_SF (psi2 n)).
    { replace eps with (eps / 3 + eps / 3 + eps / 3) by lra.
      repeat rewrite Rplus_assoc; apply Rplus_lt_compat.
      { apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi3 n))).
        { apply RRle_abs. }
        apply Rlt_trans with (pos (RinvN n)).
        { assumption. }
        apply H5; assumption. }
      apply Rplus_lt_compat.
      { apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi1 n))).
        { apply RRle_abs. }
        apply Rlt_trans with (pos (RinvN n)).
        { assumption. }
        apply H5; assumption. }
      apply Rle_lt_trans with (Rabs (RiemannInt_SF (psi2 n))).
      { apply RRle_abs. }
      apply Rlt_trans with (pos (RinvN n)).
      { assumption. }
      apply H5; assumption. }
    replace (RiemannInt_SF (psi3 n)) with
      (RiemannInt_SF (mkStepFun (pre (psi3 n)))).
    { rewrite &lt;- (StepFun_P43 H11 H13 (pre (psi3 n))); ring. }
    reflexivity. }
  apply (StepFun_P43 H10 H12 (pre phi3)).
Qed.
Lemma RiemannInt_P26 :
  forall (f:R -&gt; R) (a b c:R) (pr1:Riemann_integrable f a b)
    (pr2:Riemann_integrable f b c) (pr3:Riemann_integrable f a c),
    RiemannInt pr1 + RiemannInt pr2 = RiemannInt pr3.
Proof.
  intros; destruct (Rle_dec a b) as [Hle|Hnle]; destruct (Rle_dec b c) as [Hle'|Hnle'].
  - apply RiemannInt_P25; assumption.
  - destruct (Rle_dec a c) as [Hle''|Hnle''].
    { assert (H : c &lt;= b).
      { auto with real. }
      rewrite &lt;- (RiemannInt_P25 pr3 (RiemannInt_P1 pr2) pr1 Hle'' H);
        rewrite (RiemannInt_P8 pr2 (RiemannInt_P1 pr2)); ring. }
    assert (H : c &lt;= a).
    { auto with real. }
    rewrite (RiemannInt_P8 pr2 (RiemannInt_P1 pr2));
      rewrite &lt;- (RiemannInt_P25 (RiemannInt_P1 pr3) pr1 (RiemannInt_P1 pr2) H Hle);
      rewrite (RiemannInt_P8 pr3 (RiemannInt_P1 pr3)); ring.
  - assert (H : b &lt;= a).
    { auto with real. }
    destruct (Rle_dec a c) as [Hle''|Hnle''].
    { rewrite &lt;- (RiemannInt_P25 (RiemannInt_P1 pr1) pr3 pr2 H Hle'');
        rewrite (RiemannInt_P8 pr1 (RiemannInt_P1 pr1)); ring. }
    assert (H0 : c &lt;= a).
    { auto with real. }
    rewrite (RiemannInt_P8 pr1 (RiemannInt_P1 pr1));
      rewrite &lt;- (RiemannInt_P25 pr2 (RiemannInt_P1 pr3) (RiemannInt_P1 pr1) Hle' H0);
      rewrite (RiemannInt_P8 pr3 (RiemannInt_P1 pr3)); ring.
  - rewrite (RiemannInt_P8 pr1 (RiemannInt_P1 pr1));
      rewrite (RiemannInt_P8 pr2 (RiemannInt_P1 pr2));
      rewrite (RiemannInt_P8 pr3 (RiemannInt_P1 pr3));
      rewrite &lt;-
              (RiemannInt_P25 (RiemannInt_P1 pr2) (RiemannInt_P1 pr1) (RiemannInt_P1 pr3))
    ; [ ring | auto with real | auto with real ].
Qed.
Lemma RiemannInt_P27 :
  forall (f:R -&gt; R) (a b x:R) (h:a &lt;= b)
    (C0:forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x),
    a &lt; x &lt; b -&gt; derivable_pt_lim (primitive h (FTC_P1 h C0)) x (f x).
Proof.
  intro f; intros; elim H; clear H; intros; assert (H1 : continuity_pt f x).
  { apply C0; split; left; assumption. }
  unfold derivable_pt_lim; intros; assert (Hyp : 0 &lt; eps / 2).
  { unfold Rdiv; apply Rmult_lt_0_compat;
      [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
  elim (H1 _ Hyp); unfold dist, D_x, no_cond; simpl;
    unfold Rdist; intros; set (del := Rmin x0 (Rmin (b - x) (x - a)));
    assert (H4 : 0 &lt; del).
  { unfold del; unfold Rmin; case (Rle_dec (b - x) (x - a));
      intro.
    { destruct (Rle_dec x0 (b - x)) as [Hle|Hnle];
        [ elim H3; intros; assumption | apply Rlt_0_minus; assumption ]. }
    destruct (Rle_dec x0 (x - a)) as [Hle'|Hnle'];
      [ elim H3; intros; assumption | apply Rlt_0_minus; assumption ]. }
  split with (mkposreal _ H4); intros;
    assert (H7 : Riemann_integrable f x (x + h0)).
  { destruct (Rle_dec x (x + h0)) as [Hle''|Hnle''].
    { apply continuity_implies_RiemannInt; try assumption.
      intros; apply C0; elim H7; intros; split.
      { apply Rle_trans with x; [ left; assumption | assumption ]. }
      apply Rle_trans with (x + h0).
      { assumption. }
      left; apply Rlt_le_trans with (x + del).
      { apply Rplus_lt_compat_l; apply Rle_lt_trans with (Rabs h0);
          [ apply RRle_abs | apply H6 ]. }
      unfold del; apply Rle_trans with (x + Rmin (b - x) (x - a)).
      { apply Rplus_le_compat_l; apply Rmin_r. }
      pattern b at 2; replace b with (x + (b - x));
        [ apply Rplus_le_compat_l; apply Rmin_l | ring ]. }
    apply RiemannInt_P1; apply continuity_implies_RiemannInt; auto with real.
    intros; apply C0; elim H7; intros; split.
    { apply Rle_trans with (x + h0).
      { left; apply Rle_lt_trans with (x - del).
        { unfold del; apply Rle_trans with (x - Rmin (b - x) (x - a)).
          { pattern a at 1; replace a with (x + (a - x)); [ idtac | ring ].
            unfold Rminus; apply Rplus_le_compat_l; apply Ropp_le_cancel.
            rewrite Ropp_involutive; rewrite Ropp_plus_distr; rewrite Ropp_involutive;
              rewrite (Rplus_comm x); apply Rmin_r. }
          unfold Rminus; apply Rplus_le_compat_l; apply Ropp_le_cancel.
          do 2 rewrite Ropp_involutive; apply Rmin_r. }
        unfold Rminus; apply Rplus_lt_compat_l; apply Ropp_lt_cancel.
        rewrite Ropp_involutive; apply Rle_lt_trans with (Rabs h0);
          [ rewrite &lt;- Rabs_Ropp; apply RRle_abs | apply H6 ]. }
      assumption. }
    apply Rle_trans with x; [ assumption | left; assumption ]. }
  replace (primitive h (FTC_P1 h C0) (x + h0) - primitive h (FTC_P1 h C0) x)
    with (RiemannInt H7).
  2:{ cut (a &lt;= x + h0).
      { cut (x + h0 &lt;= b).
        { intros; unfold primitive.
          assert (H10: a &lt;= x) by (left; assumption).
          assert (H11: x &lt;= b) by (left; assumption).
          decide (Rle_dec a (x + h0)) with H9; decide (Rle_dec (x + h0) b) with H8;
            decide (Rle_dec a x) with H10; decide (Rle_dec x b) with H11.
          rewrite &lt;- (RiemannInt_P26 (FTC_P1 h C0 H10 H11) H7 (FTC_P1 h C0 H9 H8)); ring. }
        apply Rplus_le_reg_l with (- x); replace (- x + (x + h0)) with h0;
          [ idtac | ring ].
        rewrite Rplus_comm; apply Rle_trans with (Rabs h0).
        { apply RRle_abs. }
        apply Rle_trans with del;
          [ left; assumption
          | unfold del; apply Rle_trans with (Rmin (b - x) (x - a));
            [ apply Rmin_r | apply Rmin_l ] ]. }
      apply Ropp_le_cancel; apply Rplus_le_reg_l with x;
        replace (x + - (x + h0)) with (- h0) by ring.
      apply Rle_trans with (Rabs h0).
      { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
      apply Rle_trans with del.
      { left; assumption. }
      unfold del; apply Rle_trans with (Rmin (b - x) (x - a));
        apply Rmin_r. }
  replace (f x) with (RiemannInt (RiemannInt_P14 x (x + h0) (f x)) / h0).
  2:{ rewrite RiemannInt_P15; apply Rmult_eq_reg_l with h0;
      [ unfold Rdiv; rewrite (Rmult_comm h0); repeat rewrite Rmult_assoc;
        rewrite Rinv_l; [ ring | assumption ]
      | assumption ]. }
  replace
    (RiemannInt H7 / h0 - RiemannInt (RiemannInt_P14 x (x + h0) (f x)) / h0)
    with ((RiemannInt H7 - RiemannInt (RiemannInt_P14 x (x + h0) (f x))) / h0).
  2:{ unfold Rdiv, Rminus; rewrite Rmult_plus_distr_r; ring. }
  replace (RiemannInt H7 - RiemannInt (RiemannInt_P14 x (x + h0) (f x))) with
    (RiemannInt (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))).
  2:{ rewrite
        (RiemannInt_P13 H7 (RiemannInt_P14 x (x + h0) (f x))
                        (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))).
      ring. }
  unfold Rdiv; rewrite Rabs_mult; destruct (Rle_dec x (x + h0)) as [Hle|Hnle].
  - apply Rle_lt_trans with
      (RiemannInt
         (RiemannInt_P16
            (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))) *
         Rabs (/ h0)).
    { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
      { apply Rabs_pos. }
      apply
        (RiemannInt_P17 (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))
                        (RiemannInt_P16
                           (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))));
        assumption. }
    apply Rle_lt_trans with
      (RiemannInt (RiemannInt_P14 x (x + h0) (eps / 2)) * Rabs (/ h0)).
    { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
      { apply Rabs_pos. }
      apply RiemannInt_P19; try assumption.
      intros; replace (f x1 + -1 * fct_cte (f x) x1) with (f x1 - f x).
      { unfold fct_cte; destruct (Req_dec x x1) as [H9|H9].
        { rewrite H9; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; left;
            assumption. }
        elim H3; intros; left; apply  H11.
        repeat split.
        { assumption. }
        rewrite Rabs_right.
        { apply Rplus_lt_reg_l with x; replace (x + (x1 - x)) with x1; [ idtac | ring ].
          apply Rlt_le_trans with (x + h0).
          { elim H8; intros; assumption. }
          apply Rplus_le_compat_l; apply Rle_trans with del.
          { left; apply Rle_lt_trans with (Rabs h0); [ apply RRle_abs | assumption ]. }
          unfold del; apply Rmin_l. }
        apply Rge_minus; apply Rle_ge; left; elim H8; intros; assumption. }
      unfold fct_cte; ring. }
    rewrite RiemannInt_P15.
    rewrite Rmult_assoc; replace ((x + h0 - x) * Rabs (/ h0)) with 1.
    { rewrite Rmult_1_r; unfold Rdiv; apply Rmult_lt_reg_l with 2;
        [ prove_sup0
        | rewrite &lt;- (Rmult_comm (/ 2)); rewrite &lt;- Rmult_assoc;
          rewrite Rinv_r;
          [ rewrite Rmult_1_l; pattern eps at 1; rewrite &lt;- Rplus_0_r;
          rewrite &lt;-Rplus_diag; apply Rplus_lt_compat_l; assumption
          | discrR ] ]. }
    rewrite Rabs_right.
    { replace (x + h0 - x) with h0; [ idtac | ring ].
      symmetry; apply Rinv_r.
      assumption. }
    apply Rle_ge; left; apply Rinv_0_lt_compat.
    elim Hle; intro.
    { apply Rplus_lt_reg_l with x; rewrite Rplus_0_r; assumption. }
    elim H5; symmetry ; apply Rplus_eq_reg_l with x; rewrite Rplus_0_r;
      assumption.
  - apply Rle_lt_trans with
      (RiemannInt
         (RiemannInt_P16
            (RiemannInt_P1
               (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x))))) *
         Rabs (/ h0)).
    { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
      { apply Rabs_pos. }
      replace
        (RiemannInt (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x)))) with
        (-
           RiemannInt
             (RiemannInt_P1 (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x))))).
      { rewrite Rabs_Ropp;
          apply
            (RiemannInt_P17
               (RiemannInt_P1
                  (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x))))
               (RiemannInt_P16
                  (RiemannInt_P1
                     (RiemannInt_P10 (-1) H7 (RiemannInt_P14 x (x + h0) (f x))))));
          auto with real. }
      symmetry ; apply RiemannInt_P8. }
    apply Rle_lt_trans with
      (RiemannInt (RiemannInt_P14 (x + h0) x (eps / 2)) * Rabs (/ h0)).
    { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
      { apply Rabs_pos. }
      apply RiemannInt_P19.
      { auto with real. }
      intros; replace (f x1 + -1 * fct_cte (f x) x1) with (f x1 - f x).
      { unfold fct_cte; case (Req_dec x x1); intro.
        { rewrite H9; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0; left;
            assumption. }
        elim H3; intros; left; apply H11.
        repeat split.
        { assumption. }
        rewrite Rabs_left.
        { apply Rplus_lt_reg_l with (x1 - x0); replace (x1 - x0 + x0) with x1 by ring.
          replace (x1 - x0 + - (x1 - x)) with (x - x0) by ring.
          apply Rle_lt_trans with (x + h0).
          { unfold Rminus; apply Rplus_le_compat_l; apply Ropp_le_cancel.
            rewrite Ropp_involutive; apply Rle_trans with (Rabs h0).
            { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
            apply Rle_trans with del;
              [ left; assumption | unfold del; apply Rmin_l ]. }
          elim H8; intros; assumption. }
        lra. }
      unfold fct_cte; ring. }
    rewrite RiemannInt_P15.
    rewrite Rmult_assoc; replace ((x - (x + h0)) * Rabs (/ h0)) with 1.
    { lra. }
    rewrite Rabs_left.
    { field. lra. }
    apply Rinv_lt_0_compat.
    assert (H8 : x + h0 &lt; x).
    { auto with real. }
    apply Rplus_lt_reg_l with x; rewrite Rplus_0_r; assumption.
Qed.
Lemma RiemannInt_P28 :
  forall (f:R -&gt; R) (a b x:R) (h:a &lt;= b)
    (C0:forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x),
    a &lt;= x &lt;= b -&gt; derivable_pt_lim (primitive h (FTC_P1 h C0)) x (f x).
Proof.
  intro f; intros; elim h; intro.
  1:elim H; clear H; intros; elim H; intro.
  - elim H1; intro.
    { apply RiemannInt_P27; split; assumption. }
    set
      (f_b := fun x:R =&gt; f b * (x - b) + RiemannInt (FTC_P1 h C0 h (Rle_refl b)));
      rewrite H3.
    assert (H4 : derivable_pt_lim f_b b (f b)).
    { unfold f_b; pattern (f b) at 2; replace (f b) with (f b + 0) by ring.
      change
        (derivable_pt_lim
           ((fct_cte (f b) * (id - fct_cte b))%F +
              fct_cte (RiemannInt (FTC_P1 h C0 h (Rle_refl b)))) b (
             f b + 0)).
      apply derivable_pt_lim_plus.
      { pattern (f b) at 2;
          replace (f b) with (0 * (id - fct_cte b)%F b + fct_cte (f b) b * 1)
          by (unfold fct_cte;ring).
        apply derivable_pt_lim_mult.
        { apply derivable_pt_lim_const. }
        replace 1 with (1 - 0); [ idtac | ring ].
        apply derivable_pt_lim_minus.
        { apply derivable_pt_lim_id. }
        apply derivable_pt_lim_const. }
      apply derivable_pt_lim_const. }
    unfold derivable_pt_lim; intros; elim (H4 _ H5); intros;
      assert (H7 : continuity_pt f b).
    { apply C0; split; [ left; assumption | right; reflexivity ]. }
    assert (H8 : 0 &lt; eps / 2).
    { unfold Rdiv; apply Rmult_lt_0_compat;
        [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
    elim (H7 _ H8); unfold D_x, no_cond, dist; simpl;
      unfold Rdist; intros; set (del := Rmin x0 (Rmin x1 (b - a)));
      assert (H10 : 0 &lt; del).
    { unfold del; unfold Rmin; case (Rle_dec x1 (b - a)); intros.
      { destruct (Rle_dec x0 x1) as [Hle|Hnle];
          [ apply (cond_pos x0) | elim H9; intros; assumption ]. }
      destruct (Rle_dec x0 (b - a)) as [Hle'|Hnle'];
        [ apply (cond_pos x0) | apply Rlt_0_minus; assumption ]. }
    split with (mkposreal _ H10); intros; destruct (Rcase_abs h0) as [Hle|Hnle].
    + assert (H14 : b + h0 &lt; b).
      { pattern b at 2; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l;
          assumption. }
      assert (H13 : Riemann_integrable f (b + h0) b).
      { apply continuity_implies_RiemannInt.
        { left; assumption. }
        intros; apply C0; elim H13; intros; split; try assumption.
        apply Rle_trans with (b + h0); try assumption.
        apply Rplus_le_reg_l with (- a - h0).
        replace (- a - h0 + a) with (- h0); [ idtac | ring ].
        replace (- a - h0 + (b + h0)) with (b - a); [ idtac | ring ].
        apply Rle_trans with del.
        { apply Rle_trans with (Rabs h0).
          { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
          left; assumption. }
        unfold del; apply Rle_trans with (Rmin x1 (b - a)); apply Rmin_r. }
      replace (primitive h (FTC_P1 h C0) (b + h0) - primitive h (FTC_P1 h C0) b)
        with (- RiemannInt H13).
      { replace (f b) with (- RiemannInt (RiemannInt_P14 (b + h0) b (f b)) / h0).
        2:{ rewrite RiemannInt_P15.
            rewrite &lt;- Ropp_mult_distr_l_reverse; apply Rmult_eq_reg_l with h0;
              [ repeat rewrite (Rmult_comm h0); unfold Rdiv;
                repeat rewrite Rmult_assoc; rewrite Rinv_l;
                [ ring | assumption ]
              | assumption ]. }
        rewrite &lt;- Rabs_Ropp; unfold Rminus; unfold Rdiv;
          rewrite Ropp_mult_distr_l_reverse; rewrite Ropp_plus_distr;
          repeat rewrite Ropp_involutive;
          replace
            (RiemannInt H13 * / h0 +
             - RiemannInt (RiemannInt_P14 (b + h0) b (f b)) * / h0) with
          ((RiemannInt H13 - RiemannInt (RiemannInt_P14 (b + h0) b (f b))) / h0).
        2:{ unfold Rdiv, Rminus; rewrite Rmult_plus_distr_r; ring. }
        replace (RiemannInt H13 - RiemannInt (RiemannInt_P14 (b + h0) b (f b))) with
          (RiemannInt (RiemannInt_P10 (-1) H13 (RiemannInt_P14 (b + h0) b (f b)))).
        2:{ rewrite
              (RiemannInt_P13 H13 (RiemannInt_P14 (b + h0) b (f b))
                              (RiemannInt_P10 (-1) H13 (RiemannInt_P14 (b + h0) b (f b))))
            ; ring. }
        unfold Rdiv; rewrite Rabs_mult;
          apply Rle_lt_trans with
          (RiemannInt
             (RiemannInt_P16
                (RiemannInt_P10 (-1) H13 (RiemannInt_P14 (b + h0) b (f b)))) *
             Rabs (/ h0)).
        { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
          { apply Rabs_pos. }
          apply
            (RiemannInt_P17 (RiemannInt_P10 (-1) H13 (RiemannInt_P14 (b + h0) b (f b)))
                            (RiemannInt_P16
                               (RiemannInt_P10 (-1) H13 (RiemannInt_P14 (b + h0) b (f b)))));
            left; assumption. }
        apply Rle_lt_trans with
          (RiemannInt (RiemannInt_P14 (b + h0) b (eps / 2)) * Rabs (/ h0)).
        { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
          { apply Rabs_pos. }
          apply RiemannInt_P19.
          { left; assumption. }
          intros; replace (f x2 + -1 * fct_cte (f b) x2) with (f x2 - f b)
            by (unfold fct_cte; ring).
          unfold fct_cte; case (Req_dec b x2); intro.
          { rewrite H16; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
              left; assumption. }
          elim H9; intros; left; apply H18.
          repeat split.
          { assumption. }
          rewrite &lt;- Rabs_Ropp; rewrite Ropp_minus_distr; rewrite Rabs_right.
          2:{ apply Rle_ge; left; apply Rlt_0_minus; elim H15; intros; assumption. }
          apply Rplus_lt_reg_l with (x2 - x1);
            replace (x2 - x1 + (b - x2)) with (b - x1); [ idtac | ring ].
          replace (x2 - x1 + x1) with x2; [ idtac | ring ].
          apply Rlt_le_trans with (b + h0).
          2: elim H15; intros; left; assumption.
          unfold Rminus; apply Rplus_lt_compat_l; apply Ropp_lt_cancel;
            rewrite Ropp_involutive; apply Rle_lt_trans with (Rabs h0).
          { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
          apply Rlt_le_trans with del;
            [ assumption
            | unfold del; apply Rle_trans with (Rmin x1 (b - a));
              [ apply Rmin_r | apply Rmin_l ] ].
        }
        rewrite RiemannInt_P15.
        rewrite Rmult_assoc; replace ((b - (b + h0)) * Rabs (/ h0)) with 1.
        { lra. }
        rewrite Rabs_left.
        { apply Rmult_eq_reg_l with h0;
            [ do 2 rewrite (Rmult_comm h0); rewrite Rmult_assoc;
              rewrite Ropp_mult_distr_l_reverse; rewrite Rinv_l;
              [ ring | assumption ]
            | assumption ]. }
        apply Rinv_lt_0_compat; assumption. }
      cut (a &lt;= b + h0).
      { cut (b + h0 &lt;= b).
        2:{ left; assumption. }
        intros; unfold primitive; destruct (Rle_dec a (b + h0)) as [Hle'|Hnle'];
          destruct (Rle_dec (b + h0) b) as [Hle''|[]]; destruct (Rle_dec a b) as [Hleab|[]]; destruct (Rle_dec b b) as [Hlebb|[]];
          assumption || (right; reflexivity) || (try (left; assumption)).
        { rewrite &lt;- (RiemannInt_P26 (FTC_P1 h C0 Hle' Hle'') H13 (FTC_P1 h C0 Hleab Hlebb)); ring. }
        elim Hnle'; assumption. }
      apply Rplus_le_reg_l with (- a - h0).
      replace (- a - h0 + a) with (- h0); [ idtac | ring ].
      replace (- a - h0 + (b + h0)) with (b - a); [ idtac | ring ].
      apply Rle_trans with del.
      { apply Rle_trans with (Rabs h0).
        { rewrite &lt;- Rabs_Ropp; apply RRle_abs. }
        left; assumption. }
      unfold del; apply Rle_trans with (Rmin x1 (b - a)); apply Rmin_r.
    + cut (primitive h (FTC_P1 h C0) b = f_b b).
      { intro; cut (primitive h (FTC_P1 h C0) (b + h0) = f_b (b + h0)).
        { intro; rewrite H13; rewrite H14; apply H6.
          { assumption. }
          apply Rlt_le_trans with del;
            [ assumption | unfold del; apply Rmin_l ]. }
        assert (H14 : b &lt; b + h0).
        { pattern b at 1; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l.
          assert (H14 := Rge_le _ _ Hnle); elim H14; intro.
          { assumption. }
          elim H11; symmetry ; assumption. }
        unfold primitive; destruct (Rle_dec a (b + h0)) as [Hle|[]];
          destruct (Rle_dec (b + h0) b) as [Hle'|Hnle'];
          [ elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H14))
          | unfold f_b; reflexivity
          | left; apply Rlt_trans with b; assumption
          | left; apply Rlt_trans with b; assumption ]. }
      unfold f_b; unfold Rminus; rewrite Rplus_opp_r;
        rewrite Rmult_0_r; rewrite Rplus_0_l; unfold primitive;
        destruct (Rle_dec a b) as [Hle'|Hnle']; destruct (Rle_dec b b) as [Hle''|[]];
        [ apply RiemannInt_P5
        | right; reflexivity
        | elim Hnle'; left; assumption
        | right; reflexivity ].
  - (****
    set (f_a := fun x:R =&gt; f a * (x - a)); rewrite &lt;- H2;
      assert (H3 : derivable_pt_lim f_a a (f a)).
    { unfold f_a;
        change (derivable_pt_lim (fct_cte (f a) * (id - fct_cte a)%F) a (f a))
      ; pattern (f a) at 2;
        replace (f a) with (0 * (id - fct_cte a)%F a + fct_cte (f a) a * 1).
      { apply derivable_pt_lim_mult.
        { apply derivable_pt_lim_const. }
        replace 1 with (1 - 0); [ idtac | ring ].
        apply derivable_pt_lim_minus.
        { apply derivable_pt_lim_id. }
        apply derivable_pt_lim_const. }
      unfold fct_cte; ring. }
    unfold derivable_pt_lim; intros; elim (H3 _ H4); intros.
    assert (H6 : continuity_pt f a).
    { apply C0; split; [ right; reflexivity | left; assumption ]. }
    assert (H7 : 0 &lt; eps / 2).
    { unfold Rdiv; apply Rmult_lt_0_compat;
        [ assumption | apply Rinv_0_lt_compat; prove_sup0 ]. }
    elim (H6 _ H7); unfold D_x, no_cond, dist; simpl;
      unfold Rdist; intros.
    set (del := Rmin x0 (Rmin x1 (b - a))).
    assert (H9 : 0 &lt; del).
    { unfold del; unfold Rmin.
      case (Rle_dec x1 (b - a)); intros.
      { case (Rle_dec x0 x1); intro.
        { apply (cond_pos x0). }
        elim H8; intros; assumption. }
      case (Rle_dec x0 (b - a)); intro.
      { apply (cond_pos x0). }
      apply Rlt_0_minus; assumption. }
    split with (mkposreal _ H9).
    intros; destruct (Rcase_abs h0) as [Hle|Hnle].
    + assert (H12 : a + h0 &lt; a).
      { pattern a at 2; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l;
          assumption. }
      unfold primitive.
      destruct (Rle_dec a (a + h0)) as [Hle'|Hnle'];
        destruct (Rle_dec (a + h0) b) as [Hle''|Hnle''];
        destruct (Rle_dec a a) as [Hleaa|[]];
        destruct (Rle_dec a b) as [Hleab|[]];
        try (left; assumption) || (right; reflexivity).
      * elim (Rlt_irrefl _ (Rle_lt_trans _ _ _ Hle' H12)).
      * elim Hnle''; left; apply Rlt_trans with a; assumption.
      * rewrite RiemannInt_P9; replace 0 with (f_a a).
        { replace (f a * (a + h0 - a)) with (f_a (a + h0)).
          { apply H5; try assumption.
            apply Rlt_le_trans with del;
              [ assumption | unfold del; apply Rmin_l ]. }
          unfold f_a; ring. }
        unfold f_a; ring.
      * elim Hnle''; left; apply Rlt_trans with a; assumption.
    + assert (H12 : a &lt; a + h0).
      { pattern a at 1; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l.
        assert (H12 := Rge_le _ _ Hnle); elim H12; intro.
        { assumption. }
        elim H10; symmetry ; assumption. }
      assert (H13 : Riemann_integrable f a (a + h0)).
      { apply continuity_implies_RiemannInt.
        { left; assumption. }
        intros; apply C0; elim H13; intros; split; try assumption.
        apply Rle_trans with (a + h0); try assumption.
        apply Rplus_le_reg_l with (- b - h0).
        replace (- b - h0 + b) with (- h0); [ idtac | ring ].
        replace (- b - h0 + (a + h0)) with (a - b); [ idtac | ring ].
        apply Ropp_le_cancel; rewrite Ropp_involutive; rewrite Ropp_minus_distr;
          apply Rle_trans with del.
        { apply Rle_trans with (Rabs h0); [ apply RRle_abs | left; assumption ]. }
        unfold del; apply Rle_trans with (Rmin x1 (b - a)); apply Rmin_r. }
      replace (primitive h (FTC_P1 h C0) (a + h0) - primitive h (FTC_P1 h C0) a)
        with (RiemannInt H13).
      { replace (f a) with (RiemannInt (RiemannInt_P14 a (a + h0) (f a)) / h0).
        2:{ rewrite RiemannInt_P15.
            rewrite Rplus_comm; unfold Rminus; rewrite Rplus_assoc;
              rewrite Rplus_opp_r; rewrite Rplus_0_r; unfold Rdiv;
              rewrite Rmult_assoc; rewrite Rinv_r; [ ring | assumption ]. }
        replace
          (RiemannInt H13 / h0 - RiemannInt (RiemannInt_P14 a (a + h0) (f a)) / h0)
          with ((RiemannInt H13 - RiemannInt (RiemannInt_P14 a (a + h0) (f a))) / h0).
        2:{ unfold Rdiv, Rminus; rewrite Rmult_plus_distr_r; ring. }
        replace (RiemannInt H13 - RiemannInt (RiemannInt_P14 a (a + h0) (f a))) with
          (RiemannInt (RiemannInt_P10 (-1) H13 (RiemannInt_P14 a (a + h0) (f a)))).
        2:{ rewrite
              (RiemannInt_P13 H13 (RiemannInt_P14 a (a + h0) (f a))
                              (RiemannInt_P10 (-1) H13 (RiemannInt_P14 a (a + h0) (f a))))
            ; ring. }
        unfold Rdiv; rewrite Rabs_mult;
          apply Rle_lt_trans with
          (RiemannInt
             (RiemannInt_P16
                (RiemannInt_P10 (-1) H13 (RiemannInt_P14 a (a + h0) (f a)))) *
             Rabs (/ h0)).
        { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
          { apply Rabs_pos. }
          apply
            (RiemannInt_P17 (RiemannInt_P10 (-1) H13 (RiemannInt_P14 a (a + h0) (f a)))
                            (RiemannInt_P16
                               (RiemannInt_P10 (-1) H13 (RiemannInt_P14 a (a + h0) (f a)))));
            left; assumption. }
        apply Rle_lt_trans with
          (RiemannInt (RiemannInt_P14 a (a + h0) (eps / 2)) * Rabs (/ h0)).
        { do 2 rewrite &lt;- (Rmult_comm (Rabs (/ h0))); apply Rmult_le_compat_l.
          { apply Rabs_pos. }
          apply RiemannInt_P19.
          { left; assumption. }
          intros; replace (f x2 + -1 * fct_cte (f a) x2) with (f x2 - f a).
          2:{ unfold fct_cte; ring. } unfold fct_cte; case (Req_dec a x2); intro.
          { rewrite H15; unfold Rminus; rewrite Rplus_opp_r; rewrite Rabs_R0;
              left; assumption. }
          elim H8; intros; left; apply H17; repeat split.
          { assumption. }
          rewrite Rabs_right.
          { apply Rplus_lt_reg_l with a; replace (a + (x2 - a)) with x2; [ idtac | ring ].
            apply Rlt_le_trans with (a + h0).
            { elim H14; intros; assumption. }
            apply Rplus_le_compat_l; left; apply Rle_lt_trans with (Rabs h0).
            { apply RRle_abs. }
            apply Rlt_le_trans with del;
              [ assumption
              | unfold del; apply Rle_trans with (Rmin x1 (b - a));
                [ apply Rmin_r | apply Rmin_l ] ]. }
          apply Rle_ge; left; apply Rlt_0_minus; elim H14; intros; assumption. }
        rewrite RiemannInt_P15.
        rewrite Rmult_assoc; replace ((a + h0 - a) * Rabs (/ h0)) with 1.
        { lra. }
        rewrite Rabs_right.
        { rewrite Rplus_comm; unfold Rminus; rewrite Rplus_assoc;
            rewrite Rplus_opp_r; rewrite Rplus_0_r; rewrite Rinv_r;
            [ reflexivity | assumption ]. }
        apply Rle_ge; left; apply Rinv_0_lt_compat; assert (H14 := Rge_le _ _ Hnle);
          elim H14; intro.
        { assumption. }
        elim H10; symmetry ; assumption. }
      cut (a &lt;= a + h0).
      2:left;assumption.
      cut (a + h0 &lt;= b).
      { intros; unfold primitive.
        decide (Rle_dec (a+h0) b) with H14.
        decide (Rle_dec a a) with (Rle_refl a).
        decide (Rle_dec a (a+h0)) with H15.
        decide (Rle_dec a b) with h.
        rewrite RiemannInt_P9; unfold Rminus; rewrite Ropp_0;
          rewrite Rplus_0_r; apply RiemannInt_P5. }
      apply Rplus_le_reg_l with (- a); replace (- a + (a + h0)) with h0;
        [ idtac | ring ].
      rewrite Rplus_comm; apply Rle_trans with del;
        [ apply Rle_trans with (Rabs h0); [ apply RRle_abs | left; assumption ]
        | unfold del; apply Rle_trans with (Rmin x1 (b - a)); apply Rmin_r ].
  - (****
    assert (H1 : x = a).
    { rewrite &lt;- H0 in H; elim H; intros; apply Rle_antisym; assumption. }
    set (f_a := fun x:R =&gt; f a * (x - a)).
    assert (H2 : derivable_pt_lim f_a a (f a)).
    { unfold f_a;
        change (derivable_pt_lim (fct_cte (f a) * (id - fct_cte a)%F) a (f a))
      ; pattern (f a) at 2;
        replace (f a) with (0 * (id - fct_cte a)%F a + fct_cte (f a) a * 1).
      { apply derivable_pt_lim_mult.
        { apply derivable_pt_lim_const. }
        replace 1 with (1 - 0); [ idtac | ring ].
        apply derivable_pt_lim_minus.
        { apply derivable_pt_lim_id. }
        apply derivable_pt_lim_const. }
      unfold fct_cte; ring. }
    set
      (f_b := fun x:R =&gt; f b * (x - b) + RiemannInt (FTC_P1 h C0 h (Rle_refl b))).
    assert (H3 : derivable_pt_lim f_b b (f b)).
    { unfold f_b; pattern (f b) at 2; replace (f b) with (f b + 0).
      { change
          (derivable_pt_lim
             ((fct_cte (f b) * (id - fct_cte b))%F +
                fct_cte (RiemannInt (FTC_P1 h C0 h (Rle_refl b)))) b (
               f b + 0)).
        apply derivable_pt_lim_plus.
        { pattern (f b) at 2;
            replace (f b) with (0 * (id - fct_cte b)%F b + fct_cte (f b) b * 1).
          { apply derivable_pt_lim_mult.
            { apply derivable_pt_lim_const. }
            replace 1 with (1 - 0); [ idtac | ring ].
            apply derivable_pt_lim_minus.
            { apply derivable_pt_lim_id. }
            apply derivable_pt_lim_const. }
          unfold fct_cte; ring. }
        apply derivable_pt_lim_const. }
      ring. }
    unfold derivable_pt_lim; intros; elim (H2 _ H4); intros;
      elim (H3 _ H4); intros; set (del := Rmin x0 x1).
    assert (H7 : 0 &lt; del).
    { unfold del; unfold Rmin; destruct (Rle_dec x0 x1) as [Hle|Hnle].
      { apply (cond_pos x0). }
      apply (cond_pos x1). }
    split with (mkposreal _ H7); intros; destruct (Rcase_abs h0) as [Hle|Hnle].
    { assert (H10 : a + h0 &lt; a).
      { pattern a at 2; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l;
          assumption. }
      rewrite H1; unfold primitive.
      apply (decide_left (Rle_dec a b) h); intro h'.
      assert (H11:~ a&lt;=a+h0) by auto using Rlt_not_le.
      decide (Rle_dec a (a+h0)) with H11.
      decide (Rle_dec a a) with (Rle_refl a).
      rewrite RiemannInt_P9; replace 0 with (f_a a).
      { replace (f a * (a + h0 - a)) with (f_a (a + h0)).
        { apply H5; try assumption.
          apply Rlt_le_trans with del; try assumption.
          unfold del; apply Rmin_l. }
        unfold f_a; ring. }
      unfold f_a; ring. }
    assert (H10 : a &lt; a + h0).
    { pattern a at 1; rewrite &lt;- Rplus_0_r; apply Rplus_lt_compat_l.
      assert (H10 := Rge_le _ _ Hnle); elim H10; intro.
      { assumption. }
      elim H8; symmetry ; assumption. }
    rewrite H0 in H1; rewrite H1; unfold primitive.
    decide (Rle_dec a b) with h.
    decide (Rle_dec b b) with (Rle_refl b).
    assert (H12 : a&lt;=b+h0) by (eauto using Rlt_le_trans with real).
    decide (Rle_dec a (b+h0)) with H12.
    rewrite H0 in H10.
    assert (H13 : ~b+h0&lt;=b) by (auto using Rlt_not_le).
    decide (Rle_dec (b+h0) b) with H13.
    replace (RiemannInt (FTC_P1 h C0 hbis H11)) with (f_b b).
    { fold (f_b (b + h0)).
      apply H6; try assumption.
      apply Rlt_le_trans with del; try assumption.
      unfold del; apply Rmin_r. }
    unfold f_b; unfold Rminus; rewrite Rplus_opp_r;
      rewrite Rmult_0_r; rewrite Rplus_0_l; apply RiemannInt_P5.
Qed.
Lemma RiemannInt_P29 :
  forall (f:R -&gt; R) a b (h:a &lt;= b)
    (C0:forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x),
    antiderivative f (primitive h (FTC_P1 h C0)) a b.
Proof.
  intro f; intros; unfold antiderivative; split; try assumption; intros;
    assert (H0 := RiemannInt_P28 h C0 H);
      assert (H1 : derivable_pt (primitive h (FTC_P1 h C0)) x);
        [ unfold derivable_pt; split with (f x); apply H0
          | split with H1; symmetry ; apply derive_pt_eq_0; apply H0 ].
Qed.
Lemma RiemannInt_P30 :
  forall (f:R -&gt; R) (a b:R),
    a &lt;= b -&gt;
    (forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt f x) -&gt;
    { g:R -&gt; R | antiderivative f g a b }.
Proof.
  intros; split with (primitive H (FTC_P1 H H0)); apply RiemannInt_P29.
Qed.
Record C1_fun : Type := mkC1
  {c1 :&gt; R -&gt; R; diff0 : derivable c1; cont1 : continuity (derive c1 diff0)}.
Lemma RiemannInt_P31 :
  forall (f:C1_fun) (a b:R),
    a &lt;= b -&gt; antiderivative (derive f (diff0 f)) f a b.
Proof.
  intro f; intros; unfold antiderivative; split; try assumption; intros;
    split with (diff0 f x); reflexivity.
Qed.
Lemma RiemannInt_P32 :
  forall (f:C1_fun) (a b:R), Riemann_integrable (derive f (diff0 f)) a b.
Proof.
  intro f; intros; destruct (Rle_dec a b) as [Hle|Hnle];
    [ apply continuity_implies_RiemannInt; try assumption; intros;
      apply (cont1 f)
      | assert (H : b &lt;= a);
        [ auto with real
          | apply RiemannInt_P1; apply continuity_implies_RiemannInt;
            try assumption; intros; apply (cont1 f) ] ].
Qed.
Lemma RiemannInt_P33 :
  forall (f:C1_fun) (a b:R) (pr:Riemann_integrable (derive f (diff0 f)) a b),
    a &lt;= b -&gt; RiemannInt pr = f b - f a.
Proof.
  intro f; intros;
    assert
      (H0 : forall x:R, a &lt;= x &lt;= b -&gt; continuity_pt (derive f (diff0 f)) x).
  { intros; apply (cont1 f). }
  rewrite (RiemannInt_P20 H (FTC_P1 H H0) pr);
    assert (H1 := RiemannInt_P29 H H0); assert (H2 := RiemannInt_P31 f H);
    elim (antiderivative_Ucte (derive f (diff0 f)) _ _ _ _ H1 H2);
    intros C H3; repeat rewrite H3;
    [ ring
    | split; [ right; reflexivity | assumption ]
    | split; [ assumption | right; reflexivity ] ].
Qed.
Lemma FTC_Riemann :
  forall (f:C1_fun) (a b:R) (pr:Riemann_integrable (derive f (diff0 f)) a b),
    RiemannInt pr = f b - f a.
Proof.
  intro f; intros; destruct (Rle_dec a b) as [Hle|Hnle];
    [ apply RiemannInt_P33; assumption
      | assert (H : b &lt;= a);
        [ auto with real
          | assert (H0 := RiemannInt_P1 pr); rewrite (RiemannInt_P8 pr H0);
            rewrite (RiemannInt_P33 _ H0 H); ring ] ].
Qed.
RiemannInt
Lemma RiemannInt_const_bound :
  forall f a b l u (h : Riemann_integrable f a b), a &lt;= b -&gt;
    (forall x, a &lt; x &lt; b -&gt; l &lt;= f x &lt;= u) -&gt;
    l * (b - a) &lt;= RiemannInt h &lt;= u * (b - a).
intros f a b l u ri ab intf.
rewrite &lt;- !(fun l =&gt; RiemannInt_P15 (RiemannInt_P14 a b l)).
split; apply RiemannInt_P19; try assumption;
 intros x intx; unfold fct_cte; destruct (intf x intx); assumption.
Qed.
Lemma Riemann_integrable_scal :
  forall f a b k,
     Riemann_integrable f a b -&gt;
     Riemann_integrable (fun x =&gt; k * f x) a b.
intros f a b k ri.
apply Riemann_integrable_ext with
   (f := fun x =&gt; 0 + k * f x).
 { intros; ring. }
apply (RiemannInt_P10 _ (RiemannInt_P14 _ _ 0) ri).
Qed.
Arguments Riemann_integrable_scal [f a b] k _ eps.
Lemma Riemann_integrable_Ropp :
  forall f a b, Riemann_integrable f a b -&gt;
    Riemann_integrable (fun x =&gt; - f x) a b.
intros ff a b h.
apply Riemann_integrable_ext with (f := fun x =&gt; (-1) * ff x).
{ intros; ring. }
apply Riemann_integrable_scal; assumption.
Qed.
Arguments Riemann_integrable_Ropp [f a b] _ eps.
</pre>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
