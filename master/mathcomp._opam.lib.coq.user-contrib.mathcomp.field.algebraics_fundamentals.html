
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.algebraics_fundamentals</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.algebraics_fundamentals" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.ssrnum.html">ssrnum</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
<li><a href="mathcomp.ssreflect.bigop.html">bigop</a></li>
<li><a href="mathcomp.ssreflect.binomial.html">binomial</a></li>
<li><a href="mathcomp.ssreflect.choice.html">choice</a></li>
<li><a href="mathcomp.ssreflect.div.html">div</a></li>
<li><a href="mathcomp.ssreflect.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.ssreflect.finfun.html">finfun</a></li>
<li><a href="mathcomp.ssreflect.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.ssreflect.finset.html">finset</a></li>
<li><a href="mathcomp.ssreflect.fintype.html">fintype</a></li>
<li><a href="mathcomp.ssreflect.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.ssreflect.order.html">order</a></li>
<li><a href="mathcomp.ssreflect.path.html">path</a></li>
<li><a href="mathcomp.ssreflect.prime.html">prime</a></li>
<li><a href="mathcomp.ssreflect.seq.html">seq</a></li>
<li><a href="mathcomp.ssreflect.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.ssreflect.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.ssreflect.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.ssreflect.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.ssreflect.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.ssreflect.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.ssreflect.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.ssreflect.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.mathcomp.field.algebraics_fundamentals</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrbool</span><span class="id"> ssrfun</span><span class="id"> ssrnat</span><span class="id"> eqtype</span><span class="id"> seq</span><span class="id"> choice</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> div</span><span class="id"> fintype</span><span class="id"> path</span><span class="id"> tuple</span><span class="id"> bigop</span><span class="id"> finset</span><span class="id"> prime</span><span class="id"> order</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssralg</span><span class="id"> poly</span><span class="id"> polydiv</span><span class="id"> mxpoly</span><span class="id"> countalg</span><span class="id"> closed_field</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssrnum</span><span class="id"> ssrint</span><span class="id"> archimedean</span><span class="id"> rat</span><span class="id"> intdiv</span><span class="id"> fingroup</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> finalg</span><span class="id"> zmodp</span><span class="id"> cyclic</span><span class="id"> pgroup</span><span class="id"> sylow</span><span class="id"> vector</span><span class="id"> falgebra</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> fieldext</span><span class="id"> separable</span><span class="id"> galois</span>.<br/>
<br/>
<pre class="ssrdoc">
  The main result in this file is the existence theorem that underpins the
construction of the algebraic numbers in file algC.v. This theorem simply
asserts the existence of an algebraically closed field with an
automorphism of order 2, and dubbed the Fundamental_Theorem_of_Algebraics
because it is essentially the Fundamental Theorem of Algebra for algebraic
numbers (the more familiar version for complex numbers can be derived by
continuity).
  Although our proof does indeed construct exactly the algebraics, we
choose not to expose this in the statement of our Theorem. In algC.v we
construct the norm and partial order of the "complex field" introduced by
the Theorem; as these imply is has characteristic 0, we then get the
algebraics as a subfield. To avoid some duplication a few basic properties
of the algebraics, such as the existence of minimal polynomials, that are
required by the proof of the Theorem, are also proved here.
 The main theorem of closed_field supplies us directly with an algebraic
closure of the rationals (as the rationals are a countable field), so all
we really need to construct is a conjugation automorphism that exchanges
the two roots (i and -i) of X^2 + 1, and fixes a (real) subfield of
index 2. This does not require actually constructing this field: the
kHomExtend construction from galois.v supplies us with an automorphism
conj_n of the number field Q[z_n] = Q[x_n, i] for any x_n such that Q[x_n]
does not contain i (e.g., such that Q[x_n] is real). As conj_n will extend
conj_m when Q[x_n] contains x_m, it therefore suffices to construct a
sequence x_n such that
(1) For each n, Q[x_n] is a REAL field containing Q[x_m] for all m &lt;= n.
(2) Each z in C belongs to Q[z_n] = Q[x_n, i] for large enough n.
This, of course, amounts to proving the Fundamental Theorem of Algebra.
  Indeed, we use a constructive variant of Artin's algebraic proof of that
Theorem to replace (2) by
(3) Each monic polynomial over Q[x_m] whose constant term is -c^2 for some
    c in Q[x_m] has a root in Q[x_n] for large enough n.
We then ensure (3) by setting Q[x_n+1] = Q[x_n, y] where y is the root of
of such a polynomial p found by dichotomy in some interval [0, b] with b
suitably large (such that p[b] &gt;= 0), and p is obtained by decoding n into
a triple (m, p, c) that satisfies the conditions of (3) (taking x_n+1=x_n
if this is not the case), thereby ensuring that all such triples are
ultimately considered.
  In more detail, the 600-line proof consists in six (uneven) parts:
(A) - Construction of number fields (~ 100 lines): in order to make use of
    the theory developped in falgebra, fieldext, separable and galois we
    construct a separate fielExtType Q z for the number field Q[z], with
    z in C, the closure of rat supplied by countable_algebraic_closure.
    The morphism (ofQ z) maps Q z to C, and the Primitive Element Theorem
    lets us define a predicate sQ z characterizing the image of (ofQ z),
    as well as a partial inverse (inQ z) to (ofQ z).
(B) - Construction of the real extension Q[x, y] (~ 230 lines): here y has
    to be a root of a polynomial p over Q[x] satisfying the conditions of
    (3), and Q[x] should be real and archimedean, which we represent by
    a morphism from Q x to some archimedean field R, as the ssrnum and
    fieldext structures are not compatible. The construction starts by
    weakening the condition p[0] = -c^2 to p[0] &lt;= 0 (in R), then reducing
    to the case where p is the minimal polynomial over Q[x] of some y (in
    some Q[w] that contains x and all roots of p). Then we only need to
    construct a realFieldType structure for Q[t] = Q[x,y] (we don't even
    need to show it is consistent with that of R). This amounts to fixing
    the sign of all z != 0 in Q[t], consistently with arithmetic in Q[t].
    Now any such z is equal to q[y] for some q in Q[x][X] coprime with p.
    Then up + vq = 1 for Bezout coefficients u and v. As p is monic, there
    is some b0 &gt;= 0 in R such that p changes sign in ab0 = [0; b0]. As R
    is archimedean, some iteration of the binary search for a root of p in
    ab0 will yield an interval ab_n such that |up[d]| &lt; 1/2 for d in ab_n.
    Then |q[d]| &gt; 1/2M &gt; 0 for any upper bound M on |v[X]| in ab0, so q
    cannot change sign in ab_n (as then root-finding in ab_n would yield a
    d with |Mq[d]| &lt; 1/2), so we can fix the sign of z to that of q in
    ab_n.
(C) - Construction of the x_n and z_n (~50 lines): x_ n is obtained by
    iterating (B), starting with x_0 = 0, and then (A) and the PET yield
    z_ n. We establish (1) and (3), and that the minimal polynomial of the
    preimage i_ n of i over the preimage R_ n of Q[x_n] is X^2 + 1.
(D) - Establish (2), i.e., prove the FTA (~180 lines). We must depart from
    Artin's proof because deciding membership in the union of the Q[x_n]
    requires the FTA, i.e., we cannot (yet) construct a maximal real
    subfield of C. We work around this issue by first reducing to the case
    where Q[z] is Galois over Q and contains i, then using induction over
    the degree of z over Q[z_ n] (i.e., the degree of a monic polynomial
    over Q[z_n] that has z as a root). We can assume that z is not in
    Q[z_n]; then it suffices to find some y in Q[z_n, z] \ Q[z_n] that is
    also in Q[z_m] for some m &gt; n, as then we can apply induction with the
    minimal polynomial of z over Q[z_n, y]. In any Galois extension Q[t]
    of Q that contains both z and z_n, Q[x_n, z] = Q[z_n, z] is Galois
    over both Q[x_n] and Q[z_n]. If Gal(Q[x_n,z] / Q[x_n]) isn't a 2-group
    take one of its Sylow 2-groups P; the minimal polynomial p of any
    generator of the fixed field F of P over Q[x_n] has odd degree, hence
    by (3) - p[X]p[-X] and thus p has a root y in some Q[x_m], hence in
    Q[z_m]. As F is normal, y is in F, with minimal polynomial p, and y
    is not in Q[z_n] = Q[x_n, i] since p has odd degree. Otherwise,
    Gal(Q[z_n,z] / Q[z_n]) is a proper 2-group, and has a maximal subgroup
    P of index 2. The fixed field F of P has a generator w over Q[z_n]
    with w^2 in Q[z_n] \ Q[x_n], i.e. w^2 = u + 2iv with v != 0. From (3)
    X^4 - uX^2 - v^2 has a root x in some Q[x_m]; then x != 0 as v != 0,
    hence w^2 = y^2 for y = x + iv/x in Q[z_m], and y generates F.
(E) - Construct conj and conclude (~40 lines): conj z is defined as
    conj_ n z with the n provided by (2); since each conj_ m is a morphism
    of order 2 and conj z = conj_ m z for any m &gt;= n, it follows that conj
    is also a morphism of order 2.
Note that (C), (D) and (E) only depend on Q[x_n] not containing i; the
order structure is not used (hence we need not prove that the ordering of
Q[x_m] is consistent with that of Q[x_n] for m &gt;= n).
</pre>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Order</span>.<span class="id">TTheory</span><span class="id"> GroupScope</span><span class="id"> GRing</span>.<span class="id">Theory</span><span class="id"> Num</span>.<span class="id">Theory</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> ring_scope</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;p ^ f&quot;</span><span class="id"> :=</span> (<span class="id">map_poly</span><span class="id"> f</span><span class="id"> p</span>)<span class="id"> :</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;p ^@&quot;</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> in_alg</span><span class="id"> _</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;p ^@&quot;</span>)<span class="id">:</span><span class="id"> ring_scope</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;&lt;&lt; E ; u &gt;&gt;&quot;</span><span class="id"> :=</span><span class="id"> &lt;&lt;E;</span><span class="id"> u&gt;&gt;%VS</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> Qmorphism</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> {rmorphism</span><span class="id"> rat</span><span class="id"> -&gt;</span><span class="id"> C}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rat_algebraic_archimedean</span> (<span class="id">C</span><span class="id"> :</span><span class="id"> numFieldType</span>) (<span class="id">QtoC</span><span class="id"> :</span><span class="id"> Qmorphism</span><span class="id"> C</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">integralRange</span><span class="id"> QtoC</span><span class="id"> -&gt;</span><span class="id"> Num</span>.<span class="id">archimedean_axiom</span><span class="id"> C</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> algC</span><span class="id"> x</span>.<br/>
<span class="id">without</span><span class="id"> loss</span><span class="id"> x_ge0:</span><span class="id"> x</span><span class="id"> /</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -normr_id;</span><span class="id"> apply</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> nz_x]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> x</span><span class="id"> 0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 1;</span><span class="id"> rewrite</span><span class="id"> normr0</span>.<br/>
<span class="id">have</span><span class="id"> [p</span><span class="id"> mon_p</span><span class="id"> px0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> x;</span><span class="gallina-kwd"> exists</span> (<span class="id">\sum_</span>(<span class="id">j</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> p</span>)<span class="id"> `|numq</span><span class="id"> p`_j|</span>)<span class="id">%N</span>.<br/>
<span class="id">rewrite</span><span class="id"> ger0_norm</span><span class="id"> //</span><span class="id"> real_ltNge</span><span class="id"> ?rpred_nat</span><span class="id"> ?ger0_real</span><span class="id"> //</span>.<br/>
<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> px0</span><span class="id"> =&gt;</span><span class="id"> lb_x;</span><span class="id"> rewrite</span><span class="id"> rootE</span><span class="id"> gt_eqF</span><span class="id"> //</span><span class="id"> horner_coef</span><span class="id"> size_map_poly</span>.<br/>
<span class="id">have</span><span class="id"> x_gt0</span><span class="id"> k:</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> k</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> exprn_gt0</span><span class="id"> //</span><span class="id"> lt_def</span><span class="id"> nz_x</span>.<br/>
<span class="id">move:</span><span class="id"> lb_x;</span><span class="id"> rewrite</span><span class="id"> polySpred</span><span class="id"> ?monic_neq0</span><span class="id"> //</span><span class="id"> !big_ord_recr</span><span class="id"> coef_map</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> -lead_coefE</span> (<span class="id">monicP</span><span class="id"> mon_p</span>)<span class="id"> natrD</span><span class="id"> [QtoC</span><span class="id"> _]rmorph1</span><span class="id"> mul1r</span><span class="id"> =&gt;</span><span class="id"> lb_x</span>.<br/>
<span class="id">case:</span><span class="id"> _</span>.<span class="id">-1</span> (<span class="id">lb_x</span>)<span class="id"> =&gt;</span><span class="id"> [|n];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !big_ord0</span><span class="id"> !add0r</span><span class="id"> ltr01</span>.<br/>
<span class="id">rewrite</span><span class="id"> -ltrBlDl</span><span class="id"> add0r</span><span class="id"> -</span>(<span class="id">ler_pM2r</span> (<span class="id">x_gt0</span><span class="id"> n</span>))<span class="id"> -exprS</span>.<br/>
<span class="id">apply:</span><span class="id"> lt_le_trans;</span><span class="id"> rewrite</span><span class="id"> mulrDl</span><span class="id"> mul1r</span><span class="id"> ltr_pwDr</span><span class="id"> //</span><span class="id"> -sumrN</span>.<br/>
<span class="id">rewrite</span><span class="id"> natr_sum</span><span class="id"> mulr_suml</span><span class="id"> ler_sum</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
<span class="id">rewrite</span><span class="id"> coef_map</span><span class="id"> /=</span><span class="id"> fmorph_eq_rat</span> (<span class="id">le_trans</span> (<span class="id">real_ler_norm</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rpredN</span><span class="id"> rpredM</span><span class="id"> ?rpred_rat</span><span class="id"> ?rpredX</span><span class="id"> //</span><span class="id"> ger0_real</span>.<br/>
<span class="id">rewrite</span><span class="id"> normrN</span><span class="id"> normrM</span><span class="id"> ler_pM</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> normf_div</span><span class="id"> -!intr_norm</span><span class="id"> -!abszE</span><span class="id"> ler_piMr</span><span class="id"> ?ler0n</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invf_le1</span><span class="id"> ?ler1n</span><span class="id"> ?ltr0n</span><span class="id"> absz_gt0</span>.<br/>
<span class="id">rewrite</span><span class="id"> normrX</span><span class="id"> ger0_norm</span><span class="id"> ?</span>(<span class="id">ltrW</span><span class="id"> x_gt0</span>)<span class="id"> //</span><span class="id"> ler_weXn2l</span><span class="id"> ?leq_ord</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> lb_x</span>)<span class="id"> //</span><span class="id"> natr1</span><span class="id"> ler1n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> decidable_embedding</span><span class="id"> sT</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> sT</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> y,</span><span class="id"> decidable</span> (<span class="gallina-kwd">exists</span><span class="id"> x,</span><span class="id"> y</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rat_algebraic_decidable</span> (<span class="id">C</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">QtoC</span><span class="id"> :</span><span class="id"> Qmorphism</span><span class="id"> C</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">integralRange</span><span class="id"> QtoC</span><span class="id"> -&gt;</span><span class="id"> decidable_embedding</span><span class="id"> QtoC</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> QtoCinj:</span><span class="id"> injective</span><span class="id"> QtoC</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> fmorph_inj</span>.<br/>
<span class="id">pose</span><span class="id"> ZtoQ</span><span class="id"> :</span><span class="id"> int</span><span class="id"> -&gt;</span><span class="id"> rat</span><span class="id"> :=</span><span class="id"> intr;</span><span class="id"> pose</span><span class="id"> ZtoC</span><span class="id"> :</span><span class="id"> int</span><span class="id"> -&gt;</span><span class="id"> C</span><span class="id"> :=</span><span class="id"> intr</span>.<br/>
<span class="id">have</span><span class="id"> ZtoQinj:</span><span class="id"> injective</span><span class="id"> ZtoQ</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> intr_inj</span>.<br/>
<span class="id">have</span><span class="id"> defZtoC:</span><span class="id"> ZtoC</span><span class="id"> =1</span><span class="id"> QtoC</span><span class="id"> \o</span><span class="id"> ZtoQ</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> rmorph_int</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> algC</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> /sig2_eqW[q</span><span class="id"> mon_q</span><span class="id"> qx0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> x;</span><span class="id"> pose</span><span class="id"> d</span><span class="id"> :=</span> (<span class="id">size</span><span class="id"> q</span>).<span class="id">-1</span>.<br/>
<span class="id">have</span><span class="id"> [n</span><span class="id"> ub_n]:</span><span class="id"> {n</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> root</span><span class="id"> q</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> `|y|</span><span class="id"> &lt;</span><span class="id"> n}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n1</span><span class="id"> ub_n1]</span><span class="id"> :=</span><span class="id"> monic_Cauchy_bound</span><span class="id"> mon_q</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /monic_Cauchy_bound[n2</span><span class="id"> ub_n2]:</span> (<span class="id">-1</span>)<span class="id"> ^+</span><span class="id"> d</span><span class="id"> *:</span> (<span class="id">q</span><span class="id"> \Po</span><span class="id"> -</span><span class="id"> 'X</span>)<span class="id"> \is</span><span class="id"> monic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> monicE</span><span class="id"> lead_coefZ</span><span class="id"> lead_coef_comp</span><span class="id"> ?size_polyN</span><span class="id"> ?size_polyX</span><span class="id"> //</span><span class="id"> -/d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lead_coefN</span><span class="id"> lead_coefX</span> (<span class="id">monicP</span><span class="id"> mon_q</span>) (<span class="id">mulrC</span><span class="id"> 1</span>)<span class="id"> signrMK</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">Num</span>.<span class="id">max</span><span class="id"> n1</span><span class="id"> n2</span>)<span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> ltNge</span><span class="id"> ler_normr</span><span class="id"> !leUx</span><span class="id"> rootE</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> =&gt;</span><span class="id"> /orP[]/andP[]</span><span class="id"> =&gt;</span><span class="id"> [/ub_n1/gt_eqF-&gt;//</span><span class="id"> |</span><span class="id"> _</span><span class="id"> /ub_n2/gt_eqF]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> hornerZ</span><span class="id"> horner_comp</span><span class="id"> !hornerE</span><span class="id"> opprK</span><span class="id"> mulf_eq0</span><span class="id"> signr_eq0</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> -&gt;</span>.<br/>
<span class="id">have</span><span class="id"> [p</span><span class="id"> [a</span><span class="id"> nz_a</span><span class="id"> Dq]]</span><span class="id"> :=</span><span class="id"> rat_poly_scale</span><span class="id"> q;</span><span class="id"> pose</span><span class="id"> N</span><span class="id"> :=</span><span class="id"> Num</span>.<span class="id">bound</span><span class="id"> `|n</span><span class="id"> *</span><span class="id"> a%:~R|</span>.<br/>
<span class="id">pose</span><span class="id"> xa</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> rat</span><span class="id"> :=</span><span class="id"> [seq</span> (<span class="id">m%:R</span><span class="id"> -</span><span class="id"> N%:R</span>)<span class="id"> /</span><span class="id"> a%:~R</span><span class="id"> |</span><span class="id"> m</span><span class="id"> &lt;-</span><span class="id"> iota</span><span class="id"> 0</span><span class="id"> N</span>.<span class="id">*2]</span>.<br/>
<span class="id">have</span><span class="id"> [/sig2_eqW[y</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> xa'x]</span><span class="id"> :=</span><span class="id"> @mapP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> QtoC</span><span class="id"> xa</span><span class="id"> x;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span>.<br/>
<span class="id">right=&gt;</span><span class="id"> [[y</span><span class="id"> Dx]];</span><span class="id"> case:</span><span class="id"> xa'x;</span><span class="gallina-kwd"> exists</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">have{x</span><span class="id"> Dx</span><span class="id"> qx0}</span><span class="id"> qy0:</span><span class="id"> root</span><span class="id"> q</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Dx</span><span class="id"> fmorph_root</span><span class="gallina-kwd"> in</span><span class="id"> qx0</span>.<br/>
<span class="id">have</span><span class="id"> /dvdzP[b</span><span class="id"> Da]:</span> (<span class="id">denq</span><span class="id"> y</span><span class="id"> %|</span><span class="id"> a</span>)<span class="id">%Z</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Gauss_dvdzl</span><span class="id"> &lt;-:</span><span class="id"> coprimez</span> (<span class="id">denq</span><span class="id"> y</span>) (<span class="id">numq</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> d</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> coprimez_sym</span><span class="id"> coprimezXl</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> coprime_num_den</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> p1</span><span class="id"> :</span><span class="id"> {poly</span><span class="id"> int}</span><span class="id"> :=</span><span class="id"> a</span><span class="id"> *:</span><span class="id"> 'X^d</span><span class="id"> -</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Dp1:</span><span class="id"> p1</span><span class="id"> ^</span><span class="id"> intr</span><span class="id"> =</span><span class="id"> a%:~R</span><span class="id"> *:</span> (<span class="id">'X^d</span><span class="id"> -</span><span class="id"> q</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphB</span><span class="id"> /=</span><span class="id"> linearZ</span><span class="id"> /=</span><span class="id"> map_polyXn</span><span class="id"> scalerBr</span><span class="id"> Dq</span><span class="id"> scalerKV</span><span class="id"> ?intr_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/dvdzP;</span><span class="gallina-kwd"> exists</span> (<span class="id">\sum_</span>(<span class="id">i</span><span class="id"> &lt;</span><span class="id"> d</span>)<span class="id"> p1`_i</span><span class="id"> *</span><span class="id"> numq</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> *</span><span class="id"> denq</span><span class="id"> y</span><span class="id"> ^+</span> (<span class="id">d</span><span class="id"> -</span><span class="id"> i</span>.<span class="id">+1</span>)).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> ZtoQinj;</span><span class="id"> rewrite</span><span class="id"> /ZtoQ</span><span class="id"> rmorphM</span><span class="id"> mulr_suml</span><span class="id"> rmorph_sum</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">transitivity</span> ((<span class="id">p1</span><span class="id"> ^</span><span class="id"> intr</span>).<span class="id">[y]</span><span class="id"> *</span> (<span class="id">denq</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> d</span>)<span class="id">%:~R</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Dp1</span><span class="id"> !hornerE</span> (<span class="id">rootP</span><span class="id"> qy0</span>)<span class="id"> subr0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !rmorphXn</span><span class="id"> /=</span><span class="id"> numqE</span><span class="id"> exprMn</span><span class="id"> mulrA</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sz_p1:</span> (<span class="id">size</span> (<span class="id">p1</span><span class="id"> ^</span><span class="id"> ZtoQ</span>)<span class="id">%R</span><span class="id"> &lt;=</span><span class="id"> d</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Dp1</span><span class="id"> size_scale</span><span class="id"> ?intr_eq0</span><span class="id"> //;</span><span class="id"> apply/leq_sizeP=&gt;</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> eq_sym</span><span class="id"> -polySpred</span><span class="id"> ?monic_neq0</span><span class="id"> //</span><span class="id"> coefB</span><span class="id"> coefXn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> _</span><span class="id"> |</span><span class="id"> _</span><span class="id"> /</span>(<span class="id">nth_default</span><span class="id"> 0</span>)<span class="id">-&gt;//]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -lead_coefE</span> (<span class="id">monicP</span><span class="id"> mon_q</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">horner_coef_wide</span><span class="id"> _</span><span class="id"> sz_p1</span>)<span class="id"> mulr_suml;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!mulrA</span><span class="id"> -exprSr</span><span class="id"> coef_map</span><span class="id"> !rmorphM</span><span class="id"> !rmorphXn</span><span class="id"> /=</span><span class="id"> numqE</span><span class="id"> exprMn</span><span class="id"> -mulrA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -exprD</span><span class="id"> -addSnnS</span><span class="id"> subnKC</span>.<br/>
<span class="id">pose</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> `|</span>(<span class="id">numq</span><span class="id"> y</span><span class="id"> *</span><span class="id"> b</span><span class="id"> +</span><span class="id"> N</span>)<span class="id">%R|%N</span>.<br/>
<span class="id">have</span><span class="id"> Dm:</span><span class="id"> m%:R</span><span class="id"> =</span><span class="id"> `|y</span><span class="id"> *</span><span class="id"> a%:~R</span><span class="id"> +</span><span class="id"> N%:R|</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pmulrn</span><span class="id"> abszE</span><span class="id"> intr_norm</span><span class="id"> Da</span><span class="id"> rmorphD</span><span class="id"> !rmorphM</span><span class="id"> /=</span><span class="id"> numqE</span><span class="id"> mulrAC</span><span class="id"> mulrA</span>.<br/>
<span class="id">have</span><span class="id"> ltr_Qnat</span><span class="id"> n1</span><span class="id"> n2</span><span class="id"> :</span> (<span class="id">n1%:R</span><span class="id"> &lt;</span><span class="id"> n2%:R</span><span class="id"> :&gt;</span><span class="id"> rat</span><span class="id"> =</span><span class="id"> _</span>)<span class="id"> :=</span><span class="id"> ltr_nat</span><span class="id"> _</span><span class="id"> n1</span><span class="id"> n2</span>.<br/>
<span class="id">have</span><span class="id"> ub_y:</span><span class="id"> `|y</span><span class="id"> *</span><span class="id"> a%:~R|</span><span class="id"> &lt;</span><span class="id"> N%:R</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_lt_trans</span> (<span class="id">archi_boundP</span> (<span class="id">normr_ge0</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !normrM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler_pM</span><span class="id"> //</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">ler_norm</span><span class="id"> n</span>))<span class="id"> ?ltW</span><span class="id"> ?ub_n</span>.<br/>
<span class="id">apply/mapP;</span><span class="gallina-kwd"> exists</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_iota</span><span class="id"> /=</span><span class="id"> add0n</span><span class="id"> -addnn</span><span class="id"> -ltr_Qnat</span><span class="id"> Dm</span><span class="id"> natrD</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_lt_trans</span> (<span class="id">ler_normD</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> //</span><span class="id"> normr_nat</span><span class="id"> ltrD2</span>.<br/>
<span class="id">rewrite</span><span class="id"> Dm</span><span class="id"> ger0_norm</span><span class="id"> ?addrK</span><span class="id"> ?mulfK</span><span class="id"> ?intr_eq0</span><span class="id"> //</span><span class="id"> -lerBlDl</span><span class="id"> sub0r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span> (<span class="id">ler_norm</span><span class="id"> _</span>))<span class="id"> ?normrN</span><span class="id"> ?ltW</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> minPoly_decidable_closure</span><br/>
&nbsp;&nbsp;(<span class="id">F</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> closedFieldType</span>) (<span class="id">FtoL</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> F</span><span class="id"> -&gt;</span><span class="id"> L}</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">decidable_embedding</span><span class="id"> FtoL</span><span class="id"> -&gt;</span><span class="id"> integralOver</span><span class="id"> FtoL</span><span class="id"> x</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">{p</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> monic,</span><span class="id"> root</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> FtoL</span>)<span class="id"> x</span><span class="id"> &amp;</span><span class="id"> irreducible_poly</span><span class="id"> p]}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> isF</span><span class="id"> /sig2W[p</span><span class="id"> /monicP</span><span class="id"> mon_p</span><span class="id"> px0]</span>.<br/>
<span class="id">have</span><span class="id"> [r</span><span class="id"> Dp]</span><span class="id"> :=</span><span class="id"> closed_field_poly_normal</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> FtoL</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> size</span><span class="id"> r</span>.<br/>
<span class="id">rewrite</span><span class="id"> lead_coef_map</span><span class="id"> {}mon_p</span><span class="id"> rmorph1</span><span class="id"> scale1r</span><span class="gallina-kwd"> in</span><span class="id"> Dp</span>.<br/>
<span class="id">pose</span><span class="id"> Fpx</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">q</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> isF</span>)<span class="id"> &amp;&amp;</span><span class="id"> root</span><span class="id"> q</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> FpxF</span><span class="id"> q:</span><span class="id"> Fpx</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> FtoL</span>)<span class="id"> =</span><span class="id"> root</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> FtoL</span>)<span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /Fpx</span><span class="id"> polyOver_poly</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> apply/sumboolP;</span><span class="gallina-kwd"> exists</span><span class="id"> q`_j</span>.<br/>
<span class="id">pose</span><span class="id"> p_</span> (<span class="id">I</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> 'I_n}</span>)<span class="id"> :=</span><span class="id"> \prod_</span>(<span class="id">i</span><span class="id"> &lt;-</span><span class="id"> enum</span><span class="id"> I</span>) (<span class="id">'X</span><span class="id"> -</span> (<span class="id">r`_i</span>)<span class="id">%:P</span>).<br/>
<span class="id">have{px0</span><span class="id"> Dp}</span><span class="id"> /ex_minset[I</span><span class="id"> /minsetP[/andP[FpI</span><span class="id"> pIx0]</span><span class="id"> minI]]:</span><span class="gallina-kwd"> exists</span><span class="id"> I,</span><span class="id"> Fpx</span> (<span class="id">p_</span><span class="id"> I</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> setT;</span><span class="id"> suffices</span><span class="id"> -&gt;:</span><span class="id"> p_</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> FtoL</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> FpxF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dp</span> (<span class="id">big_nth</span><span class="id"> 0</span>)<span class="id"> big_mkord</span><span class="id"> /p_</span><span class="id"> big_enum;</span><span class="id"> apply/eq_bigl</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> /[1!inE]</span>.<br/>
<span class="id">have{p}</span><span class="id"> [p</span><span class="id"> DpI]:</span><span class="id"> {p</span><span class="id"> |</span><span class="id"> p_</span><span class="id"> I</span><span class="id"> =</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> FtoL}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">p_</span><span class="id"> I</span><span class="id"> ^</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> isF</span><span class="id"> y</span><span class="id"> is</span><span class="id"> left</span><span class="id"> Fy</span><span class="gallina-kwd"> then</span><span class="id"> sval</span> (<span class="id">sig_eqW</span><span class="id"> Fy</span>)<span class="gallina-kwd"> else</span><span class="id"> 0</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -map_poly_comp</span><span class="id"> map_poly_id</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /</span>(<span class="id">allP</span><span class="id"> FpI</span>)<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> unfold_in;</span><span class="id"> case:</span> (<span class="id">isF</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> Fy</span><span class="id"> _;</span><span class="id"> case:</span> (<span class="id">sig_eqW</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> mon_pI:</span><span class="id"> p_</span><span class="id"> I</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> monic_prod_XsubC</span>.<br/>
<span class="id">have</span><span class="id"> mon_p:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">map_monic</span><span class="id"> FtoL</span>)<span class="id"> -DpI</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> p;</span><span class="id"> rewrite</span><span class="id"> -DpI;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> [|q</span><span class="id"> nCq</span><span class="id"> q_dv_p]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> FtoL</span>)<span class="id"> -DpI</span> (<span class="id">root_size_gt1</span><span class="id"> _</span><span class="id"> pIx0</span>)<span class="id"> ?monic_neq0</span>.<br/>
<span class="id">rewrite</span><span class="id"> -dvdp_size_eqp</span><span class="id"> //;</span><span class="id"> apply/eqP</span>.<br/>
<span class="id">without</span><span class="id"> loss</span><span class="id"> mon_q:</span><span class="id"> q</span><span class="id"> nCq</span><span class="id"> q_dv_p</span><span class="id"> /</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> monic</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IHq;</span><span class="id"> pose</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> lead_coef</span><span class="id"> q;</span><span class="id"> pose</span><span class="id"> q1</span><span class="id"> :=</span><span class="id"> a^-1</span><span class="id"> *:</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nz_a:</span><span class="id"> a</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lead_coef_eq0</span> (<span class="id">dvdpN0</span><span class="id"> q_dv_p</span>)<span class="id"> ?monic_neq0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /IHq</span><span class="id"> IHq1:</span><span class="id"> q1</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> monicE</span><span class="id"> lead_coefZ</span><span class="id"> mulVf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -IHq1</span><span class="id"> ?size_scale</span><span class="id"> ?dvdpZl</span><span class="id"> ?invr_eq0</span>.<br/>
<span class="id">without</span><span class="id"> loss{nCq}</span><span class="id"> qx0:</span><span class="id"> q</span><span class="id"> mon_q</span><span class="id"> q_dv_p</span><span class="id"> /</span><span class="id"> root</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> FtoL</span>)<span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /dvdpP[q1</span><span class="id"> Dp]</span><span class="id"> :=</span><span class="id"> q_dv_p;</span><span class="id"> rewrite</span><span class="id"> DpI</span><span class="id"> Dp</span><span class="id"> rmorphM</span><span class="id"> rootM</span><span class="id"> -implyNb</span><span class="gallina-kwd"> in</span><span class="id"> pIx0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> mon_q1:</span><span class="id"> q1</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Dp</span><span class="id"> monicMr</span><span class="gallina-kwd"> in</span><span class="id"> mon_p</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IH;</span><span class="id"> apply:</span> (<span class="id">IH</span>) (<span class="id">implyP</span><span class="id"> pIx0</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> nCq</span><span class="id"> =&gt;</span><span class="id"> /IH</span><span class="id"> IHq1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> natr1E</span><span class="id"> -</span>(<span class="id">subnn</span> (<span class="id">size</span><span class="id"> q1</span>))<span class="id"> {1}IHq1</span><span class="id"> ?Dp</span><span class="id"> ?dvdp_mulr</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> polySpred</span><span class="id"> ?monic_neq0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqSS</span><span class="id"> size_monicM</span><span class="id"> ?monic_neq0</span><span class="id"> //</span><span class="id"> -!subn1</span><span class="id"> subnAC</span><span class="id"> addKn</span>.<br/>
<span class="id">have</span><span class="id"> /dvdp_prod_XsubC[m</span><span class="id"> Dq]:</span><span class="id"> q</span><span class="id"> ^</span><span class="id"> FtoL</span><span class="id"> %|</span><span class="id"> p_</span><span class="id"> I</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> DpI</span><span class="id"> dvdp_map</span>.<br/>
<span class="id">pose</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> [set</span><span class="id"> j</span><span class="gallina-kwd"> in</span><span class="id"> mask</span><span class="id"> m</span> (<span class="id">enum</span><span class="id"> I</span>)<span class="id">];</span><span class="id"> have{}</span><span class="id"> Dq:</span><span class="id"> q</span><span class="id"> ^</span><span class="id"> FtoL</span><span class="id"> =</span><span class="id"> p_</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -eqp_monic</span><span class="id"> ?monic_map</span><span class="id"> ?monic_prod_XsubC</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span> (_<span class="id"> %=</span><span class="id"> _</span>)<span class="id">:</span><span class="id"> Dq;</span><span class="id"> apply:</span><span class="id"> perm_big</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?mask_uniq</span><span class="id"> ?enum_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> mem_enum</span><span class="id"> inE</span>.<br/>
<span class="id">rewrite</span><span class="id"> -!</span>(<span class="id">size_map_poly</span><span class="id"> FtoL</span>)<span class="id"> Dq</span><span class="id"> -DpI</span> (<span class="id">minI</span><span class="id"> B</span>)<span class="id"> //</span><span class="id"> -?Dq</span><span class="id"> ?FpxF</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> j</span><span class="id"> /[1!inE]</span><span class="id"> /mem_mask;</span><span class="id"> rewrite</span><span class="id"> mem_enum</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> alg_integral</span> (<span class="id">F</span><span class="id"> :</span><span class="id"> fieldType</span>) (<span class="id">L</span><span class="id"> :</span><span class="id"> fieldExtType</span><span class="id"> F</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">integralRange</span> (<span class="id">in_alg</span><span class="id"> L</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> [/polyOver1P[p</span><span class="id"> Dp]]</span><span class="id"> :=</span> (<span class="id">minPolyOver</span><span class="id"> 1</span><span class="id"> x,</span><span class="id"> monic_minPoly</span><span class="id"> 1</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dp</span><span class="id"> map_monic;</span><span class="gallina-kwd"> exists</span><span class="id"> p;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> -Dp</span><span class="id"> root_minPoly</span>.<br/>
Qed.</div></details>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> alg_integral</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> map_poly_inj</span><span class="id"> {F</span><span class="id"> R}</span><span class="id"> f</span><span class="id"> [p1</span><span class="id"> p2]</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> Fundamental_Theorem_of_Algebraics</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{L</span><span class="id"> :</span><span class="id"> closedFieldType</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{conj</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> L</span><span class="id"> -&gt;</span><span class="id"> L}</span><span class="id"> |</span><span class="id"> involutive</span><span class="id"> conj</span><span class="id"> &amp;</span><span class="id"> ~</span><span class="id"> conj</span><span class="id"> =1</span><span class="id"> id}}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> maxn3</span><span class="id"> n1</span><span class="id"> n2</span><span class="id"> n3:</span><span class="id"> {m</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> n1</span><span class="id"> &lt;=</span><span class="id"> m,</span><span class="id"> n2</span><span class="id"> &lt;=</span><span class="id"> m</span><span class="id"> &amp;</span><span class="id"> n3</span><span class="id"> &lt;=</span><span class="id"> m]%N}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> n1</span> (<span class="id">maxn</span><span class="id"> n2</span><span class="id"> n3</span>))<span class="id">;</span><span class="id"> apply/and3P;</span><span class="id"> rewrite</span><span class="id"> -!geq_max</span>.<br/>
<span class="id">have</span><span class="id"> [C</span><span class="id"> [/=</span><span class="id"> QtoC</span><span class="id"> algC]]</span><span class="id"> :=</span><span class="id"> countable_algebraic_closure</span><span class="id"> rat</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> C;</span><span class="id"> have</span><span class="id"> [i</span><span class="id"> Di2]</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">imaginary_exists</span><span class="id"> C</span>.<br/>
<span class="id">pose</span><span class="id"> Qfield</span><span class="id"> :=</span><span class="id"> fieldExtType</span><span class="id"> rat</span>.<br/>
<span class="id">pose</span><span class="id"> Cmorph</span> (<span class="id">L</span><span class="id"> :</span><span class="id"> Qfield</span>)<span class="id"> :=</span><span class="id"> {rmorphism</span><span class="id"> L</span><span class="id"> -&gt;</span><span class="id"> C}</span>.<br/>
<span class="id">have</span><span class="id"> pcharQ</span> (<span class="id">L</span><span class="id"> :</span><span class="id"> Qfield</span>)<span class="id">:</span><span class="id"> [pchar</span><span class="id"> L]</span><span class="id"> =i</span><span class="id"> pred0</span><span class="id"> :=</span><span class="id"> ftrans</span> (<span class="id">pchar_lalg</span><span class="id"> L</span>) (<span class="id">pchar_num</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> sepQ</span>  (<span class="id">L</span><span class="id"> :</span><span class="id"> Qfield</span>) (<span class="id">K</span><span class="id"> E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> L}</span>)<span class="id">:</span><span class="id"> separable</span><span class="id"> K</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/separableP=&gt;</span><span class="id"> u</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> pcharf0_separable</span>.<br/>
<span class="id">pose</span><span class="id"> genQfield</span><span class="id"> z</span><span class="id"> L</span><span class="id"> :=</span><span class="id"> {LtoC</span><span class="id"> :</span><span class="id"> Cmorph</span><span class="id"> L</span><span class="id"> &amp;</span><span class="id"> {u</span><span class="id"> |</span><span class="id"> LtoC</span><span class="id"> u</span><span class="id"> =</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> &lt;&lt;1;</span><span class="id"> u&gt;&gt;</span><span class="id"> =</span><span class="id"> fullv}}</span>.<br/>
<span class="id">have</span><span class="id"> /all_tag[Q</span><span class="id"> /all_tag[ofQ</span><span class="id"> genQz]]</span><span class="id"> z:</span><span class="id"> {Qz</span><span class="id"> :</span><span class="id"> Qfield</span><span class="id"> &amp;</span><span class="id"> genQfield</span><span class="id"> z</span><span class="id"> Qz}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|p</span><span class="id"> [/monic_neq0</span><span class="id"> nzp</span><span class="id"> pz0</span><span class="id"> irr_p]]</span><span class="id"> :=</span><span class="id"> minPoly_decidable_closure</span><span class="id"> _</span> (<span class="id">algC</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> rat_algebraic_decidable</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Qz</span><span class="id"> :=</span><span class="id"> SubFieldExtType</span><span class="id"> pz0</span><span class="id"> irr_p</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> QzC</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> :=</span><span class="id"> @subfx_inj</span><span class="id"> _</span><span class="id"> _</span><span class="id"> QtoC</span><span class="id"> z</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> Qz,</span><span class="id"> QzC,</span> (<span class="id">subfx_root</span><span class="id"> QtoC</span><span class="id"> z</span><span class="id"> p</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> subfx_inj_root</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/vspaceP=&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> memvf;</span><span class="id"> apply/Fadjoin1_polyP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [q]</span><span class="id"> :=</span><span class="id"> subfxEroot</span><span class="id"> pz0</span><span class="id"> nzp</span><span class="id"> u;</span><span class="gallina-kwd"> exists</span><span class="id"> q</span>.<br/>
<span class="id">have</span><span class="id"> pQof</span><span class="id"> z</span><span class="id"> p:</span><span class="id"> p^@</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> =</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> QtoC</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -map_poly_comp;</span><span class="id"> apply:</span><span class="id"> eq_map_poly</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> !fmorph_eq_rat</span>.<br/>
<span class="id">have</span><span class="id"> pQof2</span><span class="id"> z</span><span class="id"> p</span><span class="id"> u:</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> p^@</span>.<span class="id">[u]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QtoC</span>).<span class="id">[ofQ</span><span class="id"> z</span><span class="id"> u]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -horner_map</span><span class="id"> pQof</span>.<br/>
<span class="id">have</span><span class="id"> PET_Qz</span><span class="id"> z</span> (<span class="id">E</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> Q</span><span class="id"> z}</span>)<span class="id">:</span><span class="id"> {u</span><span class="id"> |</span><span class="id"> &lt;&lt;1;</span><span class="id"> u&gt;&gt;</span><span class="id"> =</span><span class="id"> E}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">separable_generator</span><span class="id"> 1</span><span class="id"> E</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eq_adjoin_separable_generator</span><span class="id"> ?sub1v</span>.<br/>
<span class="id">pose</span><span class="id"> gen</span><span class="id"> z</span><span class="id"> x</span><span class="id"> :=</span><span class="gallina-kwd"> exists</span><span class="id"> q,</span><span class="id"> x</span><span class="id"> =</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> QtoC</span>).<span class="id">[z]</span>.<br/>
<span class="id">have</span><span class="id"> PET2</span><span class="id"> x</span><span class="id"> y:</span><span class="id"> {z</span><span class="id"> |</span><span class="id"> gen</span><span class="id"> z</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> gen</span><span class="id"> z</span><span class="id"> y}</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Gxy</span><span class="id"> :=</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> let:</span> (<span class="id">p,</span><span class="id"> q,</span><span class="id"> z</span>)<span class="id"> :=</span><span class="id"> _</span><span class="gallina-kwd"> in</span> ((<span class="id">p</span><span class="id"> ^</span><span class="id"> QtoC</span>).<span class="id">[z],</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> QtoC</span>).<span class="id">[z]</span>).<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> [[[p</span><span class="id"> q]</span><span class="id"> z]</span><span class="id"> []]:</span><span class="id"> {w</span><span class="id"> |</span><span class="id"> Gxy</span><span class="id"> w}</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> [exists</span><span class="id"> p</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> q]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/sig_eqW;</span><span class="id"> have</span><span class="id"> /integral_algebraic[px</span><span class="id"> nz_px</span><span class="id"> pxx0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /integral_algebraic[py</span><span class="id"> nz_py</span><span class="id"> pyy0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n</span><span class="id"> [[p</span><span class="id"> Dx]</span><span class="id"> [q</span><span class="id"> Dy]]]</span><span class="id"> :=</span><span class="id"> pchar0_PET</span><span class="id"> nz_px</span><span class="id"> pxx0</span><span class="id"> nz_py</span><span class="id"> pyy0</span> (<span class="id">pchar_num</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">p,</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> *+</span><span class="id"> n</span><span class="id"> -</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> congr</span> (<span class="id">_,</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> gen_inQ</span><span class="id"> z</span><span class="id"> x:</span><span class="id"> gen</span><span class="id"> z</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> {u</span><span class="id"> |</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> u</span><span class="id"> =</span><span class="id"> x}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [u</span><span class="id"> Dz</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> genQz</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> /sig_eqW[q</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> q^@</span>.<span class="id">[u];</span><span class="id"> rewrite</span><span class="id"> pQof2</span><span class="id"> Dz</span>.<br/>
<span class="id">have</span><span class="id"> gen_ofP</span><span class="id"> z</span><span class="id"> u</span><span class="id"> v:</span><span class="id"> reflect</span> (<span class="id">gen</span> (<span class="id">ofQ</span><span class="id"> z</span><span class="id"> u</span>) (<span class="id">ofQ</span><span class="id"> z</span><span class="id"> v</span>)) (<span class="id">v</span><span class="id"> \in</span><span class="id"> &lt;&lt;1;</span><span class="id"> u&gt;&gt;</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> Fadjoin1_polyP</span>)<span class="id"> =&gt;</span><span class="id"> [[q</span><span class="id"> -&gt;]|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pQof2;</span><span class="gallina-kwd"> exists</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> q;</span><span class="id"> rewrite</span><span class="id"> -pQof2</span><span class="id"> =&gt;</span><span class="id"> /fmorph_inj-&gt;;</span><span class="gallina-kwd"> exists</span><span class="id"> q</span>.<br/>
<span class="id">have</span><span class="id"> /all_tag[sQ</span><span class="id"> genP]</span><span class="id"> z:</span><span class="id"> {s</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> C</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> reflect</span> (<span class="id">gen</span><span class="id"> z</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> all_tag</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> reflect</span> (<span class="id">gen</span><span class="id"> z</span><span class="id"> x</span>))<span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [w</span><span class="id"> /gen_inQ[u</span><span class="id"> &lt;-]</span><span class="id"> /gen_inQ[v</span><span class="id"> &lt;-]]</span><span class="id"> :=</span><span class="id"> PET2</span><span class="id"> z</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">v</span><span class="id"> \in</span><span class="id"> &lt;&lt;1;</span><span class="id"> u&gt;&gt;</span>)<span class="id">%VS;</span><span class="id"> apply:</span><span class="id"> gen_ofP</span>.<br/>
<span class="id">have</span><span class="id"> sQtrans:</span><span class="id"> transitive</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> /genP[p</span><span class="id"> -&gt;]</span><span class="id"> /genP[q</span><span class="id"> -&gt;];</span><span class="id"> apply/genP;</span><span class="gallina-kwd"> exists</span> (<span class="id">p</span><span class="id"> \Po</span><span class="id"> q</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_comp_poly</span><span class="id"> horner_comp</span>.<br/>
<span class="id">have</span><span class="id"> sQid</span><span class="id"> z:</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="gallina-kwd"> by</span><span class="id"> apply/genP;</span><span class="gallina-kwd"> exists</span><span class="id"> 'X;</span><span class="id"> rewrite</span><span class="id"> map_polyX</span><span class="id"> hornerX</span>.<br/>
<span class="id">have{gen_ofP}</span><span class="id"> sQof2</span><span class="id"> z</span><span class="id"> u</span><span class="id"> v:</span> (<span class="id">ofQ</span><span class="id"> z</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">ofQ</span><span class="id"> z</span><span class="id"> v</span>))<span class="id"> =</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> &lt;&lt;1;</span><span class="id"> v&gt;&gt;%VS</span>).<br/>
&nbsp;&nbsp;<span class="id">exact/genP/</span>(<span class="id">gen_ofP</span><span class="id"> z</span>).<br/>
<span class="id">have</span><span class="id"> sQof</span><span class="id"> z</span><span class="id"> v:</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [u</span><span class="id"> Dz</span><span class="id"> defQz]</span><span class="id"> :=</span><span class="id"> genQz</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> sQ</span><span class="id"> z]Dz</span><span class="id"> sQof2</span><span class="id"> defQz</span><span class="id"> memvf</span>.<br/>
<span class="id">have{gen_inQ}</span><span class="id"> sQ_inQ</span><span class="id"> z</span><span class="id"> x</span><span class="id"> z_x</span><span class="id"> :=</span><span class="id"> gen_inQ</span><span class="id"> z</span><span class="id"> x</span> (<span class="id">genP</span><span class="id"> z</span><span class="id"> x</span><span class="id"> z_x</span>).<br/>
<span class="id">have</span><span class="id"> /all_sig[inQ</span><span class="id"> inQ_K]</span><span class="id"> z:</span><span class="id"> {inQ</span><span class="id"> |</span><span class="id"> {in</span><span class="id"> sQ</span><span class="id"> z,</span><span class="id"> cancel</span><span class="id"> inQ</span> (<span class="id">ofQ</span><span class="id"> z</span>)<span class="id">}}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> all_sig_cond</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> u</span><span class="id"> =</span><span class="id"> x</span>)<span class="id"> 0</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /sQ_inQ</span>.<br/>
<span class="id">have</span><span class="id"> ofQ_K</span><span class="id"> z:</span><span class="id"> cancel</span> (<span class="id">ofQ</span><span class="id"> z</span>) (<span class="id">inQ</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> have</span><span class="id"> /inQ_K/fmorph_inj</span><span class="id"> :=</span><span class="id"> sQof</span><span class="id"> z</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> sQring</span><span class="id"> z:</span><span class="id"> divring_closed</span> (<span class="id">sQ</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sQ_1:</span><span class="id"> 1</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">rmorph1</span> (<span class="id">ofQ</span><span class="id"> z</span>))<span class="id"> sQof</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /inQ_K&lt;-</span><span class="id"> /inQ_K&lt;-</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">rmorphB,</span><span class="id"> fmorph_div</span>)<span class="id"> sQof</span>.<br/>
<span class="id">pose</span><span class="id"> sQoM</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isOppClosed</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sQring</span><span class="id"> z</span>).<br/>
<span class="id">pose</span><span class="id"> sQaM</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isAddClosed</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sQring</span><span class="id"> z</span>).<br/>
<span class="id">pose</span><span class="id"> sQmM</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMulClosed</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sQring</span><span class="id"> z</span>).<br/>
<span class="id">pose</span><span class="id"> sQiM</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isInvClosed</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">sQring</span><span class="id"> z</span>).<br/>
<span class="id">pose</span><span class="id"> sQC</span><span class="id"> z</span><span class="id"> :</span><span class="id"> divringClosed</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span> (<span class="id">sQ</span><span class="id"> z</span>)<br/>
&nbsp;&nbsp;(<span class="id">sQaM</span><span class="id"> z</span>) (<span class="id">sQoM</span><span class="id"> z</span>) (<span class="id">sQmM</span><span class="id"> z</span>) (<span class="id">sQiM</span><span class="id"> z</span>).<br/>
<span class="id">pose</span><span class="id"> morph_ofQ</span><span class="id"> x</span><span class="id"> z</span><span class="id"> Qxz</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> u,</span><span class="id"> ofQ</span><span class="id"> z</span> (<span class="id">Qxz</span><span class="id"> u</span>)<span class="id"> =</span><span class="id"> ofQ</span><span class="id"> x</span><span class="id"> u</span>.<br/>
<span class="id">have</span><span class="id"> QtoQ</span><span class="id"> z</span><span class="id"> x:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="id"> -&gt;</span><span class="id"> {Qxz</span><span class="id"> :</span><span class="id"> 'AHom</span>(<span class="id">Q</span><span class="id"> x,</span><span class="id"> Q</span><span class="id"> z</span>)<span class="id"> |</span><span class="id"> morph_ofQ</span><span class="id"> x</span><span class="id"> z</span><span class="id"> Qxz}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z_x;</span><span class="id"> pose</span><span class="id"> Qxz</span><span class="id"> u</span><span class="id"> :=</span><span class="id"> inQ</span><span class="id"> z</span> (<span class="id">ofQ</span><span class="id"> x</span><span class="id"> u</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> QxzE</span><span class="id"> u:</span><span class="id"> ofQ</span><span class="id"> z</span> (<span class="id">Qxz</span><span class="id"> u</span>)<span class="id"> =</span><span class="id"> ofQ</span><span class="id"> x</span><span class="id"> u</span><span class="gallina-kwd"> by</span><span class="id"> apply/inQ_K/</span>(<span class="id">sQtrans</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Qxza</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> Qxz</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> u</span><span class="id"> v;</span><span class="id"> apply:</span> (<span class="id">canLR</span> (<span class="id">ofQ_K</span><span class="id"> z</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !rmorphB</span><span class="id"> !QxzE</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Qxzm</span><span class="id"> :</span><span class="id"> multiplicative</span><span class="id"> Qxz</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [u</span><span class="id"> v|];</span><span class="id"> apply:</span> (<span class="id">canLR</span> (<span class="id">ofQ_K</span><span class="id"> z</span>))<span class="id">;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ?rmorph1</span><span class="id"> ?rmorphM</span><span class="id"> /=</span><span class="id"> ?QxzE</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> QxzaM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isAdditive</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Qxza</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> QxzmM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> Qxzm</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> QxzlM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isScalable</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">rat_linear</span><span class="id"> Qxza</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> QxzLRM</span><span class="id"> :</span><span class="id"> {lrmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> Qxz</span><span class="id"> QxzaM</span><span class="id"> QxzmM</span><span class="id"> QxzlM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">linfun_ahom</span><span class="id"> QxzLRM</span>)<span class="id"> =&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> lfunE</span><span class="id"> QxzE</span>.<br/>
<span class="id">pose</span><span class="id"> sQs</span><span class="id"> z</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> all</span> (<span class="id">mem</span> (<span class="id">sQ</span><span class="id"> z</span>))<span class="id"> s</span>.<br/>
<span class="id">have</span><span class="id"> inQsK</span><span class="id"> z</span><span class="id"> s:</span><span class="id"> sQs</span><span class="id"> z</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> map</span> (<span class="id">ofQ</span><span class="id"> z</span>) (<span class="id">map</span> (<span class="id">inQ</span><span class="id"> z</span>)<span class="id"> s</span>)<span class="id"> =</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -map_comp</span><span class="id"> =&gt;</span><span class="id"> /allP/</span>(_<span class="id"> _</span><span class="id"> _</span>)<span class="id">/inQ_K;</span><span class="id"> apply:</span><span class="id"> map_id_in</span>.<br/>
<span class="id">have</span><span class="id"> inQpK</span><span class="id"> z</span><span class="id"> p:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span> (<span class="id">sQ</span><span class="id"> z</span>)<span class="id"> -&gt;</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> inQ</span><span class="id"> z</span>)<span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /allP/</span>(_<span class="id"> _</span><span class="id"> _</span>)<span class="id">/inQ_K/=/map_poly_id;</span><span class="id"> rewrite</span><span class="id"> -map_poly_comp</span>.<br/>
<span class="id">have{gen</span><span class="id"> PET2</span><span class="id"> genP}</span><span class="id"> PET</span><span class="id"> s:</span><span class="id"> {z</span><span class="id"> |</span><span class="id"> sQs</span><span class="id"> z</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> &lt;&lt;1</span><span class="id"> &amp;</span><span class="id"> map</span> (<span class="id">inQ</span><span class="id"> z</span>)<span class="id"> s&gt;&gt;%VS</span><span class="id"> =</span><span class="id"> fullv}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [y</span><span class="id"> /inQsK</span><span class="id"> Ds]:</span><span class="id"> {y</span><span class="id"> |</span><span class="id"> sQs</span><span class="id"> y</span><span class="id"> s}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> [y</span><span class="id"> IHs]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [z</span><span class="id"> /genP</span><span class="id"> z_x</span><span class="id"> /genP</span><span class="id"> z_y]</span><span class="id"> :=</span><span class="id"> PET2</span><span class="id"> x</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> {x}z_x;</span><span class="id"> apply:</span><span class="id"> sub_all</span><span class="id"> IHs</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /sQtrans/=</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [w</span><span class="id"> defQs]</span><span class="id"> :=</span><span class="id"> PET_Qz</span><span class="id"> _</span><span class="id"> &lt;&lt;1</span><span class="id"> &amp;</span><span class="id"> map</span> (<span class="id">inQ</span><span class="id"> y</span>)<span class="id"> s&gt;&gt;%AS;</span><span class="id"> pose</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> ofQ</span><span class="id"> y</span><span class="id"> w</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> z_s:</span><span class="id"> sQs</span><span class="id"> z</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -Ds</span><span class="id"> /sQs</span><span class="id"> all_map;</span><span class="id"> apply/allP=&gt;</span><span class="id"> u</span><span class="id"> s_u</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sQof2</span><span class="id"> defQs</span><span class="id"> seqv_sub_adjoin</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[u</span><span class="id"> Dz</span><span class="id"> defQz]</span><span class="id"> [Qzy</span><span class="id"> QzyE]]</span><span class="id"> :=</span> (<span class="id">genQz</span><span class="id"> z,</span><span class="id"> QtoQ</span><span class="id"> y</span><span class="id"> z</span> (<span class="id">sQof</span><span class="id"> y</span><span class="id"> w</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> subvf</span><span class="id"> /=</span><span class="id"> -defQz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">limg_ker0</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">AHom_lker0</span><span class="id"> Qzy</span>))<span class="id"> aimg_adjoin_seq</span><span class="id"> aimg_adjoin</span><span class="id"> aimg1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[map</span><span class="id"> _</span><span class="id"> _]</span>(<span class="id">mapK</span> (<span class="id">ofQ_K</span><span class="id"> y</span>))<span class="id"> -</span>(<span class="id">map_comp</span> (<span class="id">ofQ</span><span class="id"> y</span>)) (<span class="id">eq_map</span><span class="id"> QzyE</span>)<span class="id"> inQsK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defQs</span><span class="id"> -</span>(<span class="id">canLR</span> (<span class="id">ofQ_K</span><span class="id"> y</span>)<span class="id"> Dz</span>)<span class="id"> -QzyE</span><span class="id"> ofQ_K</span>.<br/>
<span class="id">pose</span><span class="id"> rp</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> \prod_</span>(<span class="id">z</span><span class="id"> &lt;-</span><span class="id"> s</span>) (<span class="id">'X</span><span class="id"> -</span><span class="id"> z%:P</span>).<br/>
<span class="id">have</span><span class="id"> map_rp</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span>)<span class="id"> s:</span><span class="id"> rp</span><span class="id"> _</span><span class="id"> s</span><span class="id"> ^</span><span class="id"> f</span><span class="id"> =</span><span class="id"> rp</span><span class="id"> _</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rmorph_prod</span><span class="id"> /rp</span><span class="id"> big_map;</span><span class="id"> apply:</span><span class="id"> eq_bigr</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphB</span><span class="id"> /=</span><span class="id"> map_polyX</span><span class="id"> map_polyC</span>.<br/>
<span class="id">pose</span><span class="id"> is_Gal</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> SplittingField</span>.<span class="id">axiom</span> (<span class="id">Q</span><span class="id"> z</span>).<br/>
<span class="id">have</span><span class="id"> galQ</span><span class="id"> x:</span><span class="id"> {z</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> is_Gal</span><span class="id"> z}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sig2W[p</span><span class="id"> mon_p</span><span class="id"> pz0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [s</span><span class="id"> Dp]</span><span class="id"> :=</span><span class="id"> closed_field_poly_normal</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QtoC</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">monicP</span><span class="id"> _</span>)<span class="id"> ?monic_map</span><span class="id"> //</span><span class="id"> scale1r</span><span class="gallina-kwd"> in</span><span class="id"> Dp;</span><span class="id"> have</span><span class="id"> [z</span><span class="id"> z_s</span><span class="id"> defQz]</span><span class="id"> :=</span><span class="id"> PET</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> z;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/</span>(<span class="id">allP</span><span class="id"> z_s</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -root_prod_XsubC</span><span class="id"> -Dp</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> p^@;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> alg_polyOver</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">map</span> (<span class="id">inQ</span><span class="id"> z</span>)<span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/vspaceP=&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> defQz</span><span class="id"> memvf</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eqp_map</span> (<span class="id">ofQ</span><span class="id"> z</span>))<span class="id"> pQof</span><span class="id"> Dp</span><span class="id"> map_rp</span><span class="id"> inQsK</span><span class="id"> ?eqpxx</span>.<br/>
<span class="id">pose</span><span class="id"> is_realC</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> {R</span><span class="id"> :</span><span class="id"> archiRealFieldType</span><span class="id"> &amp;</span><span class="id"> {rmorphism</span><span class="id"> Q</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R}}</span>.<br/>
<span class="id">pose</span><span class="id"> realC</span><span class="id"> :=</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> C</span><span class="id"> &amp;</span><span class="id"> is_realC</span><span class="id"> x}</span>.<br/>
<span class="id">pose</span><span class="id"> has_Rroot</span> (<span class="id">xR</span><span class="id"> :</span><span class="id"> realC</span>)<span class="id"> p</span><span class="id"> c</span> (<span class="id">Rx</span><span class="id"> :=</span><span class="id"> sQ</span> (<span class="id">tag</span><span class="id"> xR</span>))<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[&amp;&amp;</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Rx,</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> monic,</span><span class="id"> c</span><span class="id"> \in</span><span class="id"> Rx</span><span class="id"> &amp;</span><span class="id"> p</span>.<span class="id">[0]</span><span class="id"> ==</span><span class="id"> -</span><span class="id"> c</span><span class="id"> ^+</span><span class="id"> 2]</span>.<br/>
<span class="id">pose</span><span class="id"> root_in</span> (<span class="id">xR</span><span class="id"> :</span><span class="id"> realC</span>)<span class="id"> p</span><span class="id"> :=</span><span class="gallina-kwd"> exists2</span><span class="id"> w,</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">tag</span><span class="id"> xR</span>)<span class="id"> &amp;</span><span class="id"> root</span><span class="id"> p</span><span class="id"> w</span>.<br/>
<span class="id">pose</span><span class="id"> extendsR</span> (<span class="id">xR</span><span class="id"> yR</span><span class="id"> :</span><span class="id"> realC</span>)<span class="id"> :=</span><span class="id"> tag</span><span class="id"> xR</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">tag</span><span class="id"> yR</span>).<br/>
<span class="id">have</span><span class="id"> add_Rroot</span><span class="id"> xR</span><span class="id"> p</span><span class="id"> c:</span><span class="id"> {yR</span><span class="id"> |</span><span class="id"> extendsR</span><span class="id"> xR</span><span class="id"> yR</span><span class="id"> &amp;</span><span class="id"> has_Rroot</span><span class="id"> xR</span><span class="id"> p</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> root_in</span><span class="id"> yR</span><span class="id"> p}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {}/extendsR;</span><span class="id"> case:</span> (<span class="id">has_Rroot</span><span class="id"> xR</span><span class="id"> p</span><span class="id"> c</span>)<span class="id"> /</span><span class="id"> and4P;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> xR</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> xR</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [R</span><span class="id"> QxR]</span><span class="id"> /=</span><span class="id"> [/inQpK</span><span class="id"> &lt;-];</span><span class="id"> move:</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> {}p</span><span class="id"> mon_p</span><span class="id"> /inQ_K&lt;-</span><span class="id"> Dc</span>.<br/>
&nbsp;&nbsp;<span class="id">have{c</span><span class="id"> Dc}</span><span class="id"> p0_le0:</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QxR</span>).<span class="id">[0]</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> horner_coef0</span><span class="id"> coef_map</span><span class="id"> -[p`_0]ofQ_K</span><span class="id"> -coef_map</span><span class="id"> -horner_coef0</span> (<span class="id">eqP</span><span class="id"> Dc</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -rmorphXn</span><span class="id"> -rmorphN</span><span class="id"> ofQ_K</span><span class="id"> /=</span><span class="id"> rmorphN</span><span class="id"> rmorphXn</span><span class="id"> oppr_le0</span><span class="id"> sqr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [s</span><span class="id"> Dp]</span><span class="id"> :=</span><span class="id"> closed_field_poly_normal</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="id">have{Dp}</span><span class="id"> /all_and2[s_p</span><span class="id"> p_s]</span><span class="id"> y:</span><span class="id"> root</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> x</span>)<span class="id"> y</span><span class="id"> &lt;-&gt;</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dp</span> (<span class="id">monicP</span><span class="id"> mon_p</span>)<span class="id"> scale1r</span><span class="id"> root_prod_XsubC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_monic</span><span class="gallina-kwd"> in</span><span class="id"> mon_p;</span><span class="id"> have</span><span class="id"> [z</span><span class="id"> /andP[z_x</span><span class="id"> /allP/=z_s]</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> PET</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;<span class="id">have{z_x}</span><span class="id"> [[Qxz</span><span class="id"> QxzE]</span><span class="id"> Dx]</span><span class="id"> :=</span> (<span class="id">QtoQ</span><span class="id"> z</span><span class="id"> x</span><span class="id"> z_x,</span><span class="id"> inQ_K</span><span class="id"> z</span><span class="id"> x</span><span class="id"> z_x</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Qx</span><span class="id"> :=</span><span class="id"> &lt;&lt;1;</span><span class="id"> inQ</span><span class="id"> z</span><span class="id"> x&gt;&gt;%AS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> pQwx</span><span class="id"> q1:</span><span class="id"> q1</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Qx</span><span class="id"> -&gt;</span><span class="id"> {q</span><span class="id"> |</span><span class="id"> q1</span><span class="id"> =</span><span class="id"> q</span><span class="id"> ^</span><span class="id"> Qxz}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/polyOverP=&gt;</span><span class="id"> Qx_q1;</span><span class="gallina-kwd"> exists</span> ((<span class="id">q1</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> z</span>)<span class="id"> ^</span><span class="id"> inQ</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">map_poly_inj</span> (<span class="id">ofQ</span><span class="id"> z</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -map_poly_comp</span> (<span class="id">eq_map_poly</span><span class="id"> QxzE</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inQpK</span><span class="id"> ?polyOver_poly</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -Dx</span><span class="id"> sQof2</span><span class="id"> Qx_q1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /all_sig[t_</span><span class="id"> Dt]</span><span class="id"> u:</span><span class="id"> {t</span><span class="id"> |</span><span class="id"> &lt;&lt;1;</span><span class="id"> t&gt;&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;Qx;</span><span class="id"> u&gt;&gt;}</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> PET_Qz</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices{p_s}[u</span><span class="id"> Ry</span><span class="id"> px0]:</span><span class="id"> {u</span><span class="id"> :</span><span class="id"> Q</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> is_realC</span> (<span class="id">ofQ</span><span class="id"> z</span> (<span class="id">t_</span><span class="id"> u</span>))<span class="id"> &amp;</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> s}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">Tagged</span><span class="id"> is_realC</span><span class="id"> Ry</span>)<span class="id"> =&gt;</span><span class="id"> [|_]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Dx</span><span class="id"> sQof2</span><span class="id"> Dt</span><span class="id"> subvP_adjoin</span><span class="id"> ?memv_adjoin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">ofQ</span><span class="id"> z</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?p_s</span><span class="id"> //</span><span class="id"> sQof2</span><span class="id"> Dt</span><span class="id"> memv_adjoin</span>.<br/>
&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss{z_s</span><span class="id"> s_p}</span><span class="id"> [u</span><span class="id"> Dp</span><span class="id"> s_y]:</span><span class="id"> p</span><span class="id"> mon_p</span><span class="id"> p0_le0</span><span class="id"> /</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{u</span><span class="id"> |</span><span class="id"> minPoly</span><span class="id"> Qx</span><span class="id"> u</span><span class="id"> =</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> Qxz</span><span class="id"> &amp;</span><span class="id"> ofQ</span><span class="id"> z</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> s}</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> IHp;</span><span class="id"> move:</span><span class="id"> {2}_</span>.<span class="id">+1</span> (<span class="id">ltnSn</span> (<span class="id">size</span><span class="id"> p</span>))<span class="id"> =&gt;</span><span class="id"> d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> d</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> d</span><span class="id"> IHd</span><span class="gallina-kwd"> in</span><span class="id"> p</span><span class="id"> mon_p</span><span class="id"> s_p</span><span class="id"> p0_le0</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> =&gt;</span><span class="id"> le_p_d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /closed_rootP/sig_eqW[y</span><span class="id"> py0]:</span><span class="id"> size</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> x</span>)<span class="id"> !=</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_map_poly</span><span class="id"> size_poly_eq1</span><span class="id"> eqp_monic</span><span class="id"> ?rpred1</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraTneq</span><span class="id"> p0_le0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> rmorph1</span><span class="id"> hornerC</span><span class="id"> lt_geF</span><span class="id"> ?ltr01</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /s_p</span><span class="id"> s_y</span><span class="id"> :=</span><span class="id"> py0;</span><span class="id"> have</span><span class="id"> /z_s/sQ_inQ[u</span><span class="id"> Dy]</span><span class="id"> :=</span><span class="id"> s_y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /pQwx[q</span><span class="id"> Dq]</span><span class="id"> :=</span><span class="id"> minPolyOver</span><span class="id"> Qx</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> mon_q:</span><span class="id"> q</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> have:=</span><span class="id"> monic_minPoly</span><span class="id"> Qx</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> Dq</span><span class="id"> map_monic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /dvdpP/sig_eqW[r</span><span class="id"> Dp]:</span><span class="id"> q</span><span class="id"> %|</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dvdp_map</span><span class="id"> Qxz</span>)<span class="id"> -Dq</span><span class="id"> minPoly_dvdp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> polyOver_poly</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -sQof2</span><span class="id"> QxzE</span><span class="id"> Dx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">fmorph_root</span> (<span class="id">ofQ</span><span class="id"> z</span>))<span class="id"> Dy</span><span class="id"> -map_poly_comp</span> (<span class="id">eq_map_poly</span><span class="id"> QxzE</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> mon_r:</span><span class="id"> r</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Dp</span><span class="id"> monicMr</span><span class="gallina-kwd"> in</span><span class="id"> mon_p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [q0_le0</span><span class="id"> |</span><span class="id"> q0_gt0]</span><span class="id"> :=</span><span class="id"> lerP</span> ((<span class="id">q</span><span class="id"> ^</span><span class="id"> QxR</span>).<span class="id">[0]</span>)<span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">IHp</span><span class="id"> q</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> ?Dy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> r0_le0:</span> (<span class="id">r</span><span class="id"> ^</span><span class="id"> QxR</span>).<span class="id">[0]</span><span class="id"> &lt;=</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">ler_pM2r</span><span class="id"> q0_gt0</span>)<span class="id"> mul0r</span><span class="id"> -hornerM</span><span class="id"> -rmorphM</span><span class="id"> -Dp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">IHd</span><span class="id"> r</span><span class="id"> mon_r</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [w</span><span class="id"> rw0|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> s_p</span><span class="id"> //</span><span class="id"> Dp</span><span class="id"> rmorphM</span><span class="id"> rootM</span><span class="id"> rw0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> leq_trans</span><span class="id"> le_p_d;</span><span class="id"> rewrite</span><span class="id"> Dp</span><span class="id"> size_Mmonic</span><span class="id"> ?monic_neq0</span><span class="id"> //</span><span class="id"> addnC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">size_map_poly</span><span class="id"> Qxz</span><span class="id"> q</span>)<span class="id"> -Dq</span><span class="id"> size_minPoly</span><span class="id"> !ltnS</span><span class="id"> leq_addl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> {s</span><span class="id"> s_y}//;</span><span class="id"> set</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> ofQ</span><span class="id"> z</span> (<span class="id">t_</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> set</span><span class="id"> p1</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> Qx</span><span class="id"> u</span><span class="gallina-kwd"> in</span><span class="id"> Dp</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /QtoQ[Qyz</span><span class="id"> QyzE]:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> sQof</span><span class="id"> z</span> (<span class="id">t_</span><span class="id"> u</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> q1_</span><span class="id"> v</span><span class="id"> :=</span><span class="id"> Fadjoin_poly</span><span class="id"> Qx</span><span class="id"> u</span> (<span class="id">Qyz</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;<span class="id">have{}</span><span class="id"> QyzE</span><span class="id"> v:</span><span class="id"> Qyz</span><span class="id"> v</span><span class="id"> =</span> (<span class="id">q1_</span><span class="id"> v</span>).<span class="id">[u]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Fadjoin_poly_eq</span><span class="id"> //</span><span class="id"> -Dt</span><span class="id"> -sQof2</span><span class="id"> QyzE</span><span class="id"> sQof</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /all_sig2[q_</span><span class="id"> coqp</span><span class="id"> Dq]</span><span class="id"> v:</span><span class="id"> {q</span><span class="id"> |</span><span class="id"> v</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> coprimep</span><span class="id"> p</span><span class="id"> q</span><span class="id"> &amp;</span><span class="id"> q</span><span class="id"> ^</span><span class="id"> Qxz</span><span class="id"> =</span><span class="id"> q1_</span><span class="id"> v}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /pQwx[q</span><span class="id"> Dq]:</span><span class="id"> q1_</span><span class="id"> v</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Qx</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> Fadjoin_polyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> q</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> nz_v;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">coprimep_map</span><span class="id"> Qxz</span>)<span class="id"> -Dp</span><span class="id"> -Dq</span><span class="id"> -gcdp_eqp1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /minPoly_irr/orP[]</span><span class="id"> //</span><span class="id"> :=</span><span class="id"> dvdp_gcdl</span><span class="id"> p1</span> (<span class="id">q1_</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gcdp_polyOver</span><span class="id"> ?minPolyOver</span><span class="id"> ?Fadjoin_polyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/p1</span><span class="id"> {1}/eqp</span><span class="id"> dvdp_gcd</span><span class="id"> =&gt;</span><span class="id"> /and3P[_</span><span class="id"> _</span><span class="id"> /dvdp_leq/=/implyP]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_minPoly</span><span class="id"> ltnNge</span><span class="id"> size_poly</span> (<span class="id">contraNneq</span><span class="id"> _</span><span class="id"> nz_v</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> q1v0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">fmorph_eq0</span><span class="id"> Qyz</span>)<span class="id"> /=</span><span class="id"> QyzE</span><span class="id"> q1v0</span><span class="id"> horner0</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> h2</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> 2^-1;</span><span class="id"> have</span><span class="id"> nz2:</span><span class="id"> 2</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> R</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> pnatr_eq0</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> itv</span><span class="id"> ab</span><span class="id"> :=</span><span class="id"> [pred</span><span class="id"> c</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><span class="id"> ab</span>.<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> c</span><span class="id"> &lt;=</span><span class="id"> ab</span>.<span class="id">2]</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> wid</span><span class="id"> ab</span><span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> ab</span>.<span class="id">2</span><span class="id"> -</span><span class="id"> ab</span>.<span class="id">1;</span><span class="id"> pose</span><span class="id"> mid</span><span class="id"> ab</span><span class="id"> :=</span> (<span class="id">ab</span>.<span class="id">1</span><span class="id"> +</span><span class="id"> ab</span>.<span class="id">2</span>)<span class="id"> *</span><span class="id"> h2</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> sub_itv</span><span class="id"> ab</span><span class="id"> cd</span><span class="id"> :=</span><span class="id"> cd</span>.<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> ab</span>.<span class="id">1</span><span class="id"> :&gt;</span><span class="id"> R</span><span class="id"> /\</span><span class="id"> ab</span>.<span class="id">2</span><span class="id"> &lt;=</span><span class="id"> cd</span>.<span class="id">2</span><span class="id"> :&gt;</span><span class="id"> R</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> xup</span><span class="id"> q</span><span class="id"> ab</span><span class="id"> :=</span><span class="id"> [/\</span><span class="id"> q</span>.<span class="id">[ab</span>.<span class="id">1]</span><span class="id"> &lt;=</span><span class="id"> 0,</span><span class="id"> q</span>.<span class="id">[ab</span>.<span class="id">2]</span><span class="id"> &gt;=</span><span class="id"> 0</span><span class="id"> &amp;</span><span class="id"> ab</span>.<span class="id">1</span><span class="id"> &lt;=</span><span class="id"> ab</span>.<span class="id">2</span><span class="id"> :&gt;</span><span class="id"> R]</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> narrow</span><span class="id"> q</span><span class="id"> ab</span> (<span class="id">c</span><span class="id"> :=</span><span class="id"> mid</span><span class="id"> ab</span>)<span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> q</span>.<span class="id">[c]</span><span class="id"> &gt;=</span><span class="id"> 0</span><span class="gallina-kwd"> then</span> (<span class="id">ab</span>.<span class="id">1,</span><span class="id"> c</span>)<span class="gallina-kwd"> else</span> (<span class="id">c,</span><span class="id"> ab</span>.<span class="id">2</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> find</span><span class="id"> k</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> iter</span><span class="id"> k</span> (<span class="id">narrow</span><span class="id"> q</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> findP</span><span class="id"> k</span><span class="id"> q</span><span class="id"> ab</span> (<span class="id">cd</span><span class="id"> :=</span><span class="id"> find</span><span class="id"> k</span><span class="id"> q</span><span class="id"> ab</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xup</span><span class="id"> q</span><span class="id"> ab</span><span class="id"> -&gt;</span><span class="id"> [/\</span><span class="id"> xup</span><span class="id"> q</span><span class="id"> cd,</span><span class="id"> sub_itv</span><span class="id"> cd</span><span class="id"> ab</span><span class="id"> &amp;</span><span class="id"> wid</span><span class="id"> cd</span><span class="id"> =</span><span class="id"> wid</span><span class="id"> ab</span><span class="id"> /</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">%:R]</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> rewrite</span><span class="id"> {}/cd;</span><span class="id"> case:</span><span class="id"> ab</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> xq_ab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|k];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> divr1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">find</span><span class="id"> k</span><span class="id"> q</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> c</span><span class="id"> d</span><span class="id"> [[/=</span><span class="id"> qc_le0</span><span class="id"> qd_ge0</span><span class="id"> le_cd]</span><span class="id"> [/=</span><span class="id"> le_ac</span><span class="id"> le_db]</span><span class="id"> Dcd]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/=</span><span class="id"> le_ce</span><span class="id"> le_ed]</span><span class="id"> :=</span><span class="id"> midf_le</span><span class="id"> le_cd;</span><span class="id"> set</span><span class="id"> e</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> /</span><span class="id"> _</span><span class="gallina-kwd"> in</span><span class="id"> le_ce</span><span class="id"> le_ed</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expnSr</span><span class="id"> natrM</span><span class="id"> invfM</span><span class="id"> mulrA</span><span class="id"> -{}Dcd</span><span class="id"> /narrow</span><span class="id"> /=</span><span class="id"> -[mid</span><span class="id"> _]/e</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [qe_ge0</span><span class="id"> //</span><span class="id"> |</span><span class="id"> /ltW</span><span class="id"> qe_le0]</span><span class="id"> :=</span><span class="id"> lerP</span><span class="id"> 0</span><span class="id"> q</span>.<span class="id">[e]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">do</span><span class="id"> ?split=&gt;</span><span class="id"> //=;</span><span class="id"> [exact:</span> (<span class="id">le_trans</span><span class="id"> le_ed</span>)<span class="id"> |</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">mulfK</span><span class="id"> nz2</span>)<span class="id"> _]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrBl</span><span class="id"> divfK</span><span class="id"> //</span><span class="id"> mulr_natr</span><span class="id"> opprD</span><span class="id"> addrACA</span><span class="id"> subrr</span><span class="id"> add0r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">do</span><span class="id"> ?split=&gt;</span><span class="id"> //=;</span><span class="id"> [exact:</span> (<span class="id">le_trans</span><span class="id"> le_ac</span>)<span class="id"> |</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">mulfK</span><span class="id"> nz2</span>)<span class="id"> _]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrBl</span><span class="id"> divfK</span><span class="id"> //</span><span class="id"> mulr_natr</span><span class="id"> opprD</span><span class="id"> addrACA</span><span class="id"> subrr</span><span class="id"> addr0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> find_root</span><span class="id"> r</span><span class="id"> q</span><span class="id"> ab:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xup</span><span class="id"> q</span><span class="id"> ab</span><span class="id"> -&gt;</span><span class="id"> {n</span><span class="id"> |</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> itv</span> (<span class="id">find</span><span class="id"> n</span><span class="id"> q</span><span class="id"> ab</span>)<span class="id"> -&gt;`|</span>(<span class="id">r</span><span class="id"> *</span><span class="id"> q</span>).<span class="id">[x]|</span><span class="id"> &lt;</span><span class="id"> h2}</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> xab;</span><span class="id"> have</span><span class="id"> ub_ab</span><span class="id"> :=</span><span class="id"> poly_itv_bound</span><span class="id"> _</span><span class="id"> ab</span>.<span class="id">1</span><span class="id"> ab</span>.<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [Mu</span><span class="id"> MuP]</span><span class="id"> :=</span><span class="id"> ub_ab</span><span class="id"> r;</span><span class="id"> have</span><span class="id"> /all_sig[Mq</span><span class="id"> MqP]</span><span class="id"> j</span><span class="id"> :=</span><span class="id"> ub_ab</span><span class="id"> q^`N</span>(<span class="id">j</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> d</span><span class="id"> :=</span><span class="id"> wid</span><span class="id"> ab;</span><span class="id"> pose</span><span class="id"> dq</span><span class="id"> :=</span><span class="id"> \poly_</span>(<span class="id">i</span><span class="id"> &lt;</span> (<span class="id">size</span><span class="id"> q</span>).<span class="id">-1</span>)<span class="id"> Mq</span><span class="id"> i</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> d_ge0:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> d</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subr_ge0;</span><span class="id"> case:</span><span class="id"> xab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [Mdq</span><span class="id"> MdqP]</span><span class="id"> :=</span><span class="id"> poly_disk_bound</span><span class="id"> dq</span><span class="id"> d</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> Num</span>.<span class="id">bound</span> (<span class="id">Mu</span><span class="id"> *</span><span class="id"> Mdq</span><span class="id"> *</span><span class="id"> d</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> c</span><span class="id"> /andP[]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{xab}</span><span class="id"> [[]]</span><span class="id"> :=</span><span class="id"> findP</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _</span><span class="id"> xab;</span><span class="id"> case:</span> (<span class="id">find</span><span class="id"> n</span><span class="id"> q</span><span class="id"> ab</span>)<span class="id"> =&gt;</span><span class="id"> a1</span><span class="id"> b1</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/d</span><span class="id"> =&gt;</span><span class="id"> qa1_le0</span><span class="id"> qb1_ge0</span><span class="id"> le_ab1</span><span class="id"> [/=</span><span class="id"> le_aa1</span><span class="id"> le_b1b]</span><span class="id"> Dab1</span><span class="id"> le_a1c</span><span class="id"> le_cb1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /MuP</span><span class="id"> lbMu:</span><span class="id"> c</span><span class="id"> \in</span><span class="id"> itv</span><span class="id"> ab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span> (<span class="id">le_trans</span><span class="id"> le_aa1</span>)<span class="id"> ?</span>(<span class="id">le_trans</span><span class="id"> le_cb1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Mu_ge0:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> Mu</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span><span class="id"> lbMu</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Mdq_ge0:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> Mdq</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">MdqP</span><span class="id"> 0</span><span class="id"> _</span>))<span class="id"> ?normr0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> lb1</span><span class="id"> a2</span><span class="id"> b2</span> (<span class="id">ab1</span><span class="id"> :=</span> (<span class="id">a1,</span><span class="id"> b1</span>)) (<span class="id">ab2</span><span class="id"> :=</span> (<span class="id">a2,</span><span class="id"> b2</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">xup</span><span class="id"> q</span><span class="id"> ab2</span><span class="id"> /\</span><span class="id"> sub_itv</span><span class="id"> ab2</span><span class="id"> ab1</span><span class="id"> -&gt;</span><span class="id"> q</span>.<span class="id">[b2]</span><span class="id"> -</span><span class="id"> q</span>.<span class="id">[a2]</span><span class="id"> &lt;=</span><span class="id"> Mdq</span><span class="id"> *</span><span class="id"> wid</span><span class="id"> ab1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">+</span><span class="id"> apply:</span><span class="id"> le_lt_trans</span> (_<span class="id"> :</span><span class="id"> Mu</span><span class="id"> *</span><span class="id"> Mdq</span><span class="id"> *</span><span class="id"> wid</span> (<span class="id">a1,</span><span class="id"> b1</span>)<span class="id"> &lt;</span><span class="id"> h2</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {}Dab1</span><span class="id"> mulrA</span><span class="id"> ltr_pdivrMr</span><span class="id"> ?ltr0n</span><span class="id"> ?expn_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">lt_le_trans</span> (<span class="id">archi_boundP</span><span class="id"> _</span>))<span class="id"> ?mulr_ge0</span><span class="id"> ?ltr_nat</span><span class="id"> //</span><span class="id"> -/n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ler_pdivlMl</span><span class="id"> ?ltr0n</span><span class="id"> //</span><span class="id"> -natrM</span><span class="id"> ler_nat</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> expnS</span><span class="id"> leq_pmul2l</span><span class="id"> //</span><span class="id"> ltn_expl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -mulrA</span><span class="id"> hornerM</span><span class="id"> normrM</span><span class="id"> ler_pM</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [/ltW</span><span class="id"> qc_le0</span><span class="id"> |</span><span class="id"> qc_ge0]</span><span class="id"> :=</span><span class="id"> ltrP</span><span class="id"> q</span>.<span class="id">[c]</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> le_trans</span> (<span class="id">lb1</span><span class="id"> c</span><span class="id"> b1</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?ler0_norm</span><span class="id"> ?ler_wpDl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> le_trans</span> (<span class="id">lb1</span><span class="id"> a1</span><span class="id"> c</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?ger0_norm</span><span class="id"> ?ler_wpDr</span><span class="id"> ?oppr_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case{c</span><span class="id"> le_a1c</span><span class="id"> le_cb1</span><span class="id"> lbMu}=&gt;</span><span class="id"> [[/=qa2_le0</span><span class="id"> qb2_ge0</span><span class="id"> le_ab2]</span><span class="id"> [/=le_a12</span><span class="id"> le_b21]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> h</span><span class="id"> :=</span><span class="id"> b2</span><span class="id"> -</span><span class="id"> a2;</span><span class="id"> have</span><span class="id"> h_ge0:</span><span class="id"> 0</span><span class="id"> &lt;=</span><span class="id"> h</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subr_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> nz_q]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> q</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !horner0</span><span class="id"> subrr</span><span class="id"> mulr_ge0</span><span class="id"> ?subr_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">subrK</span><span class="id"> a2</span><span class="id"> b2</span>) (<span class="id">addrC</span><span class="id"> h</span>) (<span class="id">nderiv_taylor</span><span class="id"> q</span> (<span class="id">mulrC</span><span class="id"> a2</span><span class="id"> h</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">polySpred</span><span class="id"> nz_q</span>)<span class="id"> big_ord_recl</span><span class="id"> /=</span><span class="id"> mulr1</span><span class="id"> nderivn0</span><span class="id"> addrC</span><span class="id"> addKr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [le_aa2</span><span class="id"> le_b2b]</span><span class="id"> :=</span> (<span class="id">le_trans</span><span class="id"> le_aa1</span><span class="id"> le_a12,</span><span class="id"> le_trans</span><span class="id"> le_b21</span><span class="id"> le_b1b</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /MqP</span><span class="id"> MqPx1:</span><span class="id"> a2</span><span class="id"> \in</span><span class="id"> itv</span><span class="id"> ab</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> le_aa2</span> (<span class="id">le_trans</span><span class="id"> le_ab2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_trans</span> (<span class="id">le_trans</span> (<span class="id">ler_norm</span><span class="id"> _</span>) (<span class="id">ler_norm_sum</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> le_trans</span> (_<span class="id"> :</span><span class="id"> `|dq</span>.<span class="id">[h]</span><span class="id"> *</span><span class="id"> h|</span><span class="id"> &lt;=</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> normrM</span><span class="id"> ler_pM</span><span class="id"> ?normr_ge0</span><span class="id"> ?MdqP</span><span class="id"> //</span><span class="id"> ?ger0_norm</span><span class="id"> ?lerB</span><span class="id"> ?h_ge0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> horner_poly</span><span class="id"> ger0_norm</span><span class="id"> ?mulr_ge0</span><span class="id"> ?sumr_ge0</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [|j</span><span class="id"> _];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulr_ge0</span><span class="id"> ?exprn_ge0</span><span class="id"> //</span> (<span class="id">le_trans</span><span class="id"> _</span> (<span class="id">MqPx1</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulr_suml</span><span class="id"> ler_sum</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> normrM</span><span class="id"> -mulrA</span><span class="id"> -exprSr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ler_pM</span><span class="id"> //</span><span class="id"> normrX</span><span class="id"> ger0_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [ab0</span><span class="id"> xab0]:</span><span class="id"> {ab</span><span class="id"> |</span><span class="id"> xup</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QxR</span>)<span class="id"> ab}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /monic_Cauchy_bound[b</span><span class="id"> pb_gt0]:</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> QxR</span><span class="id"> \is</span><span class="id"> monic</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> monic_map</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">0,</span><span class="id"> `|b|</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /xup</span><span class="id"> normr_ge0</span><span class="id"> p0_le0</span><span class="id"> ltW</span><span class="id"> ?pb_gt0</span><span class="id"> ?ler_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> ab_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> find</span><span class="id"> n</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QxR</span>)<span class="id"> ab0;</span><span class="id"> pose</span><span class="id"> Iab_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> itv</span> (<span class="id">ab_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> lim</span><span class="id"> v</span><span class="id"> a</span><span class="id"> :=</span> (<span class="id">q_</span><span class="id"> v</span><span class="id"> ^</span><span class="id"> QxR</span>).<span class="id">[a];</span><span class="id"> pose</span><span class="id"> nlim</span><span class="id"> v</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> lim</span><span class="id"> v</span> (<span class="id">ab_</span><span class="id"> n</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> lim0</span><span class="id"> a:</span><span class="id"> lim</span><span class="id"> 0</span><span class="id"> a</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /lim;</span><span class="id"> suffices</span><span class="id"> /eqP</span><span class="id"> -&gt;:</span><span class="id"> q_</span><span class="id"> 0</span><span class="id"> ==</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rmorph0</span><span class="id"> horner0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">map_poly_eq0</span><span class="id"> Qxz</span>)<span class="id"> Dq</span><span class="id"> /q1_</span><span class="id"> !raddf0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> limN</span><span class="id"> v</span><span class="id"> a:</span><span class="id"> lim</span> (<span class="id">-</span><span class="id"> v</span>)<span class="id"> a</span><span class="id"> =</span><span class="id"> -</span><span class="id"> lim</span><span class="id"> v</span><span class="id"> a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /lim;</span><span class="id"> suffices</span><span class="id"> -&gt;:</span><span class="id"> q_</span> (<span class="id">-</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> -</span><span class="id"> q_</span><span class="id"> v</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rmorphN</span><span class="id"> hornerN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">map_poly_inj</span><span class="id"> Qxz</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Dq</span><span class="id"> /q1_</span> (<span class="id">raddfN</span><span class="id"> _</span><span class="id"> v</span>) (<span class="id">raddfN</span><span class="id"> _</span> (<span class="id">Qyz</span><span class="id"> v</span>))<span class="id"> [RHS]raddfN</span><span class="id"> /=</span><span class="id"> Dq</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> lim_nz</span><span class="id"> n</span><span class="id"> v</span><span class="id"> :=</span><span class="gallina-kwd"> exists2</span><span class="id"> e,</span><span class="id"> e</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> Iab_</span><span class="id"> n,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> e</span><span class="id"> &lt;</span><span class="id"> `|lim</span><span class="id"> v</span><span class="id"> a|</span><span class="id"> }</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">all_sig_cond</span><span class="id"> 0</span>)<span class="id">[n_</span><span class="id"> nzP]</span><span class="id"> v:</span><span class="id"> v</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> {n</span><span class="id"> |</span><span class="id"> lim_nz</span><span class="id"> n</span><span class="id"> v}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> nz_v;</span><span class="id"> do</span><span class="id"> [move/</span>(_<span class="id"> v</span><span class="id"> nz_v</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">coprimep_map</span><span class="id"> QxR</span>)<span class="id">]</span><span class="gallina-kwd"> in</span><span class="id"> coqp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sig_eqW[r</span><span class="id"> r_pq_1]</span><span class="id"> :=</span><span class="id"> Bezout_eq1_coprimepP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> coqp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">find_root</span><span class="id"> r</span>.<span class="id">1</span>)<span class="id">[n</span><span class="id"> ub_rp]</span><span class="id"> :=</span><span class="id"> xab0;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [M</span><span class="id"> Mgt0</span><span class="id"> ubM]:</span><span class="id"> {M</span><span class="id"> |</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> M</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> Iab_</span><span class="id"> n,</span><span class="gallina-kwd"> forall</span><span class="id"> a,</span><span class="id"> `|r</span>.<span class="id">2</span>.<span class="id">[a]|</span><span class="id"> &lt;=</span><span class="id"> M}}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [M</span><span class="id"> ubM]</span><span class="id"> :=</span><span class="id"> poly_itv_bound</span><span class="id"> r</span>.<span class="id">2</span> (<span class="id">ab_</span><span class="id"> n</span>).<span class="id">1</span> (<span class="id">ab_</span><span class="id"> n</span>).<span class="id">2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">Num</span>.<span class="id">max</span><span class="id"> 1</span><span class="id"> M</span>)<span class="id"> =&gt;</span><span class="id"> [|s</span><span class="id"> /ubM</span><span class="id"> vM];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lt_max</span><span class="id"> ltr01</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> le_max</span><span class="id"> orbC</span><span class="id"> vM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">h2</span><span class="id"> /</span><span class="id"> M</span>)<span class="id"> =&gt;</span><span class="id"> [|a</span><span class="id"> xn_a];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> divr_gt0</span><span class="id"> ?invr_gt0</span><span class="id"> ?ltr0n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltr_pdivrMr</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">ltrD2l</span><span class="id"> h2</span>)<span class="id"> -mulr2n</span><span class="id"> -mulr_natl</span><span class="id"> divff</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -normr1</span><span class="id"> -</span>(<span class="id">hornerC</span><span class="id"> 1</span><span class="id"> a</span>)<span class="id"> -[1%:P]r_pq_1</span><span class="id"> hornerD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ?</span>(<span class="id">le_lt_trans</span> (<span class="id">ler_normD</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> ?ltr_leD</span><span class="id"> ?ub_rp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulrC</span><span class="id"> hornerM</span><span class="id"> normrM</span><span class="id"> ler_wpM2l</span><span class="id"> ?ubM</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ab_le</span><span class="id"> m</span><span class="id"> n:</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span> (<span class="id">ab_</span><span class="id"> n</span>).<span class="id">2</span><span class="id"> \in</span><span class="id"> Iab_</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/subnKC=&gt;</span><span class="id"> &lt;-;</span><span class="id"> move:</span><span class="id"> {n}</span>(<span class="id">n</span><span class="id"> -</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> /ab_</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">findP</span><span class="id"> m</span>)<span class="id">[/</span>(<span class="id">findP</span><span class="id"> n</span>)<span class="id">[[_</span><span class="id"> _]]]</span><span class="id"> :=</span><span class="id"> xab0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /find</span><span class="id"> -iterD</span><span class="id"> -!/</span>(<span class="id">find</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> -!/</span>(<span class="id">ab_</span><span class="id"> _</span>)<span class="id"> addnC</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span> (<span class="id">ab_</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> ab_mn</span><span class="id"> le_ab_mn</span><span class="id"> [/le_trans-&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> w</span><span class="id"> :=</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> nlim</span> (<span class="id">w</span><span class="id"> -</span><span class="id"> v</span>) (<span class="id">n_</span> (<span class="id">w</span><span class="id"> -</span><span class="id"> v</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posN</span><span class="id"> v:</span><span class="id"> lt</span><span class="id"> 0</span> (<span class="id">-</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /lt</span><span class="id"> subr0</span><span class="id"> add0r</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posB</span><span class="id"> v</span><span class="id"> w:</span><span class="id"> lt</span><span class="id"> 0</span> (<span class="id">w</span><span class="id"> -</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> w</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /lt</span><span class="id"> subr0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posE</span><span class="id"> n</span><span class="id"> v:</span> (<span class="id">n_</span><span class="id"> v</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> =</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> nlim</span><span class="id"> v</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /lt</span><span class="id"> subr0</span><span class="id"> /nlim</span><span class="id"> =&gt;</span><span class="id"> /ab_le;</span><span class="id"> set</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> _</span>.<span class="id">2;</span><span class="id"> set</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> _</span>.<span class="id">2</span><span class="id"> =&gt;</span><span class="id"> Iv_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> /nzP[e</span><span class="id"> e_gt0]]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> v</span><span class="id"> 0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !lim0</span><span class="id"> ltxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move:</span> (<span class="id">n_</span><span class="id"> v</span>)<span class="id"> =&gt;</span><span class="id"> m</span><span class="gallina-kwd"> in</span><span class="id"> Iv_a</span><span class="id"> b</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> v_gte</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss</span><span class="id"> lt0v:</span><span class="id"> v</span><span class="id"> v_gte</span><span class="id"> /</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> lim</span><span class="id"> v</span><span class="id"> b</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IHv;</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> [v_gt0</span><span class="id"> |</span><span class="id"> /ltW];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -IHv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt_def</span><span class="id"> -normr_gt0</span><span class="id"> ?</span>(<span class="id">lt_trans</span><span class="id"> _</span> (<span class="id">v_gte</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> ?ab_le</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !leNgt</span><span class="id"> -!oppr_gt0</span><span class="id"> -!limN;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> =&gt;</span><span class="id"> v_lt0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -IHv</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> c</span><span class="id"> /v_gte;</span><span class="id"> rewrite</span><span class="id"> limN</span><span class="id"> normrN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt0v</span> (<span class="id">lt_trans</span><span class="id"> e_gt0</span>)<span class="id"> ?</span>(<span class="id">lt_le_trans</span> (<span class="id">v_gte</span><span class="id"> a</span><span class="id"> Iv_a</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ger0_norm</span><span class="id"> //</span><span class="id"> leNgt;</span><span class="id"> apply/negP=&gt;</span><span class="id"> /ltW</span><span class="id"> lev0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [le_a</span><span class="id"> le_ab]</span><span class="id"> :</span><span class="id"> _</span><span class="id"> /\</span><span class="id"> a</span><span class="id"> &lt;=</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> Iv_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> xab:</span><span class="id"> xup</span> (<span class="id">q_</span><span class="id"> v</span><span class="id"> ^</span><span class="id"> QxR</span>) (<span class="id">a,</span><span class="id"> b</span>)<span class="gallina-kwd"> by</span><span class="id"> move/ltW</span><span class="gallina-kwd"> in</span><span class="id"> lt0v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">find_root</span> (<span class="id">h2</span><span class="id"> /</span><span class="id"> e</span>)<span class="id">%:P</span>)<span class="id">[n1]</span><span class="id"> :=</span><span class="id"> xab;</span><span class="id"> have</span><span class="id"> /</span>(<span class="id">findP</span><span class="id"> n1</span>)<span class="id">[[_</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> xab</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">find</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> c</span><span class="id"> d</span><span class="id"> /=</span><span class="id"> le_cd</span><span class="id"> [/=</span><span class="id"> le_ac</span><span class="id"> le_db]</span><span class="id"> _</span><span class="id"> /</span>(_<span class="id"> c</span>)<span class="id">/implyP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> lexx</span><span class="id"> le_cd</span><span class="id"> hornerM</span><span class="id"> hornerC</span><span class="id"> normrM</span><span class="id"> le_gtF</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ger0_norm</span><span class="id"> ?divr_ge0</span><span class="id"> ?invr_ge0</span><span class="id"> ?ler0n</span><span class="id"> ?</span>(<span class="id">ltW</span><span class="id"> e_gt0</span>)<span class="id"> //</span><span class="id"> mulrAC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ler_pdivlMr</span><span class="id"> //</span><span class="id"> ler_wpM2l</span><span class="id"> ?invr_ge0</span><span class="id"> ?ler0n</span><span class="id"> //</span><span class="id"> ltW</span><span class="id"> //</span><span class="id"> v_gte</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -/b</span> (<span class="id">le_trans</span><span class="id"> le_a</span>)<span class="id"> //=</span> (<span class="id">le_trans</span><span class="id"> le_cd</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> lim_pos</span><span class="id"> m</span><span class="id"> v</span><span class="id"> :=</span><span class="gallina-kwd"> exists2</span><span class="id"> e,</span><span class="id"> e</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> n,</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> e</span><span class="id"> &lt;</span><span class="id"> nlim</span><span class="id"> v</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posP</span><span class="id"> v:</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> m,</span><span class="id"> lim_pos</span><span class="id"> m</span><span class="id"> v</span>) (<span class="id">lt</span><span class="id"> 0</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [v_gt0|[m</span><span class="id"> [e</span><span class="id"> e_gt0</span><span class="id"> v_gte]]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">posE</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">leq_maxl</span><span class="id"> _</span><span class="id"> m</span>)) (<span class="id">lt_trans</span><span class="id"> e_gt0</span>)<span class="id"> ?v_gte</span><span class="id"> ?leq_maxr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|e</span><span class="id"> e_gt0</span><span class="id"> v_gte]</span><span class="id"> :=</span><span class="id"> nzP</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraTneq</span><span class="id"> v_gt0</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> /lt</span><span class="id"> subr0</span><span class="id"> /nlim</span><span class="id"> lim0</span><span class="id"> ltxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">n_</span><span class="id"> v</span>)<span class="id">,</span><span class="id"> e</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> le_vn;</span><span class="id"> rewrite</span> (<span class="id">posE</span><span class="id"> n</span>)<span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> v_gt0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">ger0_norm</span> (<span class="id">ltW</span><span class="id"> v_gt0</span>))<span class="id"> v_gte</span><span class="id"> ?ab_le</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posNneg</span><span class="id"> v:</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/posP=&gt;</span><span class="id"> m</span><span class="id"> [d</span><span class="id"> d_gt0</span><span class="id"> v_gtd];</span><span class="id"> rewrite</span><span class="id"> -posN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> d_gt0</span><span class="id"> =&gt;</span><span class="id"> /posP[n</span><span class="id"> [e</span><span class="id"> e_gt0</span><span class="id"> nv_gte]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> lt_gtF</span><span class="id"> //</span> (<span class="id">lt_trans</span> (<span class="id">v_gtd</span><span class="id"> _</span> (<span class="id">leq_maxl</span><span class="id"> m</span><span class="id"> n</span>)))<span class="id"> //</span><span class="id"> -oppr_gt0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /nlim</span><span class="id"> -limN</span> (<span class="id">lt_trans</span><span class="id"> e_gt0</span>)<span class="id"> ?nv_gte</span><span class="id"> ?leq_maxr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posVneg</span><span class="id"> v:</span><span class="id"> v</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> ||</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/nzP=&gt;</span><span class="id"> e</span><span class="id"> e_gt0</span><span class="id"> v_gte;</span><span class="id"> rewrite</span><span class="id"> -posN;</span><span class="id"> set</span><span class="id"> w</span><span class="id"> :=</span><span class="id"> -</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [m</span><span class="id"> [le_vm</span><span class="id"> le_wm</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> maxn3</span> (<span class="id">n_</span><span class="id"> v</span>) (<span class="id">n_</span><span class="id"> w</span>)<span class="id"> 0;</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">posE</span><span class="id"> m</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /nlim</span><span class="id"> limN</span><span class="id"> -ltr_normr</span> (<span class="id">lt_trans</span><span class="id"> e_gt0</span>)<span class="id"> ?v_gte</span><span class="id"> ?ab_le</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posD</span><span class="id"> v</span><span class="id"> w:</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> w</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span> (<span class="id">v</span><span class="id"> +</span><span class="id"> w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /posP[m</span><span class="id"> [d</span><span class="id"> d_gt0</span><span class="id"> v_gtd]]</span><span class="id"> /posP[n</span><span class="id"> [e</span><span class="id"> e_gt0</span><span class="id"> w_gte]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/posP;</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> m</span><span class="id"> n</span>)<span class="id">,</span> (<span class="id">d</span><span class="id"> +</span><span class="id"> e</span>)<span class="id"> =&gt;</span><span class="id"> [|k];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> addr_gt0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> geq_max</span><span class="id"> =&gt;</span><span class="id"> /andP[le_mk</span><span class="id"> le_nk];</span><span class="id"> rewrite</span><span class="id"> /nlim</span><span class="id"> /lim</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> q_</span> (<span class="id">v</span><span class="id"> +</span><span class="id"> w</span>)<span class="id"> =</span><span class="id"> q_</span><span class="id"> v</span><span class="id"> +</span><span class="id"> q_</span><span class="id"> w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">map_poly_inj</span><span class="id"> Qxz</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> rmorphD</span><span class="id"> /=</span><span class="id"> !{1}Dq</span><span class="id"> /q1_</span><span class="id"> !raddfD</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphD</span><span class="id"> hornerD</span><span class="id"> ltrD</span><span class="id"> ?v_gtd</span><span class="id"> ?w_gte</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> posM</span><span class="id"> v</span><span class="id"> w:</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span><span class="id"> w</span><span class="id"> -&gt;</span><span class="id"> lt</span><span class="id"> 0</span> (<span class="id">v</span><span class="id"> *</span><span class="id"> w</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> /posP[m</span><span class="id"> [d</span><span class="id"> d_gt0</span><span class="id"> v_gtd]]</span><span class="id"> /posP[n</span><span class="id"> [e</span><span class="id"> e_gt0</span><span class="id"> w_gte]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /dvdpP[r</span><span class="id"> /</span>(<span class="id">canRL</span> (<span class="id">subrK</span><span class="id"> _</span>))<span class="id">Dqvw]:</span><span class="id"> p</span><span class="id"> %|</span><span class="id"> q_</span> (<span class="id">v</span><span class="id"> *</span><span class="id"> w</span>)<span class="id"> -</span><span class="id"> q_</span><span class="id"> v</span><span class="id"> *</span><span class="id"> q_</span><span class="id"> w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dvdp_map</span><span class="id"> Qxz</span>)<span class="id"> rmorphB</span><span class="id"> rmorphM</span><span class="id"> /=</span><span class="id"> !Dq</span><span class="id"> -Dp</span><span class="id"> minPoly_dvdp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rpredB</span><span class="id"> 1?rpredM</span><span class="id"> ?Fadjoin_polyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rootE</span><span class="id"> !hornerE</span><span class="id"> -!QyzE</span><span class="id"> rmorphM</span><span class="id"> subrr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /</span>(<span class="id">find_root</span> ((<span class="id">d</span><span class="id"> *</span><span class="id"> e</span>)<span class="id">^-1</span><span class="id"> *:</span><span class="id"> r</span><span class="id"> ^</span><span class="id"> QxR</span>))<span class="id">[N</span><span class="id"> ub_rp]</span><span class="id"> :=</span><span class="id"> xab0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> f</span><span class="id"> :=</span><span class="id"> d</span><span class="id"> *</span><span class="id"> e</span><span class="id"> *</span><span class="id"> h2;</span><span class="id"> apply/posP;</span><span class="gallina-kwd"> exists</span> (<span class="id">maxn</span><span class="id"> N</span> (<span class="id">maxn</span><span class="id"> m</span><span class="id"> n</span>))<span class="id">,</span><span class="id"> f</span><span class="id"> =&gt;</span><span class="id"> [|k]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !mulr_gt0</span><span class="id"> ?invr_gt0</span><span class="id"> ?ltr0n</span>.<br/>
&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !geq_max</span><span class="id"> =&gt;</span><span class="id"> /and3P[/ab_le/ub_rp{}ub_rp</span><span class="id"> le_mk</span><span class="id"> le_nk]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ltrD2r</span><span class="id"> f</span>)<span class="id"> -mulr2n</span><span class="id"> -mulr_natr</span><span class="id"> divfK</span><span class="id"> //</span><span class="id"> /nlim</span><span class="id"> /lim</span><span class="id"> Dqvw</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rmorphD</span><span class="id"> hornerD</span><span class="id"> /=</span><span class="id"> -addrA</span><span class="id"> -ltrBlDl</span><span class="id"> ler_ltD</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphM</span><span class="id"> hornerM</span><span class="id"> ler_pM</span><span class="id"> ?ltW</span><span class="id"> ?v_gtd</span><span class="id"> ?w_gte</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -ltr_pdivrMl</span><span class="id"> ?mulr_gt0</span><span class="id"> //</span> (<span class="id">le_lt_trans</span><span class="id"> _</span><span class="id"> ub_rp</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -scalerAl</span><span class="id"> hornerZ</span><span class="id"> -rmorphM</span><span class="id"> mulrN</span><span class="id"> -normrN</span><span class="id"> ler_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> le</span><span class="id"> v</span><span class="id"> w</span><span class="id"> :=</span> (<span class="id">v</span><span class="id"> ==</span><span class="id"> w</span>)<span class="id"> ||</span><span class="id"> lt</span><span class="id"> v</span><span class="id"> w</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> abs</span><span class="id"> v</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> le</span><span class="id"> 0</span><span class="id"> v</span><span class="gallina-kwd"> then</span><span class="id"> v</span><span class="gallina-kwd"> else</span><span class="id"> -</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> absN</span><span class="id"> v:</span><span class="id"> abs</span> (<span class="id">-</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> abs</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /abs</span><span class="id"> /le</span><span class="id"> !</span>(<span class="id">eq_sym</span><span class="id"> 0</span>)<span class="id"> oppr_eq0</span><span class="id"> opprK</span><span class="id"> posN</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> /posVneg/orP[v_gt0</span><span class="id"> |</span><span class="id"> v_lt0]]</span><span class="id"> :=</span><span class="id"> eqVneq;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oppr0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> v_gt0</span><span class="id"> /=</span><span class="id"> -if_neg</span><span class="id"> posNneg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> v_lt0</span><span class="id"> /=</span><span class="id"> -if_neg</span><span class="id"> -</span>(<span class="id">opprK</span><span class="id"> v</span>)<span class="id"> posN</span><span class="id"> posNneg</span><span class="id"> ?posN</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> absE</span><span class="id"> v:</span><span class="id"> le</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> -&gt;</span><span class="id"> abs</span><span class="id"> v</span><span class="id"> =</span><span class="id"> v</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /abs</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> RyM</span><span class="id"> :=</span><span class="id"> Num</span>.<span class="id">IntegralDomain_isLtReal</span>.<span class="id">Build</span> (<span class="id">Q</span><span class="id"> y</span>)<span class="id"> posD</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">posM</span><span class="id"> posNneg</span><span class="id"> posB</span><span class="id"> posVneg</span><span class="id"> absN</span><span class="id"> absE</span> (<span class="id">rrefl</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Ry</span><span class="id"> :</span><span class="id"> realFieldType</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span> (<span class="id">Q</span><span class="id"> y</span>)<span class="id"> RyM</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> QisArchi</span><span class="id"> :</span><span class="id"> Num</span>.<span class="id">NumDomain_bounded_isArchimedean</span><span class="id"> Ry</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> constructor;</span><span class="id"> apply:</span> (<span class="id">@rat_algebraic_archimedean</span><span class="id"> Ry</span><span class="id"> _</span><span class="id"> alg_integral</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">HB</span>.<span class="id">pack_for</span><span class="id"> archiRealFieldType</span><span class="id"> _</span><span class="id"> QisArchi</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> idfun</span>.<br/>
<span class="id">have</span><span class="id"> some_realC:</span><span class="id"> realC</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> /all_sig[f</span><span class="id"> QfK]</span><span class="id"> x:</span><span class="id"> {a</span><span class="id"> |</span><span class="id"> in_alg</span> (<span class="id">Q</span><span class="id"> 0</span>)<span class="id"> a</span><span class="id"> =</span><span class="id"> x}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> fA</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> can2_additive</span> (<span class="id">inj_can_sym</span><span class="id"> QfK</span> (<span class="id">fmorph_inj</span><span class="id"> _</span>))<span class="id"> QfK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> fM</span><span class="id"> :</span><span class="id"> multiplicative</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> can2_rmorphism</span> (<span class="id">inj_can_sym</span><span class="id"> QfK</span> (<span class="id">fmorph_inj</span><span class="id"> _</span>))<span class="id"> QfK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> faM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isAdditive</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> fA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> fmM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> fM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> fRM</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> f</span><span class="id"> faM</span><span class="id"> fmM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span><span class="id"> rat;</span><span class="id"> exact:</span><span class="id"> fRM</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Fadjoin1_polyP/sig_eqW[q]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> &lt;&lt;1;</span><span class="id"> 0&gt;&gt;%VS</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sQof2</span><span class="id"> rmorph0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> q</span>.<span class="id">[0];</span><span class="id"> rewrite</span><span class="id"> -horner_map</span><span class="id"> rmorph0</span>.<br/>
<span class="id">pose</span><span class="gallina-kwd"> fix</span><span class="id"> xR</span><span class="id"> n</span><span class="id"> :</span><span class="id"> realC</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> isn't</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> some_realC</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> unpickle</span> (<span class="id">nth</span><span class="id"> 0</span> (<span class="id">CodeSeq</span>.<span class="id">decode</span><span class="id"> n'</span>)<span class="id"> 1</span>)<span class="id"> isn't</span><span class="id"> Some</span> (<span class="id">p,</span><span class="id"> c</span>)<span class="gallina-kwd"> then</span><span class="id"> xR</span><span class="id"> n'</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="id">tag</span> (<span class="id">add_Rroot</span> (<span class="id">xR</span><span class="id"> n'</span>)<span class="id"> p</span><span class="id"> c</span>).<br/>
<span class="id">pose</span><span class="id"> x_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> tag</span> (<span class="id">xR</span><span class="id"> n</span>).<br/>
<span class="id">have</span><span class="id"> sRle</span><span class="id"> m</span><span class="id"> n:</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> m</span>)<span class="id"> &lt;=</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> n</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">move/subnK</span><span class="id"> &lt;-;</span><span class="id"> elim:</span><span class="id"> {n}</span>(<span class="id">n</span><span class="id"> -</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> x</span><span class="id"> /IHn{IHn}Rx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addSn</span><span class="id"> /x_</span><span class="id"> /=;</span><span class="id"> case:</span> (<span class="id">unpickle</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> [[p</span><span class="id"> c]|]</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">add_Rroot</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> yR</span><span class="id"> /=</span><span class="id"> /</span>(<span class="id">sQtrans</span><span class="id"> _</span><span class="id"> x</span>)<span class="id">-&gt;</span>.<br/>
<span class="id">have</span><span class="id"> xRroot</span><span class="id"> n</span><span class="id"> p</span><span class="id"> c:</span><span class="id"> has_Rroot</span> (<span class="id">xR</span><span class="id"> n</span>)<span class="id"> p</span><span class="id"> c</span><span class="id"> -&gt;</span><span class="id"> {m</span><span class="id"> |</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> m</span><span class="id"> &amp;</span><span class="id"> root_in</span> (<span class="id">xR</span><span class="id"> m</span>)<span class="id"> p}%N</span>.<br/>
&nbsp;&nbsp;<span class="id">case/and4P=&gt;</span><span class="id"> Rp</span><span class="id"> mon_p</span><span class="id"> Rc</span><span class="id"> Dc;</span><span class="id"> pose</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> CodeSeq</span>.<span class="id">code</span><span class="id"> [::</span><span class="id"> n;</span><span class="id"> pickle</span> (<span class="id">p,</span><span class="id"> c</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> le_n_m:</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> apply/ltnW/</span>(<span class="id">allP</span> (<span class="id">CodeSeq</span>.<span class="id">ltn_code</span><span class="id"> _</span>))<span class="id">/mem_head</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> m</span>.<span class="id">+1;</span><span class="id"> rewrite</span><span class="id"> ?leqW</span><span class="id"> /x_</span><span class="id"> //=</span><span class="id"> CodeSeq</span>.<span class="id">codeK</span><span class="id"> pickleK</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">add_Rroot</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> yR</span><span class="id"> /=</span><span class="id"> _;</span><span class="id"> apply;</span><span class="id"> apply/and4P</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> polyOverS</span><span class="id"> Rp;</span><span class="id"> apply:</span> (<span class="id">sRle</span><span class="id"> n</span>).<br/>
<span class="id">have</span><span class="id"> /all_sig[z_</span><span class="id"> /all_and3[Ri_R</span><span class="id"> Ri_i</span><span class="id"> defRi]]</span><span class="id"> n</span> (<span class="id">x</span><span class="id"> :=</span><span class="id"> x_</span><span class="id"> n</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;<span class="id">{z</span><span class="id"> |</span><span class="id"> [/\</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z,</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> &lt;&lt;&lt;&lt;1;</span><span class="id"> inQ</span><span class="id"> z</span><span class="id"> x&gt;&gt;;</span><span class="id"> inQ</span><span class="id"> z</span><span class="id"> i&gt;&gt;</span><span class="id"> =</span><span class="id"> fullv]}</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [z</span><span class="id"> /and3P[z_x</span><span class="id"> z_i</span><span class="id"> _]</span><span class="id"> Dzi]</span><span class="id"> :=</span><span class="id"> PET</span><span class="id"> [::</span><span class="id"> x;</span><span class="id"> i]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> -adjoin_seq1</span><span class="id"> -adjoin_cons</span>.<br/>
<span class="id">pose</span><span class="id"> i_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> inQ</span> (<span class="id">z_</span><span class="id"> n</span>)<span class="id"> i;</span><span class="id"> pose</span><span class="id"> R_</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> &lt;&lt;1;</span><span class="id"> inQ</span> (<span class="id">z_</span><span class="id"> n</span>) (<span class="id">x_</span><span class="id"> n</span>)<span class="id">&gt;&gt;%AS</span>.<br/>
<span class="id">have</span><span class="id"> memRi</span><span class="id"> n:</span><span class="id"> &lt;&lt;R_</span><span class="id"> n;</span><span class="id"> i_</span><span class="id"> n&gt;&gt;</span><span class="id"> =i</span><span class="id"> predT</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> defRi</span><span class="id"> memvf</span>.<br/>
<span class="id">have</span><span class="id"> sCle</span><span class="id"> m</span><span class="id"> n:</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> m</span>)<span class="id"> &lt;=</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> n</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">move/sRle=&gt;</span><span class="id"> Rmn</span><span class="id"> _</span><span class="id"> /sQ_inQ[u</span><span class="id"> &lt;-]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /Fadjoin_polyP[p</span><span class="id"> /polyOverP</span><span class="id"> Rp</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> memRi</span><span class="id"> m</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -horner_map</span><span class="id"> inQ_K</span><span class="id"> ?</span>(<span class="id">@rpred_horner</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sQtrans</span> (<span class="id">Ri_R</span><span class="id"> n</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> Rmn</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">inQ_K</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">Ri_R</span><span class="id"> m</span>))<span class="id"> sQof2</span>.<br/>
<span class="id">have</span><span class="id"> R'i</span><span class="id"> n:</span><span class="id"> i</span><span class="id"> \notin</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /x_;</span><span class="id"> case:</span> (<span class="id">xR</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> [Rn</span><span class="id"> QxR]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span> (<span class="id">@ltr01</span><span class="id"> Rn</span>)<span class="id"> =&gt;</span><span class="id"> /sQ_inQ[v</span><span class="id"> Di]</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> /eqP</span><span class="id"> &lt;-:</span><span class="id"> -</span><span class="id"> QxR</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> ==</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oppr_gt0</span><span class="id"> -leNgt</span><span class="id"> sqr_ge0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -rmorphXn</span><span class="id"> -rmorphN</span><span class="id"> fmorph_eq1</span><span class="id"> -</span>(<span class="id">fmorph_eq1</span> (<span class="id">ofQ</span><span class="id"> x</span>))<span class="id"> rmorphN</span><span class="id"> eqr_oppLR</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphXn</span><span class="id"> /=</span><span class="id"> Di</span><span class="id"> Di2</span>.<br/>
<span class="id">have</span><span class="id"> szX2_1:</span><span class="id"> size</span> (<span class="id">'X^2</span><span class="id"> +</span><span class="id"> 1</span>)<span class="id"> =</span><span class="id"> 3%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> R;</span><span class="id"> rewrite</span><span class="id"> size_polyDl</span><span class="id"> ?size_polyXn</span><span class="id"> ?size_poly1</span>.<br/>
<span class="id">have</span><span class="id"> minp_i</span><span class="id"> n</span> (<span class="id">p_i</span><span class="id"> :=</span><span class="id"> minPoly</span> (<span class="id">R_</span><span class="id"> n</span>) (<span class="id">i_</span><span class="id"> n</span>))<span class="id">:</span><span class="id"> p_i</span><span class="id"> =</span><span class="id"> 'X^2</span><span class="id"> +</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> p_dv_X2_1:</span><span class="id"> p_i</span><span class="id"> %|</span><span class="id"> 'X^2</span><span class="id"> +</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> minPoly_dvdp</span><span class="id"> ?rpredD</span><span class="id"> ?rpredX</span><span class="id"> ?rpred1</span><span class="id"> ?polyOverX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">fmorph_root</span> (<span class="id">ofQ</span><span class="id"> _</span>))<span class="id"> inQ_K</span><span class="id"> //</span><span class="id"> rmorphD</span><span class="id"> rmorph1</span><span class="id"> /=</span><span class="id"> map_polyXn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rootE</span><span class="id"> hornerD</span><span class="id"> hornerXn</span><span class="id"> hornerC</span><span class="id"> Di2</span><span class="id"> addNr</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -eqp_monic</span><span class="id"> ?monic_minPoly</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> monicE</span><span class="id"> lead_coefE</span><span class="id"> szX2_1</span><span class="id"> coefD</span><span class="id"> coefXn</span><span class="id"> coefC</span><span class="id"> addr0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -dvdp_size_eqp</span><span class="id"> //</span><span class="id"> eqn_leq</span><span class="id"> dvdp_leq</span><span class="id"> -?size_poly_eq0</span><span class="id"> ?szX2_1</span><span class="id"> //=</span><span class="id"> ltnNge</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_minPoly</span><span class="id"> ltnS</span><span class="id"> leq_eqVlt</span><span class="id"> orbF</span><span class="id"> adjoin_deg_eq1</span><span class="id"> -sQof2</span><span class="id"> !inQ_K</span>.<br/>
<span class="id">have</span><span class="id"> /all_sig[n_</span><span class="id"> FTA]</span><span class="id"> z:</span><span class="id"> {n</span><span class="id"> |</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> n</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss</span><span class="id"> [z_i</span><span class="id"> gal_z]:</span><span class="id"> z</span><span class="id"> /</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> z</span><span class="id"> /\</span><span class="id"> is_Gal</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [y</span><span class="id"> /and3P[/sQtrans</span><span class="id"> y_z</span><span class="id"> /sQtrans</span><span class="id"> y_i</span><span class="id"> _]</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> PET</span><span class="id"> [::</span><span class="id"> z;</span><span class="id"> i]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [t</span><span class="id"> /sQtrans</span><span class="id"> t_y</span><span class="id"> gal_t]</span><span class="id"> :=</span><span class="id"> galQ</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/</span>(_<span class="id"> t</span>)<span class="id">=&gt;</span><span class="id"> [|n];</span><span class="id"> last</span><span class="gallina-kwd"> exists</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> ?y_z</span><span class="id"> ?y_i</span><span class="id"> ?t_y</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/sig_eqW;</span><span class="id"> have</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> 0%N</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [p]:</span><span class="gallina-kwd"> exists</span><span class="id"> p,</span><span class="id"> [&amp;&amp;</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> monic,</span><span class="id"> root</span><span class="id"> p</span><span class="id"> z</span><span class="id"> &amp;</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span> (<span class="id">sQ</span> (<span class="id">z_</span><span class="id"> n</span>))<span class="id">]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [p</span><span class="id"> mon_p</span><span class="id"> pz0]</span><span class="id"> :=</span><span class="id"> algC</span><span class="id"> z;</span><span class="gallina-kwd"> exists</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> QtoC</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_monic</span><span class="id"> mon_p</span><span class="id"> pz0</span><span class="id"> -</span>(<span class="id">pQof</span> (<span class="id">z_</span><span class="id"> n</span>))<span class="id">;</span><span class="id"> apply/polyOver_poly</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [d</span><span class="id"> lepd]</span><span class="id"> :=</span><span class="id"> ubnP</span> (<span class="id">size</span><span class="id"> p</span>)<span class="id">;</span><span class="id"> elim:</span><span class="id"> d</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> d</span><span class="id"> IHd</span><span class="gallina-kwd"> in</span><span class="id"> p</span><span class="id"> n</span><span class="id"> lepd</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> pz0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [t</span><span class="id"> [t_C</span><span class="id"> t_z</span><span class="id"> gal_t]]:</span><span class="gallina-kwd"> exists</span><span class="id"> t,</span><span class="id"> [/\</span><span class="id"> z_</span><span class="id"> n</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> sQ</span><span class="id"> t</span><span class="id"> &amp;</span><span class="id"> is_Gal</span><span class="id"> t]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [y</span><span class="id"> /and3P[y_C</span><span class="id"> y_z</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> PET</span><span class="id"> [::</span><span class="id"> z_</span><span class="id"> n;</span><span class="id"> z]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [t</span><span class="id"> /</span>(<span class="id">sQtrans</span><span class="id"> y</span>)<span class="id">t_y]</span><span class="id"> :=</span><span class="id"> galQ</span><span class="id"> y;</span><span class="gallina-kwd"> exists</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> !t_y</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> QtMixin</span><span class="id"> :=</span><span class="id"> FieldExt_isSplittingField</span>.<span class="id">Build</span><span class="id"> _</span> (<span class="id">Q</span><span class="id"> t</span>)<span class="id"> gal_t</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Qt</span><span class="id"> :</span><span class="id"> splittingFieldType</span><span class="id"> rat</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span> (<span class="id">Q</span><span class="id"> t</span>)<span class="id"> QtMixin</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /QtoQ[CnQt</span><span class="id"> CnQtE]</span><span class="id"> :=</span><span class="id"> t_C</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Rn</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> Qt}</span><span class="id"> :=</span> (<span class="id">CnQt</span><span class="id"> @:</span><span class="id"> R_</span><span class="id"> n</span>)<span class="id">%AS;</span><span class="id"> pose</span><span class="id"> i_t</span><span class="id"> :</span><span class="id"> Qt</span><span class="id"> :=</span><span class="id"> CnQt</span> (<span class="id">i_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Cn</span><span class="id"> :</span><span class="id"> {subfield</span><span class="id"> Qt}</span><span class="id"> :=</span><span class="id"> &lt;&lt;Rn;</span><span class="id"> i_t&gt;&gt;%AS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defCn:</span><span class="id"> Cn</span><span class="id"> =</span><span class="id"> limg</span><span class="id"> CnQt</span><span class="id"> :&gt;</span><span class="id"> {vspace</span><span class="id"> Q</span><span class="id"> t}</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -aimg_adjoin</span><span class="id"> defRi</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> memRn</span><span class="id"> u:</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> Rn</span>)<span class="id"> =</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> aimg_adjoin</span><span class="id"> aimg1</span><span class="id"> -sQof2</span><span class="id"> CnQtE</span><span class="id"> inQ_K</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> memCn</span><span class="id"> u:</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> Cn</span>)<span class="id"> =</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [v</span><span class="id"> Dv</span><span class="id"> genCn]</span><span class="id"> :=</span><span class="id"> genQz</span> (<span class="id">z_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Dv</span><span class="id"> -CnQtE</span><span class="id"> sQof2</span><span class="id"> defCn</span><span class="id"> -genCn</span><span class="id"> aimg_adjoin</span><span class="id"> aimg1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Dit:</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> i_t</span><span class="id"> =</span><span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> CnQtE</span><span class="id"> inQ_K</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Dit2:</span><span class="id"> i_t</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> -1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">fmorph_inj</span> (<span class="id">ofQ</span><span class="id"> t</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> rmorphXn</span><span class="id"> rmorphN1</span><span class="id"> /=</span><span class="id"> Dit</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> dimCn:</span><span class="id"> \dim_Rn</span><span class="id"> Cn</span><span class="id"> =</span><span class="id"> 2%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -adjoin_degreeE</span><span class="id"> adjoin_degree_aimg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> succn_inj;</span><span class="id"> rewrite</span><span class="id"> -size_minPoly</span><span class="id"> minp_i</span><span class="id"> szX2_1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /sQ_inQ[u_z</span><span class="id"> Dz]</span><span class="id"> :=</span><span class="id"> t_z;</span><span class="id"> pose</span><span class="id"> Rz</span><span class="id"> :=</span><span class="id"> &lt;&lt;Cn;</span><span class="id"> u_z&gt;&gt;%AS</span>.<br/>
&nbsp;&nbsp;<span class="id">have{p</span><span class="id"> lepd</span><span class="id"> pz0}</span><span class="id"> le_Rz_d:</span> (<span class="id">\dim_Cn</span><span class="id"> Rz</span><span class="id"> &lt;</span><span class="id"> d</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -ltnS</span><span class="id"> -adjoin_degreeE</span><span class="id"> -size_minPoly</span> (<span class="id">leq_trans</span><span class="id"> _</span><span class="id"> lepd</span>)<span class="id"> //</span><span class="id"> !ltnS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{pz0}</span><span class="id"> [mon_p</span><span class="id"> pz0</span><span class="id"> Cp]</span><span class="id"> :=</span><span class="id"> and3P</span><span class="id"> pz0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{Cp}</span><span class="id"> Dp:</span> ((<span class="id">p</span><span class="id"> ^</span><span class="id"> inQ</span> (<span class="id">z_</span><span class="id"> n</span>))<span class="id"> ^</span><span class="id"> CnQt</span>)<span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -map_poly_comp</span> (<span class="id">eq_map_poly</span><span class="id"> CnQtE</span>)<span class="id"> inQpK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -Dp</span><span class="id"> size_map_poly</span><span class="id"> dvdp_leq</span><span class="id"> ?monic_neq0</span><span class="id"> -?</span>(<span class="id">map_monic</span> (<span class="id">ofQ</span><span class="id"> _</span>))<span class="id"> ?Dp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defCn</span><span class="id"> minPoly_dvdp</span><span class="id"> //;</span><span class="id"> try</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">fmorph_root</span> (<span class="id">ofQ</span><span class="id"> t</span>))<span class="id"> Dz</span><span class="id"> Dp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> memv_img</span><span class="id"> ?memvf</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sRCn</span><span class="id"> sCnRz]:</span> (<span class="id">Rn</span><span class="id"> &lt;=</span><span class="id"> Cn</span>)<span class="id">%VS</span><span class="id"> /\</span> (<span class="id">Cn</span><span class="id"> &lt;=</span><span class="id"> Rz</span>)<span class="id">%VS</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !subv_adjoin</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sRnRz</span><span class="id"> :=</span><span class="id"> subv_trans</span><span class="id"> sRCn</span><span class="id"> sCnRz</span>.<br/>
&nbsp;&nbsp;<span class="id">have{gal_z}</span><span class="id"> galRz:</span><span class="id"> galois</span><span class="id"> Rn</span><span class="id"> Rz</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/and3P;</span><span class="id"> split;</span><span class="id"> [by</span><span class="id"> []|by</span><span class="id"> apply:</span><span class="id"> sepQ|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/splitting_normalField=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> QzMixin</span><span class="id"> :=</span><span class="id"> FieldExt_isSplittingField</span>.<span class="id">Build</span><span class="id"> _</span> (<span class="id">Q</span><span class="id"> z</span>)<span class="id"> gal_z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> Qz</span><span class="id"> :</span><span class="id"> splittingFieldType</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span> (<span class="id">Q</span><span class="id"> z</span>)<span class="id"> QzMixin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> u</span><span class="id"> :</span><span class="id"> Qz</span><span class="id"> :=</span><span class="id"> inQ</span><span class="id"> z</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /QtoQ[Qzt</span><span class="id"> QztE]</span><span class="id"> :=</span><span class="id"> t_z;</span><span class="gallina-kwd"> exists</span> (<span class="id">minPoly</span><span class="id"> 1</span><span class="id"> u</span><span class="id"> ^</span><span class="id"> Qzt</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /polyOver1P[q</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> minPolyOver</span><span class="id"> 1</span><span class="id"> u;</span><span class="id"> apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> coef_map</span><span class="id"> linearZZ</span><span class="id"> rmorph1</span><span class="id"> rpredZ</span><span class="id"> ?rpred1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [s</span><span class="id"> /eqP</span><span class="id"> Ds]</span><span class="id"> :=</span><span class="id"> splitting_field_normal</span><span class="id"> 1</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Ds;</span><span class="gallina-kwd"> exists</span> (<span class="id">map</span><span class="id"> Qzt</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_rp</span><span class="id"> eqpxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/Fadjoin_seqP;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> /mapP[w</span><span class="id"> s_w</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subvP</span> (<span class="id">adjoinSl</span><span class="id"> u_z</span> (<span class="id">sub1v</span><span class="id"> _</span>)))<span class="id"> //</span><span class="id"> -sQof2</span><span class="id"> Dz</span><span class="id"> QztE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> adjoinC</span> (<span class="id">Fadjoin_idP</span><span class="id"> _</span>)<span class="id"> -/Rz;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subvP</span> (<span class="id">adjoinSl</span><span class="id"> _</span> (<span class="id">sub1v</span><span class="id"> _</span>)))<span class="id"> //</span><span class="id"> -sQof2</span><span class="id"> Dz</span><span class="id"> Dit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -adjoin_seq1</span><span class="id"> adjoin_seqSr</span><span class="id"> //;</span><span class="id"> apply/allP=&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">mem_map</span> (<span class="id">fmorph_inj</span> (<span class="id">ofQ</span><span class="id"> _</span>)))<span class="id"> -map_comp</span> (<span class="id">eq_map</span><span class="id"> QztE</span>)<span class="id">;</span><span class="id"> apply/mapP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> ?inQ_K</span><span class="id"> //</span><span class="id"> -root_prod_XsubC</span><span class="id"> -Ds</span><span class="id"> root_minPoly</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> galCz:</span><span class="id"> galois</span><span class="id"> Cn</span><span class="id"> Rz</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">galoisS</span><span class="id"> _</span><span class="id"> galRz</span>)<span class="id"> ?sRCn</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [Cz</span><span class="id"> |</span><span class="id"> C'z]:=</span><span class="id"> boolP</span> (<span class="id">u_z</span><span class="id"> \in</span><span class="id"> Cn</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -Dz</span><span class="id"> -memCn</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> 'Gal</span>(<span class="id">Rz</span><span class="id"> /</span><span class="id"> Cn</span>)<span class="id">%G;</span><span class="id"> have{C'z}</span><span class="id"> ntG:</span><span class="id"> G</span><span class="id"> :!=:</span><span class="id"> 1%g</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> trivg_card1</span><span class="id"> -galois_dim</span><span class="id"> 1?</span>(<span class="id">galoisS</span><span class="id"> _</span><span class="id"> galCz</span>)<span class="id"> ?subvv</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -adjoin_degreeE</span><span class="id"> adjoin_deg_eq1</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> extRz</span><span class="id"> m</span><span class="id"> :=</span><span class="gallina-kwd"> exists2</span><span class="id"> w,</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> m</span>)<span class="id"> &amp;</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> [predD</span><span class="id"> Rz</span><span class="id"> &amp;</span><span class="id"> Cn]</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> [m</span><span class="id"> le_n_m</span><span class="id"> [w</span><span class="id"> Cw</span><span class="id"> /andP[C'w</span><span class="id"> Rz_w]]]:</span><span class="gallina-kwd"> exists2</span><span class="id"> m,</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> &amp;</span><span class="id"> extRz</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> &lt;&lt;Cn;</span><span class="id"> w&gt;&gt;</span><span class="id"> u_z;</span><span class="id"> apply:</span> (<span class="id">IHd</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> t</span>)<span class="id"> m</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> leq_trans</span><span class="id"> le_Rz_d;</span><span class="id"> rewrite</span><span class="id"> size_map_poly</span><span class="id"> size_minPoly</span><span class="id"> ltnS</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> adjoin_degreeE</span><span class="id"> adjoinC</span> (<span class="id">addv_idPl</span><span class="id"> Rz_w</span>)<span class="id"> agenv_id</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltn_divLR</span><span class="id"> ?adim_gt0</span><span class="id"> //</span><span class="id"> mulnC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> muln_divCA</span><span class="id"> ?field_dimS</span><span class="id"> ?subv_adjoin</span><span class="id"> //</span><span class="id"> ltn_Pmulr</span><span class="id"> ?adim_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -adjoin_degreeE</span><span class="id"> ltnNge</span><span class="id"> leq_eqVlt</span><span class="id"> orbF</span><span class="id"> adjoin_deg_eq1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_monic</span><span class="id"> monic_minPoly</span><span class="id"> -Dz</span><span class="id"> fmorph_root</span><span class="id"> root_minPoly</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /polyOverP</span><span class="id"> Cw_p:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> &lt;&lt;Cn;</span><span class="id"> w&gt;&gt;%VS</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> minPolyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> /Fadjoin_polyP[q</span><span class="id"> Cq</span><span class="id"> {j}-&gt;]</span><span class="id"> :=</span><span class="id"> Cw_p</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -horner_map</span> (<span class="id">@rpred_horner</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">sCle</span><span class="id"> n</span>)<span class="id"> //</span><span class="id"> -memCn</span> (<span class="id">polyOverP</span><span class="id"> Cq</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [evenG</span><span class="id"> |</span><span class="id"> oddG]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">2</span>.<span class="id">-group</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [P</span><span class="id"> /and3P[sPG</span><span class="id"> evenP</span><span class="id"> oddPG]]</span><span class="id"> :=</span><span class="id"> Sylow_exists</span><span class="id"> 2</span><span class="id"> 'Gal</span>(<span class="id">Rz</span><span class="id"> /</span><span class="id"> Rn</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [w</span><span class="id"> defQw]</span><span class="id"> :=</span><span class="id"> PET_Qz</span><span class="id"> t</span><span class="id"> [aspace</span><span class="id"> of</span><span class="id"> fixedField</span><span class="id"> P]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> pw</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> Rn</span><span class="id"> w;</span><span class="id"> pose</span><span class="id"> p</span><span class="id"> :=</span> (<span class="id">-</span><span class="id"> pw</span><span class="id"> *</span> (<span class="id">pw</span><span class="id"> \Po</span><span class="id"> -</span><span class="id"> 'X</span>))<span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> t</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> sz_pw:</span> (<span class="id">size</span><span class="id"> pw</span>).<span class="id">-1</span><span class="id"> =</span><span class="id"> #|'Gal</span>(<span class="id">Rz</span><span class="id"> /</span><span class="id"> Rn</span>)<span class="id"> :</span><span class="id"> P|</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_minPoly</span><span class="id"> adjoin_degreeE</span><span class="id"> -dim_fixed_galois</span><span class="id"> //=</span><span class="id"> -defQw</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">congr</span> (<span class="id">\dim_Rn</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> adjoinSl</span><span class="id"> ?sub1v</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/FadjoinP;</span><span class="id"> rewrite</span><span class="id"> memv_adjoin</span><span class="id"> /=</span><span class="id"> defQw</span><span class="id"> -galois_connection</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> mon_p:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> monic</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> mon_pw:</span><span class="id"> pw</span><span class="id"> \is</span><span class="id"> monic</span><span class="id"> :=</span><span class="id"> monic_minPoly</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> map_monic</span><span class="id"> mulNr</span><span class="id"> -mulrN</span><span class="id"> monicMl</span><span class="id"> //</span><span class="id"> monicE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">lead_coefN,</span><span class="id"> lead_coef_comp</span>)<span class="id"> ?size_polyN</span><span class="id"> ?size_polyX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> lead_coefX</span><span class="id"> sz_pw</span><span class="id"> -signr_odd</span><span class="id"> odd_2'nat</span><span class="id"> oddPG</span><span class="id"> mulrN1</span><span class="id"> opprK</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Dp0:</span><span class="id"> p</span>.<span class="id">[0]</span><span class="id"> =</span><span class="id"> -</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> pw</span>.<span class="id">[0]</span><span class="id"> ^+</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">rmorph0</span> (<span class="id">ofQ</span><span class="id"> t</span>))<span class="id"> horner_map</span><span class="id"> hornerM</span><span class="id"> rmorphM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> horner_comp</span><span class="id"> !hornerN</span><span class="id"> hornerX</span><span class="id"> oppr0</span><span class="id"> /=</span><span class="id"> rmorphN</span><span class="id"> mulNr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Rpw:</span><span class="id"> pw</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Rn</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> minPolyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Rp:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span> (<span class="id">sQ</span> (<span class="id">x_</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/polyOver_poly=&gt;</span><span class="id"> j</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -memRn;</span><span class="id"> apply:</span><span class="id"> polyOverP</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rpredM</span><span class="id"> 1?polyOver_comp</span><span class="id"> ?rpredN</span><span class="id"> ?polyOverX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Rp0:</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> pw</span>.<span class="id">[0]</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> n</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -memRn</span><span class="id"> rpred_horner</span><span class="id"> ?rpred0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|{mon_p</span><span class="id"> Rp</span><span class="id"> Rp0</span><span class="id"> Dp0}m</span><span class="id"> lenm</span><span class="id"> p_Rm_0]</span><span class="id"> :=</span><span class="id"> xRroot</span><span class="id"> n</span><span class="id"> p</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> pw</span>.<span class="id">[0]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /has_Rroot</span><span class="id"> mon_p</span><span class="id"> Rp</span><span class="id"> Rp0</span><span class="id"> -Dp0</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{p_Rm_0}</span><span class="id"> [y</span><span class="id"> Ry</span><span class="id"> pw_y]:</span><span class="id"> {y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">x_</span><span class="id"> m</span>)<span class="id"> &amp;</span><span class="id"> root</span> (<span class="id">pw</span><span class="id"> ^</span><span class="id"> ofQ</span><span class="id"> t</span>)<span class="id"> y}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/sig2W;</span><span class="id"> have</span><span class="id"> [y</span><span class="id"> Ry]</span><span class="id"> :=</span><span class="id"> p_Rm_0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [p]rmorphM</span><span class="id"> /=</span><span class="id"> map_comp_poly</span><span class="id"> !rmorphN</span><span class="id"> /=</span><span class="id"> map_polyX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rootM</span><span class="id"> rootN</span><span class="id"> root_comp</span><span class="id"> hornerN</span><span class="id"> hornerX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/orP;</span><span class="id"> [exists</span><span class="id"> y</span><span class="id"> |</span><span class="gallina-kwd"> exists</span> (<span class="id">-</span><span class="id"> y</span>)<span class="id">];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">rpredN</span> (<span class="id">sQC</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [u</span><span class="id"> Rz_u</span><span class="id"> Dy]:</span><span class="gallina-kwd"> exists2</span><span class="id"> u,</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> Rz</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> =</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> u</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Rz_w:</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> Rz</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sub_adjoin1v</span><span class="id"> defQw</span><span class="id"> capvSl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sg</span><span class="id"> [Gsg</span><span class="id"> _</span><span class="id"> Dpw]]</span><span class="id"> :=</span><span class="id"> galois_factors</span><span class="id"> sRnRz</span><span class="id"> galRz</span><span class="id"> w</span><span class="id"> Rz_w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> map</span><span class="id"> _</span><span class="id"> sg</span><span class="gallina-kwd"> in</span><span class="id"> Dpw</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /mapP[u</span><span class="id"> /mapP[g</span><span class="id"> Gg</span><span class="id"> Du]</span><span class="id"> -&gt;]:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> map</span> (<span class="id">ofQ</span><span class="id"> t</span>)<span class="id"> s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -root_prod_XsubC</span><span class="id"> -/</span>(<span class="id">rp</span><span class="id"> C</span><span class="id"> _</span>)<span class="id"> -map_rp</span><span class="id"> -[rp</span><span class="id"> _</span><span class="id"> _]Dpw</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> Du</span><span class="id"> memv_gal</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have{pw_y}</span><span class="id"> pw_u:</span><span class="id"> root</span><span class="id"> pw</span><span class="id"> u</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">fmorph_root</span> (<span class="id">ofQ</span><span class="id"> t</span>))<span class="id"> -Dy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> u;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -Dy;</span><span class="id"> apply:</span><span class="id"> sQtrans</span><span class="id"> Ry</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /=</span><span class="id"> Rz_u</span><span class="id"> andbT;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> oddG</span><span class="id"> =&gt;</span><span class="id"> Cu</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suffices:</span><span class="id"> 2</span>.<span class="id">-group</span><span class="id"> 'Gal</span>(<span class="id">Rz</span><span class="id"> /</span><span class="id"> Rn</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> pnat_dvd;</span><span class="id"> rewrite</span><span class="id"> -!galois_dim</span><span class="id"> //</span><span class="id"> ?</span>(<span class="id">galoisS</span><span class="id"> _</span><span class="id"> galQr</span>)<span class="id"> ?sRCz</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dvdn_divLR</span><span class="id"> ?field_dimS</span><span class="id"> ?adim_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulnC</span><span class="id"> muln_divCA</span><span class="id"> ?field_dimS</span><span class="id"> ?dvdn_mulr</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">congr</span> (<span class="id">2</span>.<span class="id">-group</span><span class="id"> _</span>)<span class="id">:</span><span class="id"> evenP;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> sPG</span><span class="id"> -indexg_eq1</span> (<span class="id">pnat_1</span><span class="id"> _</span><span class="id"> oddPG</span>)<span class="id"> //</span><span class="id"> -sz_pw</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span> (<span class="id">pu</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> Rn</span><span class="id"> u</span>)<span class="id">:</span> (<span class="id">pu</span><span class="id"> %=</span><span class="id"> pw</span>)<span class="id"> ||</span> (<span class="id">pu</span><span class="id"> %=</span><span class="id"> 1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> minPoly_irr</span><span class="id"> ?minPoly_dvdp</span><span class="id"> ?minPolyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -size_poly_eq1</span><span class="id"> {1}size_minPoly</span><span class="id"> orbF</span><span class="id"> =&gt;</span><span class="id"> /eqp_size</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_minPoly</span><span class="id"> /=</span><span class="id"> adjoin_degreeE</span> (<span class="id">@pnat_dvd</span><span class="id"> _</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -dimCn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dvdn_divLR</span><span class="id"> ?divnK</span><span class="id"> ?adim_gt0</span><span class="id"> ?field_dimS</span><span class="id"> ?subv_adjoin</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact/FadjoinP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [w</span><span class="id"> Rz_w</span><span class="id"> deg_w]:</span><span class="gallina-kwd"> exists2</span><span class="id"> w,</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> Rz</span><span class="id"> &amp;</span><span class="id"> adjoin_degree</span><span class="id"> Cn</span><span class="id"> w</span><span class="id"> =</span><span class="id"> 2%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [P</span><span class="id"> sPG</span><span class="id"> iPG]:</span><span class="gallina-kwd"> exists2</span><span class="id"> P</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gal_of</span><span class="id"> Rz},</span><span class="id"> P</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> P|</span><span class="id"> =</span><span class="id"> 2%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [k</span><span class="id"> oG]]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> evenG</span><span class="id"> ntG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [P</span><span class="id"> [sPG</span><span class="id"> _</span><span class="id"> oP]]</span><span class="id"> :=</span><span class="id"> normal_pgroup</span><span class="id"> evenG</span> (<span class="id">normal_refl</span><span class="id"> G</span>) (<span class="id">leq_pred</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> P</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> -divgS</span><span class="id"> //</span><span class="id"> oP</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -expnB</span><span class="id"> ?subSnn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [w</span><span class="id"> defQw]</span><span class="id"> :=</span><span class="id"> PET_Qz</span><span class="id"> _</span><span class="id"> [aspace</span><span class="id"> of</span><span class="id"> fixedField</span><span class="id"> P]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> w;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -sub_adjoin1v</span><span class="id"> defQw</span><span class="id"> capvSl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> adjoin_degreeE</span><span class="id"> -iPG</span><span class="id"> -dim_fixed_galois</span><span class="id"> //</span><span class="id"> -defQw;</span><span class="id"> congr</span> (<span class="id">\dim_Cn</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/esym/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubv</span><span class="id"> adjoinSl</span><span class="id"> ?sub1v</span><span class="id"> //=;</span><span class="id"> apply/FadjoinP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> memv_adjoin</span><span class="id"> /=</span><span class="id"> defQw</span><span class="id"> -galois_connection</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nz2:</span><span class="id"> 2</span><span class="id"> !=</span><span class="id"> 0</span><span class="id"> :&gt;</span><span class="id"> Qt</span><span class="gallina-kwd"> by</span><span class="id"> move/pcharf0P:</span> (<span class="id">pcharQ</span> (<span class="id">Q</span><span class="id"> t</span>))<span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss{deg_w}</span><span class="id"> [C'w</span><span class="id"> Cw2]:</span><span class="id"> w</span><span class="id"> Rz_w</span><span class="id"> /</span><span class="id"> w</span><span class="id"> \notin</span><span class="id"> Cn</span><span class="id"> /\</span><span class="id"> w</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> \in</span><span class="id"> Cn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> minPoly</span><span class="id"> Cn</span><span class="id"> w;</span><span class="id"> pose</span><span class="id"> v</span><span class="id"> :=</span><span class="id"> p`_1</span><span class="id"> /</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /polyOverP</span><span class="id"> Cp:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Cn</span><span class="id"> :=</span><span class="id"> minPolyOver</span><span class="id"> Cn</span><span class="id"> w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Cv:</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> Cn</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpred_div</span><span class="id"> ?rpred_nat</span><span class="id"> ?Cp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/</span>(_ (<span class="id">v</span><span class="id"> +</span><span class="id"> w</span>))<span class="id">;</span><span class="id"> apply;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpredD</span><span class="id"> //</span><span class="id"> subvP_adjoin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpredDl</span><span class="id"> //</span><span class="id"> -adjoin_deg_eq1</span><span class="id"> deg_w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addrC</span><span class="id"> -[_</span><span class="id"> ^+</span><span class="id"> 2]subr0</span><span class="id"> -</span>(<span class="id">rootP</span> (<span class="id">root_minPoly</span><span class="id"> Cn</span><span class="id"> w</span>))<span class="id"> -/p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sqrrD</span><span class="id"> [_</span><span class="id"> -</span><span class="id"> _]addrAC</span><span class="id"> rpredD</span><span class="id"> ?rpredX</span><span class="id"> //</span><span class="id"> -mulr_natr</span><span class="id"> -mulrA</span><span class="id"> divfK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [w</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> +</span><span class="id"> _]addrC</span><span class="id"> mulrC</span><span class="id"> -rpredN</span><span class="id"> opprB</span><span class="id"> horner_coef</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /monicP</span><span class="id"> :=</span><span class="id"> monic_minPoly</span><span class="id"> Cn</span><span class="id"> w;</span><span class="id"> rewrite</span><span class="id"> lead_coefE</span><span class="id"> size_minPoly</span><span class="id"> deg_w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> 2!big_ord_recl</span><span class="id"> big_ord1</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulr1</span><span class="id"> mul1r</span><span class="id"> addrK</span><span class="id"> Cp</span>.<br/>
&nbsp;&nbsp;<span class="id">without</span><span class="id"> loss</span><span class="id"> R'w2:</span><span class="id"> w</span><span class="id"> Rz_w</span><span class="id"> C'w</span><span class="id"> Cw2</span><span class="id"> /</span><span class="id"> w</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> \notin</span><span class="id"> Rn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> IHw;</span><span class="id"> have</span><span class="id"> [Rw2</span><span class="id"> |</span><span class="id"> /IHw]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">w</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> \in</span><span class="id"> Rn</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> exact</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> R'it:</span><span class="id"> i_t</span><span class="id"> \notin</span><span class="id"> Rn</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> memRn</span><span class="id"> Dit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">pose</span><span class="id"> v</span><span class="id"> :=</span><span class="id"> 1</span><span class="id"> +</span><span class="id"> i_t;</span><span class="id"> have</span><span class="id"> R'v:</span><span class="id"> v</span><span class="id"> \notin</span><span class="id"> Rn</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpredDl</span><span class="id"> ?rpred1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Cv:</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> Cn</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rpredD</span><span class="id"> ?rpred1</span><span class="id"> ?memv_adjoin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> nz_v:</span><span class="id"> v</span><span class="id"> !=</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">memPnC</span><span class="id"> R'v</span>)<span class="id"> ?rpred0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">IHw</span> (<span class="id">v</span><span class="id"> *</span><span class="id"> w</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> 1</span><span class="id"> [|]</span><span class="id"> ||</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> fpredMl</span><span class="id"> //</span><span class="id"> subvP_adjoin</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> exprMn</span><span class="id"> rpredM</span><span class="id"> //</span><span class="id"> rpredX</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> exprMn</span><span class="id"> fpredMr</span><span class="id"> //=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expf_eq0</span> (<span class="id">memPnC</span><span class="id"> C'w</span>)<span class="id"> ?rpred0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sqrrD</span><span class="id"> Dit2</span><span class="id"> expr1n</span><span class="id"> addrC</span><span class="id"> addKr</span><span class="id"> -mulrnAl</span><span class="id"> fpredMl</span><span class="id"> ?rpred_nat</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> rect_w2</span><span class="id"> u</span><span class="id"> v</span><span class="id"> :=</span><span class="id"> [/\</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> Rn,</span><span class="id"> v</span><span class="id"> \in</span><span class="id"> Rn</span><span class="id"> &amp;</span><span class="id"> u</span><span class="id"> +</span><span class="id"> i_t</span><span class="id"> *</span> (<span class="id">v</span><span class="id"> *</span><span class="id"> 2</span>)<span class="id"> =</span><span class="id"> w</span><span class="id"> ^+</span><span class="id"> 2]</span>.<br/>
&nbsp;&nbsp;<span class="id">have{Cw2}</span><span class="id"> [u</span><span class="id"> [v</span><span class="id"> [Ru</span><span class="id"> Rv</span><span class="id"> Dw2]]]:</span><span class="id"> {u</span><span class="id"> :</span><span class="id"> Qt</span><span class="id"> &amp;</span><span class="id"> {v</span><span class="id"> |</span><span class="id"> rect_w2</span><span class="id"> u</span><span class="id"> v}}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /rect_w2</span><span class="id"> -</span>(<span class="id">Fadjoin_poly_eq</span><span class="id"> Cw2</span>)<span class="id">;</span><span class="id"> set</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> Fadjoin_poly</span><span class="id"> Rn</span><span class="id"> i_t</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> /polyOverP</span><span class="id"> Rp:</span><span class="id"> p</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> polyOver</span><span class="id"> Rn</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> Fadjoin_polyOver</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> p`_0,</span> (<span class="id">p`_1</span><span class="id"> /</span><span class="id"> 2</span>)<span class="id">;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?rpred_div</span><span class="id"> ?rpred_nat</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> divfK</span><span class="id"> //</span> (<span class="id">horner_coef_wide</span><span class="id"> _</span> (<span class="id">size_Fadjoin_poly</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> -/p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> adjoin_degreeE</span><span class="id"> dimCn</span><span class="id"> big_ord_recl</span><span class="id"> big_ord1</span><span class="id"> mulr1</span><span class="id"> mulrC</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> Poly</span><span class="id"> [::</span><span class="id"> -</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 2</span>)<span class="id">;</span><span class="id"> 0;</span><span class="id"> -</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> u;</span><span class="id"> 0;</span><span class="id"> 1]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|m</span><span class="id"> lenm</span><span class="id"> [x</span><span class="id"> Rx</span><span class="id"> px0]]</span><span class="id"> :=</span><span class="id"> xRroot</span><span class="id"> n</span><span class="id"> p</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /has_Rroot</span><span class="id"> 2!unfold_in/=</span><span class="id"> lead_coefE</span><span class="id"> horner_coef0</span><span class="id"> -memRn</span><span class="id"> Rv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@PolyK</span><span class="id"> _</span><span class="id"> 1</span>)<span class="id"> ?oner_eq0</span><span class="id"> //=</span><span class="id"> !eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">rpred0</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> ?</span>(<span class="id">rpred1</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> ?</span>(<span class="id">rpredN</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !andbT</span> (<span class="id">@rpredX</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> -memRn</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> [y</span><span class="id"> Cy</span><span class="id"> Dy2]:</span><span class="id"> {y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> m</span>)<span class="id"> &amp;</span><span class="id"> ofQ</span><span class="id"> t</span><span class="id"> w</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> ==</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> w;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> C'w</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> Dy2;</span><span class="id"> rewrite</span><span class="id"> eqf_sqr</span><span class="id"> =&gt;</span><span class="id"> /pred2P[]-&gt;;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">rpredN</span> (<span class="id">sQC</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">x</span><span class="id"> +</span><span class="id"> i</span><span class="id"> *</span> (<span class="id">ofQ</span><span class="id"> t</span><span class="id"> v</span><span class="id"> /</span><span class="id"> x</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@rpredD</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> 1?</span>(<span class="id">@rpredM</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">sQtrans</span> (<span class="id">x_</span><span class="id"> m</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">@rpred_div</span><span class="id"> _</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //</span> (<span class="id">sQtrans</span> (<span class="id">x_</span><span class="id"> m</span>))<span class="id"> //</span> (<span class="id">sRle</span><span class="id"> n</span>)<span class="id"> //</span><span class="id"> -memRn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rootE</span><span class="id"> /horner</span> (<span class="id">@PolyK</span><span class="id"> _</span><span class="id"> 1</span>)<span class="id"> ?oner_eq0</span><span class="id"> //=</span><span class="id"> ?addr0</span><span class="id"> ?mul0r</span><span class="gallina-kwd"> in</span><span class="id"> px0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> add0r</span><span class="id"> mul1r</span><span class="id"> -mulrA</span><span class="id"> -expr2</span><span class="id"> subr_eq0</span><span class="gallina-kwd"> in</span><span class="id"> px0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nz_x2:</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> !=</span><span class="id"> 0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraNneq</span><span class="id"> R'w2</span><span class="id"> =&gt;</span><span class="id"> y2_0;</span><span class="id"> rewrite</span><span class="id"> -Dw2</span><span class="id"> mulrCA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> /eqP-&gt;:</span><span class="id"> v</span><span class="id"> ==</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mul0r</span><span class="id"> addr0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> y2_0</span><span class="id"> mulr0</span><span class="id"> eq_sym</span><span class="id"> sqrf_eq0</span><span class="id"> fmorph_eq0</span><span class="gallina-kwd"> in</span><span class="id"> px0</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP/esym/</span>(<span class="id">mulIf</span><span class="id"> nz_x2</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -exprMn</span><span class="id"> -rmorphXn</span><span class="id"> -Dw2</span><span class="id"> rmorphD</span><span class="id"> rmorphM</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> Dit</span><span class="id"> mulrDl</span><span class="id"> -expr2</span><span class="id"> mulrA</span><span class="id"> divfK;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expf_eq0</span><span class="gallina-kwd"> in</span><span class="id"> nz_x2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulr_natr</span><span class="id"> addrC</span><span class="id"> sqrrD</span><span class="id"> exprMn</span><span class="id"> Di2</span><span class="id"> mulN1r</span><span class="id"> -</span>(<span class="id">eqP</span><span class="id"> px0</span>)<span class="id"> -mulNr</span><span class="id"> opprB</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -mulrnAl</span><span class="id"> -mulrnAr</span><span class="id"> -rmorphMn</span><span class="id"> -!mulrDl</span><span class="id"> addrAC</span><span class="id"> subrK</span>.<br/>
<span class="id">have</span><span class="id"> inFTA</span><span class="id"> n</span><span class="id"> z:</span> (<span class="id">n_</span><span class="id"> z</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> ofQ</span> (<span class="id">z_</span><span class="id"> n</span>) (<span class="id">inQ</span> (<span class="id">z_</span><span class="id"> n</span>)<span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/sCle=&gt;</span><span class="id"> le_zn;</span><span class="id"> rewrite</span><span class="id"> inQ_K</span><span class="id"> ?le_zn</span>.<br/>
<span class="id">pose</span><span class="id"> is_cj</span><span class="id"> n</span><span class="id"> cj</span><span class="id"> :=</span><span class="id"> {in</span><span class="id"> R_</span><span class="id"> n,</span><span class="id"> cj</span><span class="id"> =1</span><span class="id"> id}</span><span class="id"> /\</span><span class="id"> cj</span> (<span class="id">i_</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> -</span><span class="id"> i_</span><span class="id"> n</span>.<br/>
<span class="id">have</span><span class="id"> /all_sig[cj_</span><span class="id"> /all_and2[cj_R</span><span class="id"> cj_i]]</span><span class="id"> n:</span><span class="id"> {cj</span><span class="id"> :</span><span class="id"> 'AEnd</span>(<span class="id">Q</span> (<span class="id">z_</span><span class="id"> n</span>))<span class="id"> |</span><span class="id"> is_cj</span><span class="id"> n</span><span class="id"> cj}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cj_P:</span><span class="id"> root</span> (<span class="id">minPoly</span> (<span class="id">R_</span><span class="id"> n</span>) (<span class="id">i_</span><span class="id"> n</span>)<span class="id"> ^</span><span class="id"> \1%VF</span>) (<span class="id">-</span><span class="id"> i_</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> minp_i</span><span class="id"> -</span>(<span class="id">fmorph_root</span> (<span class="id">ofQ</span><span class="id"> _</span>))<span class="id"> !rmorphD</span><span class="id"> !rmorph1</span><span class="id"> /=</span><span class="id"> !map_polyXn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rmorphN</span><span class="id"> inQ_K</span><span class="id"> //</span><span class="id"> rootE</span><span class="id"> hornerD</span><span class="id"> hornerXn</span><span class="id"> hornerC</span><span class="id"> sqrrN</span><span class="id"> Di2</span><span class="id"> addNr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cj_M:</span><span class="id"> ahom_in</span><span class="id"> fullv</span> (<span class="id">kHomExtend</span> (<span class="id">R_</span><span class="id"> n</span>)<span class="id"> \1</span> (<span class="id">i_</span><span class="id"> n</span>) (<span class="id">-</span><span class="id"> i_</span><span class="id"> n</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defRi</span><span class="id"> -k1HomE</span><span class="id"> kHomExtendP</span><span class="id"> ?sub1v</span><span class="id"> ?kHom1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">AHom</span><span class="id"> cj_M</span>)<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> [y</span><span class="id"> /kHomExtend_id-&gt;|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?id_lfunE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">kHomExtend_val</span> (<span class="id">kHom1</span><span class="id"> 1</span><span class="id"> _</span>)).<br/>
<span class="id">pose</span><span class="id"> conj_</span><span class="id"> n</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> ofQ</span><span class="id"> _</span> (<span class="id">cj_</span><span class="id"> n</span> (<span class="id">inQ</span><span class="id"> _</span><span class="id"> z</span>))<span class="id">;</span><span class="id"> pose</span><span class="id"> conj</span><span class="id"> z</span><span class="id"> :=</span><span class="id"> conj_</span> (<span class="id">n_</span><span class="id"> z</span>)<span class="id"> z</span>.<br/>
<span class="id">have</span><span class="id"> conjK</span><span class="id"> n</span><span class="id"> m</span><span class="id"> z:</span> (<span class="id">n_</span><span class="id"> z</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span> (<span class="id">n</span><span class="id"> &lt;=</span><span class="id"> m</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> conj_</span><span class="id"> m</span> (<span class="id">conj_</span><span class="id"> n</span><span class="id"> z</span>)<span class="id"> =</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">move/sCle=&gt;</span><span class="id"> le_z_n</span><span class="id"> le_n_m;</span><span class="id"> have</span><span class="id"> /le_z_n/sQ_inQ[u</span><span class="id"> &lt;-]</span><span class="id"> :=</span><span class="id"> FTA</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /QtoQ[Qmn</span><span class="id"> QmnE]:</span><span class="id"> z_</span><span class="id"> n</span><span class="id"> \in</span><span class="id"> sQ</span> (<span class="id">z_</span><span class="id"> m</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sCle</span><span class="id"> n</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /conj_</span><span class="id"> ofQ_K</span><span class="id"> -!QmnE</span><span class="id"> !ofQ_K</span><span class="id"> -!comp_lfunE;</span><span class="id"> congr</span> (<span class="id">ofQ</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> u</span> (<span class="id">memRi</span><span class="id"> n</span><span class="id"> u</span>)<span class="id">;</span><span class="id"> apply/eqlfun_inP/FadjoinP;</span><span class="id"> split=&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqlfun_inP=&gt;</span><span class="id"> y</span><span class="id"> Ry;</span><span class="id"> rewrite</span><span class="id"> !comp_lfunE</span><span class="id"> !cj_R</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> Ry;</span><span class="id"> rewrite</span><span class="id"> -!sQof2</span><span class="id"> QmnE</span><span class="id"> !inQ_K</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sRle</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqlfunP;</span><span class="id"> rewrite</span><span class="id"> !comp_lfunE</span><span class="id"> cj_i</span><span class="id"> !linearN</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> Qmn</span> (<span class="id">i_</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> i_</span><span class="id"> m</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cj_i</span><span class="id"> ?opprK</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">fmorph_inj</span> (<span class="id">ofQ</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> QmnE</span><span class="id"> !inQ_K</span>.<br/>
<span class="id">have</span><span class="id"> conjE</span><span class="id"> n</span><span class="id"> z:</span> (<span class="id">n_</span><span class="id"> z</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id">%N</span><span class="id"> -&gt;</span><span class="id"> conj</span><span class="id"> z</span><span class="id"> =</span><span class="id"> conj_</span><span class="id"> n</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">move/leq_trans=&gt;</span><span class="id"> le_zn;</span><span class="id"> set</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> conj</span><span class="id"> z;</span><span class="id"> set</span><span class="id"> y</span><span class="id"> :=</span><span class="id"> conj_</span><span class="id"> n</span><span class="id"> z</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [m</span><span class="id"> [le_xm</span><span class="id"> le_ym</span><span class="id"> le_nm]]</span><span class="id"> :=</span><span class="id"> maxn3</span> (<span class="id">n_</span><span class="id"> x</span>) (<span class="id">n_</span><span class="id"> y</span>)<span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /conjK/=/can_in_inj</span><span class="id"> :=</span><span class="id"> leqnn</span><span class="id"> m;</span><span class="id"> apply;</span><span class="id"> rewrite</span><span class="id"> ?conjK</span><span class="id"> //</span><span class="id"> le_zn</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> conjA</span><span class="id"> :</span><span class="id"> additive</span><span class="id"> conj</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> x</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [m</span><span class="id"> [le_xm</span><span class="id"> le_ym</span><span class="id"> le_xym]]</span><span class="id"> :=</span><span class="id"> maxn3</span> (<span class="id">n_</span><span class="id"> x</span>) (<span class="id">n_</span><span class="id"> y</span>) (<span class="id">n_</span> (<span class="id">x</span><span class="id"> -</span><span class="id"> y</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">conjE</span><span class="id"> m</span>)<span class="id"> //</span> (<span class="id">inFTA</span><span class="id"> m</span><span class="id"> x</span>)<span class="id"> //</span> (<span class="id">inFTA</span><span class="id"> m</span><span class="id"> y</span>)<span class="id"> -?rmorphB</span><span class="id"> /conj_</span><span class="id"> ?ofQ_K</span>.<br/>
<span class="id">have</span><span class="id"> conjM</span><span class="id"> :</span><span class="id"> multiplicative</span><span class="id"> conj</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> [x</span><span class="id"> y|];</span><span class="id"> last</span><span class="id"> pose</span><span class="id"> n1</span><span class="id"> :=</span><span class="id"> n_</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [m</span><span class="id"> [le_xm</span><span class="id"> le_ym</span><span class="id"> le_xym]]</span><span class="id"> :=</span><span class="id"> maxn3</span> (<span class="id">n_</span><span class="id"> x</span>) (<span class="id">n_</span><span class="id"> y</span>) (<span class="id">n_</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">conjE</span><span class="id"> m</span>)<span class="id"> //</span> (<span class="id">inFTA</span><span class="id"> m</span><span class="id"> x</span>)<span class="id"> //</span> (<span class="id">inFTA</span><span class="id"> m</span><span class="id"> y</span>)<span class="id"> -?rmorphM</span><span class="id"> /conj_</span><span class="id"> ?ofQ_K</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /conj</span><span class="id"> -/n1</span><span class="id"> -</span>(<span class="id">rmorph1</span> (<span class="id">ofQ</span> (<span class="id">z_</span><span class="id"> n1</span>)))<span class="id"> /conj_</span><span class="id"> ofQ_K</span><span class="id"> !rmorph1</span>.<br/>
<span class="id">have</span><span class="id"> conjaM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isAdditive</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> conjA</span>.<br/>
<span class="id">have</span><span class="id"> conjmM</span><span class="id"> :=</span><span class="id"> GRing</span>.<span class="id">isMultiplicative</span>.<span class="id">Build</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> conjM</span>.<br/>
<span class="id">pose</span><span class="id"> conjRM</span><span class="id"> :</span><span class="id"> {rmorphism</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> _}</span><span class="id"> :=</span><span class="id"> HB</span>.<span class="id">pack</span><span class="id"> conj</span><span class="id"> conjaM</span><span class="id"> conjmM</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> conjRM</span><span class="id"> =&gt;</span><span class="id"> [z</span><span class="id"> |</span><span class="id"> /</span>(_<span class="id"> i</span>)<span class="id">/eqP/idPn[]]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [n</span><span class="id"> [/conjE-&gt;</span><span class="id"> /</span>(<span class="id">conjK</span> (<span class="id">n_</span><span class="id"> z</span>))<span class="id">-&gt;]]</span><span class="id"> :=</span><span class="id"> maxn3</span> (<span class="id">n_</span> (<span class="id">conj</span><span class="id"> z</span>)) (<span class="id">n_</span><span class="id"> z</span>)<span class="id"> 0</span>.<br/>
<span class="id">rewrite</span><span class="id"> /conj/conj_</span><span class="id"> cj_i</span><span class="id"> rmorphN</span><span class="id"> inQ_K</span><span class="id"> //</span><span class="id"> eq_sym</span><span class="id"> -addr_eq0</span><span class="id"> -mulr2n</span><span class="id"> -mulr_natl</span>.<br/>
<span class="id">rewrite</span><span class="id"> mulf_neq0</span><span class="id"> ?</span>(<span class="id">memPnC</span> (<span class="id">R'i</span><span class="id"> 0</span>))<span class="id"> ?</span>(<span class="id">rpred0</span> (<span class="id">sQC</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /pcharf0P-&gt;</span><span class="id"> :=</span><span class="id"> ftrans</span> (<span class="id">fmorph_pchar</span><span class="id"> QtoC</span>) (<span class="id">pchar_num</span><span class="id"> _</span>).<br/>
Qed.</div></details>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
