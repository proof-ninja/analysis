
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.mathcomp.ssreflect.seq</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.mathcomp.ssreflect.seq" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.ssrnum.html">ssrnum</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
<li><a href="mathcomp.ssreflect.bigop.html">bigop</a></li>
<li><a href="mathcomp.ssreflect.binomial.html">binomial</a></li>
<li><a href="mathcomp.ssreflect.choice.html">choice</a></li>
<li><a href="mathcomp.ssreflect.div.html">div</a></li>
<li><a href="mathcomp.ssreflect.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.ssreflect.finfun.html">finfun</a></li>
<li><a href="mathcomp.ssreflect.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.ssreflect.finset.html">finset</a></li>
<li><a href="mathcomp.ssreflect.fintype.html">fintype</a></li>
<li><a href="mathcomp.ssreflect.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.ssreflect.order.html">order</a></li>
<li><a href="mathcomp.ssreflect.path.html">path</a></li>
<li><a href="mathcomp.ssreflect.prime.html">prime</a></li>
<li><a href="mathcomp.ssreflect.seq.html">seq</a></li>
<li><a href="mathcomp.ssreflect.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.ssreflect.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.ssreflect.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.ssreflect.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.ssreflect.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.ssreflect.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.ssreflect.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.ssreflect.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.mathcomp.ssreflect.seq</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrfun</span><span class="id"> ssrbool</span><span class="id"> eqtype</span><span class="id"> ssrnat</span>.<br/>
<br/>
<pre class="ssrdoc">
The seq type is the ssreflect type for sequences; it is an alias for the
standard Coq list type. The ssreflect library equips it with many
operations, as well as eqType and predType (and, later, choiceType)
structures. The operations are geared towards reflection: they generally
expect and provide boolean predicates, e.g., the membership predicate
expects an eqType. To avoid any confusion we do not Import the Coq List
module.
  As there is no true subtyping in Coq, we don't use a type for non-empty
sequences; rather, we pass explicitly the head and tail of the sequence.
  The empty sequence is especially bothersome for subscripting, since it
forces us to pass a default value. This default value can often be hidden
by a notation.
  Here is the list of seq operations:
 ** Constructors:
                       seq T == the type of sequences of items of type T.
                      bitseq == seq bool.
            [::], nil, Nil T == the empty sequence (of type T).
x :: s, cons x s, Cons T x s == the sequence x followed by s (of type T).
                      [:: x] == the singleton sequence.
          [:: x_0; ...; x_n] == the explicit sequence of the x_i.
      [:: x_0, ..., x_n &amp; s] == the sequence of the x_i, followed by s.
                   rcons s x == the sequence s, followed by x.
 All of the above, except rcons, can be used in patterns. We define a view
lastP and an induction principle last_ind that can be used to decompose
or traverse a sequence in a right to left order. The view lemma lastP has
a dependent family type, so the ssreflect tactic case/lastP: p =&gt; [|p' x]
will generate two subgoals in which p has been replaced by [::] and by
rcons p' x, respectively.
 ** Factories:
            nseq n x == a sequence of n x's.
         ncons n x s == a sequence of n x's, followed by s.
seqn n x_0 ... x_n-1 == the sequence of the x_i; can be partially applied.
            iota m n == the sequence m, m + 1, ..., m + n - 1.
           mkseq f n == the sequence f 0, f 1, ..., f (n - 1).
 ** Sequential access:
     head x0 s == the head (zero'th item) of s if s is non-empty, else x0.
       ohead s == None if s is empty, else Some x when the head of s is x.
      behead s == s minus its head, i.e., s' if s = x :: s', else [::].
      last x s == the last element of x :: s (which is non-empty).
    belast x s == x :: s minus its last item.
 ** Dimensions:
        size s == the number of items (length) in s.
      shape ss == the sequence of sizes of the items of the sequence of
                  sequences ss.
 ** Random access:
        nth x0 s i == the item i of s (numbered from 0), or x0 if s does
                      not have at least i+1 items (i.e., size x &lt;= i)
              s`_i == standard notation for nth x0 s i for a default x0,
                      e.g., 0 for rings.
          onth s i == Some x if x is the i^th idem of s (numbered from 0),
                      or None if size s &lt;= i)
  set_nth x0 s i y == s where item i has been changed to y; if s does not
                      have an item i, it is first padded with copies of x0
                      to size i+1.
      incr_nth s i == the nat sequence s with item i incremented (s is
                      first padded with 0's to size i+1, if needed).
 ** Predicates:
         nilp s &lt;=&gt; s is [::].
                := (size s == 0).
        x \in s == x appears in s (this requires an eqType for T).
      index x s == the first index at which x appears in s, or size s if
                   x \notin s.
        has a s &lt;=&gt; a holds for some item in s, where a is an applicative
                    bool predicate.
        all a s &lt;=&gt; a holds for all items in s.
        'has_aP &lt;-&gt; the view reflect (exists2 x, x \in s &amp; A x) (has a s),
                    where aP x : reflect (A x) (a x).
        'all_aP &lt;=&gt; the view for reflect {in s, forall x, A x} (all a s).
     all2 r s t &lt;=&gt; the (bool) relation r holds for all _respective_ items
                   in s and t, which must also have the same size, i.e.,
                   for s := [:: x1; ...; x_m] and t := [:: y1; ...; y_n],
                   the condition [&amp;&amp; r x_1 y_1, ..., r x_n y_n &amp; m == n].
       find p s == the index of the first item in s for which p holds,
                   or size s if no such item is found.
      count p s == the number of items of s for which p holds.
  count_mem x s == the multiplicity of x in s, i.e., count (pred1 x) s.
        tally s == a tally of s, i.e., a sequence of (item, multiplicity)
                   pairs for all items in sequence s (without duplicates).
incr_tally bs x == increment the multiplicity of x in the tally bs, or add
                   x with multiplicity 1 at then end if x is not in bs.
bs \is a wf_tally &lt;=&gt; bs is well-formed tally, with no duplicate items or
                   null multiplicities.
   tally_seq bs == the expansion of a tally bs into a sequence where each
                   (x, n) pair expands into a sequence of n x's.
     constant s &lt;=&gt; all items in s are identical (trivial if s = [::]).
         uniq s &lt;=&gt; all the items in s are pairwise different.
   subseq s1 s2 &lt;=&gt; s1 is a subsequence of s2, i.e., s1 = mask m s2 for
                   some m : bitseq (see below).
    infix s1 s2 &lt;=&gt; s1 is a contiguous subsequence of s2, i.e.,
                      s ++ s1 ++ s' = s2 for some sequences s, s'.
   prefix s1 s2 &lt;=&gt; s1 is a subchain of s2 appearing at the beginning
                      of s2.
   suffix s1 s2 &lt;=&gt; s1 is a subchain of s2 appearing at the end of s2.
infix_index s1 s2 &lt;=&gt; the first index at which s1 appears in s2,
                      or (size s2).+1 if infix s1 s2 is false.
  perm_eq s1 s2 &lt;=&gt; s2 is a permutation of s1, i.e., s1 and s2 have the
                   items (with the same repetitions), but possibly in a
                   different order.
 perm_eql s1 s2 &lt;-&gt; s1 and s2 behave identically on the left of perm_eq.
 perm_eqr s1 s2 &lt;-&gt; s1 and s2 behave identically on the right of perm_eq.
--&gt; These left/right transitive versions of perm_eq make it easier to
 chain a sequence of equivalences.
  permutations s == a duplicate-free list of all permutations of s.
 ** Filtering:
          filter p s == the subsequence of s consisting of all the items
                        for which the (boolean) predicate p holds.
             rem x s == the subsequence of s, where the first occurrence
                        of x has been removed (compare filter (predC1 x) s
                        where ALL occurrences of x are removed).
             undup s == the subsequence of s containing only the first
                        occurrence of each item in s, i.e., s with all
                        duplicates removed.
            mask m s == the subsequence of s selected by m : bitseq, with
                        item i of s selected by bit i in m (extra items or
                        bits are ignored.
 ** Surgery:
s1 ++ s2, cat s1 s2 == the concatenation of s1 and s2.
           take n s == the sequence containing only the first n items of s
                       (or all of s if size s &lt;= n).
           drop n s == s minus its first n items ([::] if size s &lt;= n)
            rot n s == s rotated left n times (or s if size s &lt;= n).
                    := drop n s ++ take n s
           rotr n s == s rotated right n times (or s if size s &lt;= n).
              rev s == the (linear time) reversal of s.
       catrev s1 s2 == the reversal of s1 followed by s2 (this is the
                       recursive form of rev).
 ** Dependent iterator: for s : seq S and t : S -&gt; seq T
[seq E | x &lt;- s, y &lt;- t] := flatten [seq [seq E | x &lt;- t] | y &lt;- s]
               == the sequence of all the f x y, with x and y drawn from
                  s and t, respectively, in row-major order,
                  and where t is possibly dependent in elements of s
allpairs_dep f s t := self expanding definition for
                      [seq f x y | x &lt;- s, y &lt;- t y]
 ** Iterators: for s == [:: x_1, ..., x_n], t == [:: y_1, ..., y_m],
allpairs f s t := same as allpairs_dep but where t is non dependent,
                   i.e. self expanding definition for
                     [seq f x y | x &lt;- s, y &lt;- t]
              := [:: f x_1 y_1; ...; f x_1 y_m; f x_2 y_1; ...; f x_n y_m]
allrel r xs ys := all [pred x | all (r x) ys] xs
               &lt;=&gt; r x y holds whenever x is in xs and y is in ys
  all2rel r xs := allrel r xs xs
               &lt;=&gt; the proposition r x y holds for all possible x, y in xs.
 pairwise r xs &lt;=&gt; the relation r holds for any i-th and j-th element of
                   xs such that i &lt; j.
       map f s == the sequence [:: f x_1, ..., f x_n].
     pmap pf s == the sequence [:: y_i1, ..., y_ik] where i1 &lt; ... &lt; ik,
                  pf x_i = Some y_i, and pf x_j = None iff j is not in
                  {i1, ..., ik}.
  foldr f a s == the right fold of s by f (i.e., the natural iterator).
              := f x_1 (f x_2 ... (f x_n a))
       sumn s == x_1 + (x_2 + ... + (x_n + 0)) (when s : seq nat).
  foldl f a s == the left fold of s by f.
              := f (f ... (f a x_1) ... x_n-1) x_n
  scanl f a s == the sequence of partial accumulators of foldl f a s.
              := [:: f a x_1; ...; foldl f a s]
pairmap f a s == the sequence of f applied to consecutive items in a :: s.
              := [:: f a x_1; f x_1 x_2; ...; f x_n-1 x_n]
      zip s t == itemwise pairing of s and t (dropping any extra items).
              := [:: (x_1, y_1); ...; (x_mn, y_mn)] with mn = minn n m.
     unzip1 s == [:: (x_1).1; ...; (x_n).1] when s : seq (S * T).
     unzip2 s == [:: (x_1).2; ...; (x_n).2] when s : seq (S * T).
    flatten s == x_1 ++ ... ++ x_n ++ [::] when s : seq (seq T).
  reshape r s == s reshaped into a sequence of sequences whose sizes are
                 given by r (truncating if s is too long or too short).
              := [:: [:: x_1; ...; x_r1];
                     [:: x_(r1 + 1); ...; x_(r0 + r1)];
                     ...;
                     [:: x_(r1 + ... + r(k-1) + 1); ...; x_(r0 + ... rk)]]
flatten_index sh r c == the index, in flatten ss, of the item of indexes
                 (r, c) in any sequence of sequences ss of shape sh
              := sh_1 + sh_2 + ... + sh_r + c
reshape_index sh i == the index, in reshape sh s, of the sequence
                 containing the i-th item of s.
reshape_offset sh i == the offset, in the (reshape_index sh i)-th
                 sequence of reshape sh s of the i-th item of s
 ** Notation for manifest comprehensions:
        [seq x &lt;- s | C] := filter (fun x =&gt; C) s.
        [seq E | x &lt;- s] := map (fun x =&gt; E) s.
  [seq x &lt;- s | C1 &amp; C2] := [seq x &lt;- s | C1 &amp;&amp; C2].
    [seq E | x &lt;- s &amp; C] := [seq E | x &lt;- [seq x | C]].
 --&gt; The above allow optional type casts on the eigenvariables, as in
 [seq x : T &lt;- s | C] or [seq E | x : T &lt;- s, y : U &lt;- t]. The cast may be
 needed as type inference considers E or C before s.
  We are quite systematic in providing lemmas to rewrite any composition
of two operations. "rev", whose simplifications are not natural, is
protected with simpl never.
 ** The following are equivalent:
 [&lt;-&gt; P0; P1; ..; Pn] &lt;-&gt; P0, P1, ..., Pn are all equivalent.
                      := P0 -&gt; P1 -&gt; ... -&gt; Pn -&gt; P0
 if T : [&lt;-&gt; P0; P1; ..; Pn]  is such an equivalence, and i, j are in nat
 then T i j is a proof of the equivalence Pi &lt;-&gt; Pj between Pi and Pj;
 when i (resp. j) is out of bounds, Pi (resp. Pj) defaults to P0.
 The tactic tfae splits the goal into n+1 implications to prove.
 An example of use can be found in fingraph theorem orbitPcycle.
</pre>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Declare</span><span class="vernacular"> Scope</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;[ '&lt;-&gt;' P0 ; P1 ; .. ; Pn ]&quot;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ '&lt;-&gt;' '['  P0 ;  '/' P1 ;  '/'  .. ;  '/'  Pn ']' ]&quot;</span>).<br/>
<br/>
<span class="vernacular">Delimit</span><span class="vernacular"> Scope</span><span class="id"> seq_scope</span><span class="gallina-kwd"> with</span><span class="id"> SEQ</span>.<br/>
<span class="vernacular">Open</span><span class="vernacular"> Scope</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> seq</span><span class="id"> :=</span><span class="id"> list</span>.<br/>
<span class="vernacular">Bind</span><span class="vernacular"> Scope</span><span class="id"> seq_scope</span><span class="gallina-kwd"> with</span><span class="id"> list</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> cons</span><span class="id"> {T%_type}</span><span class="id"> x</span><span class="id"> s%_SEQ</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> nil</span><span class="id"> {T%_type}</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Notation</span><span class="id"> Cons</span><span class="id"> T</span><span class="id"> :=</span> (<span class="id">@cons</span><span class="id"> T</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> Nil</span><span class="id"> T</span><span class="id"> :=</span> (<span class="id">@nil</span><span class="id"> T</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Infix</span> <span class="id">&quot;::&quot;</span><span class="id"> :=</span><span class="id"> cons</span><span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ :: ]&quot;</span><span class="id"> :=</span><span class="id"> nil</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ :: ]&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ :: x1 ]&quot;</span><span class="id"> :=</span> (<span class="id">x1</span><span class="id"> ::</span><span class="id"> [::]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ ::  x1 ]&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ :: x &amp; s ]&quot;</span><span class="id"> :=</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>) (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ :: x1 , x2 , .. , xn &amp; s ]&quot;</span><span class="id"> :=</span> (<span class="id">x1</span><span class="id"> ::</span><span class="id"> x2</span><span class="id"> ::</span> .. (<span class="id">xn</span><span class="id"> ::</span><span class="id"> s</span>) ..)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span><br/>
&nbsp;&nbsp;<span class="id">&quot;'[hv' [ :: '['  x1 , '/'  x2 , '/'  .. , '/'  xn ']' '/ '  &amp;  s ] ']'&quot;</span><br/>
&nbsp;&nbsp;)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ :: x1 ; x2 ; .. ; xn ]&quot;</span><span class="id"> :=</span> (<span class="id">x1</span><span class="id"> ::</span><span class="id"> x2</span><span class="id"> ::</span> .. <span class="id">[::</span><span class="id"> xn]</span> ..)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> format</span> <span class="id">&quot;[ :: '['  x1 ; '/'  x2 ; '/'  .. ; '/'  xn ']' ]&quot;</span><br/>
&nbsp;&nbsp;)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Sequences</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> n0</span><span class="id"> :</span><span class="id"> nat</span>.  <br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.  <br/>
<span class="vernacular">Variable</span><span class="id"> x0</span><span class="id"> :</span><span class="id"> T</span>.    <br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> size</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> _</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span> (<span class="id">size</span><span class="id"> s'</span>).<span class="id">+1</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size0nil</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> nilp</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nilP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">s</span><span class="id"> =</span><span class="id"> [::]</span>) (<span class="id">nilp</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s];</span><span class="id"> constructor</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> ohead</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> _</span><span class="gallina-kwd"> then</span><span class="id"> Some</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> None</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> head</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> _</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> behead</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> _</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_behead</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">behead</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span>).<span class="id">-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> iter</span><span class="id"> n</span> (<span class="id">cons</span><span class="id"> x</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> n</span><span class="id"> +</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_ncons</span><span class="id"> addn0</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> seqn_type</span><span class="id"> n</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> seqn_type</span><span class="id"> n'</span><span class="gallina-kwd"> else</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> seqn_rec</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :</span><span class="id"> seqn_type</span><span class="id"> n</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> return</span><span class="id"> seqn_type</span><span class="id"> n</span><span class="gallina-kwd"> then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> seqn_rec</span> (<span class="gallina-kwd">fun</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> f</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>))<span class="id"> n'</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> f</span><span class="id"> [::]</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> seqn</span><span class="id"> :=</span><span class="id"> seqn_rec</span><span class="id"> id</span>.<br/>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s1</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1'</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1'</span><span class="id"> ++</span><span class="id"> s2</span><span class="gallina-kwd"> else</span><span class="id"> s2</span><br/>
<span class="gallina-kwd">where</span> <span class="id">&quot;s1 ++ s2&quot;</span><span class="id"> :=</span> (<span class="id">cat</span><span class="id"> s1</span><span class="id"> s2</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> [::]</span><span class="id"> ++</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> cat1s</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> s</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> cat_cons</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>)<span class="id"> ++</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> s</span><span class="id"> =</span><span class="id"> ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nseqD</span><span class="id"> n1</span><span class="id"> n2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nseq</span> (<span class="id">n1</span><span class="id"> +</span><span class="id"> n2</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> nseq</span><span class="id"> n1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> nseq</span><span class="id"> n2</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cat_nseq</span><span class="id"> /nseq</span><span class="id"> /ncons</span><span class="id"> iterD</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cats0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> [::]</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span><span class="id"> =</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> ++</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_nilp</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> nilp</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> nilp</span><span class="id"> s1</span><span class="id"> &amp;&amp;</span><span class="id"> nilp</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s1</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> z</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> rcons</span><span class="id"> s'</span><span class="id"> z</span><span class="gallina-kwd"> else</span><span class="id"> [::</span><span class="id"> z]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> z</span><span class="id"> :</span><span class="id"> rcons</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> z</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cats1</span><span class="id"> s</span><span class="id"> z</span><span class="id"> :</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> [::</span><span class="id"> z]</span><span class="id"> =</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x'</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> last</span><span class="id"> x'</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> x</span>.<br/>
<span class="vernacular">Fixpoint</span><span class="id"> belast</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x'</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span> (<span class="id">belast</span><span class="id"> x'</span><span class="id"> s'</span>)<span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lastI</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span><span class="id"> =</span><span class="id"> rcons</span> (<span class="id">belast</span><span class="id"> x</span><span class="id"> s</span>) (<span class="id">last</span><span class="id"> x</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> x</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_cons</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> :</span><span class="id"> last</span><span class="id"> x</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> last</span><span class="id"> y</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span>).<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> size_cat</span><span class="id"> addnC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_belast</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">belast</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> x</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> last</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> last</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> x</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_rcons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> z</span><span class="id"> :</span><span class="id"> last</span><span class="id"> x</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> z</span>)<span class="id"> =</span><span class="id"> z</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> last_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> belast_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">belast</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> belast</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> belast</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> x</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> belast_rcons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> z</span><span class="id"> :</span><span class="id"> belast</span><span class="id"> x</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> z</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lastI</span><span class="id"> -!cats1</span><span class="id"> belast_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_rcons</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> rcons</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> -catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> rcons</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> x</span><span class="id"> =</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> rcons</span><span class="id"> s2</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Variant</span><span class="id"> last_spec</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> LastNil</span>       <span class="id"> :</span><span class="id"> last_spec</span><span class="id"> [::]</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> LastRcons</span><span class="id"> s</span><span class="id"> x</span> <span class="id"> :</span><span class="id"> last_spec</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> lastP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> last_spec</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s];</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> lastI;</span><span class="id"> right]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_ind</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">P</span><span class="id"> [::]</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> s</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> s,</span><span class="id"> P</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Hnil</span><span class="id"> Hlast</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">cat0s</span><span class="id"> s</span>).<br/>
<span class="id">elim:</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> Hnil</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2</span><span class="id"> IHs]</span><span class="id"> s1</span><span class="id"> Hs1;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cats0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -cat_rcons;</span><span class="id"> apply/IHs/Hlast</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> {struct</span><span class="id"> n}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> @nth</span><span class="id"> s'</span><span class="id"> n'</span><span class="gallina-kwd"> else</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> set_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> y</span><span class="id"> {struct</span><span class="id"> n}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> @set_nth</span><span class="id"> s'</span><span class="id"> n'</span><span class="id"> y</span><span class="gallina-kwd"> else</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s'</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> ncons</span><span class="id"> n</span><span class="id"> x0</span><span class="id"> [::</span><span class="id"> y]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> 0</span><span class="id"> =</span><span class="id"> head</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_default</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span><span class="id"> x0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> if_nth</span><span class="id"> s</span><span class="id"> b</span><span class="id"> n</span><span class="id"> :</span><span class="id"> b</span><span class="id"> ||</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>)<span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> leqP;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> nth_default</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_nil</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> [::]</span><span class="id"> n</span><span class="id"> =</span><span class="id"> x0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_seq1</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> n</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> ==</span><span class="id"> 0</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|[]]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_nth</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span><span class="id"> nth</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>) (<span class="id">size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> x</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_last</span><span class="id"> s</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> s</span> (<span class="id">size</span><span class="id"> s</span>).<span class="id">-1</span><span class="id"> =</span><span class="id"> last</span><span class="id"> x0</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> last_nth</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_behead</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nth</span> (<span class="id">behead</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s]</span><span class="id"> [|n]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nth</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> n</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> nth</span><span class="id"> s1</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> nth</span><span class="id"> s2</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nth</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> n</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> ==</span><span class="id"> size</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> nth_nil</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_rcons_default</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nth</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x0</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_rcons;</span><span class="id"> case:</span><span class="id"> ltngtP</span><span class="id"> =&gt;</span><span class="id"> //[/ltnW</span><span class="id"> ?|-&gt;];</span><span class="id"> rewrite</span><span class="id"> nth_default</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_ncons</span><span class="id"> m</span><span class="id"> x</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nth</span> (<span class="id">ncons</span><span class="id"> m</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> m</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> nth</span><span class="id"> s</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> m</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|m</span><span class="id"> IHm]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_nseq</span><span class="id"> m</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nth</span> (<span class="id">nseq</span><span class="id"> m</span><span class="id"> x</span>)<span class="id"> n</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> m</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> x0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|m</span><span class="id"> IHm]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_from_nth</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> s1</span><span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s2</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [|x1</span><span class="id"> s1</span><span class="id"> IHs1]</span><span class="id"> [|x2</span><span class="id"> s2]</span><span class="id"> //=</span><span class="id"> [eq_sz]</span><span class="id"> eq_s12</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [x1]</span>(<span class="id">eq_s12</span><span class="id"> 0</span>)<span class="id"> //</span> (<span class="id">IHs1</span><span class="id"> s2</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> i;</span><span class="id"> apply:</span> (<span class="id">eq_s12</span><span class="id"> i</span>.<span class="id">+1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_set_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> y</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">set_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> maxn</span><span class="id"> n</span>.<span class="id">+1</span> (<span class="id">size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> maxnC;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_ncons</span><span class="id"> addn1</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> IHs</span><span class="id"> maxnSS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_nth_nil</span><span class="id"> n</span><span class="id"> y</span><span class="id"> :</span><span class="id"> set_nth</span><span class="id"> [::]</span><span class="id"> n</span><span class="id"> y</span><span class="id"> =</span><span class="id"> ncons</span><span class="id"> n</span><span class="id"> x0</span><span class="id"> [::</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_set_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> y</span><span class="id"> :</span><span class="id"> nth</span> (<span class="id">set_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> y</span>)<span class="id"> =1</span><span class="id"> [eta</span><span class="id"> nth</span><span class="id"> s</span><span class="gallina-kwd"> with</span><span class="id"> n</span><span class="id"> |-&gt;</span><span class="id"> y]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> [|m]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?nth_nil</span><span class="id"> ?IHs</span><span class="id"> //</span><span class="id"> nth_ncons</span><span class="id"> eqSS</span>.<br/>
<span class="id">case:</span><span class="id"> ltngtP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [lt_nm</span><span class="id"> |</span><span class="id"> -&gt;];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subnn</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_default</span><span class="id"> //</span><span class="id"> subn_gt0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_set_nth</span><span class="id"> s</span><span class="id"> n1</span><span class="id"> y1</span><span class="id"> n2</span><span class="id"> y2</span> (<span class="id">s2</span><span class="id"> :=</span><span class="id"> set_nth</span><span class="id"> s</span><span class="id"> n2</span><span class="id"> y2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">set_nth</span> (<span class="id">set_nth</span><span class="id"> s</span><span class="id"> n1</span><span class="id"> y1</span>)<span class="id"> n2</span><span class="id"> y2</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n1</span><span class="id"> ==</span><span class="id"> n2</span><span class="gallina-kwd"> then</span><span class="id"> s2</span><span class="gallina-kwd"> else</span><span class="id"> set_nth</span><span class="id"> s2</span><span class="id"> n1</span><span class="id"> y1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> ne_n12]</span><span class="id"> :=</span><span class="id"> eqVneq</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_from_nth</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !size_set_nth</span><span class="id"> maxnA</span><span class="id"> maxnn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> 2!rewrite</span><span class="id"> !nth_set_nth</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> eqP</span>.<br/>
<span class="id">apply:</span><span class="id"> eq_from_nth</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !size_set_nth</span><span class="id"> maxnCA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> 2!rewrite</span><span class="id"> !nth_set_nth</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> case:</span><span class="id"> eqVneq</span><span class="id"> ne_n12</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SeqFind</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> find</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> a</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> 0</span><span class="gallina-kwd"> else</span> (<span class="id">find</span><span class="id"> s'</span>).<span class="id">+1</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> filter</span><span class="id"> s</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> a</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> filter</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> filter</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> count</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> a</span><span class="id"> x</span><span class="id"> +</span><span class="id"> count</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> has</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> a</span><span class="id"> x</span><span class="id"> ||</span><span class="id"> has</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> false</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> all</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> a</span><span class="id"> x</span><span class="id"> &amp;&amp;</span><span class="id"> all</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> true</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_filter</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">filter</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;-;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_count</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> count</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_size</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> apply:</span><span class="id"> leqW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_count</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">count</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> add0n</span><span class="id"> eqn_leq</span><span class="id"> andbC</span><span class="id"> ltnNge</span><span class="id"> count_size</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_all</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">filter</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_filterP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">filter</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>) (<span class="id">all</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|</span><span class="id"> &lt;-];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> filter_all</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[-&gt;</span><span class="id"> Hs];</span><span class="id"> rewrite</span><span class="id"> IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_id</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span> (<span class="id">filter</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> filter</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/all_filterP;</span><span class="id"> apply:</span><span class="id"> filter_all</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_find</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">find</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?leqnn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_size</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">find</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> has</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> find</span><span class="id"> s1</span><span class="gallina-kwd"> else</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> find</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> IHs;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> IHs</span> (<span class="id">fun_if</span><span class="id"> succn</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_nil</span><span class="id"> :</span><span class="id"> has</span><span class="id"> [::]</span><span class="id"> =</span><span class="id"> false</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_seq1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> has</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> orbF</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> &amp;&amp;</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> andKb</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_seqb</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> x</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">nseq</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> b</span><span class="id"> &amp;&amp;</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_nseq</span><span class="id"> lt0b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_nil</span><span class="id"> :</span><span class="id"> all</span><span class="id"> [::]</span><span class="id"> =</span><span class="id"> true</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_seq1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> all</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">n</span><span class="id"> ==</span><span class="id"> 0</span>)<span class="id"> ||</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> orKb</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_nseqb</span> (<span class="id">b</span><span class="id"> :</span><span class="id"> bool</span>)<span class="id"> x</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">nseq</span><span class="id"> b</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> b</span><span class="id"> ==&gt;</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> all_nseq</span><span class="id"> eqb0</span><span class="id"> implybE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> filter</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> nseq</span> (<span class="id">a</span><span class="id"> x</span><span class="id"> *</span><span class="id"> n</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|n</span><span class="id"> -&gt;];</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> count</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> x</span><span class="id"> *</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_filter</span><span class="id"> filter_nseq</span><span class="id"> size_nseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> find</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> ~~</span><span class="id"> a</span><span class="id"> x</span><span class="id"> *</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|n</span><span class="id"> -&gt;];</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_find</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> s</span> (<span class="id">find</span><span class="id"> s</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case</span><span class="id"> a_x:</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> before_find</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> find</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> s</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> a'x</span><span class="id"> [|i]</span><span class="id"> //</span><span class="id"> /</span>(<span class="id">IHs</span><span class="id"> i</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasNfind</span><span class="id"> s</span><span class="id"> :</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> find</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_find;</span><span class="id"> case:</span><span class="id"> ltngtP</span> (<span class="id">find_size</span><span class="id"> s</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> filter</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> filter</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> filter</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">filter</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> a</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> rcons</span> (<span class="id">filter</span><span class="id"> s</span>)<span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> filter</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> filter_cat</span><span class="id"> /=;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?cats0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> count</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> count</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> filter_cat</span><span class="id"> size_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> has</span><span class="id"> s1</span><span class="id"> ||</span><span class="id"> has</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span><span class="id"> orbA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> x</span><span class="id"> ||</span><span class="id"> has</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> has_cat</span><span class="id"> has_seq1</span><span class="id"> orbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> s1</span><span class="id"> &amp;&amp;</span><span class="id"> all</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span><span class="id"> andbA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> x</span><span class="id"> &amp;&amp;</span><span class="id"> all</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> all_cat</span><span class="id"> all_seq1</span><span class="id"> andbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SeqFind</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_pred0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find</span><span class="id"> pred0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_predT</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find</span><span class="id"> predT</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_find</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2</span><span class="id"> -&gt;</span><span class="id"> find</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> find</span><span class="id"> a2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ea;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> Ea</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_filter</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2</span><span class="id"> -&gt;</span><span class="id"> filter</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> filter</span><span class="id"> a2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ea;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> Ea</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_count</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2</span><span class="id"> -&gt;</span><span class="id"> count</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> count</span><span class="id"> a2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ea</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span> (<span class="id">eq_filter</span><span class="id"> Ea</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_has</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2</span><span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> has</span><span class="id"> a2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ea</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> !has_count</span> (<span class="id">eq_count</span><span class="id"> Ea</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_all</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> all</span><span class="id"> a2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ea</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> !all_count</span> (<span class="id">eq_count</span><span class="id"> Ea</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_filter</span> (<span class="id">p</span><span class="id"> q</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> xs</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all</span><span class="id"> p</span> (<span class="id">filter</span><span class="id"> q</span><span class="id"> xs</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> [pred</span><span class="id"> i</span><span class="id"> |</span><span class="id"> q</span><span class="id"> i</span><span class="id"> ==&gt;</span><span class="id"> p</span><span class="id"> i]</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> &lt;-;</span><span class="id"> case:</span> (<span class="id">q</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> SubPred</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> s12</span><span class="id"> :</span><span class="id"> subpred</span><span class="id"> a1</span><span class="id"> a2</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_find</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> find</span><span class="id"> a1</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /</span>(<span class="id">contraFF</span> (<span class="id">@s12</span><span class="id"> x</span>))<span class="id">-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_has</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !has_find;</span><span class="id"> apply:</span><span class="id"> leq_ltn_trans</span> (<span class="id">sub_find</span><span class="id"> s</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_count</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> count</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> apply:</span><span class="id"> leq_add;</span><span class="id"> case</span><span class="id"> a1x:</span> (<span class="id">a1</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> s12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_all</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !all_count</span><span class="id"> !eqn_leq</span><span class="id"> !count_size</span><span class="id"> =&gt;</span><span class="id"> /leq_trans-&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> sub_count</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> SubPred</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_pred0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span><span class="id"> pred0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_predT</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span><span class="id"> predT</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_predI</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span> (<span class="id">predI</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> filter</span><span class="id"> a1</span> (<span class="id">filter</span><span class="id"> a2</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> andbC;</span><span class="id"> case:</span> (<span class="id">a2</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_pred0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> pred0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_filter</span><span class="id"> filter_pred0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_predT</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> predT</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_filter</span><span class="id"> filter_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_predUI</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">count</span> (<span class="id">predU</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span><span class="id"> +</span><span class="id"> count</span> (<span class="id">predI</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> count</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> +</span><span class="id"> count</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> addnACA</span><span class="id"> [RHS]addnACA</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">a1</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> addn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_predC</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span><span class="id"> +</span><span class="id"> count</span> (<span class="id">predC</span><span class="id"> a</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> addnACA</span><span class="id"> IHs;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_filter</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> a1</span> (<span class="id">filter</span><span class="id"> a2</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span> (<span class="id">predI</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> filter_predI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_pred0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> pred0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_count</span><span class="id"> count_pred0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_predT</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> predT</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_count</span><span class="id"> count_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_predC</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">predC</span><span class="id"> a</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> ~~</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_predU</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">predU</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> has</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> ||</span><span class="id"> has</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -!orbA;</span><span class="id"> do</span><span class="id"> !bool_congr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_pred0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> pred0</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> all_count</span><span class="id"> count_pred0</span><span class="id"> eq_sym</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_predT</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> predT</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> all_count</span><span class="id"> count_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allT</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> s</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> a</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/eq_all-&gt;;</span><span class="id"> apply/all_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_predC</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">predC</span><span class="id"> a</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_predI</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">predI</span><span class="id"> a1</span><span class="id"> a2</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> all</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> &amp;&amp;</span><span class="id"> all</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">can_inj</span><span class="id"> negbK</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> negb_and</span><span class="id"> -!has_predC</span><span class="id"> -has_predU</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> eq_has</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> negb_and</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="id"> {struct</span><span class="id"> s}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> s,</span><span class="id"> n</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _</span><span class="id"> ::</span><span class="id"> s',</span><span class="id"> n'</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> drop</span><span class="id"> n'</span><span class="id"> s'</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> s</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_behead</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> n0</span><span class="id"> =1</span><span class="id"> iter</span><span class="id"> n0</span><span class="id"> behead</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> [|x</span><span class="id"> s]</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> iterSr</span><span class="id"> -IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> 0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop1</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> 1</span><span class="id"> =1</span><span class="id"> behead</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> [|x</span><span class="id"> [|y</span><span class="id"> s]]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_oversize</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_size</span><span class="id"> s</span><span class="id"> :</span><span class="id"> drop</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> drop_oversize</span><span class="id"> //</span><span class="id"> leqnn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">drop</span><span class="id"> n0</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n0</span><span class="id"> is</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="gallina-kwd"> else</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_drop</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">drop</span><span class="id"> n0</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> drop</span><span class="id"> n0</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="gallina-kwd"> else</span><span class="id"> drop</span> (<span class="id">n0</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_size_cat</span><span class="id"> n</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> drop</span><span class="id"> n</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move</span><span class="id"> &lt;-;</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> drop0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nconsK</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> cancel</span> (<span class="id">ncons</span><span class="id"> n</span><span class="id"> x</span>) (<span class="id">drop</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_drop</span><span class="id"> s</span><span class="id"> n1</span><span class="id"> n2</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> n1</span> (<span class="id">drop</span><span class="id"> n2</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> drop</span> (<span class="id">n1</span><span class="id"> +</span><span class="id"> n2</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n2</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> ihs</span><span class="id"> [|n2];</span><span class="id"> rewrite</span><span class="id"> ?drop0</span><span class="id"> ?addn0</span><span class="id"> ?addnS</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> take</span><span class="id"> n</span><span class="id"> s</span><span class="id"> {struct</span><span class="id"> s}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> s,</span><span class="id"> n</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s',</span><span class="id"> n'</span>.<span class="id">+1</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> take</span><span class="id"> n'</span><span class="id"> s'</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> [::]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> 0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_oversize</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span><span class="id"> /IHs-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_size</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> take_oversize</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">take</span><span class="id"> n0</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n0</span><span class="id"> is</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> s</span>)<span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_rcons</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n0</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> drop</span><span class="id"> n0</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> rcons</span> (<span class="id">drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_take_drop</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> drop</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_takel</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n0</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> n0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move/subKn;</span><span class="id"> rewrite</span><span class="id"> -size_drop</span><span class="id"> -[in</span><span class="id"> size</span><span class="id"> s]</span>(<span class="id">cat_take_drop</span><span class="id"> s</span>)<span class="id"> size_cat</span><span class="id"> addnK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_take</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> n0</span><span class="gallina-kwd"> else</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [le_sn</span><span class="id"> |</span><span class="id"> lt_ns]</span><span class="id"> :=</span><span class="id"> leqP</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> n0;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> take_oversize</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_takel</span><span class="id"> //</span><span class="id"> ltnW</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_take_min</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> minn</span><span class="id"> n0</span> (<span class="id">size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> size_take</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">take</span><span class="id"> n0</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> take</span><span class="id"> n0</span><span class="id"> s1</span><span class="gallina-kwd"> else</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> take</span> (<span class="id">n0</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> subSS</span><span class="id"> -</span>(<span class="id">fun_if</span> (<span class="id">cons</span><span class="id"> x</span>))<span class="id"> -IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_size_cat</span><span class="id"> n</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> n</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move</span><span class="id"> &lt;-;</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs];</span><span class="id"> rewrite</span><span class="id"> ?take0</span><span class="id"> //=</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> takel_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> n0</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> n0</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> take</span><span class="id"> n0</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> take_cat;</span><span class="id"> case:</span><span class="id"> ltngtP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> subnn</span><span class="id"> take0</span><span class="id"> take_size</span><span class="id"> cats0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_drop</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nth</span> (<span class="id">drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span> (<span class="id">n0</span><span class="id"> +</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> RHS]cat_take_drop</span><span class="id"> nth_cat</span><span class="id"> size_take</span><span class="id"> ltnNge</span>.<br/>
<span class="id">case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [?|le_s_n0];</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">leq_trans</span><span class="id"> le_s_n0</span>)<span class="id"> ?leq_addr</span><span class="id"> ?addKn</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> drop_oversize</span><span class="id"> //</span><span class="id"> !nth_default</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_ltn</span><span class="id"> p</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> has</span><span class="id"> p</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> -&gt;</span><span class="id"> find</span><span class="id"> p</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> ihs]</span><span class="id"> [|i]//=;</span><span class="id"> case:</span> (<span class="id">p</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> /ihs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_take</span><span class="id"> p</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> has</span><span class="id"> p</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> p</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">find</span><span class="id"> p</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> ihs]</span><span class="id"> [|i]//=;</span><span class="id"> case:</span> (<span class="id">p</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> /ihs</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_take_leq</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">has</span><span class="id"> p</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">find</span><span class="id"> p</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> ihs]</span><span class="id"> [|i]//=;</span><span class="id"> case:</span> (<span class="id">p</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> /ihs</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_take</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n0</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> s,</span><span class="id"> nth</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lt_i_n0</span><span class="id"> s;</span><span class="id"> case</span><span class="id"> lt_n0_s:</span> (<span class="id">n0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> RHS]cat_take_drop</span><span class="id"> nth_cat</span><span class="id"> size_take</span><span class="id"> lt_n0_s</span><span class="id"> /=</span><span class="id"> lt_i_n0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> LHS]cats0</span><span class="id"> take_cat</span><span class="id"> lt_n0_s</span><span class="id"> /=</span><span class="id"> cats0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_min</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span> (<span class="id">minn</span><span class="id"> i</span><span class="id"> j</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">take</span><span class="id"> j</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> a</span><span class="id"> l</span><span class="id"> IH</span><span class="id"> [|i]</span><span class="id"> [|j]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> minnSS</span><span class="id"> IH</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_takel</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">take</span><span class="id"> j</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> -take_min</span> (<span class="id">minn_idPl</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_taker</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> j</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">take</span><span class="id"> j</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> take</span><span class="id"> j</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> -take_min</span> (<span class="id">minn_idPr</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_drop</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">drop</span><span class="id"> j</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> drop</span><span class="id"> j</span> (<span class="id">take</span> (<span class="id">i</span><span class="id"> +</span><span class="id"> j</span>)<span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addnC;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> [|i]</span><span class="id"> [|j]</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> takeD</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span> (<span class="id">i</span><span class="id"> +</span><span class="id"> j</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> take</span><span class="id"> j</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> IHi]</span><span class="id"> [|j]</span><span class="id"> [|a</span><span class="id"> s]</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> take0</span><span class="id"> addn0</span><span class="id"> cats0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addSn</span><span class="id"> /=</span><span class="id"> IHi</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> takeC</span><span class="id"> i</span><span class="id"> j</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">take</span><span class="id"> j</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> take</span><span class="id"> j</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!take_min</span><span class="id"> minnC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_nseq</span><span class="id"> i</span><span class="id"> j</span><span class="id"> x</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> i</span> (<span class="id">nseq</span><span class="id"> j</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> nseq</span><span class="id"> i</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;/subnKC</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> nseqD</span><span class="id"> take_size_cat</span><span class="id"> //</span><span class="id"> size_nseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_nseq</span><span class="id"> i</span><span class="id"> j</span><span class="id"> x</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> i</span> (<span class="id">nseq</span><span class="id"> j</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> nseq</span> (<span class="id">j</span><span class="id"> -</span><span class="id"> i</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span> (<span class="id">leqP</span><span class="id"> i</span><span class="id"> j</span>)<span class="id"> =&gt;</span><span class="id"> [/subnKC</span><span class="id"> {1}&lt;-|/ltnW</span><span class="id"> j_le_i]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nseqD</span><span class="id"> drop_size_cat</span><span class="id"> //</span><span class="id"> size_nseq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> drop_oversize</span><span class="id"> ?size_nseq</span><span class="id"> //</span> (<span class="id">eqP</span><span class="id"> j_le_i</span>).<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_nth</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> ::</span><span class="id"> drop</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> Hn</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?drop0</span><span class="id"> 1?IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_nth</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> take</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> rcons</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> s</span>) (<span class="id">nth</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> //=</span><span class="id"> [|n]</span><span class="id"> Hn</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ?take0</span><span class="id"> -?IHs</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> rot</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> take</span><span class="id"> n</span><span class="id"> s</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> 0</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> drop0</span><span class="id"> take0</span><span class="id"> cats0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_rot</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> RHS]cat_take_drop</span><span class="id"> /rot</span><span class="id"> !size_cat</span><span class="id"> addnC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_oversize</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> rot</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> le_s_n;</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> take_oversize</span><span class="id"> ?drop_oversize</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_size</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> rot_oversize</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_rot</span><span class="id"> s</span><span class="id"> a</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_cat</span><span class="id"> orbC</span><span class="id"> -has_cat</span><span class="id"> cat_take_drop</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_size_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> rot</span> (<span class="id">size</span><span class="id"> s1</span>) (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> take_size_cat</span><span class="id"> ?drop_size_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> rotr</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> rot</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n</span>)<span class="id"> s</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotK</span><span class="id"> :</span><span class="id"> cancel</span> (<span class="id">rot</span><span class="id"> n0</span>) (<span class="id">rotr</span><span class="id"> n0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> /rotr</span><span class="id"> size_rot</span><span class="id"> -size_drop</span><span class="id"> {2}/rot</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rot_size_cat</span><span class="id"> cat_take_drop</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_inj</span><span class="id"> :</span><span class="id"> injective</span> (<span class="id">rot</span><span class="id"> n0</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span> (<span class="id">can_inj</span><span class="id"> rotK</span>). Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> catrev</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s1</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1'</span><span class="gallina-kwd"> then</span><span class="id"> catrev</span><span class="id"> s1'</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="gallina-kwd"> else</span><span class="id"> s2</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> rev</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> catrev</span><span class="id"> s</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catrev_catl</span><span class="id"> s</span><span class="id"> t</span><span class="id"> u</span><span class="id"> :</span><span class="id"> catrev</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> t</span>)<span class="id"> u</span><span class="id"> =</span><span class="id"> catrev</span><span class="id"> t</span> (<span class="id">catrev</span><span class="id"> s</span><span class="id"> u</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catrev_catr</span><span class="id"> s</span><span class="id"> t</span><span class="id"> u</span><span class="id"> :</span><span class="id"> catrev</span><span class="id"> s</span> (<span class="id">t</span><span class="id"> ++</span><span class="id"> u</span>)<span class="id"> =</span><span class="id"> catrev</span><span class="id"> s</span><span class="id"> t</span><span class="id"> ++</span><span class="id"> u</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> -IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catrevE</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> catrev</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =</span><span class="id"> rev</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -catrev_catr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rcons</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> -catrevE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> rev_cons</span><span class="id"> size_rcons</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_nilp</span><span class="id"> s</span><span class="id"> :</span><span class="id"> nilp</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> nilp</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /nilp</span><span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_cat</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> rev</span><span class="id"> t</span><span class="id"> ++</span><span class="id"> rev</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -catrev_catr</span><span class="id"> -catrev_catl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> rev</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> rev_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> revK</span><span class="id"> :</span><span class="id"> involutive</span><span class="id"> rev</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> rev_cons</span><span class="id"> rev_rcons</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_rev</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n</span>.<span class="id">+1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim/last_ind:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> s</span><span class="id"> x</span><span class="id"> IHs</span><span class="gallina-kwd"> in</span><span class="id"> n</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> rev_rcons</span><span class="id"> size_rcons</span><span class="id"> ltnS</span><span class="id"> subSS</span><span class="id"> -cats1</span><span class="id"> nth_cat</span><span class="id"> /=</span>.<br/>
<span class="id">case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n]</span><span class="id"> lt_n_s;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subn0</span><span class="id"> ltnn</span><span class="id"> subnn</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subnSK</span><span class="id"> //=</span><span class="id"> leq_subr</span><span class="id"> IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_rev</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span><span class="id"> a</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rev</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IH;</span><span class="id"> rewrite</span><span class="id"> fun_if</span><span class="id"> !rev_cons</span><span class="id"> filter_rcons</span><span class="id"> IH</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_rev</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> a</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> filter_rev</span><span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_rev</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !has_count</span><span class="id"> count_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_rev</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> a</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !all_count</span><span class="id"> count_rev</span><span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> nseq</span><span class="id"> n</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> IHn;</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> LHS]addn1</span><span class="id"> nseqD</span><span class="id"> rev_cat</span><span class="id"> IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Sequences</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> size</span><span class="id"> ncons</span><span class="id"> nseq</span><span class="id"> head</span><span class="id"> ohead</span><span class="id"> behead</span><span class="id"> last</span><span class="id"> rcons</span><span class="id"> belast</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> seqn</span><span class="id"> {T}</span><span class="id"> n</span>.<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> cat</span><span class="id"> take</span><span class="id"> drop</span><span class="id"> rot</span><span class="id"> rotr</span><span class="id"> catrev</span>.<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> find</span><span class="id"> count</span><span class="id"> nth</span><span class="id"> all</span><span class="id"> has</span><span class="id"> filter</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rev</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> nth</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> set_nth</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> take</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> drop</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> nilP</span><span class="id"> {T</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> all_filterP</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rotK</span><span class="id"> n0</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rot_inj</span><span class="id"> {n0</span><span class="id"> T}</span><span class="id"> [s1</span><span class="id"> s2]</span><span class="id"> eq_rot_s12</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> revK</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> :=</span> (<span class="id">count</span> (<span class="id">pred_of_simpl</span> (<span class="id">pred1</span><span class="id"> x</span>))).<br/>
<br/>
<span class="vernacular">Infix</span> <span class="id">&quot;++&quot;</span><span class="id"> :=</span><span class="id"> cat</span><span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' x &lt;- s | C ]&quot;</span><span class="id"> :=</span> (<span class="id">filter</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> C%B</span>)<span class="id"> s</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><br/>
&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  x  &lt;-  s '/ '  |  C ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' x &lt;- s | C1 &amp; C2 ]&quot;</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> C1</span><span class="id"> &amp;&amp;</span><span class="id"> C2]</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><br/>
&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  x  &lt;-  s '/ '  |  C1 '/ '  &amp;  C2 ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' ' x &lt;- s | C ]&quot;</span><span class="id"> :=</span> (<span class="id">filter</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> C%B</span>)<span class="id"> s</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="id"> strict</span><span class="id"> pattern,</span><br/>
&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  ' x  &lt;-  s '/ '  |  C ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' ' x &lt;- s | C1 &amp; C2 ]&quot;</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> C1</span><span class="id"> &amp;&amp;</span><span class="id"> C2]</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="id"> strict</span><span class="id"> pattern,</span><br/>
&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  ' x  &lt;-  s '/ '  |  C1 '/ '  &amp;  C2 ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' x : T &lt;- s | C ]&quot;</span><span class="id"> :=</span> (<span class="id">filter</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> C%B</span>)<span class="id"> s</span>)<br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' x : T &lt;- s | C1 &amp; C2 ]&quot;</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> :</span><span class="id"> T</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> C1</span><span class="id"> &amp;&amp;</span><span class="id"> C2]</span><br/>
&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> x</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> seq_ind2</span><span class="id"> {S</span><span class="id"> T}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">P</span><span class="id"> [::]</span><span class="id"> [::]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> t,</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> s</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>) (<span class="id">y</span><span class="id"> ::</span><span class="id"> t</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> s</span><span class="id"> t,</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> s</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Pnil</span><span class="id"> Pcons;</span><span class="id"> elim=&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> [eq_sz];</span><span class="id"> apply/Pcons/IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> AllIff</span>.<br/>
<br/>
<span class="vernacular">Inductive</span><span class="id"> all_iff_and</span> (<span class="id">P</span><span class="id"> Q</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><span class="id"> AllIffConj</span><span class="id"> of</span><span class="id"> P</span><span class="id"> &amp;</span><span class="id"> Q</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> all_iff</span> (<span class="id">P0</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="id">Ps</span><span class="id"> :</span><span class="id"> seq</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="gallina-kwd"> fix</span><span class="id"> loop</span> (<span class="id">P</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>) (<span class="id">Qs</span><span class="id"> :</span><span class="id"> seq</span><span class="gallina-kwd"> Prop</span>)<span class="id"> :</span><span class="gallina-kwd"> Prop</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> Qs</span><span class="id"> is</span><span class="id"> Q</span><span class="id"> ::</span><span class="id"> Qs</span><span class="gallina-kwd"> then</span><span class="id"> all_iff_and</span> (<span class="id">P</span><span class="id"> -&gt;</span><span class="id"> Q</span>) (<span class="id">loop</span><span class="id"> Q</span><span class="id"> Qs</span>)<span class="gallina-kwd"> else</span><span class="id"> P</span><span class="id"> -&gt;</span><span class="id"> P0</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">loop</span><span class="id"> P0</span><span class="id"> Ps</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_iffLR</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> :</span><span class="id"> all_iff</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> m</span><span class="id"> n,</span><span class="id"> nth</span><span class="id"> P0</span> (<span class="id">P0</span><span class="id"> ::</span><span class="id"> Ps</span>)<span class="id"> m</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> P0</span> (<span class="id">P0</span><span class="id"> ::</span><span class="id"> Ps</span>)<span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> iffPs;</span><span class="id"> have</span><span class="id"> PsS</span><span class="id"> n:</span><span class="id"> nth</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> n</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> n</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> iffPs</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> P0</span><span class="id"> [|P</span><span class="id"> [|Q</span><span class="id"> Ps]]</span><span class="id"> //=</span><span class="id"> [iP0P]</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_nil</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> iPQ</span><span class="id"> iffPs;</span><span class="id"> apply:</span><span class="id"> IHn;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> /iP0P</span>.<br/>
<span class="id">have{PsS}</span><span class="id"> lePs:</span><span class="id"> {homo</span><span class="id"> nth</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> :</span><span class="id"> m</span><span class="id"> n</span><span class="id"> /</span><span class="id"> m</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &gt;-&gt;</span> (<span class="id">m</span><span class="id"> -&gt;</span><span class="id"> n</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> /subnK&lt;-;</span><span class="id"> elim:</span><span class="id"> {n}</span>(<span class="id">n</span><span class="id"> -</span><span class="id"> m</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> /IHn;</span><span class="id"> apply:</span><span class="id"> PsS</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> m</span><span class="id"> n</span><span class="id"> P_m;</span><span class="id"> have{m</span><span class="id"> P_m}</span><span class="id"> hP0:</span><span class="id"> P0</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> m</span><span class="id"> P_m</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> m</span><span class="id"> /</span>(<span class="id">lePs</span><span class="id"> m</span><span class="id"> _</span> (<span class="id">leq_maxl</span><span class="id"> m</span> (<span class="id">size</span><span class="id"> Ps</span>))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_default</span><span class="id"> ?leq_maxr</span>.<br/>
<span class="id">case:</span><span class="id"> n</span><span class="id"> =&gt;//</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> lePs</span><span class="id"> 0</span><span class="id"> n</span> (<span class="id">leq0n</span><span class="id"> n</span>)<span class="id"> _</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> Ps</span><span class="id"> iffPs</span><span class="id"> hP0</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> P</span><span class="id"> Ps</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_iffP</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">all_iff</span><span class="id"> P0</span><span class="id"> Ps</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> m</span><span class="id"> n,</span><span class="id"> nth</span><span class="id"> P0</span> (<span class="id">P0</span><span class="id"> ::</span><span class="id"> Ps</span>)<span class="id"> m</span><span class="id"> &lt;-&gt;</span><span class="id"> nth</span><span class="id"> P0</span> (<span class="id">P0</span><span class="id"> ::</span><span class="id"> Ps</span>)<span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /all_iffLR-iffPs</span><span class="id"> m</span><span class="id"> n;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> /iffPs</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> AllIff</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> all_iffLR</span><span class="id"> {P0</span><span class="id"> Ps}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> all_iffP</span><span class="id"> {P0</span><span class="id"> Ps}</span>.<br/>
<span class="vernacular">Coercion</span><span class="id"> all_iffP</span><span class="id"> :</span><span class="id"> all_iff</span><span class="id"> &gt;-&gt;</span><span class="id"> Funclass</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ '&lt;-&gt;' P0 ; P1 ; .. ; Pn ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">all_iff</span><span class="id"> P0</span> (<span class="id">@cons</span><span class="gallina-kwd"> Prop</span><span class="id"> P1</span> (.. (<span class="id">@cons</span><span class="gallina-kwd"> Prop</span><span class="id"> Pn</span><span class="id"> nil</span>) ..)))<span class="id"> :</span><span class="id"> form_scope</span>.<br/>
<br/>
<span class="vernacular">Ltac</span><span class="id"> tfae</span><span class="id"> :=</span><span class="id"> do</span><span class="id"> !apply:</span><span class="id"> AllIffConj</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FindSpec</span>.<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Variant</span><span class="id"> find_spec</span><span class="id"> :</span><span class="id"> bool</span><span class="id"> -&gt;</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
<span class="id">|</span><span class="id"> NotFound</span><span class="id"> of</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find_spec</span><span class="id"> false</span> (<span class="id">size</span><span class="id"> s</span>)<br/>
<span class="id">|</span><span class="id"> Found</span> (<span class="id">i</span><span class="id"> :</span><span class="id"> nat</span>)<span class="id"> of</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &amp;</span> (<span class="gallina-kwd">forall</span><span class="id"> x0,</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> i</span>))<span class="id"> &amp;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x0</span><span class="id"> j,</span><span class="id"> j</span><span class="id"> &lt;</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> j</span>)<span class="id"> =</span><span class="id"> false</span>)<span class="id"> :</span><span class="id"> find_spec</span><span class="id"> true</span><span class="id"> i</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> findP</span><span class="id"> :</span><span class="id"> find_spec</span> (<span class="id">has</span><span class="id"> a</span><span class="id"> s</span>) (<span class="id">find</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [a_s|aNs]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">has</span><span class="id"> a</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> hasNfind//;</span><span class="id"> constructor</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> constructor=&gt;</span><span class="id"> [|x0|x0];</span><span class="id"> rewrite</span><span class="id"> -?has_find</span><span class="id"> ?nth_find//;</span><span class="id"> apply:</span><span class="id"> before_find</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FindSpec</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> findP</span><span class="id"> {T}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RotRcons</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot1_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> 1</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> /=</span><span class="id"> take0</span><span class="id"> drop0</span><span class="id"> -cats1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_inj</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x1</span><span class="id"> x2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x1</span><span class="id"> =</span><span class="id"> rcons</span><span class="id"> s2</span><span class="id"> x2</span><span class="id"> :&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span> (<span class="id">s1,</span><span class="id"> x1</span>)<span class="id"> =</span> (<span class="id">s2,</span><span class="id"> x2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!rot1_cons</span><span class="id"> =&gt;</span><span class="id"> /rot_inj[-&gt;</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_injl</span><span class="id"> x</span><span class="id"> :</span><span class="id"> injective</span> (<span class="id">rcons^~</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /rcons_inj[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_injr</span><span class="id"> s</span><span class="id"> :</span><span class="id"> injective</span> (<span class="id">rcons</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x1</span><span class="id"> x2</span><span class="id"> /rcons_inj[]</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RotRcons</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> rcons_inj</span><span class="id"> {T</span><span class="id"> s1</span><span class="id"> x1</span><span class="id"> s2</span><span class="id"> x2}</span><span class="id"> eq_rcons</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rcons_injl</span><span class="id"> {T}</span><span class="id"> x</span><span class="id"> [s1</span><span class="id"> s2]</span><span class="id"> eq_rcons</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rcons_injr</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> [x1</span><span class="id"> x2]</span><span class="id"> eq_rcons</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqSeq</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">x0</span><span class="id"> :</span><span class="id"> T</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> nth</span><span class="id"> :=</span> (<span class="id">nth</span><span class="id"> x0</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> eqseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> {struct</span><span class="id"> s2}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> s1,</span><span class="id"> s2</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> [::],</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> true</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> x1</span><span class="id"> ::</span><span class="id"> s1',</span><span class="id"> x2</span><span class="id"> ::</span><span class="id"> s2'</span><span class="id"> =&gt;</span> (<span class="id">x1</span><span class="id"> ==</span><span class="id"> x2</span>)<span class="id"> &amp;&amp;</span><span class="id"> eqseq</span><span class="id"> s1'</span><span class="id"> s2'</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> false</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseqP</span><span class="id"> :</span><span class="id"> Equality</span>.<span class="id">axiom</span><span class="id"> eqseq</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move;</span><span class="id"> elim=&gt;</span><span class="id"> [|x1</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> [|x2</span><span class="id"> s2];</span><span class="id"> do</span><span class="id"> [by</span><span class="id"> constructor</span><span class="id"> |</span><span class="id"> simpl]</span>.<br/>
<span class="id">have</span><span class="id"> [&lt;-|neqx]</span><span class="id"> :=</span><span class="id"> x1</span><span class="id"> =P</span><span class="id"> x2;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> case</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span> (<span class="id">IHs</span><span class="id"> s2</span>))<span class="id"> =&gt;</span><span class="id"> [&lt;-|[]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> hasDecEq</span>.<span class="id">Build</span> (<span class="id">seq</span><span class="id"> T</span>)<span class="id"> eqseqP</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseqE</span><span class="id"> :</span><span class="id"> eqseq</span><span class="id"> =</span><span class="id"> eq_op</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_cons</span><span class="id"> x1</span><span class="id"> x2</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">x1</span><span class="id"> ::</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> x2</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> =</span> (<span class="id">x1</span><span class="id"> ==</span><span class="id"> x2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> -&gt;</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span><span class="id"> ==</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s3</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [|x1</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> [|x2</span><span class="id"> s2]</span><span class="id"> //=</span><span class="id"> [sz12]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !eqseq_cons</span><span class="id"> -andbA</span><span class="id"> IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_rcons</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x1</span><span class="id"> x2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x1</span><span class="id"> ==</span><span class="id"> rcons</span><span class="id"> s2</span><span class="id"> x2</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">x1</span><span class="id"> ==</span><span class="id"> x2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">can_eq</span><span class="id"> revK</span>)<span class="id"> !rev_rcons</span><span class="id"> eqseq_cons</span><span class="id"> andbC</span> (<span class="id">can_eq</span><span class="id"> revK</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_eq0</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> 0</span>)<span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">sameP</span><span class="id"> nilP</span><span class="id"> eqP</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nilpE</span><span class="id"> s</span><span class="id"> :</span><span class="id"> nilp</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_filter</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s</span><span class="id"> !=</span><span class="id"> [::]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -size_eq0</span><span class="id"> size_filter</span><span class="id"> has_count</span><span class="id"> lt0n</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> mem_seq</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> xpredU1</span><span class="id"> y</span> (<span class="id">mem_seq</span><span class="id"> s'</span>)<span class="gallina-kwd"> else</span><span class="id"> xpred0</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> seq_eqclass</span><span class="id"> :=</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<span class="id">Identity</span><span class="vernacular"> Coercion</span><span class="id"> seq_of_eqclass</span><span class="id"> :</span><span class="id"> seq_eqclass</span><span class="id"> &gt;-&gt;</span><span class="id"> seq</span>.<br/>
<span class="vernacular">Coercion</span><span class="id"> pred_of_seq</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq_eqclass</span>)<span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span><span class="id"> :=</span><span class="id"> mem_seq</span><span class="id"> s</span>.<br/>
<br/>
<span class="vernacular">Canonical</span><span class="id"> seq_predType</span><span class="id"> :=</span><span class="id"> PredType</span> (<span class="id">pred_of_seq</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> mem_seq_predType</span><span class="id"> :=</span><span class="id"> PredType</span><span class="id"> mem_seq</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_cons</span><span class="id"> y</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> ||</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_nil</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> [::]</span>)<span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_seq1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> [::</span><span class="id"> y]</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> in_cons</span><span class="id"> orbF</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> inE</span><span class="id"> :=</span> (<span class="id">mem_seq1,</span><span class="id"> in_cons,</span><span class="id"> inE</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> forall_cons</span><span class="id"> {P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> Prop}</span><span class="id"> {a</span><span class="id"> s}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> a::s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span><span class="id"> &lt;-&gt;</span><span class="id"> P</span><span class="id"> a</span><span class="id"> /\</span><span class="id"> {in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> P</span><span class="id"> x}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [A|[A</span><span class="id"> B]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> /predU1P</span><span class="id"> [-&gt;</span><span class="id"> //|];</span><span class="id"> apply:</span><span class="id"> B</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> [|b</span><span class="id"> Hb];</span><span class="id"> apply:</span><span class="id"> A;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> ?eqxx</span><span class="id"> ?Hb</span><span class="id"> ?orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> exists_cons</span><span class="id"> {P</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> Prop}</span><span class="id"> {a</span><span class="id"> s}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> a::s</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> x</span>)<span class="id"> &lt;-&gt;</span><span class="id"> P</span><span class="id"> a</span><span class="id"> \/</span><span class="gallina-kwd"> exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [[x</span><span class="id"> /predU1P[-&gt;|x_s]</span><span class="id"> Px]|];</span><span class="id"> [by</span><span class="id"> left|</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> x|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [?|[x</span><span class="id"> x_s</span><span class="id"> ?]];</span><span class="id"> [exists</span><span class="id"> a|exists</span><span class="id"> x];</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> ?eqxx</span><span class="id"> ?x_s</span><span class="id"> ?orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_seq2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> [::</span><span class="id"> y;</span><span class="id"> z]</span>)<span class="id"> =</span><span class="id"> xpred2</span><span class="id"> y</span><span class="id"> z</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_seq3</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> [::</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t]</span>)<span class="id"> =</span><span class="id"> xpred3</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_seq4</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> u</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> [::</span><span class="id"> y;</span><span class="id"> z;</span><span class="id"> t;</span><span class="id"> u]</span>)<span class="id"> =</span><span class="id"> xpred4</span><span class="id"> y</span><span class="id"> z</span><span class="id"> t</span><span class="id"> u</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s1</span>)<span class="id"> ||</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s1</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> -orbA</span><span class="id"> -IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rcons</span><span class="id"> s</span><span class="id"> y</span><span class="id"> :</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> y</span><span class="id"> =i</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> /=</span><span class="id"> mem_cat</span><span class="id"> mem_seq1</span><span class="id"> orbC</span><span class="id"> in_cons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_head</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> predU1l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> lastI</span><span class="id"> mem_rcons</span><span class="id"> mem_head</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_behead</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> behead</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> s}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> s</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> predU1r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_belast</span><span class="id"> s</span><span class="id"> y</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> belast</span><span class="id"> y</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x</span><span class="id"> ys'x;</span><span class="id"> rewrite</span><span class="id"> lastI</span><span class="id"> mem_rcons</span><span class="id"> mem_behead</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> [_|n</span><span class="id"> sz_s];</span><span class="id"> rewrite</span><span class="id"> ?mem_head</span><span class="id"> //</span><span class="id"> mem_behead</span><span class="id"> ?IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_take</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> take</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s0x;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">cat_take_drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> mem_cat</span><span class="id"> /=</span><span class="id"> s0x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_drop</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> drop</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s0'x;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">cat_take_drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> mem_cat</span><span class="id"> /=</span><span class="id"> s0'x</span><span class="id"> orbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_eq</span><span class="id"> s</span><span class="id"> z</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> z</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">last</span><span class="id"> z</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /negPf</span><span class="id"> xz</span><span class="id"> /negPf</span><span class="id"> yz;</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|t</span><span class="id"> s]//;</span><span class="id"> rewrite</span><span class="id"> xz</span><span class="id"> yz</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Filters</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasP</span><span class="id"> {a</span><span class="id"> s}</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> a</span><span class="id"> x</span>) (<span class="id">has</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> case</span>.<br/>
<span class="id">exact:</span><span class="id"> equivP</span> (<span class="id">orPP</span><span class="id"> idP</span><span class="id"> IHs</span>) (<span class="id">iff_sym</span><span class="id"> exists_cons</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allP</span><span class="id"> {a</span><span class="id"> s}</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> a</span><span class="id"> x}</span> (<span class="id">all</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|/=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
<span class="id">exact:</span><span class="id"> equivP</span> (<span class="id">andPP</span><span class="id"> idP</span><span class="id"> IHs</span>) (<span class="id">iff_sym</span><span class="id"> forall_cons</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasPn</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> ~~</span><span class="id"> a</span><span class="id"> x}</span> (<span class="id">~~</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -all_predC;</span><span class="id"> apply:</span><span class="id"> allP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allPn</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> ~~</span><span class="id"> a</span><span class="id"> x</span>) (<span class="id">~~</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_predC;</span><span class="id"> apply:</span><span class="id"> hasP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allss</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> [in</span><span class="id"> s]</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/allP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_filter</span><span class="id"> a</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> filter</span><span class="id"> a</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> a</span><span class="id"> x</span><span class="id"> &amp;&amp;</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> andbC;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span>.<br/>
<span class="id">rewrite</span> (<span class="id">fun_if</span> (<span class="gallina-kwd">fun</span><span class="id"> s'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s'</span>))<span class="id"> !in_cons</span><span class="id"> {}IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;|_];</span><span class="id"> case</span> (<span class="id">a</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?andbF</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variables</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">A</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Prop</span>).<br/>
<span class="vernacular">Hypothesis</span><span class="id"> aP</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> reflect</span> (<span class="id">A</span><span class="id"> x</span>) (<span class="id">a</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> hasPP</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> A</span><span class="id"> x</span>) (<span class="id">has</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> hasP</span>)<span class="id"> =&gt;</span><span class="id"> -[x</span><span class="id"> ?</span><span class="id"> /aP];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allPP</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> A</span><span class="id"> x}</span> (<span class="id">all</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> allP</span>)<span class="id"> =&gt;</span><span class="id"> a_s</span><span class="id"> x</span><span class="id"> /a_s/aP</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Filters</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqIn</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> a1</span><span class="id"> a2</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_filter</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2}</span><span class="id"> -&gt;</span><span class="id"> filter</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> filter</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /forall_cons</span><span class="id"> [-&gt;</span><span class="id"> /IHs</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_find</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2}</span><span class="id"> -&gt;</span><span class="id"> find</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> find</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /forall_cons</span><span class="id"> [-&gt;</span><span class="id"> /IHs</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_count</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2}</span><span class="id"> -&gt;</span><span class="id"> count</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> count</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/eq_in_filter=&gt;</span><span class="id"> eq_a12;</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> eq_a12</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_all</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2}</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> all</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_a12;</span><span class="id"> rewrite</span><span class="id"> !all_count</span><span class="id"> eq_in_count</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_has</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> a1</span><span class="id"> =1</span><span class="id"> a2}</span><span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> a1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> has</span><span class="id"> a2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/eq_in_filter=&gt;</span><span class="id"> eq_a12;</span><span class="id"> rewrite</span><span class="id"> !has_filter</span><span class="id"> eq_a12</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqIn</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_has_r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> has^~</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> has^~</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Es</span><span class="id"> a;</span><span class="id"> apply/hasP/hasP=&gt;</span><span class="id"> -[x</span><span class="id"> sx</span><span class="id"> ax];</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> ?Es</span><span class="gallina-kwd"> in</span><span class="id"> sx</span><span class="id"> *</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_all_r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> all^~</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> all^~</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Es</span><span class="id"> a;</span><span class="id"> apply/negb_inj;</span><span class="id"> rewrite</span><span class="id"> -!has_predC</span> (<span class="id">eq_has_r</span><span class="id"> Es</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_sym</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> has</span><span class="id"> [in</span><span class="id"> s1]</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> has</span><span class="id"> [in</span><span class="id"> s2]</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/hasP/hasP=&gt;</span><span class="id"> -[x];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_pred1</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eq_has</span> (<span class="id">mem_seq1^~</span><span class="id"> x</span>)) (<span class="id">has_sym</span><span class="id"> [::</span><span class="id"> x]</span>)<span class="id"> /=</span><span class="id"> orbF</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span><span class="id"> s</span><span class="id"> =i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> -!has_pred1</span><span class="id"> has_rev</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> constant</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> all</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> true</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_pred1P</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">s</span><span class="id"> =</span><span class="id"> nseq</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> x</span>) (<span class="id">all</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;{y}</span><span class="id"> |</span><span class="id"> ne_xy];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> right=&gt;</span><span class="id"> []</span><span class="id"> [?</span><span class="id"> _];</span><span class="id"> case</span><span class="id"> ne_xy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> IHs</span>)<span class="id"> =&gt;</span><span class="id"> [&lt;-</span><span class="id"> //|</span><span class="id"> []]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_pred1_constant</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> constant</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> /andP[/eqP-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_pred1_nseq</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><span class="id"> all</span> (<span class="id">pred1</span><span class="id"> x</span>) (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> all_nseq</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> orbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">0</span><span class="id"> &lt;</span><span class="id"> n</span>)<span class="id"> &amp;&amp;</span> (<span class="id">y</span><span class="id"> ==</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> has_nseq</span><span class="id"> eq_sym</span>.  Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nseqP</span><span class="id"> n</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> /\</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 0</span>) (<span class="id">y</span><span class="id"> \in</span><span class="id"> nseq</span><span class="id"> n</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_nseq</span><span class="id"> andbC;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> andP</span>)<span class="id"> =&gt;</span><span class="id"> -[/eqP]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> constant_nseq</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> constant</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> all_pred1_constant</span> (<span class="id">all_pred1_nseq</span><span class="id"> x</span><span class="id"> n</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> constantP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> x,</span><span class="id"> s</span><span class="id"> =</span><span class="id"> nseq</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> x</span>) (<span class="id">constant</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|</span><span class="id"> [x</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> constant_nseq</span>.<br/>
<span class="id">case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s]</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move/all_pred1P=&gt;</span><span class="id"> def_s;</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -def_s</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span> (<span class="id">x</span><span class="id"> \notin</span><span class="id"> s'</span>)<span class="id"> &amp;&amp;</span><span class="id"> uniq</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> true</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cons_uniq</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \notin</span><span class="id"> s</span>)<span class="id"> &amp;&amp;</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> [&amp;&amp;</span><span class="id"> uniq</span><span class="id"> s1,</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> [in</span><span class="id"> s1]</span><span class="id"> s2</span><span class="id"> &amp;</span><span class="id"> uniq</span><span class="id"> s2]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> has_pred0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> has_sym</span><span class="id"> /=</span><span class="id"> mem_cat</span><span class="id"> !negb_or</span><span class="id"> has_sym</span><span class="id"> IHs</span><span class="id"> -!andbA;</span><span class="id"> do</span><span class="id"> !bool_congr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_catC</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> uniq</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !cat_uniq</span><span class="id"> has_sym</span><span class="id"> andbCA</span><span class="id"> andbA</span><span class="id"> andbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_catCA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> =</span><span class="id"> uniq</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s3</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !catA</span><span class="id"> -!</span>(<span class="id">uniq_catC</span><span class="id"> s3</span>)<span class="id"> !</span>(<span class="id">cat_uniq</span><span class="id"> s3</span>)<span class="id"> uniq_catC</span><span class="id"> !has_cat</span><span class="id"> orbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons_uniq</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \notin</span><span class="id"> s</span>)<span class="id"> &amp;&amp;</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> uniq_catC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_uniq</span><span class="id"> s</span><span class="id"> a</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[s'x];</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> a_x</span><span class="id"> /IHs-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_filter</span><span class="id"> a_x</span><span class="id"> s'x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> uniq_catC</span><span class="id"> cat_take_drop</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rev_cons</span><span class="id"> -cats1</span><span class="id"> cat_uniq</span><span class="id"> /=</span><span class="id"> andbT</span><span class="id"> andbC</span><span class="id"> mem_rev</span><span class="id"> orbF</span><span class="id"> IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_memPn</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">count_mem</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span>) (<span class="id">x</span><span class="id"> \notin</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> has_count</span><span class="id"> -eqn0Ngt;</span><span class="id"> apply:</span><span class="id"> eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_uniq_mem</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[/negbTE</span><span class="id"> s'y</span><span class="id"> /IHs-&gt;</span><span class="id"> {IHs}]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_cons;</span><span class="id"> case:</span> (<span class="id">eqVneq</span><span class="id"> y</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> s'y</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_uniq_countP</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s2</span>) (<span class="id">count_mem</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/count_uniq_mem-&gt;;</span><span class="id"> case:</span> (<span class="id">boolP</span> (_<span class="id"> \in</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> _;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> constructor</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> has_count;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_uniq_count</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s1_uniq</span><span class="id"> s1_s2</span><span class="id"> x;</span><span class="id"> apply/leq_uniq_countP/s1_s2</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_pred1_uniq</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> filter</span> (<span class="id">pred1</span><span class="id"> x</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> [::</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uniq_s</span><span class="id"> s_x;</span><span class="id"> rewrite</span> (<span class="id">all_pred1P</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">filter_all</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_filter</span><span class="id"> count_uniq_mem</span><span class="id"> ?s_x</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> undup</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> undup</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_undup</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> ltnW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_undup</span><span class="id"> s</span><span class="id"> :</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> =i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> s_y:</span> (<span class="id">y</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> IHs</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;|]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">undup</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case</span><span class="id"> s_x:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> mem_undup</span><span class="id"> s_x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_id</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[/negbTE-&gt;</span><span class="id"> /IHs-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> ltn_size_undup</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">size</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> ~~</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> case</span><span class="id"> s_x:</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> ltnS</span><span class="id"> size_undup</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_undup</span><span class="id"> p</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span><span class="id"> p</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> undup</span> (<span class="id">filter</span><span class="id"> p</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span> (<span class="id">fun_if</span><span class="id"> undup</span>)<span class="id"> fun_if</span><span class="id"> /=</span><span class="id"> mem_filter</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">fun_if</span> (<span class="id">filter</span><span class="id"> p</span>))<span class="id"> /=</span><span class="id"> IHs;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> if_same</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_nil</span><span class="id"> s</span><span class="id"> :</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span><span class="id"> -&gt;</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> -mem_undup;</span><span class="id"> case:</span><span class="id"> ifP;</span><span class="id"> case:</span><span class="id"> undup</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_cat</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">undup</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> [seq</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> |</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> t]</span><span class="id"> ++</span><span class="id"> undup</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mem_cat;</span><span class="id"> do</span><span class="id"> 2</span><span class="id"> case:</span><span class="id"> in_mem</span><span class="id"> =&gt;</span><span class="id"> //=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> undup</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> rcons</span><span class="id"> [seq</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s</span><span class="id"> |</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> x]</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> undup_cat;</span><span class="id"> congr</span><span class="id"> cat;</span><span class="id"> apply:</span><span class="id"> eq_filter</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_undup</span><span class="id"> s</span><span class="id"> p</span><span class="id"> :</span><span class="id"> count</span><span class="id"> p</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> &lt;=</span><span class="id"> count</span><span class="id"> p</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> filter_undup</span><span class="id"> size_undup</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_undup</span><span class="id"> p</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> p</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> has</span><span class="id"> p</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> eq_has_r</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mem_undup</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_undup</span><span class="id"> p</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> p</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> p</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> eq_all_r</span><span class="id"> =&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mem_undup</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> index</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> find</span> (<span class="id">pred1</span><span class="id"> x</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_size</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index</span><span class="id"> find_size</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_mem</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> has_find</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> memNindex</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span> <span class="id"> x</span><span class="id"> \notin</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> =&gt;</span><span class="id"> /hasNfind</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> s</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">nth_find</span><span class="id"> x0</span>)<span class="id">/eqP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;<span class="id">index</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s1</span><span class="gallina-kwd"> else</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index</span><span class="id"> find_cat</span><span class="id"> has_pred1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_ltn</span><span class="id"> x</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -has_pred1;</span><span class="id"> apply:</span><span class="id"> find_ltn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_take</span><span class="id"> x</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -?has_pred1;</span><span class="id"> apply:</span><span class="id"> has_take</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_take_leq</span><span class="id"> x</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -?has_pred1;</span><span class="id"> apply:</span><span class="id"> has_take_leq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_nth</span><span class="id"> i</span><span class="id"> s</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> index</span> (<span class="id">nth</span><span class="id"> s</span><span class="id"> i</span>)<span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lti;</span><span class="id"> rewrite</span><span class="id"> -ltnS</span><span class="id"> index_ltn//</span><span class="id"> -</span>(<span class="id">@nth_take</span><span class="id"> i</span>.<span class="id">+1</span>)<span class="id">//</span><span class="id"> mem_nth</span><span class="id"> //</span><span class="id"> size_take</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nthK</span><span class="id"> s:</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> gtn</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">,</span><span class="id"> cancel</span> (<span class="id">nth</span><span class="id"> s</span>) (<span class="id">index^~</span><span class="id"> s</span>)<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[s'x</span><span class="id"> Us]</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> ltnS</span><span class="id"> eq_sym</span><span class="id"> -if_neg</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [_|i</span><span class="id"> lt_i_s];</span><span class="id"> rewrite</span><span class="id"> ?eqxx</span><span class="id"> ?IHs</span><span class="id"> ?</span>(<span class="id">memPn</span><span class="id"> s'x</span>)<span class="id"> ?mem_nth</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_uniq</span><span class="id"> i</span><span class="id"> s</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> index</span> (<span class="id">nth</span><span class="id"> s</span><span class="id"> i</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/nthK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_head</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> index</span><span class="id"> x</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> eqxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_last</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> -&gt;</span><span class="id"> index</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> lastI</span><span class="id"> rcons_uniq</span><span class="id"> -cats1</span><span class="id"> index_cat</span><span class="id"> size_belast</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> addn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_uniq</span><span class="id"> s</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> j</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span> (<span class="id">nth</span><span class="id"> s</span><span class="id"> i</span><span class="id"> ==</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> j</span>)<span class="id"> =</span> (<span class="id">i</span><span class="id"> ==</span><span class="id"> j</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> lti</span><span class="id"> ltj</span><span class="id"> /nthK/can_in_eq-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniqPn</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> i</span><span class="id"> j,</span><span class="id"> [/\</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> j,</span><span class="id"> j</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> s</span><span class="id"> j]</span>) (<span class="id">~~</span><span class="id"> uniq</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[i</span><span class="id"> [j</span><span class="id"> [ltij</span><span class="id"> ltjs]]]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra_eqN</span><span class="id"> =&gt;</span><span class="id"> Us;</span><span class="id"> rewrite</span><span class="id"> nth_uniq</span><span class="id"> ?ltn_eqF</span><span class="id"> //</span> (<span class="id">ltn_trans</span><span class="id"> ltij</span>).<br/>
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /nandP[/negbNE</span><span class="id"> |</span><span class="id"> /IHs[i</span><span class="id"> [j]]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<span class="id">+1,</span><span class="id"> j</span>.<span class="id">+1</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> 0,</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>).<span class="id">+1;</span><span class="id"> rewrite</span><span class="id"> !ltnS</span><span class="id"> index_mem</span><span class="id"> /=</span><span class="id"> nth_index</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniqP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span><span class="id"> {in</span><span class="id"> gtn</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> &amp;,</span><span class="id"> injective</span> (<span class="id">nth</span><span class="id"> s</span>)<span class="id">}</span> (<span class="id">uniq</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/nthK/can_in_inj//</span><span class="id"> |</span><span class="id"> nth_inj]</span>.<br/>
<span class="id">apply/uniqPn</span><span class="id"> =&gt;</span><span class="id"> -[i</span><span class="id"> [j</span><span class="id"> [ltij</span><span class="id"> ltjs</span><span class="id"> /nth_inj/eqP/idPn]]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span> (<span class="id">ltn_trans</span><span class="id"> ltij</span><span class="id"> ltjs</span>)<span class="id"> ltn_eqF</span><span class="id"> //=;</span><span class="id"> case</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rot</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> =i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> RHS]</span>(<span class="id">cat_take_drop</span><span class="id"> n0</span>)<span class="id"> !mem_cat</span><span class="id"> /=</span><span class="id"> orbC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_rot</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> rot</span><span class="id"> n0</span><span class="id"> s2</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/inj_eq/rot_inj</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_index</span><span class="id"> s</span> (<span class="id">n</span><span class="id"> :=</span><span class="id"> index</span><span class="id"> x0</span><span class="id"> s</span>)<span class="id"> :</span><span class="id"> x0</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> drop</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> x0</span><span class="id"> ::</span><span class="id"> drop</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> xs;</span><span class="id"> rewrite</span> (<span class="id">drop_nth</span><span class="id"> x0</span>)<span class="id"> ?index_mem</span><span class="id"> ?nth_index</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_pivot</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span> (<span class="id">s</span><span class="id"> :=</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">index</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> index_cat/=</span><span class="id"> eqxx</span><span class="id"> addn0;</span><span class="id"> case:</span><span class="id"> ifPn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_pivot</span><span class="id"> x</span><span class="id"> s2</span><span class="id"> s1</span> (<span class="id">s</span><span class="id"> :=</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">take</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /index_pivot-&gt;;</span><span class="id"> rewrite</span><span class="id"> take_size_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_pivot</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> rev</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> rev</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rev_cat</span><span class="id"> rev_cons</span><span class="id"> cat_rcons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_pivot2l</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s3</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xNs1</span><span class="id"> xNs3;</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> [E|/andP[/eqP-&gt;</span><span class="id"> /eqP-&gt;]//]</span>.<br/>
<span class="id">suff</span><span class="id"> S</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s3</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqseq_cat//</span><span class="id"> eqseq_cons</span><span class="id"> eqxx</span><span class="gallina-kwd"> in</span><span class="id"> E</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">index_pivot</span><span class="id"> s2</span><span class="id"> xNs1</span>) (<span class="id">eqP</span><span class="id"> E</span>)<span class="id"> index_pivot</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_pivot2r</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s4</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xNs2</span><span class="id"> xNs4;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">can_eq</span><span class="id"> revK</span>)<span class="id"> !rev_pivot</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqseq_pivot2l</span><span class="id"> ?mem_rev</span><span class="id"> //</span><span class="id"> !</span>(<span class="id">can_eq</span><span class="id"> revK</span>)<span class="id"> andbC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_pivotl</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xNs1</span><span class="id"> xNs2;</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> [E|/andP[/eqP-&gt;</span><span class="id"> /eqP-&gt;]//]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@eqseq_pivot2l</span><span class="id"> x</span>)<span class="id">//;</span><span class="id"> have</span><span class="id"> /eqP/</span>(<span class="id">congr1</span> (<span class="id">count_mem</span><span class="id"> x</span>))<span class="id"> :=</span><span class="id"> E</span>.<br/>
<span class="id">rewrite</span><span class="id"> !count_cat/=</span><span class="id"> eqxx</span><span class="id"> !addnS</span> (<span class="id">count_memPn</span><span class="id"> _</span><span class="id"> _</span><span class="id"> xNs1</span>) (<span class="id">count_memPn</span><span class="id"> _</span><span class="id"> _</span><span class="id"> xNs2</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -[/esym/eqP];</span><span class="id"> rewrite</span><span class="id"> addn_eq0</span><span class="id"> =&gt;</span><span class="id"> /andP[/eqP/count_memPn]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_pivotr</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s4</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqseq_pivotl//;</span><span class="id"> case:</span><span class="id"> eqVneq</span><span class="id"> =&gt;</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_eqseq_pivotl</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> uniq_catC/=</span><span class="id"> mem_cat</span><span class="id"> =&gt;</span><span class="id"> /andP[/norP[?</span><span class="id"> ?]</span><span class="id"> _];</span><span class="id"> rewrite</span><span class="id"> eqseq_pivotl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_eqseq_pivotr</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s2</span><span class="id"> ==</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> uniq_eqseq_pivotl//;</span><span class="id"> case:</span><span class="id"> eqVneq</span><span class="id"> =&gt;</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqSeq</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> eqseq</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'has_ view&quot;</span><span class="id"> :=</span> (<span class="id">hasPP</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> view</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 4,</span><span class="id"> right</span><span class="id"> associativity,</span><span class="id"> format</span> <span class="id">&quot;''has_' view&quot;</span>).<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;'all_ view&quot;</span><span class="id"> :=</span> (<span class="id">allPP</span><span class="id"> _</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> view</span>))<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 4,</span><span class="id"> right</span><span class="id"> associativity,</span><span class="id"> format</span> <span class="id">&quot;''all_' view&quot;</span>).<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RotIndex</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_index</span><span class="id"> s</span><span class="id"> x</span> (<span class="id">i</span><span class="id"> :=</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">rot</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span> (<span class="id">drop</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x_s;</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> drop_index</span>. Qed.</div></details>
<br/>
<span class="vernacular">Variant</span><span class="id"> rot_to_spec</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :=</span><span class="id"> RotToSpec</span><span class="id"> i</span><span class="id"> s'</span><span class="id"> of</span><span class="id"> rot</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_to</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rot_to_spec</span><span class="id"> s</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /rot_index</span><span class="id"> /RotToSpec</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RotIndex</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> inE</span><span class="id"> :=</span> (<span class="id">mem_seq1,</span><span class="id"> in_cons,</span><span class="id"> inE</span>).<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> mem_seq1</span><span class="id"> constant</span><span class="id"> uniq</span><span class="id"> undup</span><span class="id"> index</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> eqseq</span><span class="id"> {T}</span><span class="id"> !_</span><span class="id"> !_</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pred_of_seq</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> x</span><span class="id"> /</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> eqseqP</span><span class="id"> {T</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> hasP</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> hasPn</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allP</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allPn</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> nseqP</span><span class="id"> {T</span><span class="id"> n</span><span class="id"> x</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> count_memPn</span><span class="id"> {T</span><span class="id"> x</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> uniqPn</span><span class="id"> {T}</span><span class="id"> x0</span><span class="id"> {s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> uniqP</span><span class="id"> {T}</span><span class="id"> x0</span><span class="id"> {s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> forall_cons</span><span class="id"> {T</span><span class="id"> P</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> exists_cons</span><span class="id"> {T</span><span class="id"> P</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<br/>
<span class="id">#[export]</span><span class="vernacular"> Hint</span><span class="id"> Extern</span><span class="id"> 0</span> (<span class="id">is_true</span> (<span class="id">all</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> =&gt;</span><br/>
&nbsp;&nbsp;<span class="id">apply:</span> (<span class="id">allss</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> T</span><span class="id"> s,</span><span class="id"> all</span> (<span class="id">mem_seq</span><span class="id"> s</span>)<span class="id"> s</span>)<span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> NthTheory</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nthP</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> x</span><span class="id"> x0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[n</span><span class="id"> Hn</span><span class="id"> &lt;-]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> mem_nth</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> [rewrite</span><span class="id"> index_mem</span><span class="id"> |</span><span class="id"> apply</span><span class="id"> nth_index]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_nthP</span><span class="id"> a</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> i</span>)) (<span class="id">has</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> right;</span><span class="id"> case</span>.<br/>
<span class="id">case</span><span class="id"> nax:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> 0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> IHs</span>)<span class="id"> =&gt;</span><span class="id"> [[i]|[[|i]]];</span><span class="id"> [exists</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> nax</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> i]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_nthP</span><span class="id"> a</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> i</span>)) (<span class="id">all</span><span class="id"> a</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">eq_all</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> negbK</span> (<span class="id">a</span><span class="id"> x</span>)))<span class="id"> all_predC</span>.<br/>
<span class="id">case:</span> (<span class="id">has_nthP</span><span class="id"> _</span><span class="id"> _</span><span class="id"> x0</span>)<span class="id"> =&gt;</span><span class="id"> [na_s</span><span class="id"> |</span><span class="id"> a_s];</span><span class="id"> [right=&gt;</span><span class="id"> a_s</span><span class="id"> |</span><span class="id"> left=&gt;</span><span class="id"> i</span><span class="id"> lti]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> na_s</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> lti;</span><span class="id"> rewrite</span><span class="id"> a_s</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idPn=&gt;</span><span class="id"> na_si;</span><span class="id"> case:</span><span class="id"> a_s;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_nthE</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">then</span><span class="id"> take</span><span class="id"> n</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> drop</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> ncons</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> x0</span><span class="id"> [::</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|a</span><span class="id"> s</span><span class="id"> IH]</span><span class="id"> n</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subn0</span><span class="id"> set_nth_nil</span>.<br/>
<span class="id">case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> drop0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> ltnP</span> (<span class="id">IH</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_set_nth</span><span class="id"> a</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">count</span><span class="id"> a</span> (<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">count</span><span class="id"> a</span><span class="id"> s</span><span class="id"> +</span><span class="id"> a</span><span class="id"> x</span><span class="id"> -</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>)<span class="id"> *</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> +</span> (<span class="id">a</span><span class="id"> x0</span>)<span class="id"> *</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> set_nthE;</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [nlts|nges];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cat_nseq</span><span class="id"> !count_cat</span><span class="id"> count_nseq</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> muln0</span><span class="id"> addn0</span><span class="id"> subn0</span><span class="id"> addnAC</span><span class="id"> addnA</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span><span class="id"> ltnW</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[in</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s]</span>(<span class="id">cat_take_drop</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> [drop</span><span class="id"> n</span><span class="id"> s]</span>(<span class="id">drop_nth</span><span class="id"> x0</span>)<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !count_cat/=</span><span class="id"> muln1</span><span class="id"> muln0</span><span class="id"> addn0</span><span class="id"> addnAC</span><span class="id"> !addnA</span><span class="id"> [in</span><span class="id"> RHS]addnAC</span><span class="id"> addnK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_set_nth_ltn</span><span class="id"> a</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">count</span><span class="id"> a</span> (<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span><span class="id"> +</span><span class="id"> a</span><span class="id"> x</span><span class="id"> -</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nlts;</span><span class="id"> rewrite</span><span class="id"> count_set_nth</span><span class="id"> nlts</span><span class="id"> muln1</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span><span class="id"> ltnW</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> muln0</span><span class="id"> addn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_set_nthF</span><span class="id"> a</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> ~~</span><span class="id"> a</span><span class="id"> x0</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">count</span><span class="id"> a</span> (<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span><span class="id"> +</span><span class="id"> a</span><span class="id"> x</span><span class="id"> -</span><span class="id"> a</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /negbTE</span><span class="id"> ax0;</span><span class="id"> rewrite</span><span class="id"> count_set_nth</span><span class="id"> ax0</span><span class="id"> mul0n</span><span class="id"> addn0</span>.<br/>
<span class="id">case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [_|nges];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> muln1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_default//</span><span class="id"> ax0</span><span class="id"> subn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> NthTheory</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> set_nth_default</span><span class="id"> T</span><span class="id"> s</span> (<span class="id">y0</span><span class="id"> x0</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> y0</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s'</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span><span class="id"> /IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> headI</span><span class="id"> T</span><span class="id"> s</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =</span><span class="id"> head</span><span class="id"> x</span><span class="id"> s</span><span class="id"> ::</span><span class="id"> behead</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Arguments</span><span class="id"> nthP</span><span class="id"> {T</span><span class="id"> s</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> has_nthP</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> all_nthP</span><span class="id"> {T</span><span class="id"> a</span><span class="id"> s}</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> bitseq</span><span class="id"> :=</span><span class="id"> seq</span><span class="id"> bool</span>.<br/>
<span class="id">#[hnf]</span><span class="id"> HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Equality</span>.<span class="id">on</span><span class="id"> bitseq</span>.<br/>
<span class="vernacular">Canonical</span><span class="id"> bitseq_predType</span><span class="id"> :=</span><span class="vernacular"> Eval</span><span class="id"> hnf</span><span class="gallina-kwd"> in</span><span class="id"> [predType</span><span class="id"> of</span><span class="id"> bitseq]</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FindNth</span>.<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Variant</span><span class="id"> split_find_nth_spec</span><span class="id"> p</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FindNth</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> of</span><span class="id"> p</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> p</span><span class="id"> s1</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split_find_nth_spec</span><span class="id"> p</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> split_find_nth</span><span class="id"> x0</span><span class="id"> p</span><span class="id"> s</span> (<span class="id">i</span><span class="id"> :=</span><span class="id"> find</span><span class="id"> p</span><span class="id"> s</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">has</span><span class="id"> p</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> split_find_nth_spec</span><span class="id"> p</span><span class="id"> s</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>) (<span class="id">drop</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> s</span>) (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> p_s;</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> split_find_nth_spec</span><span class="id"> _</span><span class="id"> X]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span><span class="id"> s</span>).<br/>
<span class="id">rewrite</span> (<span class="id">drop_nth</span><span class="id"> x0</span><span class="id"> _</span>)<span class="id"> -?has_find//</span><span class="id"> -cat_rcons</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> constructor;</span><span class="id"> [apply:</span><span class="id"> nth_find</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> has_take</span><span class="id"> -?leqNgt]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variant</span><span class="id"> split_find_spec</span><span class="id"> p</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">FindSplit</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> of</span><span class="id"> p</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> p</span><span class="id"> s1</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split_find_spec</span><span class="id"> p</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> s1</span><span class="id"> s2</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> split_find</span><span class="id"> p</span><span class="id"> s</span> (<span class="id">i</span><span class="id"> :=</span><span class="id"> find</span><span class="id"> p</span><span class="id"> s</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">has</span><span class="id"> p</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> split_find_spec</span><span class="id"> p</span><span class="id"> s</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>) (<span class="id">drop</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> ?</span><span class="gallina-kwd"> in</span><span class="id"> i</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> case:</span><span class="id"> split_find_nth</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> constructor</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_rcons_cat_find</span><span class="id"> x0</span><span class="id"> p</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span> (<span class="id">s</span><span class="id"> :=</span><span class="id"> rcons</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">p</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> has</span><span class="id"> p</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span> (<span class="id">find</span><span class="id"> p</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pz</span><span class="id"> pNs1;</span><span class="id"> rewrite</span><span class="id"> /s</span> <span class="id"> cat_rcons</span><span class="id"> find_cat</span> (<span class="id">negPf</span><span class="id"> pNs1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_cat/=</span><span class="id"> pz</span><span class="id"> addn0</span><span class="id"> subnn</span><span class="id"> ltnn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FindNth</span>.<br/>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> incr_nth</span><span class="id"> v</span><span class="id"> i</span><span class="id"> {struct</span><span class="id"> i}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> v</span><span class="id"> is</span><span class="id"> n</span><span class="id"> ::</span><span class="id"> v'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> is</span><span class="id"> i'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> n</span><span class="id"> ::</span><span class="id"> incr_nth</span><span class="id"> v'</span><span class="id"> i'</span><span class="gallina-kwd"> else</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> ::</span><span class="id"> v'</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> ncons</span><span class="id"> i</span><span class="id"> 0</span><span class="id"> [::</span><span class="id"> 1]</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> incr_nth</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> nomatch</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_incr_nth</span><span class="id"> v</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> 0</span> (<span class="id">incr_nth</span><span class="id"> v</span><span class="id"> i</span>)<span class="id"> j</span><span class="id"> =</span> (<span class="id">i</span><span class="id"> ==</span><span class="id"> j</span>)<span class="id"> +</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> v</span><span class="id"> j</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> v</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> v</span><span class="id"> IHv]</span><span class="id"> [|i]</span><span class="id"> [|j]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?eqSS</span><span class="id"> ?addn0</span><span class="id"> //;</span><span class="id"> try</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> j</span>.<br/>
<span class="id">elim:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> IHv]</span><span class="id"> [|j]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?eqSS</span><span class="id"> //;</span><span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> j</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_incr_nth</span><span class="id"> v</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span> (<span class="id">incr_nth</span><span class="id"> v</span><span class="id"> i</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> v</span><span class="gallina-kwd"> then</span><span class="id"> size</span><span class="id"> v</span><span class="gallina-kwd"> else</span><span class="id"> i</span>.<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> v</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> v</span><span class="id"> IHv]</span><span class="id"> [|i]</span><span class="id"> //=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_ncons</span><span class="id"> /=</span><span class="id"> addn1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> IHv;</span><span class="id"> apply:</span><span class="id"> fun_if</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> incr_nth_inj</span><span class="id"> v</span><span class="id"> :</span><span class="id"> injective</span> (<span class="id">incr_nth</span><span class="id"> v</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">nth</span><span class="id"> 0</span><span class="id"> ^~</span><span class="id"> i</span>))<span class="id">;</span><span class="id"> apply:</span><span class="id"> contra_eq</span><span class="id"> =&gt;</span><span class="id"> neq_ij</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !nth_incr_nth</span><span class="id"> eqn_add2r</span><span class="id"> eqxx</span><span class="id"> /nat_of_bool</span><span class="id"> ifN_eqC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> incr_nthC</span><span class="id"> v</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">incr_nth</span> (<span class="id">incr_nth</span><span class="id"> v</span><span class="id"> i</span>)<span class="id"> j</span><span class="id"> =</span><span class="id"> incr_nth</span> (<span class="id">incr_nth</span><span class="id"> v</span><span class="id"> j</span>)<span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">@eq_from_nth</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id"> =&gt;</span><span class="id"> [|k</span><span class="id"> _];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !nth_incr_nth</span><span class="id"> addnCA</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> do</span><span class="id"> !rewrite</span><span class="id"> size_incr_nth</span><span class="id"> leqNgt</span><span class="id"> if_neg</span><span class="id"> -/</span>(<span class="id">maxn</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> maxnAC</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PermSeq</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">all</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2]</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permP</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">count^~</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> count^~</span><span class="id"> s2</span>) (<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> allP</span>)<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [eq_cnt1</span><span class="id"> a</span><span class="id"> |</span><span class="id"> eq_cnt</span><span class="id"> x</span><span class="id"> _];</span><span class="id"> last</span><span class="id"> exact/eqP</span>.<br/>
<span class="id">have</span><span class="id"> [n</span><span class="id"> le_an]</span><span class="id"> :=</span><span class="id"> ubnP</span> (<span class="id">count</span><span class="id"> a</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>))<span class="id">;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n</span><span class="id"> IHn</span><span class="gallina-kwd"> in</span><span class="id"> a</span><span class="id"> le_an</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> [/eqP|]</span><span class="id"> :=</span><span class="id"> posnP</span> (<span class="id">count</span><span class="id"> a</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> count_cat</span><span class="id"> addn_eq0;</span><span class="id"> do</span><span class="id"> 2!case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> -has_count</span><span class="id"> =&gt;</span><span class="id"> /hasP[x</span><span class="id"> s12x</span><span class="id"> a_x];</span><span class="id"> pose</span><span class="id"> a'</span><span class="id"> :=</span><span class="id"> predD1</span><span class="id"> a</span><span class="id"> x</span>.<br/>
<span class="id">have</span><span class="id"> cnt_a'</span><span class="id"> s:</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span><span class="id"> =</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s</span><span class="id"> +</span><span class="id"> count</span><span class="id"> a'</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -count_predUI</span><span class="id"> -[LHS]addn0</span><span class="id"> -</span>(<span class="id">count_pred0</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> +</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_count</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> !cnt_a'</span> (<span class="id">eqnP</span> (<span class="id">eq_cnt1</span><span class="id"> _</span><span class="id"> s12x</span>)) (<span class="id">IHn</span><span class="id"> a'</span>)<span class="id"> //</span><span class="id"> -ltnS</span>.<br/>
<span class="id">apply:</span><span class="id"> leq_trans</span><span class="id"> le_an</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> cnt_a'</span><span class="id"> -add1n</span><span class="id"> leq_add2r</span><span class="id"> -has_count</span><span class="id"> has_pred1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_refl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/permP</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> perm_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_sym</span><span class="id"> :</span><span class="id"> symmetric</span><span class="id"> perm_eq</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s1</span><span class="id"> s2;</span><span class="id"> apply/permP/permP=&gt;</span><span class="id"> eq_s12</span><span class="id"> a</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_trans</span><span class="id"> :</span><span class="id"> transitive</span><span class="id"> perm_eq</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> /permP-eq12</span><span class="id"> /permP/</span>(<span class="id">ftrans</span><span class="id"> eq12</span>)<span class="id">/permP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Notation</span><span class="id"> perm_eql</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span> (<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> perm_eq</span><span class="id"> s2</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> perm_eqr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span> (<span class="id">perm_eq^~</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> perm_eq^~</span><span class="id"> s2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permEl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eql</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permPl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">perm_eql</span><span class="id"> s1</span><span class="id"> s2</span>) (<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [eq12</span><span class="id"> s3</span><span class="id"> |</span><span class="id"> -&gt;</span><span class="id"> //];</span><span class="id"> apply/idP/idP;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> perm_trans</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">perm_sym</span><span class="id"> s3</span>)<span class="id"> =&gt;</span><span class="id"> /perm_trans;</span><span class="id"> apply</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permPr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">perm_eqr</span><span class="id"> s1</span><span class="id"> s2</span>) (<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/permPl</span><span class="id"> eq12</span><span class="id"> s3|</span><span class="id"> &lt;-</span><span class="id"> //];</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">perm_sym</span><span class="id"> s3</span>)<span class="id"> eq12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catC</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permPl/permP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> !count_cat</span><span class="id"> addnC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_cat2l</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>) (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> =</span><span class="id"> perm_eq</span><span class="id"> s2</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/permP/permP=&gt;</span><span class="id"> eq23</span><span class="id"> a;</span><span class="id"> apply/eqP;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(_<span class="id"> a</span>)<span class="id">/eqP:</span><span class="id"> eq23;</span><span class="id"> rewrite</span><span class="id"> !count_cat</span><span class="id"> eqn_add2l</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catl</span><span class="id"> s</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> -&gt;</span><span class="id"> perm_eql</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> t1</span>) (<span class="id">s</span><span class="id"> ++</span><span class="id"> t2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_t12;</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span><span class="id"> perm_cat2l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_cons</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">perm_cat2l</span><span class="id"> [::x]</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_cat2r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span>) (<span class="id">s3</span><span class="id"> ++</span><span class="id"> s1</span>)<span class="id"> =</span><span class="id"> perm_eq</span><span class="id"> s2</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> do</span><span class="id"> 2!rewrite</span><span class="id"> perm_sym</span><span class="id"> perm_catC;</span><span class="id"> apply:</span><span class="id"> perm_cat2l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eql</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> t</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_s12;</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span><span class="id"> perm_cat2r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> t1</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> t2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /perm_catr-&gt;</span><span class="id"> /perm_catl-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catAC</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> perm_eql</span> ((<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> ++</span><span class="id"> s3</span>) ((<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span><span class="id"> -!catA</span><span class="id"> perm_cat2l</span><span class="id"> perm_catC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catCA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s3</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span><span class="id"> !catA</span><span class="id"> perm_cat2r</span><span class="id"> perm_catC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_catACA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eql</span> ((<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> ++</span> (<span class="id">s3</span><span class="id"> ++</span><span class="id"> s4</span>)) ((<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> ++</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s4</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span><span class="id"> perm_catAC</span><span class="id"> !catA</span><span class="id"> perm_catAC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_rcons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> s2;</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> perm_catC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_rot</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /=</span><span class="id"> s2;</span><span class="id"> rewrite</span><span class="id"> perm_catC</span><span class="id"> cat_take_drop</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_rotr</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">rotr</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> perm_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/permPl/permP=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> count_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_filter</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s1</span>) (<span class="id">filter</span><span class="id"> a</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/permP=&gt;</span><span class="id"> s12_count;</span><span class="id"> apply/permP=&gt;</span><span class="id"> Q;</span><span class="id"> rewrite</span><span class="id"> !count_filter</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_filterC</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eql</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> filter</span> (<span class="id">predC</span><span class="id"> a</span>)<span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/permPl;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -cat1s</span><span class="id"> perm_catCA;</span><span class="id"> rewrite</span><span class="id"> perm_cons</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_size</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/permP=&gt;</span><span class="id"> eq12;</span><span class="id"> rewrite</span><span class="id"> -!count_predT</span><span class="id"> eq12</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_mem</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/permP=&gt;</span><span class="id"> eq12</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -!has_pred1</span><span class="id"> !has_count</span><span class="id"> eq12</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_nilP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">s</span><span class="id"> =</span><span class="id"> [::]</span>) (<span class="id">perm_eq</span><span class="id"> s</span><span class="id"> [::]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/perm_size/eqP/nilP</span><span class="id"> |</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_consP</span><span class="id"> x</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> i</span><span class="id"> u,</span><span class="id"> rot</span><span class="id"> i</span><span class="id"> t</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> u</span><span class="id"> /\</span><span class="id"> perm_eq</span><span class="id"> u</span><span class="id"> s</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">perm_eq</span><span class="id"> t</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [eq_txs</span><span class="id"> |</span><span class="id"> [i</span><span class="id"> [u</span><span class="id"> [Dt</span><span class="id"> eq_us]]]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /rot_to[i</span><span class="id"> u</span><span class="id"> Dt]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> t</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">perm_mem</span><span class="id"> eq_txs</span>)<span class="id"> mem_head</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>)<span class="id"> -Dt</span><span class="id"> perm_rot</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_rot</span><span class="id"> i</span>)<span class="id"> Dt</span><span class="id"> perm_cons</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_has</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> a</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/perm_mem/eq_has_r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_all</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> a</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/perm_mem/eq_all_r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_small_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> &lt;=</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s2_le1</span><span class="id"> eqs12;</span><span class="id"> move/perm_size:</span><span class="id"> eqs12</span><span class="id"> s2_le1</span> (<span class="id">perm_mem</span><span class="id"> eqs12</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> []]</span><span class="id"> //</span><span class="id"> [|y</span><span class="id"> []]</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /</span>(_<span class="id"> x</span>)<span class="id"> /[!</span>(<span class="id">inE,</span><span class="id"> eqxx</span>)<span class="id">]</span><span class="id"> /eqP-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_leq_size</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> IHs</span><span class="id"> s2</span><span class="id"> /andP[not_s1x</span><span class="id"> Us1]</span><span class="id"> /forall_cons[s2x</span><span class="id"> ss12]</span>.<br/>
<span class="id">have</span><span class="id"> [i</span><span class="id"> s3</span><span class="id"> def_s2]</span><span class="id"> :=</span><span class="id"> rot_to</span><span class="id"> s2x;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">size_rot</span><span class="id"> i</span><span class="id"> s2</span>)<span class="id"> def_s2</span>.<br/>
<span class="id">apply:</span><span class="id"> IHs</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> s1y;</span><span class="id"> have:=</span><span class="id"> ss12</span><span class="id"> y</span><span class="id"> s1y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mem_rot</span><span class="id"> i</span>)<span class="id"> def_s2</span><span class="id"> inE</span> (<span class="id">negPf</span> (<span class="id">memPn</span><span class="id"> _</span><span class="id"> y</span><span class="id"> s1y</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_size_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [[]</span><span class="id"> |</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> IHs</span><span class="id"> s2]</span><span class="id"> //</span><span class="id"> Us1x;</span><span class="id"> have</span><span class="id"> /andP[not_s1x</span><span class="id"> Us1]</span><span class="id"> :=</span><span class="id"> Us1x</span>.<br/>
<span class="id">case/forall_cons</span><span class="id"> =&gt;</span><span class="id"> /rot_to[i</span><span class="id"> s3</span><span class="id"> def_s2]</span><span class="id"> ss12</span><span class="id"> le_s21</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">rot_uniq</span><span class="id"> i</span>)<span class="id"> -</span>(<span class="id">size_rot</span><span class="id"> i</span>)<span class="id"> def_s2</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> le_s21</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> ss13</span><span class="id"> y</span> (<span class="id">s1y</span><span class="id"> :</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> s1</span>)<span class="id">:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> s3</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have:=</span><span class="id"> ss12</span><span class="id"> y</span><span class="id"> s1y;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mem_rot</span><span class="id"> i</span>)<span class="id"> def_s2</span><span class="id"> inE</span> (<span class="id">negPf</span> (<span class="id">memPn</span><span class="id"> _</span><span class="id"> y</span><span class="id"> s1y</span>)).<br/>
<span class="id">rewrite</span><span class="id"> IHs</span><span class="id"> //</span><span class="id"> andbT;</span><span class="id"> apply:</span><span class="id"> contraL</span><span class="id"> _</span><span class="id"> le_s21</span><span class="id"> =&gt;</span><span class="id"> s3x;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">uniq_leq_size</span><span class="id"> Us1x</span>)<span class="id">/allP;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> s3x;</span><span class="id"> apply/allP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_size_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> s2</span><span class="id"> ==</span><span class="id"> size</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Us1</span><span class="id"> eqs12;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [Us2</span><span class="id"> |</span><span class="id"> /eqP</span><span class="id"> eq_sz12]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> !uniq_leq_size</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> eqs12</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">leq_size_uniq</span><span class="id"> Us1</span>)<span class="id"> =&gt;</span><span class="id"> [y|];</span><span class="id"> rewrite</span> (<span class="id">eqs12,</span><span class="id"> eq_sz12</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_min_size</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span>)<span class="id"> *</span> (<span class="id">s1</span><span class="id"> =i</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Us1</span><span class="id"> ss12</span><span class="id"> le_s21;</span><span class="id"> have</span><span class="id"> Us2:</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> :=</span><span class="id"> leq_size_uniq</span><span class="id"> Us1</span><span class="id"> ss12</span><span class="id"> le_s21</span>.<br/>
<span class="id">suffices:</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="gallina-kwd"> by</span><span class="id"> split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -uniq_size_uniq</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> x;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [/ss12//</span><span class="id"> |</span><span class="id"> s2x];</span><span class="id"> apply:</span><span class="id"> contraLR</span><span class="id"> le_s21</span><span class="id"> =&gt;</span><span class="id"> not_s1x</span>.<br/>
<span class="id">rewrite</span><span class="id"> -ltnNge</span> (<span class="id">@uniq_leq_size</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>))<span class="id"> /=</span><span class="id"> ?not_s1x</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/allP;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> s2x;</span><span class="id"> apply/allP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> uniq</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_sz12</span><span class="id"> eq_s12</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> Us;</span><span class="id"> rewrite</span> (<span class="id">uniq_size_uniq</span><span class="id"> Us</span>)<span class="id"> ?eq_sz12</span><span class="id"> ?eqxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> uniq</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_s12;</span><span class="id"> apply/eq_uniq;</span><span class="id"> [apply/perm_size</span><span class="id"> |</span><span class="id"> apply/perm_mem]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_perm</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Us1</span><span class="id"> Us2</span><span class="id"> eq12;</span><span class="id"> apply/allP=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> apply/eqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !count_uniq_mem</span><span class="id"> ?eq12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_undup</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">undup</span><span class="id"> s1</span>) (<span class="id">undup</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Es12;</span><span class="id"> rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?undup_uniq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> !mem_undup</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_mem_uniq</span><span class="id"> s</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>))<span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> count1_s;</span><span class="id"> have</span><span class="id"> Uus</span><span class="id"> :=</span><span class="id"> undup_uniq</span><span class="id"> s</span>.<br/>
<span class="id">suffices:</span><span class="id"> perm_eq</span><span class="id"> s</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="gallina-kwd"> by</span><span class="id"> move/perm_uniq-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/allP=&gt;</span><span class="id"> x</span><span class="id"> _;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span> (<span class="id">count_uniq_mem</span><span class="id"> x</span><span class="id"> Uus</span>)<span class="id"> mem_undup</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_count_undup</span><span class="id"> a</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> a,</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2}</span><span class="id"> -&gt;</span><span class="id"> count</span><span class="id"> a</span> (<span class="id">undup</span><span class="id"> s1</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> a</span> (<span class="id">undup</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s1_eq_s2;</span><span class="id"> rewrite</span><span class="id"> -!size_filter</span><span class="id"> !filter_undup</span>.<br/>
<span class="id">apply/perm_size/perm_undup</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !mem_filter;</span><span class="id"> case:</span> (<span class="id">boolP</span> (<span class="id">a</span><span class="id"> x</span>))<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> /s1_eq_s2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catCA_perm_ind</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3,</span><span class="id"> P</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> -&gt;</span><span class="id"> P</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s3</span>))<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> s1</span><span class="id"> s2,</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> P</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> PcatCA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> eq_s12;</span><span class="id"> rewrite</span><span class="id"> -[s1]cats0</span><span class="id"> -[s2]cats0</span>.<br/>
<span class="id">elim:</span><span class="id"> s2</span><span class="id"> nil</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2</span><span class="id"> IHs]</span><span class="id"> s3</span><span class="gallina-kwd"> in</span><span class="id"> s1</span><span class="id"> eq_s12</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> s1</span><span class="id"> {eq_s12}</span>(<span class="id">perm_size</span><span class="id"> eq_s12</span>).<br/>
<span class="id">have</span><span class="id"> /rot_to[i</span><span class="id"> s'</span><span class="id"> def_s1]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">perm_mem</span><span class="id"> eq_s12</span>)<span class="id"> mem_head</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">cat_take_drop</span><span class="id"> i</span><span class="id"> s1</span>)<span class="id"> -catA</span><span class="id"> =&gt;</span><span class="id"> /PcatCA</span>.<br/>
<span class="id">rewrite</span><span class="id"> catA</span><span class="id"> -/</span>(<span class="id">rot</span><span class="id"> i</span><span class="id"> s1</span>)<span class="id"> def_s1</span><span class="id"> /=</span><span class="id"> -cat1s</span><span class="id"> =&gt;</span><span class="id"> /PcatCA/IHs/PcatCA;</span><span class="id"> apply</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>)<span class="id"> -def_s1</span><span class="id"> perm_rot</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catCA_perm_subst</span><span class="id"> R</span><span class="id"> F</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3,</span><span class="id"> F</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> =</span><span class="id"> F</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> :&gt;</span><span class="id"> R</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> s1</span><span class="id"> s2,</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> F</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> F</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> FcatCA</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /catCA_perm_ind</span><span class="id"> =&gt;</span><span class="id"> ind_s12</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">ind_s12</span> (<span class="id">eq</span><span class="id"> _</span><span class="id"> \o</span><span class="id"> F</span>))<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> FcatCA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> PermSeq</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> perm_eql</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span> (<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> perm_eq</span><span class="id"> s2</span>).<br/>
<span class="vernacular">Notation</span><span class="id"> perm_eqr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span> (<span class="id">perm_eq^~</span><span class="id"> s1</span><span class="id"> =1</span><span class="id"> perm_eq^~</span><span class="id"> s2</span>).<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> permP</span><span class="id"> {T</span><span class="id"> s1</span><span class="id"> s2}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> permPl</span><span class="id"> {T</span><span class="id"> s1</span><span class="id"> s2}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> permPr</span><span class="id"> {T</span><span class="id"> s1</span><span class="id"> s2}</span>.<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> perm_eq</span>.<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> perm_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RotrLemmas</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T'</span><span class="id"> :</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_rotr</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">rotr</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rotr</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T'</span>)<span class="id"> :</span><span class="id"> rotr</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> =i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mem_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotr_size_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> rotr</span> (<span class="id">size</span><span class="id"> s2</span>) (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rotr</span><span class="id"> size_cat</span><span class="id"> addnK</span><span class="id"> rot_size_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotr1_rcons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rotr</span><span class="id"> 1</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -rot1_cons</span><span class="id"> rotK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_rotr</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">rotr</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> has_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotr_uniq</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T'</span>)<span class="id"> :</span><span class="id"> uniq</span> (<span class="id">rotr</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rot_uniq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotrK</span><span class="id"> :</span><span class="id"> cancel</span> (<span class="id">@rotr</span><span class="id"> T</span><span class="id"> n0</span>) (<span class="id">rot</span><span class="id"> n0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s;</span><span class="id"> have</span><span class="id"> [lt_n0s</span><span class="id"> |</span><span class="id"> ge_n0s]</span><span class="id"> :=</span><span class="id"> ltnP</span><span class="id"> n0</span> (<span class="id">size</span><span class="id"> s</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">subKn</span> (<span class="id">ltnW</span><span class="id"> lt_n0s</span>))<span class="id"> -{1}[size</span><span class="id"> s]size_rotr;</span><span class="id"> apply:</span><span class="id"> rotK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> RHS]</span>(<span class="id">rot_oversize</span><span class="id"> ge_n0s</span>)<span class="id"> /rotr</span> (<span class="id">eqnP</span><span class="id"> ge_n0s</span>)<span class="id"> rot0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotr_inj</span><span class="id"> :</span><span class="id"> injective</span> (<span class="id">@rotr</span><span class="id"> T</span><span class="id"> n0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact</span> (<span class="id">can_inj</span><span class="id"> rotrK</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> n0</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rev</span> (<span class="id">drop</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n0</span>)<span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> -</span><span class="id"> n0;</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> LHS]</span>(<span class="id">cat_take_drop</span><span class="id"> m</span>)<span class="id"> rev_cat</span><span class="id"> take_cat</span>.<br/>
<span class="id">rewrite</span><span class="id"> size_rev</span><span class="id"> size_drop</span><span class="id"> -minnE</span><span class="id"> minnC</span><span class="id"> leq_min</span><span class="id"> ltnn</span><span class="id"> /m</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_|/eqnP-&gt;]</span><span class="id"> :=</span><span class="id"> ltnP;</span><span class="id"> rewrite</span><span class="id"> ?subnn</span><span class="id"> take0</span><span class="id"> cats0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_take</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> drop</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n0</span>) (<span class="id">rev</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> take</span><span class="id"> _</span><span class="id"> s]revK</span><span class="id"> take_rev</span><span class="id"> revK</span><span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> n0</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rev</span> (<span class="id">take</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n0</span>)<span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">set</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> -</span><span class="id"> n0;</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> LHS]</span>(<span class="id">cat_take_drop</span><span class="id"> m</span>)<span class="id"> rev_cat</span><span class="id"> drop_cat</span>.<br/>
<span class="id">rewrite</span><span class="id"> size_rev</span><span class="id"> size_drop</span><span class="id"> -minnE</span><span class="id"> minnC</span><span class="id"> leq_min</span><span class="id"> ltnn</span><span class="id"> /m</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_|/eqnP-&gt;]</span><span class="id"> :=</span><span class="id"> ltnP;</span><span class="id"> rewrite</span><span class="id"> ?take0</span><span class="id"> //</span><span class="id"> subnn</span><span class="id"> drop0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_drop</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> take</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> n0</span>) (<span class="id">rev</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> drop</span><span class="id"> _</span><span class="id"> s]revK</span><span class="id"> drop_rev</span><span class="id"> revK</span><span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_rotr</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">rotr</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span><span class="id"> n0</span> (<span class="id">rev</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rev_cat</span><span class="id"> -take_rev</span><span class="id"> -drop_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_rot</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rev</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rotr</span><span class="id"> n0</span> (<span class="id">rev</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> canLR</span><span class="id"> revK</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> rev_rotr</span><span class="id"> revK</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RotrLemmas</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> rotrK</span><span class="id"> n0</span><span class="id"> {T}</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> rotr_inj</span><span class="id"> {n0</span><span class="id"> T}</span><span class="id"> [s1</span><span class="id"> s2]</span><span class="id"> eq_rotr_s12</span><span class="id"> :</span><span class="id"> rename</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> RotCompLemmas</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotD</span><span class="id"> m</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> m</span><span class="id"> +</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rot</span> (<span class="id">m</span><span class="id"> +</span><span class="id"> n</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> rot</span><span class="id"> m</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sz_s;</span><span class="id"> rewrite</span><span class="id"> [LHS]/rot</span><span class="id"> -[take</span><span class="id"> _</span><span class="id"> s]</span>(<span class="id">cat_take_drop</span><span class="id"> n</span>).<br/>
<span class="id">rewrite</span><span class="id"> 5!</span>(<span class="id">catA,</span><span class="id"> =^~</span><span class="id"> rot_size_cat</span>)<span class="id"> !cat_take_drop</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_drop</span><span class="id"> !size_takel</span><span class="id"> ?leq_addl</span><span class="id"> ?addnK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotS</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rot</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> rot</span><span class="id"> 1</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">@rotD</span><span class="id"> 1</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_add_mod</span><span class="id"> m</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> m</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">rot</span><span class="id"> m</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span> (<span class="gallina-kwd">if</span><span class="id"> m</span><span class="id"> +</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> m</span><span class="id"> +</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> m</span><span class="id"> +</span><span class="id"> n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Hn</span><span class="id"> Hm;</span><span class="id"> case:</span><span class="id"> leqP</span><span class="id"> =&gt;</span><span class="id"> [/rotD</span><span class="id"> //</span><span class="id"> |</span><span class="id"> /ltnW</span><span class="id"> Hmn];</span><span class="id"> symmetry</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">rotK</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> /rotr</span><span class="id"> -rotD</span><span class="id"> size_rot</span><span class="id"> addnBA</span><span class="id"> ?subnK</span><span class="id"> ?addnK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_minn</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =</span><span class="id"> rot</span> (<span class="id">minn</span><span class="id"> n</span> (<span class="id">size</span><span class="id"> s</span>))<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">leqP</span><span class="id"> n</span> (<span class="id">size</span><span class="id"> s</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /leqW</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> rot_size</span><span class="id"> rot_oversize</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> rot_add</span><span class="id"> s</span><span class="id"> n</span><span class="id"> m</span> (<span class="id">k</span><span class="id"> :=</span><span class="id"> size</span><span class="id"> s</span>) (<span class="id">p</span><span class="id"> :=</span><span class="id"> minn</span><span class="id"> m</span><span class="id"> k</span><span class="id"> +</span><span class="id"> minn</span><span class="id"> n</span><span class="id"> k</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">locked</span> (<span class="gallina-kwd">if</span><span class="id"> p</span><span class="id"> &lt;=</span><span class="id"> k</span><span class="gallina-kwd"> then</span><span class="id"> p</span><span class="gallina-kwd"> else</span><span class="id"> p</span><span class="id"> -</span><span class="id"> k</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_rot_add</span><span class="id"> n</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot_add</span><span class="id"> s</span><span class="id"> n</span><span class="id"> m</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> unlock</span><span class="id"> rot_add;</span><span class="id"> case:</span><span class="id"> ifP;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> leq_subLR</span><span class="id"> leq_add</span><span class="id"> //</span><span class="id"> geq_minr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_addC</span><span class="id"> n</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot_add</span><span class="id"> s</span><span class="id"> n</span><span class="id"> m</span><span class="id"> =</span><span class="id"> rot_add</span><span class="id"> s</span><span class="id"> m</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> unlock</span><span class="id"> rot_add;</span><span class="id"> rewrite</span><span class="id"> ![minn</span><span class="id"> n</span><span class="id"> _</span><span class="id"> +</span><span class="id"> _]addnC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_rot_add</span><span class="id"> n</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> m</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span> (<span class="id">rot_add</span><span class="id"> s</span><span class="id"> n</span><span class="id"> m</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">unlock</span><span class="id"> rot_add</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">rot_minn</span><span class="id"> n</span>) (<span class="id">rot_minn</span><span class="id"> m</span>)<span class="id"> rot_add_mod</span><span class="id"> ?size_rot</span><span class="id"> ?geq_minr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_rot</span><span class="id"> m</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> m</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span><span class="id"> n</span> (<span class="id">rot</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> rot_rot_add</span><span class="id"> rot_addC</span><span class="id"> -rot_rot_add</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rot_rotr</span><span class="id"> m</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rot</span><span class="id"> m</span> (<span class="id">rotr</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rotr</span><span class="id"> n</span> (<span class="id">rot</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [RHS]/rotr</span><span class="id"> size_rot</span><span class="id"> rot_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rotr_rotr</span><span class="id"> m</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rotr</span><span class="id"> m</span> (<span class="id">rotr</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rotr</span><span class="id"> n</span> (<span class="id">rotr</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rotr</span><span class="id"> !size_rot</span><span class="id"> rot_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> RotCompLemmas</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Mask</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">m</span><span class="id"> :</span><span class="id"> bitseq</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> {struct</span><span class="id"> m}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> m,</span><span class="id"> s</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> b</span><span class="id"> ::</span><span class="id"> m',</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="id"> =&gt;</span><span class="gallina-kwd"> if</span><span class="id"> b</span><span class="gallina-kwd"> then</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> mask</span><span class="id"> m'</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> mask</span><span class="id"> m'</span><span class="id"> s'</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> [::]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_false</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> mask</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> false</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_true</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> mask</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> true</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span><span class="id"> Hn;</span><span class="id"> congr</span> (_<span class="id"> ::</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask0</span><span class="id"> m</span><span class="id"> :</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> [::]</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> m</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> mask</span><span class="id"> [::]</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [::]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask1</span><span class="id"> b</span><span class="id"> x</span><span class="id"> :</span><span class="id"> mask</span><span class="id"> [::</span><span class="id"> b]</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> nseq</span><span class="id"> b</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_cons</span><span class="id"> b</span><span class="id"> m</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> mask</span> (<span class="id">b</span><span class="id"> ::</span><span class="id"> m</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> nseq</span><span class="id"> b</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> id</span><span class="id"> m</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> m</span><span class="id"> s;</span><span class="id"> apply:</span><span class="id"> seq_ind2</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> x</span><span class="id"> m</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_cat</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> m1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> -&gt;</span><span class="id"> mask</span> (<span class="id">m1</span><span class="id"> ++</span><span class="id"> m2</span>) (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> mask</span><span class="id"> m1</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> mask</span><span class="id"> m2</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> m1</span><span class="id"> s1;</span><span class="id"> apply:</span><span class="id"> seq_ind2</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> m1</span><span class="id"> x1</span><span class="id"> s1</span><span class="id"> /=</span><span class="id"> _</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_rcons</span><span class="id"> b</span><span class="id"> m</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">mask</span> (<span class="id">rcons</span><span class="id"> m</span><span class="id"> b</span>) (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> nseq</span><span class="id"> b</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ms;</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> mask_cat//;</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_mask</span><span class="id"> a</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|[]</span><span class="id"> m]//=</span><span class="id"> /andP[ax</span><span class="id"> /IHs-&gt;];</span><span class="id"> rewrite</span><span class="id"> ?ax</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_mask_cons</span><span class="id"> a</span><span class="id"> b</span><span class="id"> m</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">has</span><span class="id"> a</span> (<span class="id">mask</span> (<span class="id">b</span><span class="id"> ::</span><span class="id"> m</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>))<span class="id"> =</span><span class="id"> b</span><span class="id"> &amp;&amp;</span><span class="id"> a</span><span class="id"> x</span><span class="id"> ||</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_mask</span><span class="id"> a</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> -&gt;</span><span class="id"> has</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/contraTT;</span><span class="id"> rewrite</span><span class="id"> -!all_predC;</span><span class="id"> apply:</span><span class="id"> all_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rev</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> mask</span> (<span class="id">rev</span><span class="id"> m</span>) (<span class="id">rev</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> m</span><span class="id"> s;</span><span class="id"> apply:</span><span class="id"> seq_ind2</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> b</span><span class="id"> x</span><span class="id"> m</span><span class="id"> s</span><span class="id"> eq_size_sm</span><span class="id"> IH</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !rev_cons</span><span class="id"> mask_rcons</span><span class="id"> ?IH</span><span class="id"> ?size_rev//</span> (<span class="id">cats1,</span><span class="id"> cats0</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_rot</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">mask</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> m</span>) (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span> (<span class="id">count</span><span class="id"> id</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> m</span>)) (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Ems;</span><span class="id"> rewrite</span><span class="id"> mask_cat</span><span class="id"> ?size_drop</span><span class="id"> ?Ems</span><span class="id"> //</span><span class="id"> -rot_size_cat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_mask</span><span class="id"> -?mask_cat</span><span class="id"> ?size_take</span><span class="id"> ?Ems</span><span class="id"> //</span><span class="id"> !cat_take_drop</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> resize_mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {m1</span><span class="id"> |</span><span class="id"> size</span><span class="id"> m1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span><span class="id"> mask</span><span class="id"> m1</span><span class="id"> s}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="id">take</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> m</span><span class="id"> ++</span><span class="id"> nseq</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> size</span><span class="id"> m</span>)<span class="id"> false</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|b</span><span class="id"> m]</span><span class="id"> //=;</span><span class="id"> rewrite</span> (<span class="id">size_nseq,</span><span class="id"> IHs</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|b</span><span class="id"> m]</span><span class="id"> //=;</span><span class="id"> rewrite</span> (<span class="id">mask_false,</span><span class="id"> IHs</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> takeEmask</span><span class="id"> i</span><span class="id"> s</span><span class="id"> :</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =</span><span class="id"> mask</span> (<span class="id">nseq</span><span class="id"> i</span><span class="id"> true</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [s|i</span><span class="id"> IHi</span><span class="id"> []//</span><span class="id"> ?</span><span class="id"> ?];</span><span class="id"> rewrite</span><span class="id"> ?take0</span><span class="id"> //=</span><span class="id"> IHi</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dropEmask</span><span class="id"> i</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =</span><span class="id"> mask</span> (<span class="id">nseq</span><span class="id"> i</span><span class="id"> false</span><span class="id"> ++</span><span class="id"> nseq</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> i</span>)<span class="id"> true</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [s|?</span><span class="id"> ?</span><span class="id"> []//];</span><span class="id"> rewrite</span><span class="id"> drop0/=</span><span class="id"> mask_true//</span><span class="id"> subn0</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Mask</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> mask</span><span class="id"> _</span><span class="id"> !_</span><span class="id"> !_</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqMask</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">m</span><span class="id"> :</span><span class="id"> bitseq</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_mask_cons</span><span class="id"> x</span><span class="id"> b</span><span class="id"> m</span><span class="id"> y</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">x</span><span class="id"> \in</span><span class="id"> mask</span> (<span class="id">b</span><span class="id"> ::</span><span class="id"> m</span>) (<span class="id">y</span><span class="id"> ::</span><span class="id"> s</span>))<span class="id"> =</span><span class="id"> b</span><span class="id"> &amp;&amp;</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> ||</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> b</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_mask</span><span class="id"> x</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!has_pred1</span><span class="id"> =&gt;</span><span class="id"> /has_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> in_mask</span><span class="id"> x</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id"> &amp;&amp;</span><span class="id"> nth</span><span class="id"> false</span><span class="id"> m</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|[]</span><span class="id"> m]//=</span><span class="id"> /andP[yNs</span><span class="id"> ?];</span><span class="id"> rewrite</span><span class="id"> ?in_cons</span><span class="id"> ?IHs</span><span class="id"> //=;</span><br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [-&gt;|neq_xy]</span><span class="id"> //=</span><span class="id"> :=</span><span class="id"> eqVneq;</span><span class="id"> rewrite</span><span class="id"> ?andbF</span><span class="id"> //</span> (<span class="id">negPf</span><span class="id"> yNs</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> m,</span><span class="id"> uniq</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> Uxs</span><span class="id"> [|b</span><span class="id"> m]</span><span class="id"> //=</span>.<br/>
<span class="id">case:</span><span class="id"> b</span><span class="id"> Uxs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> /andP[s'x</span><span class="id"> Us];</span><span class="id"> rewrite</span><span class="id"> {}IHs</span><span class="id"> //</span><span class="id"> andbT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> s'x;</span><span class="id"> apply:</span><span class="id"> mem_mask</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_mask_rot</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> mask</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> m</span>) (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =i</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ems</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> mask_rot</span><span class="id"> //</span><span class="id"> mem_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqMask</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Subseq</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s2</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s2'</span><span class="gallina-kwd"> then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s1</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1'</span><span class="gallina-kwd"> then</span><span class="id"> subseq</span> (<span class="gallina-kwd">if</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> y</span><span class="gallina-kwd"> then</span><span class="id"> s1'</span><span class="gallina-kwd"> else</span><span class="id"> s1</span>)<span class="id"> s2'</span><span class="gallina-kwd"> else</span><span class="id"> true</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub0seq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> [::]</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_refl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> subseq_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseqP</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> m,</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> &amp;</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s2</span>) (<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2</span><span class="id"> IHs2]</span><span class="id"> [|x</span><span class="id"> s1]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span><span class="id"> [::]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> right=&gt;</span><span class="id"> -[m</span><span class="id"> /eqP/nilP-&gt;]</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="gallina-kwd"> exists</span> (<span class="id">nseq</span> (<span class="id">size</span><span class="id"> s2</span>).<span class="id">+1</span><span class="id"> false</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?size_nseq</span><span class="id"> //=</span><span class="id"> mask_false</span>.<br/>
<span class="id">apply:</span><span class="id"> {IHs2}</span>(<span class="id">iffP</span> (<span class="id">IHs2</span><span class="id"> _</span>))<span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> [m</span><span class="id"> sz_m</span><span class="id"> def_s1]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> ((<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> ::</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> ?sz_m</span><span class="id"> //</span><span class="id"> -def_s1;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> |</span><span class="id"> ne_xy];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> m</span><span class="id"> def_s1</span><span class="id"> sz_m</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m]</span><span class="id"> //;</span><span class="id"> [case</span><span class="id"> |</span><span class="id"> move=&gt;</span><span class="id"> -&gt;</span><span class="id"> [&lt;-];</span><span class="gallina-kwd"> exists</span><span class="id"> m]</span>.<br/>
<span class="id">pose</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> index</span><span class="id"> true</span><span class="id"> m;</span><span class="id"> have</span><span class="id"> def_m_i:</span><span class="id"> take</span><span class="id"> i</span><span class="id"> m</span><span class="id"> =</span><span class="id"> nseq</span> (<span class="id">size</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> m</span>))<span class="id"> false</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/all_pred1P;</span><span class="id"> apply/</span>(<span class="id">all_nthP</span><span class="id"> true</span>)<span class="id"> =&gt;</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_take</span><span class="id"> ltnNge</span><span class="id"> geq_min</span><span class="id"> negb_or</span><span class="id"> -ltnNge</span><span class="id"> =&gt;</span><span class="id"> /andP[lt_j_i</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> nth_take</span><span class="id"> //=</span><span class="id"> -negb_add</span><span class="id"> addbF</span><span class="id"> -addbT</span><span class="id"> -negb_eqb</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [_</span><span class="id"> ==</span><span class="id"> _]</span>(<span class="id">before_find</span><span class="id"> _</span><span class="id"> lt_j_i</span>).<br/>
<span class="id">have</span><span class="id"> lt_i_m:</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> m</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltnNge;</span><span class="id"> apply/negP=&gt;</span><span class="id"> le_m_i;</span><span class="id"> rewrite</span><span class="id"> take_oversize</span><span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> def_m_i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> def_m_i</span><span class="id"> mask_false</span><span class="gallina-kwd"> in</span><span class="id"> def_s1</span>.<br/>
<span class="id">rewrite</span><span class="id"> size_take</span><span class="id"> lt_i_m</span><span class="gallina-kwd"> in</span><span class="id"> def_m_i</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> m</span><span class="id"> ++</span><span class="id"> drop</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> m</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> size_cat</span><span class="id"> size_take</span><span class="id"> size_drop</span><span class="id"> lt_i_m</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sz_m</span><span class="gallina-kwd"> in</span><span class="id"> lt_i_m</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> subnKC</span>.<br/>
<span class="id">rewrite</span><span class="id"> {s1</span><span class="id"> def_s1}[s1]</span>(<span class="id">congr1</span><span class="id"> behead</span><span class="id"> def_s1</span>).<br/>
<span class="id">rewrite</span><span class="id"> -[s2]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>)<span class="id"> -[m</span><span class="gallina-kwd"> in</span><span class="id"> LHS]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>)<span class="id"> {}def_m_i</span><span class="id"> -cat_cons</span>.<br/>
<span class="id">have</span><span class="id"> sz_i_s2:</span><span class="id"> size</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> i</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> size_takel;</span><span class="id"> rewrite</span><span class="id"> sz_m</span><span class="gallina-kwd"> in</span><span class="id"> lt_i_m</span>.<br/>
<span class="id">rewrite</span><span class="id"> lastI</span><span class="id"> cat_rcons</span><span class="id"> !mask_cat</span><span class="id"> ?size_nseq</span><span class="id"> ?size_belast</span><span class="id"> ?mask_false</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">drop_nth</span><span class="id"> true</span>)<span class="id"> //</span><span class="id"> nth_index</span><span class="id"> -?index_mem</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_subseq</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/subseqP;</span><span class="id"> have</span><span class="id"> [m1]</span><span class="id"> :=</span><span class="id"> resize_mask</span><span class="id"> m</span><span class="id"> s;</span><span class="gallina-kwd"> exists</span><span class="id"> m1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_trans</span><span class="id"> :</span><span class="id"> transitive</span><span class="id"> subseq</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> s</span><span class="id"> /subseqP[m2</span><span class="id"> _</span><span class="id"> -&gt;]</span><span class="id"> /subseqP[m1</span><span class="id"> _</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="gallina-kwd"> in</span><span class="id"> m2</span><span class="id"> m1</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !mask0</span>.<br/>
<span class="id">case:</span><span class="id"> m1</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m1];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mask0</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> m2</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m2]</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> IHs</span>.<br/>
&nbsp;&nbsp;<span class="id">case/subseqP:</span> (<span class="id">IHs</span><span class="id"> m2</span><span class="id"> m1</span>)<span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> sz_m</span><span class="id"> def_s;</span><span class="id"> apply/subseqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">false</span><span class="id"> ::</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> sz_m</span>.<br/>
<span class="id">case/subseqP:</span> (<span class="id">IHs</span><span class="id"> m2</span><span class="id"> m1</span>)<span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> sz_m</span><span class="id"> def_s;</span><span class="id"> apply/subseqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">false</span><span class="id"> ::</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> sz_m</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cat_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> subseq</span><span class="id"> s2</span><span class="id"> s4</span><span class="id"> -&gt;</span><span class="id"> subseq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>) (<span class="id">s3</span><span class="id"> ++</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/subseqP=&gt;</span><span class="id"> m1</span><span class="id"> sz_m1</span><span class="id"> -&gt;</span><span class="id"> /subseqP</span><span class="id"> [m2</span><span class="id"> sz_m2</span><span class="id"> -&gt;];</span><span class="id"> apply/subseqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">m1</span><span class="id"> ++</span><span class="id"> m2</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?size_cat</span><span class="id"> ?mask_cat</span><span class="id"> ?sz_m1</span><span class="id"> ?sz_m2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s1</span><span class="gallina-kwd"> in</span><span class="id"> subseq</span><span class="id"> s1]cats0</span><span class="id"> cat_subseq</span><span class="id"> ?sub0seq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s2</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cat_subseq</span> (<span class="id">sub0seq</span><span class="id"> s1</span>)<span class="id"> _</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_subseq</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> subseq</span><span class="id"> _</span><span class="id"> X]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>)<span class="id"> prefix_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_subseq</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> X</span><span class="gallina-kwd"> in</span><span class="id"> subseq</span><span class="id"> _</span><span class="id"> X]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>)<span class="id"> suffix_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/subseqP=&gt;</span><span class="id"> m</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> mem_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub1seq</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> /[1!inE];</span><span class="id"> case:</span><span class="id"> ifP;</span><span class="id"> rewrite</span><span class="id"> ?sub0seq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/subseqP=&gt;</span><span class="id"> m</span><span class="id"> sz_m</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> size_mask</span><span class="id"> -sz_m</span><span class="id"> ?count_size</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_subseq_leqif</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> ?=</span><span class="id"> iff</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sub12;</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> size_subseq</span>.<br/>
<span class="id">apply/idP/eqP=&gt;</span><span class="id"> [|-&gt;</span><span class="id"> //];</span><span class="id"> case/subseqP:</span><span class="id"> sub12</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> sz_m</span><span class="id"> -&gt;{s1}</span>.<br/>
<span class="id">rewrite</span><span class="id"> size_mask</span><span class="id"> -sz_m</span><span class="id"> //</span><span class="id"> -all_count</span><span class="id"> -</span>(<span class="id">eq_all</span><span class="id"> eqb_id</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">@all_pred1P</span><span class="id"> _</span><span class="id"> true</span>)<span class="id">-&gt;;</span><span class="id"> rewrite</span><span class="id"> sz_m</span><span class="id"> mask_true</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_anti</span><span class="id"> :</span><span class="id"> antisymmetric</span><span class="id"> subseq</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /andP[]</span><span class="id"> /size_subseq_leqif</span><span class="id"> /leqifP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [//|_]</span><span class="id"> +</span><span class="id"> /size_subseq;</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> =&gt;</span><span class="id"> /negP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_cons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> suffix_subseq</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cons_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/subseq_trans/subseq_cons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> prefix_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/subseqP=&gt;</span><span class="id"> m</span><span class="id"> _</span><span class="id"> -&gt;</span><span class="id"> Us2;</span><span class="id"> apply:</span><span class="id"> mask_uniq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_uniq</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/subseq_uniq/take_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_uniq</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">drop</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/subseq_uniq/drop_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_subseq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> case:</span> (_<span class="id"> \in</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">undup</span><span class="id"> s</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> u;</span><span class="id"> case:</span> (_<span class="id"> ==</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> cons_subseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_rev</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">wlog</span><span class="id"> suff</span><span class="id"> W</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> subseq</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> /W</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> !revK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/subseqP</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> size_m</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> rev_mask</span><span class="id"> //</span><span class="id"> mask_subseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_cat2l</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> s1</span>) (<span class="id">s</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> !cat_cons</span><span class="id"> /=</span><span class="id"> eqxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_cat2r</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subseq_rev</span><span class="id"> !rev_cat</span><span class="id"> subseq_cat2l</span><span class="id"> subseq_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_rot</span><span class="id"> p</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subseq</span><span class="id"> p</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> &amp;</span><span class="id"> subseq</span> (<span class="id">rot</span><span class="id"> k</span><span class="id"> p</span>) (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /subseqP[m</span><span class="id"> size_m</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">count</span><span class="id"> id</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> m</span>))<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -mask_rot</span><span class="id"> //</span><span class="id"> mask_subseq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">leq_trans</span> (<span class="id">count_size</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">//</span><span class="id"> size_take_min</span><span class="id"> geq_minl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Subseq</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> subseq</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> subseqP</span><span class="id"> {T</span><span class="id"> s1</span><span class="id"> s2}</span>.<br/>
<br/>
<span class="id">#[global]</span><span class="vernacular"> Hint</span><span class="id"> Resolve</span><span class="id"> subseq_refl</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Rem</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> t</span><span class="gallina-kwd"> then</span> (<span class="gallina-kwd">if</span><span class="id"> y</span><span class="id"> ==</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> t</span><span class="gallina-kwd"> else</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> rem</span><span class="id"> t</span>)<span class="gallina-kwd"> else</span><span class="id"> s</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_cons</span><span class="id"> y</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rem</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> y</span><span class="id"> ==</span><span class="id"> x</span><span class="gallina-kwd"> then</span><span class="id"> s</span><span class="gallina-kwd"> else</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> rem</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> remE</span><span class="id"> s</span><span class="id"> :</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> =</span><span class="id"> take</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> ++</span><span class="id"> drop</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>).<span class="id">+1</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> case:</span><span class="id"> eqVneq;</span><span class="id"> rewrite</span><span class="id"> ?drop0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_id</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /norP[neq_yx</span><span class="id"> /IHs-&gt;];</span><span class="id"> case:</span><span class="id"> eqVneq</span><span class="id"> neq_yx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_to_rem</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> rem</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> xs;</span><span class="id"> rewrite</span><span class="id"> remE</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> perm_eq</span><span class="id"> X]</span>(<span class="id">cat_take_drop</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> drop_index//</span><span class="id"> -cat1s</span><span class="id"> perm_catCA</span><span class="id"> cat1s</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_rem</span><span class="id"> s</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">rem</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span>).<span class="id">-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/perm_to_rem/perm_size-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_subseq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">rem</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> [apply:</span><span class="id"> subseq_cons</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> eqxx]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">rem</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subseq_uniq;</span><span class="id"> apply:</span><span class="id"> rem_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rem</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> s}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> mem_subseq</span> (<span class="id">rem_subseq</span><span class="id"> s</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_mem</span><span class="id"> y</span><span class="id"> s</span><span class="id"> :</span><span class="id"> y</span><span class="id"> !=</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> rem</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> yx;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [//|z</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> =&gt;</span><span class="id"> /orP[/eqP&lt;-|ys];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">negbTE</span><span class="id"> yx</span>)<span class="id"> inE</span><span class="id"> eqxx</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> IHs</span><span class="id"> ?orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rem_filter</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> =</span><span class="id"> filter</span> (<span class="id">predC1</span><span class="id"> x</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[not_s_y</span><span class="id"> /IHs-&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> &lt;-;</span><span class="id"> apply/esym/all_filterP;</span><span class="id"> rewrite</span><span class="id"> all_predC</span><span class="id"> has_pred1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rem_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> =i</span><span class="id"> [predD1</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/rem_filter=&gt;</span><span class="id"> -&gt;</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> mem_filter</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_rem_uniqF</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> rem</span><span class="id"> s</span><span class="id"> =</span><span class="id"> false</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/mem_rem_uniq-&gt;;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> eqxx</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_rem</span><span class="id"> P</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> P</span> (<span class="id">rem</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> P</span><span class="id"> s</span><span class="id"> -</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id"> &amp;&amp;</span><span class="id"> P</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [/perm_to_rem/permP-&gt;|xNs]/=</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addKn</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subn0</span><span class="id"> rem_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_mem_rem</span><span class="id"> y</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count_mem</span><span class="id"> y</span> (<span class="id">rem</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count_mem</span><span class="id"> y</span><span class="id"> s</span><span class="id"> -</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> count_rem;</span><span class="id"> have</span><span class="id"> []//=</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> &lt;-</span><span class="id"> /count_memPn-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Rem</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Map</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T1</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">x1</span><span class="id"> :</span><span class="id"> T1</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">T2</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">x2</span><span class="id"> :</span><span class="id"> T2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> map</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> map</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_cons</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> f</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> map</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_nseq</span><span class="id"> x</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">nseq</span><span class="id"> n0</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> nseq</span><span class="id"> n0</span> (<span class="id">f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n0</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> *;</span><span class="id"> congr</span> (_<span class="id"> ::</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> map</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> map</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_map</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> behead_map</span><span class="id"> s</span><span class="id"> :</span><span class="id"> behead</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span> (<span class="id">behead</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_map</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x2</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> f</span> (<span class="id">nth</span><span class="id"> x1</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> rcons</span> (<span class="id">map</span><span class="id"> s</span>) (<span class="id">f</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> map_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> last_map</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> last</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> f</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> belast_map</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> belast</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span> (<span class="id">belast</span><span class="id"> x</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_map</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> filter</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span> (<span class="id">filter</span> (<span class="id">preim</span><span class="id"> f</span><span class="id"> a</span>)<span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span> (<span class="id">fun_if</span><span class="id"> map</span>)<span class="id"> /=</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> find_map</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> find</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> find</span> (<span class="id">preim</span><span class="id"> f</span><span class="id"> a</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> has_map</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> has</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> has</span> (<span class="id">preim</span><span class="id"> f</span><span class="id"> a</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_map</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> all</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> all</span> (<span class="id">preim</span><span class="id"> f</span><span class="id"> a</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_mapT</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T2</span>)<span class="id"> s</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> a</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> all_map</span><span class="id"> =&gt;</span><span class="id"> /allT-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_map</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> a</span> (<span class="id">map</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span> (<span class="id">preim</span><span class="id"> f</span><span class="id"> a</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_take</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">take</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> take</span><span class="id"> n0</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> [|x</span><span class="id"> s]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_drop</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">drop</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> drop</span><span class="id"> n0</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n0</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> [|x</span><span class="id"> s]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_rot</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">rot</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rot</span><span class="id"> n0</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /rot</span><span class="id"> map_cat</span><span class="id"> map_take</span><span class="id"> map_drop</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_rotr</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">rotr</span><span class="id"> n0</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rotr</span><span class="id"> n0</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">rotK</span><span class="id"> n0</span>)<span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -map_rot</span><span class="id"> rotrK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> rev</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> !rev_cons</span><span class="id"> -!cats1</span><span class="id"> map_cat</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> mask</span><span class="id"> m</span> (<span class="id">map</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|[|]</span><span class="id"> m</span><span class="id"> IHm]</span><span class="id"> [|x</span><span class="id"> p]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHm</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> inj_map</span><span class="id"> :</span><span class="id"> injective</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> injective</span><span class="id"> map</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> injf;</span><span class="id"> elim=&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> [/injf-&gt;</span><span class="id"> /IHs-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> inj_in_map</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T1}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> [pred</span><span class="id"> s</span><span class="id"> |</span><span class="id"> all</span><span class="id"> [in</span><span class="id"> A]</span><span class="id"> s]</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> map}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> injf;</span><span class="id"> elim=&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> /andP[Ax</span><span class="id"> As]</span><span class="id"> /andP[Ay</span><span class="id"> At]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> /injf-&gt;</span><span class="id"> //</span><span class="id"> /IHs-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Map</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> onth</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> {struct</span><span class="id"> n}</span><span class="id"> :</span><span class="id"> option</span><span class="id"> T</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> isn't</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s</span><span class="gallina-kwd"> then</span><span class="id"> None</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> isn't</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> Some</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> odflt_onth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> odflt</span><span class="id"> x0</span> (<span class="id">onth</span><span class="id"> s</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|?</span><span class="id"> ?]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onthE</span><span class="id"> s</span><span class="id"> :</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> =1</span><span class="id"> nth</span><span class="id"> None</span> (<span class="id">map</span><span class="id"> Some</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|?</span><span class="id"> ?]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_nth</span><span class="id"> x0</span><span class="id"> x</span><span class="id"> t</span><span class="id"> n</span><span class="id"> :</span><span class="id"> onth</span><span class="id"> t</span><span class="id"> n</span><span class="id"> =</span><span class="id"> Some</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> t</span><span class="id"> n</span><span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> tn;</span><span class="id"> rewrite</span><span class="id"> -odflt_onth</span><span class="id"> tn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth0n</span><span class="id"> n</span><span class="id"> :</span><span class="id"> onth</span><span class="id"> [::]</span><span class="id"> n</span><span class="id"> =</span><span class="id"> None</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth1P</span><span class="id"> x</span><span class="id"> y</span><span class="id"> n</span><span class="id"> :</span><span class="id"> onth</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> n</span><span class="id"> =</span><span class="id"> Some</span><span class="id"> y</span><span class="id"> &lt;-&gt;</span><span class="id"> n</span><span class="id"> =</span><span class="id"> 0</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> =</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|[]];</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> -[]</span><span class="id"> //</span><span class="id"> _</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onthTE</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> :&gt;</span><span class="id"> bool</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|?</span><span class="id"> ?]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onthNE</span><span class="id"> s</span><span class="id"> n:</span><span class="id"> ~~</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> onthTE</span><span class="id"> -leqNgt</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_default</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span><span class="id"> None</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -onthNE;</span><span class="id"> case:</span><span class="id"> onth</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">onth</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> n</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s1</span><span class="gallina-kwd"> then</span><span class="id"> onth</span><span class="id"> s1</span><span class="id"> n</span><span class="gallina-kwd"> else</span><span class="id"> onth</span><span class="id"> s2</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|?</span><span class="id"> ?]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_nseq</span><span class="id"> x</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :</span><span class="id"> onth</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> m</span><span class="id"> =</span><span class="gallina-kwd"> if</span><span class="id"> m</span><span class="id"> &lt;</span><span class="id"> n</span><span class="gallina-kwd"> then</span><span class="id"> Some</span><span class="id"> x</span><span class="gallina-kwd"> else</span><span class="id"> None</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> onthE/=</span><span class="id"> -nth_nseq</span><span class="id"> map_nseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_onthP</span><span class="id"> {s1</span><span class="id"> s2}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[&lt;-&gt;</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> s2;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> maxn</span> (<span class="id">size</span><span class="id"> s1</span>) (<span class="id">size</span><span class="id"> s2</span>)<span class="id"> -&gt;</span><span class="id"> onth</span><span class="id"> s1</span><span class="id"> i</span><span class="id"> =</span><span class="id"> onth</span><span class="id"> s2</span><span class="id"> i;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> onth</span><span class="id"> s1</span><span class="id"> i</span><span class="id"> =</span><span class="id"> onth</span><span class="id"> s2</span><span class="id"> i]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">tfae=&gt;</span><span class="id"> [-&gt;//|eqs12</span><span class="id"> i|eqs12]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> :=</span><span class="id"> eqs12</span><span class="id"> i;</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> -&gt;//|]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> geq_max</span><span class="id"> =&gt;</span><span class="id"> /andP[is1</span><span class="id"> is2]</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> !onth_default</span>.<br/>
<span class="id">have</span><span class="id"> /eqP</span><span class="id"> eq_size_12</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> -!onthNE</span><span class="id"> eqs12</span><span class="id"> onthNE</span><span class="id"> -eqs12</span><span class="id"> onthNE</span><span class="id"> !leqnn</span>.<br/>
<span class="id">apply/</span>(<span class="id">inj_map</span><span class="id"> Some_inj</span>)<span class="id">/</span>(<span class="id">@eq_from_nth</span><span class="id"> _</span><span class="id"> None</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !size_map//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> i</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -!onthE</span><span class="id"> eqs12</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_from_onth</span><span class="id"> [s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> onth</span><span class="id"> s1</span><span class="id"> i</span><span class="id"> =</span><span class="id"> onth</span><span class="id"> s2</span><span class="id"> i</span>)<span class="id"> -&gt;</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/</span>(<span class="id">eq_onthP</span><span class="id"> 0</span><span class="id"> 2</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_from_onth_le</span><span class="id"> [s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T]</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat,</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> maxn</span> (<span class="id">size</span><span class="id"> s1</span>) (<span class="id">size</span><span class="id"> s2</span>)<span class="id"> -&gt;</span><span class="id"> onth</span><span class="id"> s1</span><span class="id"> i</span><span class="id"> =</span><span class="id"> onth</span><span class="id"> s2</span><span class="id"> i</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/</span>(<span class="id">eq_onthP</span><span class="id"> 0</span><span class="id"> 1</span>). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> onth</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_map</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> n</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">onth</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> omap</span><span class="id"> f</span> (<span class="id">onth</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> inj_onth_map</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> n</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">injective</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> onth</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> Some</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span><span class="id"> Some</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> onth_map</span><span class="id"> =&gt;</span><span class="id"> /inj_omap</span><span class="id"> +</span><span class="id"> fs;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> onthEqType</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span><span class="id"> i</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onthP</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> i,</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> i</span><span class="id"> =</span><span class="id"> Some</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> constructor=&gt;</span><span class="id"> -[]</span><span class="id"> []</span>.<br/>
<span class="id">rewrite</span><span class="id"> in_cons;</span><span class="id"> case:</span><span class="id"> eqVneq</span><span class="id"> =&gt;</span><span class="id"> [-&gt;|/=</span><span class="id"> Nxy];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> constructor;</span><span class="gallina-kwd"> exists</span><span class="id"> 0</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [/IHs[i</span><span class="id"> &lt;-]|[[|i]//=]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> [eq_xy];</span><span class="id"> rewrite</span><span class="id"> eq_xy</span><span class="id"> eqxx</span><span class="gallina-kwd"> in</span><span class="id"> Nxy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> six;</span><span class="id"> apply/IHs;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onthPn</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">forall</span><span class="id"> i,</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> i</span><span class="id"> !=</span><span class="id"> Some</span><span class="id"> x</span>) (<span class="id">x</span><span class="id"> \notin</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /onthP</span><span class="id"> +</span><span class="id"> i;</span><span class="id"> apply:</span><span class="id"> contra_not_neq;</span><span class="gallina-kwd"> exists</span><span class="id"> i</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> nsix;</span><span class="id"> apply/onthP</span><span class="id"> =&gt;</span><span class="id"> -[n</span><span class="id"> /eqP/negPn];</span><span class="id"> rewrite</span><span class="id"> nsix</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> onth_inj</span><span class="id"> s</span><span class="id"> n</span><span class="id"> m</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> minn</span><span class="id"> m</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">onth</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =</span><span class="id"> onth</span><span class="id"> s</span><span class="id"> m</span><span class="id"> -&gt;</span><span class="id"> n</span><span class="id"> =</span><span class="id"> m</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]//=</span><span class="id"> [|m]</span><span class="id"> [|n]//=;</span><span class="id"> rewrite</span><span class="id"> ?minnSS</span><span class="id"> !ltnS</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /andP[+</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> /eqP</span><span class="id"> =&gt;</span><span class="id"> /onthPn/</span>(_<span class="id"> _</span>)<span class="id">/negPf-&gt;</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /andP[+</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> /esym</span><span class="id"> /eqP</span><span class="id"> =&gt;</span><span class="id"> /onthPn/</span>(_<span class="id"> _</span>)<span class="id">/negPf-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /andP[xNs</span><span class="id"> /IHs]/[apply]/[apply]-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> onthEqType</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> onthP</span><span class="id"> {T</span><span class="id"> s</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> onthPn</span><span class="id"> {T</span><span class="id"> s</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> onth_nth</span><span class="id"> {T}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> onth_inj</span><span class="id"> {T}</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E | i &lt;- s ]&quot;</span><span class="id"> :=</span> (<span class="id">map</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> E</span>)<span class="id"> s</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> i</span><span class="id"> binder,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  E '/ '  |  i  &lt;-  s ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E | i &lt;- s &amp; C ]&quot;</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> E</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> [seq</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> C]]</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> i</span><span class="id"> binder,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  E '/ '  |  i  &lt;-  s '/ '  &amp;  C ] ']'&quot;</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E : R | i &lt;- s ]&quot;</span><span class="id"> :=</span> (<span class="id">@map</span><span class="id"> _</span><span class="id"> R</span> (<span class="gallina-kwd">fun</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> E</span>)<span class="id"> s</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> i</span><span class="id"> binder,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E : R | i &lt;- s &amp; C ]&quot;</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> E</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> [seq</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> C]]</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> i</span><span class="id"> binder,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_mask</span><span class="id"> T</span><span class="id"> a</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> filter</span><span class="id"> a</span><span class="id"> s</span><span class="id"> =</span><span class="id"> mask</span> (<span class="id">map</span><span class="id"> a</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;-;</span><span class="id"> case:</span> (<span class="id">a</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_sigP</span><span class="id"> T</span><span class="id"> a</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> {s'</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">sig</span><span class="id"> a</span>)<span class="id"> |</span><span class="id"> s</span><span class="id"> =</span><span class="id"> map</span><span class="id"> sval</span><span class="id"> s'}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [_|x</span><span class="id"> s</span><span class="id"> ihs</span><span class="id"> /andP</span><span class="id"> [ax</span><span class="id"> /ihs</span><span class="id"> [s'</span><span class="id"> -&gt;]]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> [::]</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">exist</span><span class="id"> a</span><span class="id"> x</span><span class="id"> ax</span><span class="id"> ::</span><span class="id"> s'</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> MiscMask</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_count_mask</span><span class="id"> T</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>)<span class="id"> m</span><span class="id"> s</span><span class="id"> :</span><span class="id"> count</span><span class="id"> P</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s</span>)<span class="id"> &lt;=</span><span class="id"> count</span><span class="id"> P</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|[]</span><span class="id"> m]//=;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ?leq_add2l</span> (<span class="id">leq_trans</span> (<span class="id">IHs</span><span class="id"> _</span>))<span class="id"> ?leq_addl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">m</span><span class="id"> :</span><span class="id"> bitseq</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mask_filter</span><span class="id"> s</span><span class="id"> m</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s</span><span class="id"> |</span><span class="id"> i</span><span class="id"> \in</span><span class="id"> mask</span><span class="id"> m</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m</span><span class="id"> IH]</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> /andP[/negP</span><span class="id"> xS</span><span class="id"> uS]];</span><span class="id"> rewrite</span><span class="id"> ?filter_pred0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> eqxx</span><span class="id"> /=;</span><span class="id"> congr</span><span class="id"> cons;</span><span class="id"> rewrite</span><span class="id"> [LHS]IH//</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eq_in_filter</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> /[1!inE];</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;|]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [/mem_mask</span><span class="id"> //|_];</span><span class="id"> apply:</span><span class="id"> IH</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> leq_count_subseq</span><span class="id"> P</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> count</span><span class="id"> P</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> count</span><span class="id"> P</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /subseqP[m</span><span class="id"> _</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> leq_count_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_maskP</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2</span>)<span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> m</span><span class="id"> :</span><span class="id"> bitseq,</span><span class="id"> size</span><span class="id"> m</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> &amp;</span><span class="id"> perm_eq</span><span class="id"> s1</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [s1_le|[m</span><span class="id"> _</span><span class="id"> /permP</span><span class="id"> s1ms2</span><span class="id"> x]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> s1ms2</span><span class="id"> leq_count_mask</span>.<br/>
<span class="id">suff</span><span class="id"> [m</span><span class="id"> mP]:</span><span class="gallina-kwd"> exists</span><span class="id"> m,</span><span class="id"> perm_eq</span><span class="id"> s1</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s2</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [m'</span><span class="id"> sm'</span><span class="id"> eqm]</span><span class="id"> :=</span><span class="id"> resize_mask</span><span class="id"> m</span><span class="id"> s2;</span><span class="gallina-kwd"> exists</span><span class="id"> m';</span><span class="id"> rewrite</span><span class="id"> -?eqm</span>.<br/>
<span class="id">elim:</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2</span><span class="id"> IHs]//=</span><span class="gallina-kwd"> in</span><span class="id"> s1</span><span class="id"> s1_le</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> [::];</span><span class="id"> apply/allP</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> _/=;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> s1_le</span>.<br/>
<span class="id">have</span><span class="id"> [y|m</span><span class="id"> s1s2]</span><span class="id"> :=</span><span class="id"> IHs</span> (<span class="id">rem</span><span class="id"> x</span><span class="id"> s1</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> count_mem_rem</span><span class="id"> leq_subLR</span>.<br/>
<span class="gallina-kwd">exists</span> ((<span class="id">x</span><span class="id"> \in</span><span class="id"> s1</span>)<span class="id"> ::</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> have</span><span class="id"> [|/rem_id&lt;-//]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> move/perm_to_rem/permPl-&gt;;</span><span class="id"> rewrite</span><span class="id"> perm_cons</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_subseqP</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2</span>)<span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> s,</span><span class="id"> subseq</span><span class="id"> s</span><span class="id"> s2</span><span class="id"> &amp;</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [/count_maskP[m</span><span class="id"> _]|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> s2</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?mask_subseq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -[_/subseqP[m</span><span class="id"> sm</span><span class="id"> -&gt;]</span><span class="id"> ?];</span><span class="id"> apply/count_maskP;</span><span class="gallina-kwd"> exists</span><span class="id"> m</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MiscMask</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FilterSubseq</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_subseq</span><span class="id"> a</span><span class="id"> s</span><span class="id"> :</span><span class="id"> subseq</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/subseqP;</span><span class="gallina-kwd"> exists</span> (<span class="id">map</span><span class="id"> a</span><span class="id"> s</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?size_map</span><span class="id"> ?filter_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_filter</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> a</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subseq</span><span class="id"> s1</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> a</span><span class="id"> s1</span><span class="id"> &amp;&amp;</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> s1]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?andbF</span><span class="id"> ?sub0seq</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case</span><span class="id"> a_x:</span> (<span class="id">a</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !IHs</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> a_x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_uniqP</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> reflect</span> (<span class="id">s1</span><span class="id"> =</span><span class="id"> filter</span><span class="id"> [in</span><span class="id"> s1]</span><span class="id"> s2</span>) (<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uniq_s2;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [ss12</span><span class="id"> |</span><span class="id"> -&gt;];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> filter_subseq</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -size_subseq_leqif</span><span class="id"> ?subseq_filter</span><span class="id"> ?</span>(<span class="id">introT</span><span class="id"> allP</span>)<span class="id"> //</span>.<br/>
<span class="id">apply/eqP/esym/perm_size</span>.<br/>
<span class="id">rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?filter_uniq</span><span class="id"> ?</span>(<span class="id">subseq_uniq</span><span class="id"> ss12</span>)<span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_filter;</span><span class="id"> apply:</span><span class="id"> andb_idr;</span><span class="id"> apply:</span> (<span class="id">mem_subseq</span><span class="id"> ss12</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_subseq_pivot</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s4</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :=</span><span class="id"> s3</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s4</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> subseq</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> s</span><span class="id"> =</span> (<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> &amp;&amp;</span><span class="id"> subseq</span><span class="id"> s2</span><span class="id"> s4</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> uniq_s;</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> [sub_s'_s|/andP[?</span><span class="id"> ?]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cat_subseq</span><span class="id"> //=</span><span class="id"> eqxx</span>.<br/>
<span class="id">have</span><span class="id"> uniq_s'</span><span class="id"> :=</span><span class="id"> subseq_uniq</span><span class="id"> sub_s'_s</span><span class="id"> uniq_s</span>.<br/>
<span class="id">have/eqP</span><span class="id"> {sub_s'_s</span><span class="id"> uniq_s}</span><span class="id"> :=</span><span class="id"> subseq_uniqP</span><span class="id"> _</span><span class="id"> uniq_s</span><span class="id"> sub_s'_s</span>.<br/>
<span class="id">rewrite</span><span class="id"> !filter_cat</span><span class="id"> /=</span><span class="id"> mem_cat</span><span class="id"> inE</span><span class="id"> eqxx</span><span class="id"> orbT</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> uniq_eqseq_pivotl</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /andP</span><span class="id"> [/eqP</span><span class="id"> -&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !filter_subseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_to_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> {s3</span><span class="id"> |</span><span class="id"> perm_eq</span><span class="id"> s2</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim</span><span class="id"> Ds2:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2'</span><span class="id"> IHs]</span><span class="id"> [|x</span><span class="id"> s1]</span><span class="id"> //=;</span><span class="id"> try</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> s2;</span><span class="id"> rewrite</span><span class="id"> Ds2</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> _]</span><span class="id"> /IHs[s3</span><span class="id"> perm_s2]</span><span class="id"> {IHs}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> s3;</span><span class="id"> rewrite</span><span class="id"> perm_cons</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">rcons</span><span class="id"> s3</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -cat_cons</span><span class="id"> -perm_rcons</span><span class="id"> -!cats1</span><span class="id"> catA</span><span class="id"> perm_cat2r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_rem</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> rem</span><span class="id"> x</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /</span><span class="id"> @subseq</span><span class="id"> T</span><span class="id"> s1</span><span class="id"> s2}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s1</span><span class="id"> s2;</span><span class="id"> elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|x2</span><span class="id"> s2</span><span class="id"> IHs2]</span><span class="id"> [|x1</span><span class="id"> s1];</span><span class="id"> rewrite</span><span class="id"> ?sub0seq</span><span class="id"> //=</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;|_]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> x1</span><span class="id"> x2;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> _</span><span class="id"> /IHs2;</span><span class="id"> rewrite</span><span class="id"> eqxx</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /IHs2/subseq_trans-&gt;//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [-&gt;|_]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> x</span><span class="id"> x2;</span><span class="id"> [apply:</span><span class="id"> rem_subseq|apply:</span><span class="id"> subseq_cons]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FilterSubseq</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> subseq_uniqP</span><span class="id"> [T</span><span class="id"> s1</span><span class="id"> s2]</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqMap</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">n0</span><span class="id"> :</span><span class="id"> nat</span>) (<span class="id">T1</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">x1</span><span class="id"> :</span><span class="id"> T1</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">T2</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">x2</span><span class="id"> :</span><span class="id"> T2</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_f</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /predU1P[-&gt;|/IHs];</span><span class="id"> [apply:</span><span class="id"> predU1l</span><span class="id"> |</span><span class="id"> apply:</span><span class="id"> predU1r]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mapP</span><span class="id"> s</span><span class="id"> y</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span>) (<span class="id">y</span><span class="id"> \in</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs];</span><span class="id"> [by</span><span class="id"> right;</span><span class="id"> case|rewrite</span><span class="id"> /=</span><span class="id"> inE]</span>.<br/>
<span class="id">exact:</span><span class="id"> equivP</span> (<span class="id">orPP</span><span class="id"> eqP</span><span class="id"> IHs</span>) (<span class="id">iff_sym</span><span class="id"> exists_cons</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subset_mapP</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T1</span>) (<span class="id">s'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{subset</span><span class="id"> s'</span><span class="id"> &lt;=</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s}</span><span class="id"> &lt;-&gt;</span><span class="gallina-kwd"> exists2</span><span class="id"> t,</span><span class="id"> all</span> (<span class="id">mem</span><span class="id"> s</span>)<span class="id"> t</span><span class="id"> &amp;</span><span class="id"> s'</span><span class="id"> =</span><span class="id"> map</span><span class="id"> f</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split</span><span class="id"> =&gt;</span><span class="id"> [|[r</span><span class="id"> /allP/=</span><span class="id"> rE</span><span class="id"> -&gt;]</span><span class="id"> _</span><span class="id"> /mapP[x</span><span class="id"> xr</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_f</span><span class="id"> ?rE</span>.<br/>
<span class="id">elim:</span><span class="id"> s'</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s'</span><span class="id"> IHs']</span><span class="id"> subss';</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> [::]</span>.<br/>
<span class="id">have</span><span class="id"> /mapP[y</span><span class="id"> ys</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> subss'</span><span class="id"> _</span> (<span class="id">mem_head</span><span class="id"> _</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> [x'</span><span class="id"> x's'|t</span><span class="id"> st</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> IHs';</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subss'//</span><span class="id"> inE</span><span class="id"> x's'</span><span class="id"> orbT</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> t</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //=</span><span class="id"> ys</span><span class="id"> st</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[not_sfx</span><span class="id"> /IHs-&gt;];</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> not_sfx</span><span class="id"> =&gt;</span><span class="id"> sx;</span><span class="id"> apply/mapP;</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_inj_in_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> s</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> //=</span><span class="id"> injf;</span><span class="id"> congr</span> (<span class="id">~~</span><span class="id"> _</span><span class="id"> &amp;&amp;</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/mapP/idP=&gt;</span><span class="id"> [[y</span><span class="id"> sy</span><span class="id"> /injf]</span><span class="id"> |</span><span class="id"> ];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_head</span><span class="id"> mem_behead</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> IHs</span><span class="id"> =&gt;</span><span class="id"> y</span><span class="id"> z</span><span class="id"> sy</span><span class="id"> sz;</span><span class="id"> apply:</span><span class="id"> injf</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> predU1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> subseq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s1</span>) (<span class="id">map</span><span class="id"> f</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/subseqP=&gt;</span><span class="id"> m</span><span class="id"> sz_m</span><span class="id"> -&gt;;</span><span class="id"> apply/subseqP</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> ?size_map</span><span class="id"> ?map_mask</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_index_map</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> s</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span> (<span class="id">index</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>))<span class="id"> =</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> inj_f</span><span class="id"> s_x;</span><span class="id"> rewrite</span> (<span class="id">inj_in_eq</span><span class="id"> inj_f</span>)<span class="id"> ?mem_head</span><span class="id"> //</span>.<br/>
<span class="id">move:</span><span class="id"> s_x;</span><span class="id"> rewrite</span><span class="id"> inE;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> //</span><span class="id"> |</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> eqVneq;</span><span class="id"> apply:</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> sub_in2</span><span class="id"> inj_f</span><span class="id"> =&gt;</span><span class="id"> z;</span><span class="id"> apply:</span><span class="id"> predU1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_map</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>) (<span class="id">map</span><span class="id"> f</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/permP=&gt;</span><span class="id"> Est;</span><span class="id"> apply/permP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> !count_map</span><span class="id"> Est</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_map</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s2}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sub_s</span><span class="id"> ?</span><span class="id"> /mapP[x</span><span class="id"> x_s</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> map_f</span><span class="id"> ?sub_s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_mem_map</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> =i</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Es</span><span class="id"> x;</span><span class="id"> apply/idP/idP;</span><span class="id"> apply:</span><span class="id"> sub_map</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> Es</span>. Qed.</div></details>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> Hf</span><span class="id"> :</span><span class="id"> injective</span><span class="id"> f</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_map</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/mapP/idP=&gt;</span><span class="id"> [[y</span><span class="id"> Hy</span><span class="id"> /Hf-&gt;]</span><span class="id"> //|];</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> index_map</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> index</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> index</span><span class="id"> x</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /index;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span> (<span class="id">inj_eq</span><span class="id"> Hf</span>)<span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_inj_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> uniq</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> map_inj_in_uniq;</span><span class="id"> apply:</span><span class="id"> in2W</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_map_inj</span><span class="id"> s</span><span class="id"> :</span><span class="id"> undup</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span><span class="id"> f</span> (<span class="id">undup</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s0</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mem_map</span><span class="id"> //;</span><span class="id"> case:</span> (_<span class="id"> \in</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_map_inj</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>) (<span class="id">map</span><span class="id"> f</span><span class="id"> t</span>)<span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move/permP=&gt;</span><span class="id"> Est;</span><span class="id"> apply/allP=&gt;</span><span class="id"> x</span><span class="id"> _</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> Dx:</span><span class="id"> pred1</span><span class="id"> x</span><span class="id"> =1</span><span class="id"> preim</span><span class="id"> f</span> (<span class="id">pred1</span> (<span class="id">f</span><span class="id"> x</span>))<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> inj_eq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">eq_count</span><span class="id"> Dx</span>)<span class="id"> -!count_map</span><span class="id"> Est</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqMap</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> mapP</span><span class="id"> {T1</span><span class="id"> T2</span><span class="id"> f</span><span class="id"> s</span><span class="id"> y}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> subset_mapP</span><span class="id"> {T1</span><span class="id"> T2}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_of_seq</span> (<span class="id">T1</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> T2</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T1</span>) (<span class="id">fs</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T2</span>) (<span class="id">y0</span><span class="id"> :</span><span class="id"> T2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{f</span><span class="id"> |</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> fs</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span><span class="id"> =</span><span class="id"> fs}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">exists</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> nth</span><span class="id"> y0</span><span class="id"> fs</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> s</span>))<span class="id"> =&gt;</span><span class="id"> uAs</span><span class="id"> eq_sz</span>.<br/>
<span class="id">apply/esym/</span>(<span class="id">@eq_from_nth</span><span class="id"> _</span><span class="id"> y0</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?size_map</span><span class="id"> eq_sz</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> ltis</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> x0</span><span class="id"> :</span><span class="id"> T1</span><span class="gallina-kwd"> by</span><span class="id"> [case:</span> (<span class="id">s</span>)<span class="id"> ltis];</span><span class="id"> rewrite</span> (<span class="id">nth_map</span><span class="id"> x0</span>)<span class="id"> //</span><span class="id"> index_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> MapComp</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> S</span><span class="id"> T</span><span class="id"> U</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_id</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> map</span><span class="id"> id</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_map</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> map</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> map</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ef;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> Ef</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_comp</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> U</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> s</span><span class="id"> :</span><span class="id"> map</span> (<span class="id">f</span><span class="id"> \o</span><span class="id"> g</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> map</span><span class="id"> f</span> (<span class="id">map</span><span class="id"> g</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mapK</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> :</span><span class="id"> cancel</span><span class="id"> f</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> cancel</span> (<span class="id">map</span><span class="id"> f</span>) (<span class="id">map</span><span class="id"> g</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fK;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> fK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mapK_in</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> S}</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> A,</span><span class="id"> cancel</span><span class="id"> f</span><span class="id"> g}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> [pred</span><span class="id"> s</span><span class="id"> |</span><span class="id"> all</span><span class="id"> [in</span><span class="id"> A]</span><span class="id"> s],</span><span class="id"> cancel</span> (<span class="id">map</span><span class="id"> f</span>) (<span class="id">map</span><span class="id"> g</span>)<span class="id">}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> fK;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[/fK-&gt;</span><span class="id"> /IHs-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MapComp</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_map</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> T</span> (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> s,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g}</span><span class="id"> &lt;-&gt;</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span><span class="id"> =</span><span class="id"> map</span><span class="id"> g</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> split=&gt;</span><span class="id"> [/forall_cons[-&gt;</span><span class="id"> ?]|];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> IHs</span>.<span class="id">1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> -[?</span><span class="id"> ?];</span><span class="id"> apply/forall_cons;</span><span class="id"> split=&gt;</span><span class="id"> [//|];</span><span class="id"> apply:</span><span class="id"> IHs</span>.<span class="id">2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_id_in</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> f</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> {in</span><span class="id"> s,</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> id}</span><span class="id"> -&gt;</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/eq_in_map-&gt;;</span><span class="id"> apply:</span><span class="id"> map_id</span>. Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Pmap</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> rT</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> aT</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> pmap</span><span class="id"> s</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> let</span><span class="id"> r</span><span class="id"> :=</span><span class="id"> pmap</span><span class="id"> s'</span><span class="gallina-kwd"> in</span><span class="id"> oapp</span> (<span class="id">cons^~</span><span class="id"> r</span>)<span class="id"> r</span> (<span class="id">f</span><span class="id"> x</span>)<span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_pK</span><span class="id"> :</span><span class="id"> pcancel</span><span class="id"> g</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> cancel</span> (<span class="id">map</span><span class="id"> g</span>)<span class="id"> pmap</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> gK;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> gK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_pmap</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">pmap</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> [eta</span><span class="id"> f]</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;-;</span><span class="id"> case:</span> (<span class="id">f</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pmapS_filter</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span><span class="id"> some</span> (<span class="id">pmap</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span><span class="id"> f</span> (<span class="id">filter</span><span class="id"> [eta</span><span class="id"> f]</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> case</span><span class="id"> fx:</span> (<span class="id">f</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> [u]</span><span class="id"> &lt;-;</span><span class="id"> congr</span> (_<span class="id"> ::</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> fK</span><span class="id"> :</span><span class="id"> ocancel</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pmap_filter</span><span class="id"> s</span><span class="id"> :</span><span class="id"> map</span><span class="id"> g</span> (<span class="id">pmap</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> filter</span><span class="id"> [eta</span><span class="id"> f]</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> -{3}</span>(<span class="id">fK</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> case:</span> (<span class="id">f</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pmap_cat</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> pmap</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> pmap</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> pmap</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> case/f:</span><span class="id"> x</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_pmap</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> rT</span>)<span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all</span><span class="id"> p</span> (<span class="id">pmap</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> [pred</span><span class="id"> i</span><span class="id"> |</span><span class="id"> oapp</span><span class="id"> p</span><span class="id"> true</span> (<span class="id">f</span><span class="id"> i</span>)<span class="id">]</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> &lt;-;</span><span class="id"> case:</span><span class="id"> f</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Pmap</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_pmap</span> (<span class="id">aT</span><span class="id"> :</span><span class="id"> eqType</span>)<span class="id"> rT</span> (<span class="id">f1</span><span class="id"> f2</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> rT</span>)<span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> s,</span><span class="id"> f1</span><span class="id"> =1</span><span class="id"> f2}</span><span class="id"> -&gt;</span><span class="id"> pmap</span><span class="id"> f1</span><span class="id"> s</span><span class="id"> =</span><span class="id"> pmap</span><span class="id"> f2</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> a</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /forall_cons</span><span class="id"> [-&gt;</span><span class="id"> /IHs</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_pmap</span><span class="id"> aT</span><span class="id"> rT</span> (<span class="id">f1</span><span class="id"> f2</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> rT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">f1</span><span class="id"> =1</span><span class="id"> f2</span><span class="id"> -&gt;</span><span class="id"> pmap</span><span class="id"> f1</span><span class="id"> =1</span><span class="id"> pmap</span><span class="id"> f2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ef;</span><span class="id"> elim</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> a</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> Ef</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> EqPmap</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">aT</span><span class="id"> rT</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> aT</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> rT</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> rT</span><span class="id"> -&gt;</span><span class="id"> aT</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_pmap</span><span class="id"> s</span><span class="id"> u</span><span class="id"> :</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> pmap</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">Some</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> in_cons</span><span class="id"> -IHs;</span><span class="id"> case:</span> (<span class="id">f</span><span class="id"> x</span>). Qed.</div></details>
<br/>
<span class="vernacular">Hypothesis</span><span class="id"> fK</span><span class="id"> :</span><span class="id"> ocancel</span><span class="id"> f</span><span class="id"> g</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> can2_mem_pmap</span><span class="id"> :</span><span class="id"> pcancel</span><span class="id"> g</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> s</span><span class="id"> u,</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> pmap</span><span class="id"> f</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">g</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> gK</span><span class="id"> s</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mem_map</span> (<span class="id">pcan_inj</span><span class="id"> gK</span>))<span class="id"> pmap_filter</span><span class="id"> //</span><span class="id"> mem_filter</span><span class="id"> gK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pmap_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">pmap</span><span class="id"> f</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> move/</span>(<span class="id">filter_uniq</span><span class="id"> f</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">pmap_filter</span><span class="id"> fK</span>)<span class="id">;</span><span class="id"> exact:</span><span class="id"> map_uniq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_pmap</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">pmap</span><span class="id"> f</span><span class="id"> s</span>) (<span class="id">pmap</span><span class="id"> f</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_st;</span><span class="id"> apply/</span>(<span class="id">perm_map_inj</span><span class="id"> Some_inj</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !pmapS_filter</span>.<br/>
<span class="id">exact/perm_map/perm_filter</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqPmap</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PmapSub</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">sT</span><span class="id"> :</span><span class="id"> subType</span><span class="id"> p</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_pmap_sub</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">pmap</span> (<span class="id">insub</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> sT</span>)<span class="id"> s</span>)<span class="id"> =</span><span class="id"> count</span><span class="id"> p</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_pmap</span> (<span class="id">eq_count</span> (<span class="id">isSome_insub</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> PmapSub</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqPmapSub</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>) (<span class="id">sT</span><span class="id"> :</span><span class="id"> subEqType</span><span class="id"> p</span>).<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> insT</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> option</span><span class="id"> sT</span><span class="id"> :=</span><span class="id"> insub</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_pmap_sub</span><span class="id"> s</span><span class="id"> u</span><span class="id"> :</span> (<span class="id">u</span><span class="id"> \in</span><span class="id"> pmap</span><span class="id"> insT</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">val</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/</span>(<span class="id">can2_mem_pmap</span> (<span class="id">insubK</span><span class="id"> _</span>))<span class="id">/valK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pmap_sub_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">pmap</span><span class="id"> insT</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span> (<span class="id">pmap_uniq</span> (<span class="id">insubK</span><span class="id"> _</span>)). Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqPmapSub</span>.<br/>
<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> is</span><span class="id"> n'</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> m</span><span class="id"> ::</span><span class="id"> iota</span><span class="id"> m</span>.<span class="id">+1</span><span class="id"> n'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_iota</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">iota</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> iotaD</span><span class="id"> m</span><span class="id"> n1</span><span class="id"> n2</span><span class="id"> :</span><span class="id"> iota</span><span class="id"> m</span> (<span class="id">n1</span><span class="id"> +</span><span class="id"> n2</span>)<span class="id"> =</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> n1</span><span class="id"> ++</span><span class="id"> iota</span> (<span class="id">m</span><span class="id"> +</span><span class="id"> n1</span>)<span class="id"> n2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n1</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|n1</span><span class="id"> IHn1]</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> ?addn0</span><span class="id"> //</span><span class="id"> -addSnnS</span><span class="id"> /=</span><span class="id"> -IHn1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> iotaDl</span><span class="id"> m1</span><span class="id"> m2</span><span class="id"> n</span><span class="id"> :</span><span class="id"> iota</span> (<span class="id">m1</span><span class="id"> +</span><span class="id"> m2</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> map</span> (<span class="id">addn</span><span class="id"> m1</span>) (<span class="id">iota</span><span class="id"> m2</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> m2</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> m2;</span><span class="id"> rewrite</span><span class="id"> -addnS</span><span class="id"> IHn</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_iota</span><span class="id"> p</span><span class="id"> m</span><span class="id"> n</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> p</span> (<span class="id">iota</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> m</span><span class="id"> +</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move/subnKC</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> addSnnS</span><span class="id"> iotaD</span><span class="id"> nth_cat</span><span class="id"> size_iota</span><span class="id"> ltnn</span><span class="id"> subnn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_iota</span><span class="id"> m</span><span class="id"> n</span><span class="id"> i</span><span class="id"> :</span> (<span class="id">i</span><span class="id"> \in</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> =</span> (<span class="id">m</span><span class="id"> &lt;=</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> m</span><span class="id"> +</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> /=</span><span class="id"> m;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> addn0</span><span class="id"> ltnNge</span><span class="id"> andbN</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> in_cons</span><span class="id"> IHn</span><span class="id"> addnS</span><span class="id"> ltnS;</span><span class="id"> case:</span><span class="id"> ltngtP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> leq_addr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> iota_uniq</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">iota</span><span class="id"> m</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> mem_iota</span><span class="id"> ltnn</span><span class="id"> /=</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> take_iota</span><span class="id"> k</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> take</span><span class="id"> k</span> (<span class="id">iota</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> iota</span><span class="id"> m</span> (<span class="id">minn</span><span class="id"> k</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> [lt_k_n|le_n_k]</span><span class="id"> :=</span><span class="id"> ltnP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> k</span><span class="id"> n</span><span class="id"> lt_k_n</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> [|k</span><span class="id"> IHk]</span><span class="id"> [|n]</span><span class="id"> //=</span><span class="id"> H</span><span class="id"> m;</span><span class="id"> rewrite</span><span class="id"> IHk</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> take_oversize;</span><span class="id"> rewrite</span><span class="id"> size_iota</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> drop_iota</span><span class="id"> k</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> drop</span><span class="id"> k</span> (<span class="id">iota</span><span class="id"> m</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> iota</span> (<span class="id">m</span><span class="id"> +</span><span class="id"> k</span>) (<span class="id">n</span><span class="id"> -</span><span class="id"> k</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> k</span><span class="id"> m</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|k</span><span class="id"> IHk]</span><span class="id"> m</span><span class="id"> [|n]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?addn0</span><span class="id"> //</span><span class="id"> IHk</span><span class="id"> addnS</span><span class="id"> subSS</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_iota_ltn</span><span class="id"> m</span><span class="id"> n</span><span class="id"> j</span><span class="id"> :</span><span class="id"> j</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> n</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> m</span><span class="id"> +</span><span class="id"> j]</span><span class="id"> =</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> j</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> m</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [m</span><span class="id"> j|n</span><span class="id"> IHn</span><span class="id"> m</span><span class="id"> [|j]</span><span class="id"> jlen];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@eq_in_filter</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pred0</span>)<span class="id"> ?filter_pred0//</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addn0</span><span class="id"> ltnNge</span><span class="id"> mem_iota</span><span class="id"> =&gt;</span><span class="id"> /andP[-&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> addnS</span><span class="id"> leq_addr</span><span class="id"> -addSn</span><span class="id"> IHn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_iota_leq</span><span class="id"> n</span><span class="id"> m</span><span class="id"> j</span><span class="id"> :</span><span class="id"> j</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> n</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> m</span><span class="id"> +</span><span class="id"> j]</span><span class="id"> =</span><span class="id"> iota</span><span class="id"> m</span><span class="id"> j</span>.<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> m</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [//|n</span><span class="id"> IHn]</span><span class="id"> m</span><span class="id"> [|j]</span><span class="id"> jlen</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> leq_addr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">@eq_in_filter</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pred0</span>)<span class="id"> ?filter_pred0//</span><span class="id"> =&gt;</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addn0</span><span class="id"> leqNgt</span><span class="id"> mem_iota</span><span class="id"> =&gt;</span><span class="id"> /andP[-&gt;]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addnS</span><span class="id"> -addSn</span><span class="id"> IHn</span><span class="id"> -1?ltnS</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MakeSeq</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">x0</span><span class="id"> :</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> mkseq</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> :=</span><span class="id"> map</span><span class="id"> f</span> (<span class="id">iota</span><span class="id"> 0</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_mkseq</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> size_map</span><span class="id"> size_iota</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkseqS</span><span class="id"> f</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> =</span><span class="id"> rcons</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>) (<span class="id">f</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /mkseq</span><span class="id"> -addn1</span><span class="id"> iotaD</span><span class="id"> add0n</span><span class="id"> map_cat</span><span class="id"> cats1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_mkseq</span><span class="id"> f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> g</span><span class="id"> -&gt;</span><span class="id"> mkseq</span><span class="id"> f</span><span class="id"> =1</span><span class="id"> mkseq</span><span class="id"> g</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Efg</span><span class="id"> n;</span><span class="id"> apply:</span><span class="id"> eq_map</span><span class="id"> Efg</span><span class="id"> _</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_mkseq</span><span class="id"> f</span><span class="id"> n</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> nth</span><span class="id"> x0</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> f</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Hi;</span><span class="id"> rewrite</span> (<span class="id">nth_map</span><span class="id"> 0</span>)<span class="id"> ?nth_iota</span><span class="id"> ?size_iota</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkseq_nth</span><span class="id"> s</span><span class="id"> :</span><span class="id"> mkseq</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span>) (<span class="id">size</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">@eq_from_nth</span><span class="id"> _</span><span class="id"> x0</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> size_mkseq</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> Hi;</span><span class="id"> rewrite</span><span class="id"> nth_mkseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variant</span><span class="id"> mkseq_spec</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span><span class="id"> :=</span><br/>
<span class="id">|</span><span class="id"> MapIota</span><span class="id"> n</span><span class="id"> f</span><span class="id"> :</span><span class="id"> s</span><span class="id"> =</span><span class="id"> mkseq</span><span class="id"> f</span><span class="id"> n</span><span class="id"> -&gt;</span><span class="id"> mkseq_spec</span><span class="id"> s</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkseqP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> mkseq_spec</span><span class="id"> s</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[s]mkseq_nth;</span><span class="id"> constructor</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_nth_iota0</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">i</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> [seq</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> j</span><span class="id"> |</span><span class="id"> j</span><span class="id"> &lt;-</span><span class="id"> iota</span><span class="id"> 0</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> take</span><span class="id"> i</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ile;</span><span class="id"> rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> RHS]mkseq_nth</span><span class="id"> -map_take</span><span class="id"> take_iota</span> (<span class="id">minn_idPl</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_nth_iota</span><span class="id"> s</span><span class="id"> i</span><span class="id"> j</span><span class="id"> :</span><span class="id"> j</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -</span><span class="id"> i</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> k</span><span class="id"> |</span><span class="id"> k</span><span class="id"> &lt;-</span><span class="id"> iota</span><span class="id"> i</span><span class="id"> j]</span><span class="id"> =</span><span class="id"> take</span><span class="id"> j</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> IH]</span><span class="gallina-kwd"> in</span><span class="id"> s</span><span class="id"> j</span><span class="id"> *;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subn0</span><span class="id"> drop0</span><span class="id"> =&gt;</span><span class="id"> /map_nth_iota0-&gt;</span>.<br/>
<span class="id">case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> /IH&lt;-];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> leqn0</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -add1n</span><span class="id"> iotaDl</span><span class="id"> -map_comp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MakeSeq</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MakeEqSeq</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkseq_uniqP</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> {in</span><span class="id"> gtn</span><span class="id"> n</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> f}</span> (<span class="id">uniq</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">equivP</span> (<span class="id">uniqP</span> (<span class="id">f</span><span class="id"> 0</span>)))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> size_mkseq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> injf</span><span class="id"> i</span><span class="id"> j</span><span class="id"> lti</span><span class="id"> ltj;</span><span class="id"> have:=</span><span class="id"> injf</span><span class="id"> i</span><span class="id"> j</span><span class="id"> lti</span><span class="id"> ltj;</span><span class="id"> rewrite</span><span class="id"> !nth_mkseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mkseq_uniq</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> n</span><span class="id"> :</span><span class="id"> injective</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">mkseq</span><span class="id"> f</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move/map_inj_uniq-&gt;;</span><span class="id"> apply:</span><span class="id"> iota_uniq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_iotaP</span><span class="id"> {s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T}</span><span class="id"> x0</span> (<span class="id">It</span><span class="id"> :=</span><span class="id"> iota</span><span class="id"> 0</span> (<span class="id">size</span><span class="id"> t</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> Is,</span><span class="id"> perm_eq</span><span class="id"> Is</span><span class="id"> It</span><span class="id"> &amp;</span><span class="id"> s</span><span class="id"> =</span><span class="id"> map</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> t</span>)<span class="id"> Is</span>) (<span class="id">perm_eq</span><span class="id"> s</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [Est</span><span class="id"> |</span><span class="id"> [Is</span><span class="id"> eqIst</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}[t]</span>(<span class="id">mkseq_nth</span><span class="id"> x0</span>)<span class="id"> perm_map</span>.<br/>
<span class="id">elim:</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> t</span><span class="id"> IHt]</span><span class="gallina-kwd"> in</span><span class="id"> s</span><span class="id"> It</span><span class="id"> Est</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">perm_small_eq</span><span class="id"> _</span><span class="id"> Est</span>)<span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> [::]</span>.<br/>
<span class="id">have</span><span class="id"> /rot_to[k</span><span class="id"> s1</span><span class="id"> Ds]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">perm_mem</span><span class="id"> Est</span>)<span class="id"> mem_head</span>.<br/>
<span class="id">have</span><span class="id"> [|Is1</span><span class="id"> eqIst1</span><span class="id"> Ds1]</span><span class="id"> :=</span><span class="id"> IHt</span><span class="id"> s1;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>)<span class="id"> -Ds</span><span class="id"> perm_rot</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">rotr</span><span class="id"> k</span> (<span class="id">0</span><span class="id"> ::</span><span class="id"> map</span><span class="id"> succn</span><span class="id"> Is1</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_rot</span><span class="id"> /It</span><span class="id"> /=</span><span class="id"> perm_cons</span> (<span class="id">iotaDl</span><span class="id"> 1</span>)<span class="id"> perm_map</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> map_rotr</span><span class="id"> /=</span><span class="id"> -map_comp</span><span class="id"> -</span>(<span class="id">@eq_map</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> t</span>))<span class="id"> //</span><span class="id"> -Ds1</span><span class="id"> -Ds</span><span class="id"> rotK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MakeEqSeq</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> perm_iotaP</span><span class="id"> {T</span><span class="id"> s</span><span class="id"> t}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FoldRight</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">z0</span><span class="id"> :</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> foldr</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">foldr</span><span class="id"> s'</span>)<span class="gallina-kwd"> else</span><span class="id"> z0</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> FoldRight</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> FoldRightComp</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T1</span><span class="id"> T2</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">h</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">z0</span><span class="id"> :</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldr_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> foldr</span><span class="id"> f</span><span class="id"> z0</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> foldr</span><span class="id"> f</span> (<span class="id">foldr</span><span class="id"> f</span><span class="id"> z0</span><span class="id"> s2</span>)<span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldr_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> foldr</span><span class="id"> f</span><span class="id"> z0</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> foldr</span><span class="id"> f</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> z0</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> foldr_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldr_map</span><span class="id"> s</span><span class="id"> :</span><span class="id"> foldr</span><span class="id"> f</span><span class="id"> z0</span> (<span class="id">map</span><span class="id"> h</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> foldr</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> f</span> (<span class="id">h</span><span class="id"> x</span>)<span class="id"> z</span>)<span class="id"> z0</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FoldRightComp</span>.<br/>
<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> sumn</span><span class="id"> :=</span><span class="id"> foldr</span><span class="id"> addn</span><span class="id"> 0</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_ncons</span><span class="id"> x</span><span class="id"> n</span><span class="id"> s</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">ncons</span><span class="id"> n</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> *</span><span class="id"> n</span><span class="id"> +</span><span class="id"> sumn</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulnC;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> addnA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_nseq</span><span class="id"> x</span><span class="id"> n</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> *</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sumn_ncons</span><span class="id"> addn0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> sumn</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> addnA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_count</span><span class="id"> T</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> s</span><span class="id"> :</span><span class="id"> sumn</span><span class="id"> [seq</span><span class="id"> a</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> =</span><span class="id"> count</span><span class="id"> a</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s0</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_rcons</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> n</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s</span><span class="id"> +</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> sumn_cat</span><span class="id"> /=</span><span class="id"> addn0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_sumn</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> sumn</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> sumn</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/catCA_perm_subst:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3;</span><span class="id"> rewrite</span><span class="id"> !sumn_cat</span><span class="id"> addnCA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_rot</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">rot</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/perm_sumn;</span><span class="id"> rewrite</span><span class="id"> perm_rot</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_rev</span><span class="id"> s</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> apply/perm_sumn;</span><span class="id"> rewrite</span><span class="id"> perm_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> natnseq0P</span><span class="id"> s</span><span class="id"> :</span><span class="id"> reflect</span> (<span class="id">s</span><span class="id"> =</span><span class="id"> nseq</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> 0</span>) (<span class="id">sumn</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> 0</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|-&gt;];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sumn_nseq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> addn_eq0</span><span class="id"> =&gt;</span><span class="id"> /andP[/eqP-&gt;</span><span class="id"> /IHs</span><span class="id"> &lt;-]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_set_nth</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sumn</span> (<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">sumn</span><span class="id"> s</span><span class="id"> +</span><span class="id"> x</span><span class="id"> -</span> (<span class="id">nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>)<span class="id"> *</span> (<span class="id">n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span>)<span class="id"> +</span><span class="id"> x0</span><span class="id"> *</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> set_nthE;</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [nlts|nges];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> sumn_cat</span><span class="id"> sumn_ncons</span><span class="id"> /=</span><span class="id"> addn0</span><span class="id"> muln0</span><span class="id"> subn0</span><span class="id"> addnAC</span><span class="id"> addnA</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span><span class="id"> ltnW</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[in</span><span class="id"> sumn</span><span class="id"> s]</span>(<span class="id">cat_take_drop</span><span class="id"> n</span><span class="id"> s</span>)<span class="id"> [drop</span><span class="id"> n</span><span class="id"> s]</span>(<span class="id">drop_nth</span><span class="id"> x0</span>)<span class="id">//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !sumn_cat</span><span class="id"> /=</span><span class="id"> muln1</span><span class="id"> muln0</span><span class="id"> addn0</span><span class="id"> addnAC</span><span class="id"> !addnA</span><span class="id"> [in</span><span class="id"> RHS]addnAC</span><span class="id"> addnK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_set_nth_ltn</span><span class="id"> s</span><span class="id"> x0</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">sumn</span> (<span class="id">set_nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s</span><span class="id"> +</span><span class="id"> x</span><span class="id"> -</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nlts;</span><span class="id"> rewrite</span><span class="id"> sumn_set_nth</span><span class="id"> nlts</span><span class="id"> muln1</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;</span><span class="id"> :</span><span class="id"> n</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span><span class="id"> ltnW</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> muln0</span><span class="id"> addn0</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_set_nth0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span><span class="id"> :</span><span class="id"> sumn</span> (<span class="id">set_nth</span><span class="id"> 0</span><span class="id"> s</span><span class="id"> n</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> s</span><span class="id"> +</span><span class="id"> x</span><span class="id"> -</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> s</span><span class="id"> n</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> sumn_set_nth</span><span class="id"> mul0n</span><span class="id"> addn0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> [_|nges];</span><span class="id"> rewrite</span><span class="id"> ?muln1//</span><span class="id"> nth_default</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> FoldLeft</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> R</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> foldl</span><span class="id"> z</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> foldl</span> (<span class="id">f</span><span class="id"> z</span><span class="id"> x</span>)<span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> z</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldl_rev</span><span class="id"> z</span><span class="id"> s</span><span class="id"> :</span><span class="id"> foldl</span><span class="id"> z</span> (<span class="id">rev</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> foldr</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> z</span><span class="id"> x</span>)<span class="id"> z</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim/last_ind:</span><span class="id"> s</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> s</span><span class="id"> x</span><span class="id"> IHs</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> rev_rcons</span><span class="id"> -cats1</span><span class="id"> foldr_cat</span><span class="id"> -IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldl_cat</span><span class="id"> z</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> foldl</span><span class="id"> z</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> foldl</span> (<span class="id">foldl</span><span class="id"> z</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">revK</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>))<span class="id"> foldl_rev</span><span class="id"> rev_cat</span><span class="id"> foldr_cat</span><span class="id"> -!foldl_rev</span><span class="id"> !revK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldl_rcons</span><span class="id"> z</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> foldl</span><span class="id"> z</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> f</span> (<span class="id">foldl</span><span class="id"> z</span><span class="id"> s</span>)<span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> foldl_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> FoldLeft</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Folds</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">fA</span><span class="id"> :</span><span class="id"> associative</span><span class="id"> f</span>) (<span class="id">fC</span><span class="id"> :</span><span class="id"> commutative</span><span class="id"> f</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> foldl_foldr</span><span class="id"> x0</span><span class="id"> l</span><span class="id"> :</span><span class="id"> foldl</span><span class="id"> f</span><span class="id"> x0</span><span class="id"> l</span><span class="id"> =</span><span class="id"> foldr</span><span class="id"> f</span><span class="id"> x0</span><span class="id"> l</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> l</span><span class="id"> x0</span><span class="id"> =&gt;</span><span class="id"> [//|x1</span><span class="id"> l</span><span class="id"> IHl]</span><span class="id"> x0</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> {}IHl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> l</span><span class="id"> x0</span><span class="id"> x1</span><span class="id"> =&gt;</span><span class="id"> [//|x2</span><span class="id"> l</span><span class="id"> IHl]</span><span class="id"> x0</span><span class="id"> x1</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> IHl</span><span class="id"> !fA</span><span class="id"> [f</span><span class="id"> x2</span><span class="id"> x1]fC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Folds</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Scan</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T1</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">x1</span><span class="id"> :</span><span class="id"> T1</span>) (<span class="id">T2</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">x2</span><span class="id"> :</span><span class="id"> T2</span>).<br/>
<span class="vernacular">Variables</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span>) (<span class="id">g</span><span class="id"> :</span><span class="id"> T1</span><span class="id"> -&gt;</span><span class="id"> T2</span><span class="id"> -&gt;</span><span class="id"> T1</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> pairmap</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :=</span><span class="gallina-kwd"> if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> pairmap</span><span class="id"> y</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_pairmap</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">pairmap</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairmap_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pairmap</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> pairmap</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> pairmap</span> (<span class="id">last</span><span class="id"> x</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s1</span><span class="id"> IHs1</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> IHs1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_pairmap</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> nth</span><span class="id"> x2</span> (<span class="id">pairmap</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> f</span> (<span class="id">nth</span><span class="id"> x1</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>)<span class="id"> n</span>) (<span class="id">nth</span><span class="id"> x1</span><span class="id"> s</span><span class="id"> n</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> //=</span><span class="id"> Hn</span><span class="id"> x;</span><span class="id"> apply:</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> scanl</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s'</span><span class="gallina-kwd"> then</span><span class="gallina-kwd"> let</span><span class="id"> x'</span><span class="id"> :=</span><span class="id"> g</span><span class="id"> x</span><span class="id"> y</span><span class="gallina-kwd"> in</span><span class="id"> x'</span><span class="id"> ::</span><span class="id"> scanl</span><span class="id"> x'</span><span class="id"> s'</span><span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_scanl</span><span class="id"> x</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">scanl</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> scanl_cat</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">scanl</span><span class="id"> x</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> scanl</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> scanl</span> (<span class="id">foldl</span><span class="id"> g</span><span class="id"> x</span><span class="id"> s1</span>)<span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s1</span><span class="id"> IHs1</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> IHs1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> scanl_rcons</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> y</span> <span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">scanl</span><span class="id"> x</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> y</span>)<span class="id"> =</span> <span class="id"> rcons</span> (<span class="id">scanl</span><span class="id"> x</span><span class="id"> s1</span>) (<span class="id">foldl</span><span class="id"> g</span><span class="id"> x</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> y</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> scanl_cat</span><span class="id"> foldl_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_cons_scanl</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> nth</span><span class="id"> x1</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> scanl</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> foldl</span><span class="id"> g</span><span class="id"> x</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|n]</span><span class="id"> Hn</span><span class="id"> x</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_scanl</span><span class="id"> s</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> nth</span><span class="id"> x1</span> (<span class="id">scanl</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> foldl</span><span class="id"> g</span><span class="id"> x</span> (<span class="id">take</span><span class="id"> n</span>.<span class="id">+1</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> n_lt</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> -nth_cons_scanl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> scanlK</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> cancel</span> (<span class="id">g</span><span class="id"> x</span>) (<span class="id">f</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> cancel</span> (<span class="id">scanl</span><span class="id"> x</span>) (<span class="id">pairmap</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Hfg</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> Hfg</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairmapK</span><span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> cancel</span> (<span class="id">f</span><span class="id"> x</span>) (<span class="id">g</span><span class="id"> x</span>))<span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> cancel</span> (<span class="id">pairmap</span><span class="id"> x</span>) (<span class="id">scanl</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Hgf</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> x;</span><span class="id"> rewrite</span><span class="id"> Hgf</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Scan</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> mask</span><span class="id"> map</span><span class="id"> pmap</span><span class="id"> foldr</span><span class="id"> foldl</span><span class="id"> scanl</span><span class="id"> pairmap</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Zip</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> bool</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> zip</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> {struct</span><span class="id"> t}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> s,</span><span class="id"> t</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s',</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> t'</span><span class="id"> =&gt;</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> ::</span><span class="id"> zip</span><span class="id"> s'</span><span class="id"> t'</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> [::]</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> unzip1</span><span class="id"> :=</span><span class="id"> map</span> (<span class="id">@fst</span><span class="id"> S</span><span class="id"> T</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> unzip2</span><span class="id"> :=</span><span class="id"> map</span> (<span class="id">@snd</span><span class="id"> S</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> all2</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> s,</span><span class="id"> t</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> [::],</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> true</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &amp;&amp;</span><span class="id"> all2</span><span class="id"> s</span><span class="id"> t</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> _,</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> false</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_unzip</span><span class="id"> s</span><span class="id"> :</span><span class="id"> zip</span> (<span class="id">unzip1</span><span class="id"> s</span>) (<span class="id">unzip2</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> y]</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> -&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> unzip1_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> unzip1</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> le_s_t;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> unzip2_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> unzip2</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> le_t_s;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size1_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> Hs;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size2_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> t</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> Hs;</span><span class="id"> rewrite</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> minn</span> (<span class="id">size</span><span class="id"> s</span>) (<span class="id">size</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|t2</span><span class="id"> t]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span><span class="id"> minnSS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_cat</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t1</span><span class="id"> -&gt;</span><span class="id"> zip</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>) (<span class="id">t1</span><span class="id"> ++</span><span class="id"> t2</span>)<span class="id"> =</span><span class="id"> zip</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> ++</span><span class="id"> zip</span><span class="id"> s2</span><span class="id"> t2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> s1</span><span class="id"> t1;</span><span class="id"> apply:</span><span class="id"> seq_ind2</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> _</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_zip</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> t</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> nth</span> (<span class="id">x,</span><span class="id"> y</span>) (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> i</span><span class="id"> =</span> (<span class="id">nth</span><span class="id"> x</span><span class="id"> s</span><span class="id"> i,</span><span class="id"> nth</span><span class="id"> y</span><span class="id"> t</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|i</span><span class="id"> IHi]</span><span class="id"> [|y1</span><span class="id"> s1]</span><span class="id"> [|y2</span><span class="id"> t]</span><span class="id"> //=</span><span class="id"> [/IHi-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_zip_cond</span><span class="id"> p</span><span class="id"> s</span><span class="id"> t</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">nth</span><span class="id"> p</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">=</span> (<span class="gallina-kwd">if</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="gallina-kwd"> then</span> (<span class="id">nth</span><span class="id"> p</span>.<span class="id">1</span><span class="id"> s</span><span class="id"> i,</span><span class="id"> nth</span><span class="id"> p</span>.<span class="id">2</span><span class="id"> t</span><span class="id"> i</span>)<span class="gallina-kwd"> else</span><span class="id"> p</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> size_zip</span><span class="id"> ltnNge</span><span class="id"> geq_min</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> [|i]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ?orbT</span><span class="id"> -?IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_rcons</span><span class="id"> s</span><span class="id"> t</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> zip</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>) (<span class="id">rcons</span><span class="id"> t</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> rcons</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>) (<span class="id">x,</span><span class="id"> y</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_sz;</span><span class="id"> rewrite</span><span class="id"> -!cats1</span><span class="id"> zip_cat</span><span class="id"> //=</span><span class="id"> eq_sz</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_zip</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> rev</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> zip</span> (<span class="id">rev</span><span class="id"> s</span>) (<span class="id">rev</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move:</span><span class="id"> s</span><span class="id"> t;</span><span class="id"> apply:</span><span class="id"> seq_ind2</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> t</span><span class="id"> eq_sz</span><span class="id"> IHs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !rev_cons</span><span class="id"> IHs</span><span class="id"> zip_rcons</span><span class="id"> ?size_rev</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all2E</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all2</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> size</span><span class="id"> t</span>)<span class="id"> &amp;&amp;</span><span class="id"> all</span><span class="id"> [pred</span><span class="id"> xy</span><span class="id"> |</span><span class="id"> r</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> xy</span>.<span class="id">2]</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> [|y</span><span class="id"> t]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> IHs</span><span class="id"> andbCA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_map</span><span class="id"> I</span><span class="id"> f</span><span class="id"> g</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">zip</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>) (<span class="id">map</span><span class="id"> g</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> [seq</span> (<span class="id">f</span><span class="id"> i,</span><span class="id"> g</span><span class="id"> i</span>)<span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> i</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> unzip1_map_nth_zip</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> t</span><span class="id"> l</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span> <br/>
&nbsp;&nbsp;<span class="id">unzip1</span><span class="id"> [seq</span><span class="id"> nth</span> (<span class="id">x,</span><span class="id"> y</span>) (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> l]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> nth</span><span class="id"> x</span><span class="id"> s</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> l]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> st;</span><span class="id"> elim:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [//=|n</span><span class="id"> l</span><span class="id"> IH</span><span class="id"> /=];</span><span class="id"> rewrite</span><span class="id"> nth_zip</span><span class="id"> ?IH</span><span class="id"> ?st</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> unzip2_map_nth_zip</span><span class="id"> x</span><span class="id"> y</span><span class="id"> s</span><span class="id"> t</span><span class="id"> l</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t</span><span class="id"> -&gt;</span> <br/>
&nbsp;&nbsp;<span class="id">unzip2</span><span class="id"> [seq</span><span class="id"> nth</span> (<span class="id">x,</span><span class="id"> y</span>) (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>)<span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> l]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> nth</span><span class="id"> y</span><span class="id"> t</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> l]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> st;</span><span class="id"> elim:</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [//=|n</span><span class="id"> l</span><span class="id"> IH</span><span class="id"> /=];</span><span class="id"> rewrite</span><span class="id"> nth_zip</span><span class="id"> ?IH</span><span class="id"> ?st</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Zip</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_uniql</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span> <br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|s0</span><span class="id"> s]</span><span class="id"> [|t0</span><span class="id"> t]</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contraTT</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">uniqPn</span> (<span class="id">s0,</span><span class="id"> t0</span>))<span class="id"> [i</span><span class="id"> [j]]</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> o</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> !nth_zip_cond</span><span class="id"> !ifT</span><span class="id"> ?js</span><span class="id"> ?</span>(<span class="id">ltn_trans</span><span class="id"> o</span>)<span class="id">//</span><span class="id"> =&gt;</span><span class="id"> -[n</span><span class="id"> _]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">uniqPn</span><span class="id"> s0</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> o</span><span class="id"> n</span> (<span class="id">leq_trans</span><span class="id"> z</span>)<span class="id"> ?size_zip?geq_minl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> zip_uniqr</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span> <br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> uniq</span> (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|s0</span><span class="id"> s]</span><span class="id"> [|t0</span><span class="id"> t]</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contraTT</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">uniqPn</span> (<span class="id">s0,</span><span class="id"> t0</span>))<span class="id"> [i</span><span class="id"> [j]]</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> o</span><span class="id"> z;</span><span class="id"> rewrite</span><span class="id"> !nth_zip_cond</span><span class="id"> !ifT</span><span class="id"> ?js</span><span class="id"> ?</span>(<span class="id">ltn_trans</span><span class="id"> o</span>)<span class="id">//</span><span class="id"> =&gt;</span><span class="id"> -[_</span><span class="id"> n]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">uniqPn</span><span class="id"> t0</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> o</span><span class="id"> n</span> (<span class="id">leq_trans</span><span class="id"> z</span>)<span class="id"> ?size_zip?geq_minr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_zip_sym</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t1</span><span class="id"> t2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span> <br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">zip</span><span class="id"> s1</span><span class="id"> t1</span>) (<span class="id">zip</span><span class="id"> s2</span><span class="id"> t2</span>)<span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">zip</span><span class="id"> t1</span><span class="id"> s1</span>) (<span class="id">zip</span><span class="id"> t2</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> swap</span><span class="id"> t</span><span class="id"> s</span><span class="id"> :</span><span class="id"> zip</span><span class="id"> t</span><span class="id"> s</span><span class="id"> =</span><span class="id"> map</span> (<span class="gallina-kwd">fun</span><span class="id"> u</span><span class="id"> =&gt;</span> (<span class="id">u</span>.<span class="id">2,</span><span class="id"> u</span>.<span class="id">1</span>)) (<span class="id">zip</span><span class="id"> s</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> +]</span><span class="id"> [|y</span><span class="id"> t]//=</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [zip</span><span class="id"> t1</span><span class="id"> s1]swap</span><span class="id"> [zip</span><span class="id"> t2</span><span class="id"> s2]swap;</span><span class="id"> apply:</span><span class="id"> perm_map</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_zip1</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType}</span> (<span class="id">t1</span><span class="id"> t2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id">:</span> <br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t1</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t2</span><span class="id"> -&gt;</span> <br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">zip</span><span class="id"> s1</span><span class="id"> t1</span>) (<span class="id">zip</span><span class="id"> s2</span><span class="id"> t2</span>)<span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">wlog</span><span class="id"> [x</span><span class="id"> y]</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> /</span> (<span class="id">S</span><span class="id"> *</span><span class="id"> T</span>)<span class="id">%type</span><span class="id"> =&gt;</span><span class="id"> [hwlog|]</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> s2</span><span class="id"> t2</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2]</span><span class="id"> [|y</span><span class="id"> t2]</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> hwlog</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> =&gt;</span><span class="id"> [|u</span><span class="id"> s1]</span><span class="id"> [|v</span><span class="id"> t1]//=</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /perm_nilP</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> eq1</span><span class="id"> eq2</span><span class="id"> /</span>(<span class="id">perm_iotaP</span> (<span class="id">x,</span><span class="id"> y</span>))<span class="id">[ns</span><span class="id"> nsP</span><span class="id"> /</span>(<span class="id">congr1</span> (<span class="id">@unzip1</span><span class="id"> _</span><span class="id"> _</span>))<span class="id">]</span>.<br/>
<span class="id">rewrite</span><span class="id"> unzip1_zip</span><span class="id"> ?unzip1_map_nth_zip</span><span class="id"> -?eq1//</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">perm_iotaP</span><span class="id"> x</span>)<span class="id">;</span><span class="gallina-kwd"> exists</span><span class="id"> ns;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> size_zip</span><span class="id"> -eq2</span><span class="id"> minnn</span><span class="gallina-kwd"> in</span><span class="id"> nsP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_zip2</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType}</span> (<span class="id">s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t1</span><span class="id"> t2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t1</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> size</span><span class="id"> t2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">zip</span><span class="id"> s1</span><span class="id"> t1</span>) (<span class="id">zip</span><span class="id"> s2</span><span class="id"> t2</span>)<span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> t1</span><span class="id"> t2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span> (<span class="id">@perm_zip1</span><span class="id"> _</span><span class="id"> _</span><span class="id"> s1</span><span class="id"> s2</span>)<span class="id"> 1?perm_zip_sym</span>. Qed.</div></details>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> zip</span><span class="id"> unzip1</span><span class="id"> unzip2</span><span class="id"> all2</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eqseq_all</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> t</span>)<span class="id"> =</span><span class="id"> all2</span><span class="id"> eq_op</span><span class="id"> s</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> +]</span><span class="id"> [|y</span><span class="id"> t]//=</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_map_all</span><span class="id"> I</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">f</span><span class="id"> g</span><span class="id"> :</span><span class="id"> I</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> I</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">map</span><span class="id"> f</span><span class="id"> s</span><span class="id"> ==</span><span class="id"> map</span><span class="id"> g</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> all</span><span class="id"> [pred</span><span class="id"> xy</span><span class="id"> |</span><span class="id"> xy</span>.<span class="id">1</span><span class="id"> ==</span><span class="id"> xy</span>.<span class="id">2]</span><span class="id"> [seq</span> (<span class="id">f</span><span class="id"> i,</span><span class="id"> g</span><span class="id"> i</span>)<span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqseq_all</span><span class="id"> all2E</span><span class="id"> !size_map</span><span class="id"> eqxx</span><span class="id"> zip_map</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Flatten</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">ss</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">seq</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> flatten</span><span class="id"> :=</span><span class="id"> foldr</span><span class="id"> cat</span> (<span class="id">Nil</span><span class="id"> T</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> shape</span><span class="id"> :=</span><span class="id"> map</span> (<span class="id">@size</span><span class="id"> T</span>).<br/>
<span class="vernacular">Fixpoint</span><span class="id"> reshape</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> sh</span><span class="id"> is</span><span class="id"> n</span><span class="id"> ::</span><span class="id"> sh'</span><span class="gallina-kwd"> then</span><span class="id"> take</span><span class="id"> n</span><span class="id"> s</span><span class="id"> ::</span><span class="id"> reshape</span><span class="id"> sh'</span> (<span class="id">drop</span><span class="id"> n</span><span class="id"> s</span>)<span class="gallina-kwd"> else</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> flatten_index</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span><span class="id"> :=</span><span class="id"> sumn</span> (<span class="id">take</span><span class="id"> r</span><span class="id"> sh</span>)<span class="id"> +</span><span class="id"> c</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> reshape_index</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> find</span> (<span class="id">pred1</span><span class="id"> 0</span>) (<span class="id">scanl</span><span class="id"> subn</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> sh</span>).<br/>
<span class="vernacular">Definition</span><span class="id"> reshape_offset</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> i</span><span class="id"> -</span><span class="id"> sumn</span> (<span class="id">take</span> (<span class="id">reshape_index</span><span class="id"> sh</span><span class="id"> i</span>)<span class="id"> sh</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_flatten</span><span class="id"> ss</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> sumn</span> (<span class="id">shape</span><span class="id"> ss</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> size_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_cat</span><span class="id"> ss1</span><span class="id"> ss2</span><span class="id"> :</span><span class="id"> flatten</span> (<span class="id">ss1</span><span class="id"> ++</span><span class="id"> ss2</span>)<span class="id"> =</span><span class="id"> flatten</span><span class="id"> ss1</span><span class="id"> ++</span><span class="id"> flatten</span><span class="id"> ss2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss1</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_reshape</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> size</span><span class="id"> sh</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s0</span><span class="id"> sh</span><span class="id"> IHsh</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> IHsh</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_reshape</span> (<span class="id">sh</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> nat</span>)<span class="id"> l</span><span class="id"> n</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nth</span><span class="id"> [::]</span> (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> l</span>)<span class="id"> n</span><span class="id"> =</span><span class="id"> take</span> (<span class="id">nth</span><span class="id"> 0</span><span class="id"> sh</span><span class="id"> n</span>) (<span class="id">drop</span> (<span class="id">sumn</span> (<span class="id">take</span><span class="id"> n</span><span class="id"> sh</span>))<span class="id"> l</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> sh</span><span class="id"> l</span><span class="id"> =&gt;</span><span class="id"> [|</span><span class="id"> n</span><span class="id"> IHn]</span><span class="id"> [|</span><span class="id"> sh0</span><span class="id"> sh]</span><span class="id"> l;</span><span class="id"> rewrite</span><span class="id"> ?take0</span><span class="id"> ?drop0</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> addnC</span><span class="id"> -drop_drop;</span><span class="id"> apply:</span><span class="id"> IHn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flattenK</span><span class="id"> ss</span><span class="id"> :</span><span class="id"> reshape</span> (<span class="id">shape</span><span class="id"> ss</span>) (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> ss</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> IHss;</span><span class="id"> rewrite</span><span class="id"> take_size_cat</span><span class="id"> ?drop_size_cat</span><span class="id"> ?IHss</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshapeKr</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &lt;=</span><span class="id"> sumn</span><span class="id"> sh</span><span class="id"> -&gt;</span><span class="id"> flatten</span> (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [[]|n</span><span class="id"> sh</span><span class="id"> IHsh]</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> sz_s;</span><span class="id"> rewrite</span><span class="id"> IHsh</span><span class="id"> ?cat_take_drop</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_drop</span><span class="id"> leq_subLR</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshapeKl</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s</span><span class="id"> &gt;=</span><span class="id"> sumn</span><span class="id"> sh</span><span class="id"> -&gt;</span><span class="id"> shape</span> (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> sh</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [[]|n</span><span class="id"> sh</span><span class="id"> IHsh]</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> sz_s</span>.<br/>
<span class="id">rewrite</span><span class="id"> size_takel;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> leq_trans</span> (<span class="id">leq_addr</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> sz_s</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> IHsh</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">leq_add2l</span><span class="id"> n</span>)<span class="id"> size_drop</span><span class="id"> -maxnE</span><span class="id"> leq_max</span><span class="id"> sz_s</span><span class="id"> orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_rcons</span><span class="id"> ss</span><span class="id"> s</span><span class="id"> :</span><span class="id"> flatten</span> (<span class="id">rcons</span><span class="id"> ss</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> flatten</span><span class="id"> ss</span><span class="id"> ++</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> flatten_cat</span><span class="id"> /=</span><span class="id"> cats0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_seq1</span><span class="id"> s</span><span class="id"> :</span><span class="id"> flatten</span><span class="id"> [seq</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> =</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s0</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> count_flatten</span><span class="id"> ss</span><span class="id"> P</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">count</span><span class="id"> P</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> sumn</span><span class="id"> [seq</span><span class="id"> count</span><span class="id"> P</span><span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> ss]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> IHss;</span><span class="id"> rewrite</span><span class="id"> count_cat</span><span class="id"> IHss</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> filter_flatten</span><span class="id"> ss</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">filter</span><span class="id"> P</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> flatten</span><span class="id"> [seq</span><span class="id"> filter</span><span class="id"> P</span><span class="id"> i</span><span class="id"> |</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> ss]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> /=</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> filter_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_flatten</span><span class="id"> ss</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">rev</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> flatten</span> (<span class="id">rev</span> (<span class="id">map</span><span class="id"> rev</span><span class="id"> ss</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> IHss;</span><span class="id"> rewrite</span><span class="id"> rev_cons</span><span class="id"> flatten_rcons</span><span class="id"> -IHss</span><span class="id"> rev_cat</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_shape</span><span class="id"> ss</span><span class="id"> i</span><span class="id"> :</span><span class="id"> nth</span><span class="id"> 0</span> (<span class="id">shape</span><span class="id"> ss</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> size</span> (<span class="id">nth</span><span class="id"> [::]</span><span class="id"> ss</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /shape;</span><span class="id"> case:</span> (<span class="id">ltnP</span><span class="id"> i</span> (<span class="id">size</span><span class="id"> ss</span>))<span class="id"> =&gt;</span><span class="id"> Hi;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> nth_map</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !nth_default</span><span class="id"> //</span><span class="id"> size_map</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> shape_rev</span><span class="id"> ss</span><span class="id"> :</span><span class="id"> shape</span> (<span class="id">rev</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> rev</span> (<span class="id">shape</span><span class="id"> ss</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> map_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_from_flatten_shape</span><span class="id"> ss1</span><span class="id"> ss2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">flatten</span><span class="id"> ss1</span><span class="id"> =</span><span class="id"> flatten</span><span class="id"> ss2</span><span class="id"> -&gt;</span><span class="id"> shape</span><span class="id"> ss1</span><span class="id"> =</span><span class="id"> shape</span><span class="id"> ss2</span><span class="id"> -&gt;</span><span class="id"> ss1</span><span class="id"> =</span><span class="id"> ss2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Eflat</span><span class="id"> Esh;</span><span class="id"> rewrite</span><span class="id"> -[LHS]flattenK</span><span class="id"> Eflat</span><span class="id"> Esh</span><span class="id"> flattenK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rev_reshape</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> s</span><span class="id"> =</span><span class="id"> sumn</span><span class="id"> sh</span><span class="id"> -&gt;</span><span class="id"> rev</span> (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> map</span><span class="id"> rev</span> (<span class="id">reshape</span> (<span class="id">rev</span><span class="id"> sh</span>) (<span class="id">rev</span><span class="id"> s</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> sz_s;</span><span class="id"> apply/</span>(<span class="id">canLR</span><span class="id"> revK</span>)<span class="id">/eq_from_flatten_shape</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> reshapeKr</span><span class="id"> ?sz_s</span><span class="id"> //</span><span class="id"> -rev_flatten</span><span class="id"> reshapeKr</span><span class="id"> ?revK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_rev</span><span class="id"> sumn_rev</span><span class="id"> sz_s</span>.<br/>
<span class="id">transitivity</span> (<span class="id">rev</span> (<span class="id">shape</span> (<span class="id">reshape</span> (<span class="id">rev</span><span class="id"> sh</span>) (<span class="id">rev</span><span class="id"> s</span>)))).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !reshapeKl</span><span class="id"> ?revK</span><span class="id"> ?size_rev</span><span class="id"> ?sz_s</span><span class="id"> ?sumn_rev</span>.<br/>
<span class="id">rewrite</span><span class="id"> shape_rev;</span><span class="id"> congr</span> (<span class="id">rev</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -[RHS]map_comp</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> size_rev</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshape_rcons</span><span class="id"> s</span><span class="id"> sh</span><span class="id"> n</span> (<span class="id">m</span><span class="id"> :=</span><span class="id"> sumn</span><span class="id"> sh</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">m</span><span class="id"> +</span><span class="id"> n</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reshape</span> (<span class="id">rcons</span><span class="id"> sh</span><span class="id"> n</span>)<span class="id"> s</span><span class="id"> =</span><span class="id"> rcons</span> (<span class="id">reshape</span><span class="id"> sh</span> (<span class="id">take</span><span class="id"> m</span><span class="id"> s</span>)) (<span class="id">drop</span><span class="id"> m</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Dmn;</span><span class="id"> apply/</span>(<span class="id">can_inj</span><span class="id"> revK</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> rev_reshape</span><span class="id"> ?rev_rcons</span><span class="id"> ?sumn_rcons</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> take_rev</span><span class="id"> drop_rev</span><span class="id"> -Dmn</span><span class="id"> addnK</span><span class="id"> revK</span><span class="id"> -rev_reshape</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_takel</span><span class="id"> //</span><span class="id"> -Dmn</span><span class="id"> leq_addr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_indexP</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">c</span><span class="id"> &lt;</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> flatten_index</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span><span class="id"> &lt;</span><span class="id"> sumn</span><span class="id"> sh</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> lt_c_sh;</span><span class="id"> rewrite</span><span class="id"> -[sh</span><span class="gallina-kwd"> in</span><span class="id"> sumn</span><span class="id"> sh]</span>(<span class="id">cat_take_drop</span><span class="id"> r</span>)<span class="id"> sumn_cat</span><span class="id"> ltn_add2l</span>.<br/>
<span class="id">suffices</span><span class="id"> lt_r_sh:</span><span class="id"> r</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> sh</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">drop_nth</span><span class="id"> 0</span><span class="id"> lt_r_sh</span>)<span class="id"> ltn_addr</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ltnP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> le_sh_r;</span><span class="id"> rewrite</span><span class="id"> nth_default</span><span class="gallina-kwd"> in</span><span class="id"> lt_c_sh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshape_indexP</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> :</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> sumn</span><span class="id"> sh</span><span class="id"> -&gt;</span><span class="id"> reshape_index</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> sh</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_index;</span><span class="id"> elim:</span><span class="id"> sh</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> sh</span><span class="id"> IHsh</span><span class="gallina-kwd"> in</span><span class="id"> i</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [//</span><span class="id"> |</span><span class="id"> le_n_i]</span><span class="id"> :=</span><span class="id"> ltnP</span><span class="id"> i</span><span class="id"> n;</span><span class="id"> rewrite</span><span class="id"> -leq_subLR</span><span class="id"> subSn</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /IHsh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshape_offsetP</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">i</span><span class="id"> &lt;</span><span class="id"> sumn</span><span class="id"> sh</span><span class="id"> -&gt;</span><span class="id"> reshape_offset</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> sh</span> (<span class="id">reshape_index</span><span class="id"> sh</span><span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_offset</span><span class="id"> /reshape_index;</span><span class="id"> elim:</span><span class="id"> sh</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> sh</span><span class="id"> IHsh</span><span class="gallina-kwd"> in</span><span class="id"> i</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> subn_eq0;</span><span class="id"> have</span><span class="id"> [|</span><span class="id"> le_n_i]</span><span class="id"> :=</span><span class="id"> ltnP</span><span class="id"> i</span><span class="id"> n;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subn0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leq_subLR</span><span class="id"> /=</span><span class="id"> subnDA</span><span class="id"> subSn</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /IHsh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshape_indexK</span><span class="id"> sh</span><span class="id"> i</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">flatten_index</span><span class="id"> sh</span> (<span class="id">reshape_index</span><span class="id"> sh</span><span class="id"> i</span>) (<span class="id">reshape_offset</span><span class="id"> sh</span><span class="id"> i</span>)<span class="id"> =</span><span class="id"> i</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_offset</span><span class="id"> /reshape_index</span><span class="id"> /flatten_index</span><span class="id"> -subSKn</span>.<br/>
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> sh</span><span class="id"> IHsh</span><span class="gallina-kwd"> in</span><span class="id"> i</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> subn_eq0;</span><span class="id"> have</span><span class="id"> [//|le_n_i]</span><span class="id"> :=</span><span class="id"> ltnP</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> subnDA</span><span class="id"> subSn</span><span class="id"> //</span><span class="id"> -addnA</span><span class="id"> IHsh</span><span class="id"> subnKC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_indexKl</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">c</span><span class="id"> &lt;</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> reshape_index</span><span class="id"> sh</span> (<span class="id">flatten_index</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span>)<span class="id"> =</span><span class="id"> r</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_index</span><span class="id"> /flatten_index</span>.<br/>
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> sh</span><span class="id"> IHsh]</span><span class="id"> [|r]</span><span class="id"> //=</span><span class="id"> lt_c_sh;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ifT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -addnA</span><span class="id"> -addnS</span><span class="id"> addKn</span><span class="id"> IHsh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_indexKr</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">c</span><span class="id"> &lt;</span><span class="id"> nth</span><span class="id"> 0</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> reshape_offset</span><span class="id"> sh</span> (<span class="id">flatten_index</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> c</span>)<span class="id"> =</span><span class="id"> c</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_offset</span><span class="id"> /reshape_index</span><span class="id"> /flatten_index</span>.<br/>
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> r</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> sh</span><span class="id"> IHsh]</span><span class="id"> [|r]</span><span class="id"> //=</span><span class="id"> lt_c_sh;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ifT</span><span class="id"> ?subn0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -addnA</span><span class="id"> -addnS</span><span class="id"> addKn</span><span class="id"> /=</span><span class="id"> subnDl</span><span class="id"> IHsh</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> nth_flatten</span><span class="id"> x0</span><span class="id"> ss</span><span class="id"> i</span> (<span class="id">r</span><span class="id"> :=</span><span class="id"> reshape_index</span> (<span class="id">shape</span><span class="id"> ss</span>)<span class="id"> i</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">nth</span><span class="id"> x0</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> i</span><span class="id"> =</span><span class="id"> nth</span><span class="id"> x0</span> (<span class="id">nth</span><span class="id"> [::]</span><span class="id"> ss</span><span class="id"> r</span>) (<span class="id">reshape_offset</span> (<span class="id">shape</span><span class="id"> ss</span>)<span class="id"> i</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /reshape_offset</span><span class="id"> -subSKn</span><span class="id"> {}/r</span><span class="id"> /reshape_index</span>.<br/>
<span class="id">elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> IHss</span><span class="gallina-kwd"> in</span><span class="id"> i</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> subn_eq0</span><span class="id"> nth_cat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [//|le_s_i]</span><span class="id"> :=</span><span class="id"> ltnP;</span><span class="id"> rewrite</span><span class="id"> subnDA</span><span class="id"> subSn</span><span class="id"> /=</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> reshape_leq</span><span class="id"> sh</span><span class="id"> i1</span><span class="id"> i2</span><br/>
&nbsp;&nbsp;(<span class="id">r1</span><span class="id"> :=</span><span class="id"> reshape_index</span><span class="id"> sh</span><span class="id"> i1</span>) (<span class="id">c1</span><span class="id"> :=</span><span class="id"> reshape_offset</span><span class="id"> sh</span><span class="id"> i1</span>)<br/>
&nbsp;&nbsp;(<span class="id">r2</span><span class="id"> :=</span><span class="id"> reshape_index</span><span class="id"> sh</span><span class="id"> i2</span>) (<span class="id">c2</span><span class="id"> :=</span><span class="id"> reshape_offset</span><span class="id"> sh</span><span class="id"> i2</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="id">i1</span><span class="id"> &lt;=</span><span class="id"> i2</span>)<span class="id"> =</span> ((<span class="id">r1</span><span class="id"> &lt;</span><span class="id"> r2</span>)<span class="id"> ||</span> ((<span class="id">r1</span><span class="id"> ==</span><span class="id"> r2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">c1</span><span class="id"> &lt;=</span><span class="id"> c2</span>))).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> {}/r1</span><span class="id"> {}/c1</span><span class="id"> {}/r2</span><span class="id"> {}/c2</span><span class="id"> /reshape_offset</span><span class="id"> /reshape_index</span>.<br/>
<span class="id">elim:</span><span class="id"> sh</span><span class="id"> =&gt;</span><span class="id"> [|s0</span><span class="id"> s</span><span class="id"> IHs]</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> i1</span><span class="id"> i2</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> ?subn0</span><span class="id"> ?subn_eq0</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> [[]</span><span class="id"> i1s0</span><span class="id"> []</span><span class="id"> i2s0]</span><span class="id"> :=</span> (<span class="id">ltnP</span><span class="id"> i1</span><span class="id"> s0,</span><span class="id"> ltnP</span><span class="id"> i2</span><span class="id"> s0</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !subn0</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> leq_trans</span><span class="id"> i2s0;</span><span class="id"> apply/ltnW</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> apply/negP</span><span class="id"> =&gt;</span><span class="id"> /</span>(<span class="id">leq_trans</span><span class="id"> i1s0</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> leqNgt</span><span class="id"> i2s0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !subSn</span><span class="id"> //</span><span class="id"> !eqSS</span><span class="id"> !ltnS</span><span class="id"> !subnDA</span><span class="id"> -IHs</span><span class="id"> leq_subLR</span><span class="id"> subnKC</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Flatten</span>.<br/>
<br/>
<span class="id">Prenex</span><span class="vernacular"> Implicits</span><span class="id"> flatten</span><span class="id"> shape</span><span class="id"> reshape</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_flatten</span><span class="id"> S</span><span class="id"> T</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> ss</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">map</span><span class="id"> f</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> flatten</span> (<span class="id">map</span> (<span class="id">map</span><span class="id"> f</span>)<span class="id"> ss</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> /=</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> map_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_map1</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span>)<span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">flatten</span><span class="id"> [seq</span><span class="id"> [::</span><span class="id"> f</span><span class="id"> x]</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> =</span><span class="id"> map</span><span class="id"> f</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> s0</span><span class="id"> s</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> undup_flatten_nseq</span><span class="id"> n</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> n</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">undup</span> (<span class="id">flatten</span> (<span class="id">nseq</span><span class="id"> n</span><span class="id"> s</span>))<span class="id"> =</span><span class="id"> undup</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|[|n]/=</span><span class="id"> IHn]//=</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ?cats0//</span><span class="id"> undup_cat</span><span class="id"> {}IHn//</span>.<br/>
<span class="id">rewrite</span> (<span class="id">@eq_in_filter</span><span class="id"> _</span><span class="id"> _</span><span class="id"> pred0</span>)<span class="id"> ?filter_pred0//</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_undup</span><span class="id"> mem_cat</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sumn_flatten</span> (<span class="id">ss</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">seq</span><span class="id"> nat</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">sumn</span> (<span class="id">flatten</span><span class="id"> ss</span>)<span class="id"> =</span><span class="id"> sumn</span> (<span class="id">map</span><span class="id"> sumn</span><span class="id"> ss</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> ss</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> s</span><span class="id"> ss</span><span class="id"> /=</span><span class="id"> &lt;-;</span><span class="id"> apply:</span><span class="id"> sumn_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_reshape</span><span class="id"> T</span><span class="id"> S</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> sh</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">map</span> (<span class="id">map</span><span class="id"> f</span>) (<span class="id">reshape</span><span class="id"> sh</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> reshape</span><span class="id"> sh</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> sh</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> sh0</span><span class="id"> sh</span><span class="id"> IHsh</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> map_take</span><span class="id"> IHsh</span><span class="id"> map_drop</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> EqFlatten</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> S</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flattenP</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">seq</span><span class="id"> T</span>))<span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> s,</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>) (<span class="id">x</span><span class="id"> \in</span><span class="id"> flatten</span><span class="id"> A</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> A</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|s</span><span class="id"> A</span><span class="id"> IH_A];</span><span class="id"> [by</span><span class="id"> right;</span><span class="id"> case</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> mem_cat]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> equivP</span> (<span class="id">iff_sym</span><span class="id"> exists_cons</span>)<span class="id">;</span><span class="id"> apply:</span> (<span class="id">orPP</span><span class="id"> idP</span><span class="id"> IH_A</span>).<br/>
Qed.</div></details>
<span class="vernacular">Arguments</span><span class="id"> flattenP</span><span class="id"> {A</span><span class="id"> x}</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> flatten_mapP</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> s</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists2</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> x</span>) (<span class="id">y</span><span class="id"> \in</span><span class="id"> flatten</span> (<span class="id">map</span><span class="id"> A</span><span class="id"> s</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> flattenP</span>)<span class="id"> =&gt;</span><span class="id"> [[_</span><span class="id"> /mapP[x</span><span class="id"> sx</span><span class="id"> -&gt;]]</span><span class="id"> |</span><span class="id"> [x</span><span class="id"> sx]]</span><span class="id"> Axy;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> x</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">A</span><span class="id"> x</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?map_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_flatten</span> (<span class="id">ss1</span><span class="id"> ss2</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">seq</span><span class="id"> T</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> ss1</span><span class="id"> ss2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">flatten</span><span class="id"> ss1</span>) (<span class="id">flatten</span><span class="id"> ss2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_ss;</span><span class="id"> apply/permP=&gt;</span><span class="id"> a;</span><span class="id"> apply/catCA_perm_subst:</span><span class="id"> ss1</span><span class="id"> ss2</span><span class="id"> eq_ss</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> ss1</span><span class="id"> ss2</span><span class="id"> ss3;</span><span class="id"> rewrite</span><span class="id"> !flatten_cat</span><span class="id"> !count_cat</span><span class="id"> addnCA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqFlatten</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> flattenP</span><span class="id"> {T</span><span class="id"> A</span><span class="id"> x}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> flatten_mapP</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> A</span><span class="id"> s</span><span class="id"> y}</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E | x &lt;- s , y &lt;- t ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">flatten</span><span class="id"> [seq</span><span class="id"> [seq</span><span class="id"> E</span><span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> x</span><span class="id"> binder,</span><span class="id"> y</span><span class="id"> binder,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">format</span> <span class="id">&quot;[ '[hv' 'seq'  E '/ '  |  x  &lt;-  s , '/   '  y  &lt;-  t ] ']'&quot;</span>)<br/>
&nbsp;&nbsp;&nbsp;<span class="id">:</span><span class="id"> seq_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;[ 'seq' E : R | x &lt;- s , y &lt;- t ]&quot;</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;(<span class="id">flatten</span><span class="id"> [seq</span><span class="id"> [seq</span><span class="id"> E</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span><span class="id"> |</span><span class="id"> x</span> <span class="id"> &lt;-</span><span class="id"> s]</span>)<br/>
&nbsp;&nbsp;(<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> E</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 99,</span><span class="id"> x</span><span class="id"> binder,</span><span class="id"> y</span><span class="id"> binder,</span><span class="id"> only</span><span class="id"> parsing</span>)<span class="id"> :</span><span class="id"> seq_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> PrefixSuffixInfix</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> {struct</span><span class="id"> s2}</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s1</span><span class="id"> isn't</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s1'</span><span class="gallina-kwd"> then</span><span class="id"> true</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s2</span><span class="id"> isn't</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s2'</span><span class="gallina-kwd"> then</span><span class="id"> false</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> &amp;&amp;</span><span class="id"> prefix</span><span class="id"> s1'</span><span class="id"> s2'</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefixE</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span> (<span class="id">take</span> (<span class="id">size</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> ==</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2</span><span class="id"> +]</span><span class="id"> [|x</span><span class="id"> s1]//=</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_refl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prefixE</span><span class="id"> take_size</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefixs0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> [::]</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_cons</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">prefix</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>) (<span class="id">y</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> &amp;&amp;</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_catr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s1'</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s1'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">prefix</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>) (<span class="id">s1'</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> =</span> (<span class="id">s1</span><span class="id"> ==</span><span class="id"> s1'</span>)<span class="id"> &amp;&amp;</span><span class="id"> prefix</span><span class="id"> s2</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s1'</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1</span><span class="id"> IHs1]</span><span class="id"> [|y</span><span class="id"> s1']//=</span><span class="id"> [eqs1]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> IHs1//</span><span class="id"> eqseq_cons</span><span class="id"> andbA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prefixE</span><span class="id"> take_cat</span><span class="id"> ltnn</span><span class="id"> subnn</span><span class="id"> take0</span><span class="id"> cats0</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> prefix_prefix</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefixP</span><span class="id"> {s1</span><span class="id"> s2}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> s2'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2'</span>) (<span class="id">prefix</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[{}s2</span><span class="id"> -&gt;]];</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> prefix_prefix</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prefixE</span><span class="id"> =&gt;</span><span class="id"> /eqP&lt;-;</span><span class="gallina-kwd"> exists</span> (<span class="id">drop</span> (<span class="id">size</span><span class="id"> s1</span>)<span class="id"> s2</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> cat_take_drop</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_trans</span><span class="id"> :</span><span class="id"> transitive</span><span class="id"> prefix</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> s2</span><span class="id"> _</span><span class="id"> /prefixP[s1</span><span class="id"> -&gt;]</span><span class="id"> /prefixP[s3</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> -catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefixs1</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<span class="id"> ||</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> prefixs0</span><span class="id"> eqseq_cons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catl_prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> prefix</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixP</span><span class="id"> [s2']</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_catl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> prefix</span><span class="id"> s1</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s3</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixP</span><span class="id"> [s2']</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> prefix_prefix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><span class="id"> prefix</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffixE</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span> (<span class="id">drop</span> (<span class="id">size</span><span class="id"> s2</span><span class="id"> -</span><span class="id"> size</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> ==</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> prefixE</span><span class="id"> take_rev</span> (<span class="id">can_eq</span><span class="id"> revK</span>)<span class="id"> size_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_refl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> prefix_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffixs0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> prefixs0</span><span class="id"> -!nilpE</span><span class="id"> rev_nilp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> [::]</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> prefix0s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_rev</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_revLR</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span> (<span class="id">rev</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> =</span><span class="id"> suffix</span><span class="id"> s1</span> (<span class="id">rev</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -prefix_rev</span><span class="id"> revK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_rev</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -prefix_rev</span><span class="id"> !revK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_revLR</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span> (<span class="id">rev</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> =</span><span class="id"> prefix</span><span class="id"> s1</span> (<span class="id">rev</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -prefix_rev</span><span class="id"> revK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s2</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> rev_cat</span><span class="id"> prefix_prefix</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> suffix_suffix</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffixP</span><span class="id"> {s1</span><span class="id"> s2}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> s2'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> s2'</span><span class="id"> ++</span><span class="id"> s1</span>) (<span class="id">suffix</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> prefixP</span>)<span class="id"> =&gt;</span><span class="id"> [[s2'</span><span class="id"> rev_s2]|[s2'</span><span class="id"> -&gt;]];</span><span class="gallina-kwd"> exists</span> (<span class="id">rev</span><span class="id"> s2'</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> rev_cat</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[s2]revK</span><span class="id"> rev_s2</span><span class="id"> rev_cat</span><span class="id"> revK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_trans</span><span class="id"> :</span><span class="id"> transitive</span><span class="id"> suffix</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> s2</span><span class="id"> _</span><span class="id"> /suffixP[s1</span><span class="id"> -&gt;]</span><span class="id"> /suffixP[s3</span><span class="id"> -&gt;];</span><span class="id"> rewrite</span><span class="id"> catA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_rcons</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">suffix</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x</span>) (<span class="id">rcons</span><span class="id"> s2</span><span class="id"> y</span>)<span class="id"> =</span> (<span class="id">x</span><span class="id"> ==</span><span class="id"> y</span>)<span class="id"> &amp;&amp;</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> 2!rev_rcons</span><span class="id"> prefix_cons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_catl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> s3'</span><span class="id"> :</span><span class="id"> size</span><span class="id"> s3</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s3'</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">suffix</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s3</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s3'</span>)<span class="id"> =</span> (<span class="id">s3</span><span class="id"> ==</span><span class="id"> s3'</span>)<span class="id"> &amp;&amp;</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> eqs3;</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> !rev_cat</span><span class="id"> prefix_catr</span><span class="id"> ?size_rev//</span> (<span class="id">can_eq</span><span class="id"> revK</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_catr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> suffix</span><span class="id"> s1</span> (<span class="id">s3</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixP</span><span class="id"> [s2']</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> catA</span><span class="id"> suffix_suffix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catl_suffix</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixP</span><span class="id"> [s2']</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> catA</span><span class="id"> suffix_suffix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_cons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /suffix</span><span class="id"> rev_cons</span><span class="id"> prefix_rcons</span>. Qed.</div></details>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> s2</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s2'</span><span class="gallina-kwd"> then</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> ||</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2'</span><span class="gallina-kwd"> else</span><span class="id"> s1</span><span class="id"> ==</span><span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> infix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="gallina-kwd"> then</span><span class="id"> 0</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="gallina-kwd"> if</span><span class="id"> s2</span><span class="id"> is</span><span class="id"> y</span><span class="id"> ::</span><span class="id"> s2'</span><span class="gallina-kwd"> then</span> (<span class="id">infix_index</span><span class="id"> s1</span><span class="id"> s2'</span>).<span class="id">+1</span><span class="gallina-kwd"> else</span><span class="id"> 1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> [::]</span><span class="id"> s</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixs0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_consl</span><span class="id"> s1</span><span class="id"> y</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infix</span><span class="id"> s1</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> prefix</span><span class="id"> s1</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> ||</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_indexss</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix_index</span><span class="id"> s</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> prefix_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_index_le</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> &lt;=</span> (<span class="id">size</span><span class="id"> s2</span>).<span class="id">+1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s2']</span><span class="id"> /=;</span><span class="id"> case:</span><span class="id"> ifP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixTindex</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span> (<span class="id">infix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2</span><span class="id"> +]</span><span class="id"> [|x</span><span class="id"> s1]//=</span><span class="id"> =&gt;</span><span class="id"> &lt;-;</span><span class="id"> case:</span><span class="id"> ifP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixPn</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">infix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span> (<span class="id">size</span><span class="id"> s2</span>).<span class="id">+1</span>) (<span class="id">~~</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -infixTindex</span><span class="id"> -ltnNge;</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [s2lt|-&gt;//]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> s2lt</span><span class="id"> infix_index_le</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_index0s</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix_index</span><span class="id"> [::]</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_indexs0</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix_index</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> !=</span><span class="id"> [::]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixE</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">take</span> (<span class="id">size</span><span class="id"> s1</span>) (<span class="id">drop</span> (<span class="id">infix_index</span><span class="id"> s1</span><span class="id"> s2</span>)<span class="id"> s2</span>)<span class="id"> ==</span><span class="id"> s1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2</span><span class="id"> +]</span><span class="id"> [|x</span><span class="id"> s1]//=</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> /andP[/eqP-&gt;</span><span class="id"> ps1s2/=];</span><span class="id"> rewrite</span><span class="id"> eqseq_cons</span><span class="id"> -prefixE</span><span class="id"> eqxx</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_refl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> infixE</span><span class="id"> infix_indexss//</span><span class="id"> drop0</span><span class="id"> take_size</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefixW</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> [|y</span><span class="id"> s2</span><span class="id"> IHs2]</span><span class="id"> [|x</span><span class="id"> s1]//=-&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> prefixW</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> prefix_infix</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s2</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span><span class="id"> ++</span><span class="id"> s3</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s1</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s1</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> orbT</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> infix_infix</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s2</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -[X</span><span class="gallina-kwd"> in</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> X]cats0</span>. Qed.</div></details>
<span class="vernacular">Hint</span><span class="id"> Resolve</span><span class="id"> suffix_infix</span><span class="id"> :</span><span class="id"> core</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixP</span><span class="id"> {s1</span><span class="id"> s2}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> s</span><span class="id"> s'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> s</span><span class="id"> ++</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s'</span>) (<span class="id">infix</span><span class="id"> s1</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|[p</span><span class="id"> [s</span><span class="id"> {s2}-&gt;]]]//=;</span><span class="id"> rewrite</span><span class="id"> infixE</span><span class="id"> =&gt;</span><span class="id"> /eqP&lt;-</span>.<br/>
<span class="id">set</span><span class="id"> k</span><span class="id"> :=</span><span class="id"> infix_index</span><span class="id"> _</span><span class="id"> _;</span><span class="gallina-kwd"> exists</span> (<span class="id">take</span><span class="id"> k</span><span class="id"> s2</span>)<span class="id">,</span> (<span class="id">drop</span> (<span class="id">size</span><span class="id"> s1</span><span class="id"> +</span><span class="id"> k</span>)<span class="id"> s2</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -drop_drop</span><span class="id"> !cat_take_drop</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_rev</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">gen</span><span class="id"> have</span><span class="id"> sr</span><span class="id"> :</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP</span><span class="id"> =&gt;</span><span class="id"> /sr;</span><span class="id"> rewrite</span><span class="id"> ?revK</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> /infixP[s</span><span class="id"> [p</span><span class="id"> -&gt;]];</span><span class="id"> rewrite</span><span class="id"> !rev_cat</span><span class="id"> -catA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffixW</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix_rev;</span><span class="id"> apply:</span><span class="id"> prefixW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_trans</span><span class="id"> :</span><span class="id"> transitive</span><span class="id"> infix</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> /infixP[s1p</span><span class="id"> [s1s</span><span class="id"> def_s]]</span><span class="id"> /infixP[sp</span><span class="id"> [ss</span><span class="id"> def_s2]]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/infixP;</span><span class="gallina-kwd"> exists</span> (<span class="id">sp</span><span class="id"> ++</span><span class="id"> s1p</span>)<span class="id">,</span>(<span class="id">s1s</span><span class="id"> ++</span><span class="id"> ss</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> def_s2</span><span class="id"> def_s</span><span class="id"> -!catA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_revLR</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">rev</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> =</span><span class="id"> infix</span><span class="id"> s1</span> (<span class="id">rev</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix_rev</span><span class="id"> revK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_rconsl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infix</span><span class="id"> s1</span> (<span class="id">rcons</span><span class="id"> s2</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> suffix</span><span class="id"> s1</span> (<span class="id">rcons</span><span class="id"> s2</span><span class="id"> y</span>)<span class="id"> ||</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -infix_rev</span><span class="id"> rev_rcons</span><span class="id"> infix_consl</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -rev_rcons</span><span class="id"> prefix_rev</span><span class="id"> infix_rev</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_cons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cat1s</span><span class="id"> suffix_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixs1</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::]</span>)<span class="id"> ||</span> (<span class="id">s</span><span class="id"> ==</span><span class="id"> [::</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> infix_consl</span><span class="id"> prefixs1</span><span class="id"> orbC</span><span class="id"> orbA</span><span class="id"> orbb</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catl_infix</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> apply:</span><span class="id"> infix_trans;</span><span class="id"> exact/suffixW/suffix_suffix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catr_infix</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -infix_rev</span><span class="id"> rev_cat</span><span class="id"> =&gt;</span><span class="id"> /catl_infix;</span><span class="id"> rewrite</span><span class="id"> infix_rev</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cons2_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>) (<span class="id">x</span><span class="id"> ::</span><span class="id"> s2</span>)<span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> /=</span><span class="id"> -cat1s</span><span class="id"> =&gt;</span><span class="id"> /orP[/prefixW//|];</span><span class="id"> exact:</span><span class="id"> catl_infix</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> rcons2_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">rcons</span><span class="id"> s1</span><span class="id"> x</span>) (<span class="id">rcons</span><span class="id"> s2</span><span class="id"> x</span>)<span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix_rev</span><span class="id"> !rev_rcons</span><span class="id"> =&gt;</span><span class="id"> /cons2_infix;</span><span class="id"> rewrite</span><span class="id"> infix_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catr2_infix</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">s</span><span class="id"> ++</span><span class="id"> s1</span>) (<span class="id">s</span><span class="id"> ++</span><span class="id"> s2</span>)<span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /cons2_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> catl2_infix</span><span class="id"> s</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">s1</span><span class="id"> ++</span><span class="id"> s</span>) (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s</span>)<span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix_rev</span><span class="id"> !rev_cat</span><span class="id"> =&gt;</span><span class="id"> /catr2_infix;</span><span class="id"> rewrite</span><span class="id"> infix_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_catl</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span> (<span class="id">s3</span><span class="id"> ++</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> is12;</span><span class="id"> apply:</span><span class="id"> infix_trans</span><span class="id"> is12</span> (<span class="id">suffix_infix</span><span class="id"> _</span><span class="id"> _</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_catr</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span> (<span class="id">s2</span><span class="id"> ++</span><span class="id"> s3</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case:</span><span class="id"> s3</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> /infixP</span><span class="id"> [p</span><span class="id"> [sf]]</span><span class="id"> -&gt;];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cats0</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -catA;</span><span class="id"> apply:</span><span class="id"> infix_catl;</span><span class="id"> rewrite</span><span class="id"> -catA</span><span class="id"> prefix_infix</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_infix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixW/infix_trans;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_infix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixW/infix_trans;</span><span class="id"> apply</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_prefix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> prefix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> /prefixW;</span><span class="id"> apply:</span><span class="id"> infix_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_suffix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> suffix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> +</span><span class="id"> /suffixW;</span><span class="id"> apply:</span><span class="id"> infix_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_suffix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> suffix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixW</span><span class="id"> +</span><span class="id"> /suffixW</span><span class="id"> +;</span><span class="id"> apply:</span><span class="id"> infix_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_prefix_trans</span><span class="id"> s2</span><span class="id"> s1</span><span class="id"> s3</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> prefix</span><span class="id"> s2</span><span class="id"> s3</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s3</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixW</span><span class="id"> +</span><span class="id"> /prefixW</span><span class="id"> +;</span><span class="id"> apply:</span><span class="id"> infix_trans</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infixW</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> subseq</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /infixP[sp</span><span class="id"> [ss</span><span class="id"> -&gt;]]</span>.<br/>
<span class="id">exact:</span><span class="id"> subseq_trans</span> (<span class="id">prefix_subseq</span><span class="id"> _</span><span class="id"> _</span>) (<span class="id">suffix_subseq</span><span class="id"> _</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> {subset</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> s2}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /infixW</span><span class="id"> subH;</span><span class="id"> apply:</span><span class="id"> mem_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix1s</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x'</span><span class="id"> s</span><span class="id"> /=</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> in_cons</span><span class="id"> prefix0s</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix1s</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix1s</span><span class="id"> =&gt;</span><span class="id"> /prefixW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix1s</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -infix1s</span><span class="id"> =&gt;</span><span class="id"> /suffixW</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_rcons</span><span class="id"> s</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s</span> (<span class="id">rcons</span><span class="id"> s</span><span class="id"> x</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> prefix_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /infixW</span><span class="id"> /subseq_uniq</span><span class="id"> subH</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixW</span><span class="id"> /infix_uniq</span><span class="id"> preH</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_uniq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> s1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixW</span><span class="id"> /infix_uniq</span><span class="id"> preH</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_take</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> prefix</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{2}[s]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> suffix_drop</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> suffix</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{2}[s]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_take</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> prefixW</span><span class="id"> //</span><span class="id"> prefix_take</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_drop_gt0</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> ~~</span><span class="id"> prefix</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> i</span><span class="id"> &gt;</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> drop0</span><span class="id"> ltnn</span><span class="id"> prefix_refl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> infix_drop</span><span class="id"> s</span><span class="id"> i</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">drop</span><span class="id"> i</span><span class="id"> s</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{2}[s]</span>(<span class="id">cat_take_drop</span><span class="id"> i</span>). Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> consr_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cat1s</span><span class="id"> =&gt;</span><span class="id"> /catr_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> consl_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> x</span><span class="id"> :</span><span class="id"> infix</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cat1s</span><span class="id"> =&gt;</span><span class="id"> /catl_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prefix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> infix_index</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> 0</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s1]</span><span class="id"> [|y</span><span class="id"> s2]</span><span class="id"> //=</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> infix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /infixW;</span><span class="id"> apply:</span><span class="id"> size_subseq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> prefix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /prefixW;</span><span class="id"> apply:</span><span class="id"> size_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> suffix</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> size</span><span class="id"> s1</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /suffixW;</span><span class="id"> apply:</span><span class="id"> size_infix</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> PrefixSuffixInfix</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> AllPairsDep</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">S</span><span class="id"> S'</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> allpairs_dep</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_allpairs_dep</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">size</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> sumn</span><span class="id"> [seq</span><span class="id"> size</span> (<span class="id">t</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> size_cat</span><span class="id"> size_map</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs0l</span><span class="id"> f</span><span class="id"> t</span><span class="id"> :</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> [::],</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs0r</span><span class="id"> f</span><span class="id"> s</span><span class="id"> :</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> [::]]</span><span class="id"> =</span><span class="id"> [::]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs1l</span><span class="id"> f</span><span class="id"> x</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> [::</span><span class="id"> x],</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> cats0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs1r</span><span class="id"> f</span><span class="id"> s</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> [::</span><span class="id"> y</span><span class="id"> x]]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">y</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> flatten_map1</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_cons</span><span class="id"> f</span><span class="id"> x</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allpairs</span> (<span class="id">f1</span><span class="id"> f2</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> f1</span><span class="id"> x</span><span class="id"> =1</span><span class="id"> f2</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_f;</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> eq_f</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allpairsr</span> (<span class="id">f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> s</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> :</span> (<span class="gallina-kwd">forall</span><span class="id"> x,</span><span class="id"> t1</span><span class="id"> x</span><span class="id"> =</span><span class="id"> t2</span><span class="id"> x</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_t;</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> eq_t</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_cat</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1</span><span class="id"> ++</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_cat</span><span class="id"> flatten_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_rcons</span><span class="id"> f</span><span class="id"> x</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> rcons</span><span class="id"> s</span><span class="id"> x,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> allpairs_cat</span><span class="id"> allpairs1l</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_mapl</span><span class="id"> f</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> S'</span><span class="id"> -&gt;</span><span class="id"> S</span>)<span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> map</span><span class="id"> g</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f</span> (<span class="id">g</span><span class="id"> x</span>)<span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span> (<span class="id">g</span><span class="id"> x</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -map_comp</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_mapr</span><span class="id"> f</span> (<span class="id">g</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T'</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> x</span>)<span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> map</span> (<span class="id">g</span><span class="id"> x</span>) (<span class="id">t</span><span class="id"> x</span>)<span class="id">]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">g</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> -map_comp</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> AllPairsDep</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> allpairs_dep</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> /</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> map_allpairs</span><span class="id"> S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> R'</span> (<span class="id">g</span><span class="id"> :</span><span class="id"> R'</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">map</span><span class="id"> g</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> :</span><span class="id"> S</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> g</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> map_flatten</span><span class="id"> allpairs_mapl</span><span class="id"> allpairs_mapr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> AllPairsNonDep</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">f</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> allpairs</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_allpairs</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> size</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span><span class="id"> =</span><span class="id"> size</span><span class="id"> s</span><span class="id"> *</span><span class="id"> size</span><span class="id"> t</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs;</span><span class="id"> rewrite</span><span class="id"> size_cat</span><span class="id"> size_map</span><span class="id"> IHs</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> AllPairsNonDep</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> allpairs</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> R}</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> /</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqAllPairsDep</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">S</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">R</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> seq</span> (<span class="id">T</span><span class="id"> x</span>)).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairsPdep</span><span class="id"> R</span> (<span class="id">f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>)<span class="id"> s</span><span class="id"> t</span> (<span class="id">z</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> [/\</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> t</span><span class="id"> x</span><span class="id"> &amp;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">z</span><span class="id"> \in</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> flatten_mapP</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case=&gt;</span><span class="id"> x</span><span class="id"> sx</span><span class="id"> /mapP[y</span><span class="id"> ty</span><span class="id"> -&gt;];</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> x</span><span class="id"> [y</span><span class="id"> [sx</span><span class="id"> ty</span><span class="id"> -&gt;]];</span><span class="gallina-kwd"> exists</span><span class="id"> x;</span><span class="id"> last</span><span class="id"> apply:</span><span class="id"> map_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variable</span><span class="id"> R</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_f_dep</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> t</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> sx</span><span class="id"> ty;</span><span class="id"> apply/allpairsPdep;</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> y</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_allpairs_dep</span><span class="id"> f1</span><span class="id"> f2</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> {in</span><span class="id"> t</span><span class="id"> x,</span><span class="id"> f1</span><span class="id"> x</span><span class="id"> =1</span><span class="id"> f2</span><span class="id"> x}}</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [eq_f</span><span class="id"> |</span><span class="id"> eq_fst</span><span class="id"> x</span><span class="id"> s_x]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span><span class="id"> flatten;</span><span class="id"> apply/eq_in_map=&gt;</span><span class="id"> x</span><span class="id"> s_x;</span><span class="id"> apply/eq_in_map/eq_f</span>.<br/>
<span class="id">apply/eq_in_map;</span><span class="id"> apply/eq_in_map:</span><span class="id"> x</span><span class="id"> s_x;</span><span class="id"> apply/eq_from_flatten_shape</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /shape</span><span class="id"> -!map_comp;</span><span class="id"> apply/eq_map=&gt;</span><span class="id"> x</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !size_map</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_allpairs_dep</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> s2</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> s1,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> perm_eq</span> (<span class="id">t1</span><span class="id"> x</span>) (<span class="id">t2</span><span class="id"> x</span>)<span class="id">}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1</span><span class="id"> x]</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> =&gt;</span><span class="id"> [s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> |a</span><span class="id"> s1</span><span class="id"> IH</span><span class="id"> s2</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> perm_s2</span><span class="id"> perm_t1]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_sym</span><span class="id"> =&gt;</span><span class="id"> /perm_nilP-&gt;</span>.<br/>
<span class="id">have</span><span class="id"> mem_a</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> s2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_mem</span><span class="id"> perm_s2</span>)<span class="id"> inE</span><span class="id"> eqxx</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[s2]</span>(<span class="id">cat_take_drop</span> (<span class="id">index</span><span class="id"> a</span><span class="id"> s2</span>)).<br/>
<span class="id">rewrite</span><span class="id"> allpairs_cat</span> (<span class="id">drop_nth</span><span class="id"> a</span>)<span class="id"> ?index_mem</span><span class="id"> //=</span><span class="id"> nth_index</span><span class="id"> //=</span>.<br/>
<span class="id">rewrite</span><span class="id"> perm_sym</span><span class="id"> perm_catC</span><span class="id"> -catA</span><span class="id"> perm_cat</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> perm_catC</span><span class="id"> -allpairs_cat</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -remE</span><span class="id"> perm_sym</span><span class="id"> IH</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> xI];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> perm_t1;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> xI</span><span class="id"> orbT</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> a</span>) (<span class="id">perm_trans</span><span class="id"> perm_s2</span> (<span class="id">perm_to_rem</span><span class="id"> _</span>)).<br/>
<span class="id">have</span><span class="id"> /perm_t1</span><span class="id"> :</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> a</span><span class="id"> ::</span><span class="id"> s1</span> <span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> eqxx</span>.<br/>
<span class="id">rewrite</span><span class="id"> perm_sym;</span><span class="id"> elim:</span> (<span class="id">t2</span><span class="id"> a</span>) (<span class="id">t1</span><span class="id"> a</span>)<span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [s4|b</span><span class="id"> s3</span><span class="id"> IH1</span><span class="id"> s4</span><span class="id"> perm_s4]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_sym</span><span class="id"> =&gt;</span><span class="id"> /perm_nilP-&gt;</span>.<br/>
<span class="id">have</span><span class="id"> mem_b</span><span class="id"> :</span><span class="id"> b</span><span class="id"> \in</span><span class="id"> s4</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_mem</span><span class="id"> perm_s4</span>)<span class="id"> inE</span><span class="id"> eqxx</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[s4]</span>(<span class="id">cat_take_drop</span> (<span class="id">index</span><span class="id"> b</span><span class="id"> s4</span>)).<br/>
<span class="id">rewrite</span><span class="id"> map_cat</span><span class="id"> /=</span> (<span class="id">drop_nth</span><span class="id"> b</span>)<span class="id"> ?index_mem</span><span class="id"> //=</span><span class="id"> nth_index</span><span class="id"> //=</span>.<br/>
<span class="id">rewrite</span><span class="id"> perm_sym</span><span class="id"> perm_catC</span><span class="id"> /=</span><span class="id"> perm_cons</span><span class="id"> //</span><span class="id"> perm_catC</span><span class="id"> -map_cat</span>.<br/>
<span class="id">rewrite</span><span class="id"> -remE</span><span class="id"> perm_sym</span><span class="id"> IH1</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> b</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> perm_trans</span><span class="id"> perm_s4</span> (<span class="id">perm_to_rem</span><span class="id"> _</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_allpairs_dep</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> s2</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> s1,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> t1</span><span class="id"> x</span><span class="id"> =i</span><span class="id"> t2</span><span class="id"> x}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1</span><span class="id"> x]</span><span class="id"> =i</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_s</span><span class="id"> eq_t</span><span class="id"> z;</span><span class="id"> apply/allpairsPdep/allpairsPdep=&gt;</span><span class="id"> -[x</span><span class="id"> [y</span><span class="id"> [sx</span><span class="id"> ty</span><span class="id"> -&gt;]]];</span><br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> x,</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> -eq_s</span><span class="gallina-kwd"> in</span><span class="id"> sx</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> eq_t</span><span class="gallina-kwd"> in</span><span class="id"> ty</span><span class="id"> *</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_uniq_dep</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span> (<span class="id">st</span><span class="id"> :=</span><span class="id"> [seq</span><span class="id"> Tagged</span><span class="id"> T</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> g</span> (<span class="id">p</span><span class="id"> :</span><span class="id"> {x</span><span class="id"> :</span><span class="id"> S</span><span class="id"> &amp;</span><span class="id"> T</span><span class="id"> x}</span>)<span class="id"> :</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> f</span> (<span class="id">tag</span><span class="id"> p</span>) (<span class="id">tagged</span><span class="id"> p</span>)<span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> s,</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> uniq</span> (<span class="id">t</span><span class="id"> x</span>)<span class="id">}</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> st</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> g}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> g</span><span class="id"> Us</span><span class="id"> Ut;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">map_allpairs</span><span class="id"> g</span> (<span class="id">existT</span><span class="id"> T</span>))<span class="id"> =&gt;</span><span class="id"> /map_inj_in_uniq-&gt;{f</span><span class="id"> g}</span>.<br/>
<span class="id">elim:</span><span class="id"> s</span><span class="id"> Us</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> /andP[s'x</span><span class="id"> Us]</span><span class="gallina-kwd"> in</span><span class="id"> st</span><span class="id"> Ut</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> {st}cat_uniq</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}IHs</span><span class="id"> {Us}//</span><span class="id"> ?andbT</span><span class="id"> =&gt;</span><span class="id"> [|x1</span><span class="id"> s_s1];</span><span class="id"> last</span><span class="id"> exact/Ut/mem_behead</span>.<br/>
<span class="id">have</span><span class="id"> injT:</span><span class="id"> injective</span> (<span class="id">existT</span><span class="id"> T</span><span class="id"> x</span>)<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> y</span><span class="id"> z</span><span class="id"> /eqP;</span><span class="id"> rewrite</span><span class="id"> eq_Tagged</span><span class="id"> =&gt;</span><span class="id"> /eqP</span>.<br/>
<span class="id">rewrite</span> (<span class="id">map_inj_in_uniq</span> (<span class="id">in2W</span><span class="id"> injT</span>))<span class="id"> {injT}Ut</span><span class="id"> ?mem_head</span><span class="id"> //</span><span class="id"> has_sym</span><span class="id"> has_map</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> s'x</span><span class="id"> =&gt;</span><span class="id"> /hasP[y</span><span class="id"> _</span><span class="id"> /allpairsPdep[z</span><span class="id"> [_</span><span class="id"> [?</span><span class="id"> _</span><span class="id"> /</span>(<span class="id">congr1</span><span class="id"> tag</span>)<span class="id">/=-&gt;]]]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqAllPairsDep</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> allpairsPdep</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> z}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> MemAllPairs</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">S</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="gallina-kwd"> Type</span>) (<span class="id">R</span><span class="id"> :</span><span class="id"> eqType</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_allpairs_catr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eql</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> t2</span><span class="id"> x]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/permPl;</span><span class="id"> rewrite</span><span class="id"> perm_sym;</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> ihs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_catACA</span><span class="id"> perm_cat</span><span class="id"> ?map_cat</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_allpairs_catr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> y0</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> y0</span><span class="id"> x</span><span class="id"> ++</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> y0</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/perm_mem/permPl/perm_allpairs_catr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_allpairs_consr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> y0</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eql</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> y0</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> t</span><span class="id"> x]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">y0</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply/permPl;</span><span class="id"> rewrite</span> (<span class="id">perm_allpairs_catr</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> [::</span><span class="id"> _]</span>))<span class="id"> allpairs1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_allpairs_consr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> y0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> y0</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> =i</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">y0</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/perm_mem/permPl/perm_allpairs_consr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_rconsr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> y0</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eql</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> rcons</span> (<span class="id">t</span><span class="id"> x</span>) (<span class="id">y0</span><span class="id"> x</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">y0</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/permPl;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eq_allpairsr</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">fun=&gt;</span><span class="id"> cats1</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_allpairs_catr</span><span class="id"> allpairs1r</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_allpairs_rconsr</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> y0</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> rcons</span> (<span class="id">t</span><span class="id"> x</span>) (<span class="id">y0</span><span class="id"> x</span>)<span class="id">]</span><span class="id"> =i</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span> (<span class="id">y0</span><span class="id"> x</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact/perm_mem/permPl/allpairs_rconsr</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> MemAllPairs</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all_allpairsP</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">S</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">T</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> eqType</span>) (<span class="id">R</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">p</span><span class="id"> :</span><span class="id"> pred</span><span class="id"> R</span>) (<span class="id">f</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> S,</span><span class="id"> T</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> R</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> :</span><span class="id"> S,</span><span class="id"> seq</span> (<span class="id">T</span><span class="id"> x</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">forall</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> S</span>) (<span class="id">y</span><span class="id"> :</span><span class="id"> T</span><span class="id"> x</span>)<span class="id">,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> t</span><span class="id"> x</span><span class="id"> -&gt;</span><span class="id"> p</span> (<span class="id">f</span><span class="id"> x</span><span class="id"> y</span>))<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">all</span><span class="id"> p</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t</span><span class="id"> x]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> s</span><span class="id"> IHs];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> constructor</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> all_cat</span><span class="id"> all_map</span><span class="id"> /preim</span>.<br/>
<span class="id">apply/</span>(<span class="id">iffP</span><span class="id"> andP</span>)<span class="id">=&gt;</span><span class="id"> [[/allP</span><span class="id"> /=</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> x'</span><span class="id"> y</span><span class="id"> x'_in_xs]|p_xs_t]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> x'_in_xs</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> /[1!inE]</span><span class="id"> /predU1P</span><span class="id"> [-&gt;</span><span class="id"> //|?</span><span class="id"> ?];</span><span class="id"> exact:</span><span class="id"> IHs</span>.<br/>
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> apply/allP</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> exact/p_xs_t/mem_head</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/IHs</span><span class="id"> =&gt;</span><span class="id"> x'</span><span class="id"> y</span><span class="id"> x'_in_s;</span><span class="id"> apply:</span><span class="id"> p_xs_t;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> x'_in_s</span><span class="id"> orbT</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Arguments</span><span class="id"> all_allpairsP</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> p</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> EqAllPairs</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> R</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>) (<span class="id">t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairsP</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span> (<span class="id">z</span><span class="id"> :</span><span class="id"> R</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="gallina-kwd">exists</span><span class="id"> p,</span><span class="id"> [/\</span><span class="id"> p</span>.<span class="id">1</span><span class="id"> \in</span><span class="id"> s,</span><span class="id"> p</span>.<span class="id">2</span><span class="id"> \in</span><span class="id"> t</span><span class="id"> &amp;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> f</span><span class="id"> p</span>.<span class="id">1</span><span class="id"> p</span>.<span class="id">2]</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">z</span><span class="id"> \in</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">iffP</span><span class="id"> allpairsPdep</span>)<span class="id"> =&gt;</span><span class="id"> [[x[y]]|[[x</span><span class="id"> y]]];</span><span class="id"> [exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id">|exists</span><span class="id"> x,</span><span class="id"> y]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_f</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">x</span><span class="id"> \in</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> allpairs_f_dep</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_allpairs</span><span class="id"> f1</span><span class="id"> f2</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> t,</span><span class="id"> f1</span><span class="id"> =2</span><span class="id"> f2}</span><span class="id"> &lt;-&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f1</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> R</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> f2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">split=&gt;</span><span class="id"> [eq_f</span><span class="id"> |</span><span class="id"> /eq_in_allpairs_dep-eq_f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> /eq_f/</span>(_<span class="id"> y</span>)<span class="id">//]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/eq_in_allpairs_dep=&gt;</span><span class="id"> x</span><span class="id"> /eq_f</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_allpairs</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> s2</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> t1</span><span class="id"> t2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1]</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> perm_s</span><span class="id"> perm_t;</span><span class="id"> apply:</span><span class="id"> perm_allpairs_dep</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_allpairs</span><span class="id"> f</span><span class="id"> s1</span><span class="id"> t1</span><span class="id"> s2</span><span class="id"> t2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =i</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> t1</span><span class="id"> =i</span><span class="id"> t2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s1,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t1]</span><span class="id"> =i</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s2,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t2]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eq_s</span><span class="id"> eq_t;</span><span class="id"> apply:</span><span class="id"> mem_allpairs_dep</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allpairs_uniq</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span> (<span class="id">st</span><span class="id"> :=</span><span class="id"> [seq</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> st</span><span class="id"> &amp;,</span><span class="id"> injective</span> (<span class="id">uncurry</span><span class="id"> f</span>)<span class="id">}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">uniq</span><span class="id"> [seq</span><span class="id"> f</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> s,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> t]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Us</span><span class="id"> Ut</span><span class="id"> inj_f;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">map_allpairs</span> (<span class="id">uncurry</span><span class="id"> f</span>) (<span class="id">@pair</span><span class="id"> S</span><span class="id"> T</span>))<span class="id"> -/st</span>.<br/>
<span class="id">rewrite</span><span class="id"> map_inj_in_uniq</span><span class="id"> //</span><span class="id"> allpairs_uniq_dep</span><span class="id"> {Us</span><span class="id"> Ut</span><span class="id"> st</span><span class="id"> inj_f}//</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> in2W</span><span class="id"> =&gt;</span><span class="id"> -[x1</span><span class="id"> y1]</span><span class="id"> [x2</span><span class="id"> y2]</span><span class="id"> /=</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqAllPairs</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> allpairsP</span><span class="id"> {S</span><span class="id"> T</span><span class="id"> R</span><span class="id"> f</span><span class="id"> s</span><span class="id"> t</span><span class="id"> z}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> perm_nilP</span><span class="id"> {T</span><span class="id"> s}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> perm_consP</span><span class="id"> {T</span><span class="id"> x</span><span class="id"> s</span><span class="id"> t}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> AllRel</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> S</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">y</span><span class="id"> :</span><span class="id"> S</span>) (<span class="id">xs</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">ys</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :=</span><span class="id"> all</span><span class="id"> [pred</span><span class="id"> x</span><span class="id"> |</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> ys]</span><span class="id"> xs</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel0l</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> [::]</span><span class="id"> ys</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel0r</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> [::]</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_consl</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> xs</span>)<span class="id"> ys</span><span class="id"> =</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> ys</span><span class="id"> &amp;&amp;</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_consr</span><span class="id"> xs</span><span class="id"> y</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> xs</span> (<span class="id">y</span><span class="id"> ::</span><span class="id"> ys</span>)<span class="id"> =</span><span class="id"> all</span> (<span class="id">r^~</span><span class="id"> y</span>)<span class="id"> xs</span><span class="id"> &amp;&amp;</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> all_predI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_cons2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> xs</span>) (<span class="id">y</span><span class="id"> ::</span><span class="id"> ys</span>)<span class="id"> =</span><br/>
&nbsp;&nbsp;<span class="id">[&amp;&amp;</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> ys,</span><span class="id"> all</span> (<span class="id">r^~</span><span class="id"> y</span>)<span class="id"> xs</span><span class="id"> &amp;</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> allrel_consr</span><span class="id"> -andbA</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel1l</span><span class="id"> x</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> ys</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel1r</span><span class="id"> xs</span><span class="id"> y</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> [::</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> all</span> (<span class="id">r^~</span><span class="id"> y</span>)<span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrel_consr</span><span class="id"> allrel0r</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_catl</span><span class="id"> xs</span><span class="id"> xs'</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span> (<span class="id">xs</span><span class="id"> ++</span><span class="id"> xs'</span>)<span class="id"> ys</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> &amp;&amp;</span><span class="id"> allrel</span><span class="id"> xs'</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> all_cat</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_catr</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> ys'</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> xs</span> (<span class="id">ys</span><span class="id"> ++</span><span class="id"> ys'</span>)<span class="id"> =</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> &amp;&amp;</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> ys</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|y</span><span class="id"> ys</span><span class="id"> ihys];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrel0r</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !allrel_consr</span><span class="id"> ihys</span><span class="id"> andbA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_maskl</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> xs</span>)<span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m</span><span class="id"> IHm]</span><span class="id"> [|x</span><span class="id"> xs]</span><span class="id"> //=</span><span class="id"> /andP</span><span class="id"> [xys</span><span class="id"> /IHm-&gt;];</span><span class="id"> rewrite</span><span class="id"> ?xys</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_maskr</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> xs</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> ys</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> IHxs</span><span class="id"> /andP</span><span class="id"> [/all_mask-&gt;]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_filterl</span><span class="id"> a</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> xs</span>)<span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filter_mask;</span><span class="id"> apply:</span><span class="id"> allrel_maskl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_filterr</span><span class="id"> a</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> xs</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> ys</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filter_mask;</span><span class="id"> apply:</span><span class="id"> allrel_maskr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_allpairsE</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> all</span><span class="id"> id</span><span class="id"> [seq</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> xs,</span><span class="id"> y</span><span class="id"> &lt;-</span><span class="id"> ys]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> all_cat</span><span class="id"> all_map</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> AllRel</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> simpl</span><span class="id"> never</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel0l</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel0r</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_consl</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_consr</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> y</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel1l</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> x</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel1r</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> y</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_catl</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> xs'</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_catr</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> ys'</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_maskl</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_maskr</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_filterl</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> a</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_filterr</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> a</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> allrel_allpairsE</span><span class="id"> {T</span><span class="id"> S}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<br/>
<span class="vernacular">Notation</span><span class="id"> all2rel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> :=</span> (<span class="id">allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> xs</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_in_allrel</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> S}</span>) (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> P</span><span class="id"> &amp;</span><span class="id"> Q,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> r'</span><span class="id"> x</span><span class="id"> y}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> xs</span><span class="id"> ys,</span><span class="id"> all</span><span class="id"> P</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> Q</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r'</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> rr'</span><span class="id"> +</span><span class="id"> ys;</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> IHxs</span><span class="id"> /andP</span><span class="id"> [Px</span><span class="id"> Pxs]</span><span class="id"> Qys</span>.<br/>
<span class="id">rewrite</span><span class="id"> !allrel_consl</span><span class="id"> =&gt;</span><span class="id"> /andP</span><span class="id"> [+</span><span class="id"> {}/IHxs-&gt;</span><span class="id"> //];</span><span class="id"> rewrite</span><span class="id"> andbT</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> ys</span><span class="id"> Qys</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> ys</span><span class="id"> IHys</span><span class="id"> /andP</span><span class="id"> [Qy</span><span class="id"> Qys]</span><span class="id"> /andP</span><span class="id"> [/rr'-&gt;</span><span class="id"> //</span><span class="id"> /IHys-&gt;]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_allrel</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;(<span class="gallina-kwd">forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> r'</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> xs</span><span class="id"> ys,</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r'</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> rr'</span><span class="id"> xs</span><span class="id"> ys;</span><span class="id"> apply/sub_in_allrel/all_predT/all_predT;</span><span class="id"> apply:</span><span class="id"> in2W</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_allrel</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">Q</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> S}</span>)<span class="id"> r</span><span class="id"> r'</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> P</span><span class="id"> &amp;</span><span class="id"> Q,</span><span class="id"> r</span><span class="id"> =2</span><span class="id"> r'}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> xs</span><span class="id"> ys,</span><span class="id"> all</span><span class="id"> P</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> Q</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r'</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> rr'</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> Pxs</span><span class="id"> Qys</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP;</span><span class="id"> apply/sub_in_allrel/Qys/Pxs</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> rr'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allrel</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">r</span><span class="id"> =2</span><span class="id"> r'</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> =2</span><span class="id"> allrel</span><span class="id"> r'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> rr'</span><span class="id"> xs</span><span class="id"> ys;</span><span class="id"> apply/eq_in_allrel/all_predT/all_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrelC</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> allrel</span> (<span class="gallina-kwd">fun</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> r^~</span><span class="id"> y</span>)<span class="id"> ys</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> [|x</span><span class="id"> xs</span><span class="id"> ih];</span><span class="id"> [elim:</span><span class="id"> ys</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> allrel_consr</span><span class="id"> -ih]</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_mapl</span><span class="id"> {T</span><span class="id"> T'</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> xs</span>)<span class="id"> ys</span><span class="id"> =</span><span class="id"> allrel</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> =&gt;</span><span class="id"> r</span> (<span class="id">f</span><span class="id"> x</span>))<span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> all_map</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_mapr</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> S'</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> S'</span><span class="id"> -&gt;</span><span class="id"> S</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span><span class="id"> xs</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> ys</span>)<span class="id"> =</span><span class="id"> allrel</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> x</span> (<span class="id">f</span><span class="id"> y</span>))<span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrelC</span><span class="id"> allrel_mapl</span><span class="id"> allrelC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrelP</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> eqType}</span><span class="id"> {r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool}</span><span class="id"> {xs</span><span class="id"> ys}</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> {in</span><span class="id"> xs</span><span class="id"> &amp;</span><span class="id"> ys,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> y,</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y}</span> (<span class="id">allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrel_allpairsE;</span><span class="id"> exact:</span><span class="id"> all_allpairsP</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrelT</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">xs</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">ys</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span> (<span class="gallina-kwd">fun</span><span class="id"> _</span><span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> true</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> true</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> allrel_consl</span><span class="id"> all_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_relI</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span> (<span class="gallina-kwd">fun</span><span class="id"> x</span><span class="id"> y</span><span class="id"> =&gt;</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &amp;&amp;</span><span class="id"> r'</span><span class="id"> x</span><span class="id"> y</span>)<span class="id"> xs</span><span class="id"> ys</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> &amp;&amp;</span><span class="id"> allrel</span><span class="id"> r'</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -all_predI;</span><span class="id"> apply:</span><span class="id"> eq_all</span><span class="id"> =&gt;</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -all_predI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_revl</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>) (<span class="id">s1</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span> (<span class="id">rev</span><span class="id"> s1</span>)<span class="id"> s2</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> all_rev</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_revr</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>) (<span class="id">s1</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span><span class="id"> s1</span> (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrelC</span><span class="id"> allrel_revl</span><span class="id"> allrelC</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> allrel_rev2</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>) (<span class="id">s1</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s2</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">allrel</span><span class="id"> r</span> (<span class="id">rev</span><span class="id"> s1</span>) (<span class="id">rev</span><span class="id"> s2</span>)<span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> allrel_revr</span><span class="id"> allrel_revl</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allrel_meml</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> eqType}</span><span class="id"> {S}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>) (<span class="id">s1</span><span class="id"> s1'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> s2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =i</span><span class="id"> s1'</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1'</span><span class="id"> s2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> eqs1;</span><span class="id"> apply:</span><span class="id"> eq_all_r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allrel_memr</span><span class="id"> {T}</span><span class="id"> {S</span><span class="id"> :</span><span class="id"> eqType}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<span class="id"> s1</span> (<span class="id">s2</span><span class="id"> s2'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">s2</span><span class="id"> =i</span><span class="id"> s2'</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ![allrel</span><span class="id"> _</span><span class="id"> s1</span><span class="id"> _]allrelC;</span><span class="id"> apply:</span><span class="id"> eq_allrel_meml</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_allrel_mem2</span><span class="id"> {T</span><span class="id"> S</span><span class="id"> :</span><span class="id"> eqType}</span> (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> S</span><span class="id"> -&gt;</span><span class="id"> bool</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">s1</span><span class="id"> s1'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">s2</span><span class="id"> s2'</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> S</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">s1</span><span class="id"> =i</span><span class="id"> s1'</span><span class="id"> -&gt;</span><span class="id"> s2</span><span class="id"> =i</span><span class="id"> s2'</span><span class="id"> -&gt;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> =</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> s1'</span><span class="id"> s2'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> /eq_allrel_meml</span><span class="id"> -&gt;</span><span class="id"> /eq_allrel_memr</span><span class="id"> -&gt;</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> All2Rel</span>.<br/>
<br/>
<span class="vernacular">Variable</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> nonPropType</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> z</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">xs</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<span class="vernacular">Hypothesis</span> (<span class="id">rsym</span><span class="id"> :</span><span class="id"> symmetric</span><span class="id"> r</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all2rel1</span><span class="id"> x</span><span class="id"> :</span><span class="id"> all2rel</span><span class="id"> r</span><span class="id"> [::</span><span class="id"> x]</span><span class="id"> =</span><span class="id"> r</span><span class="id"> x</span><span class="id"> x</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /allrel</span><span class="id"> /=</span><span class="id"> !andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all2rel2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> all2rel</span><span class="id"> r</span><span class="id"> [::</span><span class="id"> x;</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> r</span><span class="id"> x</span><span class="id"> x</span><span class="id"> &amp;&amp;</span><span class="id"> r</span><span class="id"> y</span><span class="id"> y</span><span class="id"> &amp;&amp;</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /allrel</span><span class="id"> /=</span><span class="id"> rsym;</span><span class="id"> do</span><span class="id"> 3</span><span class="id"> case:</span><span class="id"> r</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> all2rel_cons</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">all2rel</span><span class="id"> r</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> xs</span>)<span class="id"> =</span><span class="id"> [&amp;&amp;</span><span class="id"> r</span><span class="id"> x</span><span class="id"> x,</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> xs</span><span class="id"> &amp;</span><span class="id"> all2rel</span><span class="id"> r</span><span class="id"> xs]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> allrel_cons2;</span><span class="id"> congr</span><span class="id"> andb;</span><span class="id"> rewrite</span><span class="id"> andbA</span><span class="id"> -all_predI;</span><span class="id"> congr</span><span class="id"> andb</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> y</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> rsym</span><span class="id"> andbb</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> All2Rel</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Pairwise</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="gallina-kwd"> Type</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> bool</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> bool</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> xs</span><span class="id"> is</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> xs</span><span class="gallina-kwd"> then</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> xs</span><span class="id"> &amp;&amp;</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="gallina-kwd"> else</span><span class="id"> true</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_cons</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> pairwise</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> xs</span>)<span class="id"> =</span><span class="id"> all</span> (<span class="id">r</span><span class="id"> x</span>)<span class="id"> xs</span><span class="id"> &amp;&amp;</span><span class="id"> pairwise</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_cat</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pairwise</span> (<span class="id">xs</span><span class="id"> ++</span><span class="id"> ys</span>)<span class="id"> =</span><span class="id"> [&amp;&amp;</span><span class="id"> allrel</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys,</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="id"> &amp;</span><span class="id"> pairwise</span><span class="id"> ys]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> all_cat</span><span class="id"> -!andbA;</span><span class="id"> bool_congr</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_rcons</span><span class="id"> xs</span><span class="id"> x</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pairwise</span> (<span class="id">rcons</span><span class="id"> xs</span><span class="id"> x</span>)<span class="id"> =</span><span class="id"> all</span> (<span class="id">r^~</span><span class="id"> x</span>)<span class="id"> xs</span><span class="id"> &amp;&amp;</span><span class="id"> pairwise</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cats1</span><span class="id"> pairwise_cat</span><span class="id"> allrel1r</span><span class="id"> andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise2</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> pairwise</span><span class="id"> [::</span><span class="id"> x;</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !andbT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_mask</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span> (<span class="id">mask</span><span class="id"> m</span><span class="id"> xs</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> m</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> [|[]</span><span class="id"> m</span><span class="id"> IHm]</span><span class="id"> [|x</span><span class="id"> xs]</span><span class="id"> //=</span><span class="id"> /andP</span><span class="id"> [?</span><span class="id"> ?];</span><span class="id"> rewrite</span><span class="id"> ?IHm</span><span class="id"> //</span><span class="id"> all_mask</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_filter</span><span class="id"> a</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span> (<span class="id">filter</span><span class="id"> a</span><span class="id"> xs</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> filter_mask;</span><span class="id"> apply:</span><span class="id"> pairwise_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwiseP</span><span class="id"> x0</span><span class="id"> xs</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span><span class="id"> {in</span><span class="id"> gtn</span> (<span class="id">size</span><span class="id"> xs</span>)<span class="id"> &amp;,</span><span class="id"> {homo</span><span class="id"> nth</span><span class="id"> x0</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> i</span><span class="id"> j</span><span class="id"> /</span><span class="id"> i</span><span class="id"> &lt;</span><span class="id"> j</span><span class="id"> &gt;-&gt;</span><span class="id"> r</span><span class="id"> i</span><span class="id"> j}}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">pairwise</span><span class="id"> xs</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|x</span><span class="id"> xs</span><span class="id"> IHxs];</span><span class="id"> first</span><span class="id"> exact:</span> (<span class="id">iffP</span><span class="id"> idP</span>).<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> andP</span>)<span class="id"> =&gt;</span><span class="id"> [[r_x_xs</span><span class="id"> pxs]</span><span class="id"> i</span><span class="id"> j|Hnth];</span><span class="id"> rewrite</span><span class="id"> -?topredE</span><span class="id"> /=</span><span class="id"> ?ltnS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> i</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [|i]</span><span class="id"> [|j]</span><span class="id"> //=</span><span class="id"> gti</span><span class="id"> gtj</span><span class="id"> ij;</span><span class="id"> [exact/all_nthP</span><span class="id"> |</span><span class="id"> exact/IHxs]</span>.<br/>
<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/IHxs</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> j;</span><span class="id"> apply/</span>(<span class="id">Hnth</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> j</span>.<span class="id">+1</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/</span>(<span class="id">all_nthP</span><span class="id"> x0</span>)<span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> gti;</span><span class="id"> apply/</span>(<span class="id">Hnth</span><span class="id"> 0</span><span class="id"> i</span>.<span class="id">+1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_all2rel</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">reflexive</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> symmetric</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> xs,</span><span class="id"> pairwise</span><span class="id"> xs</span><span class="id"> =</span><span class="id"> all2rel</span><span class="id"> r</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> r_refl</span><span class="id"> r_sym;</span><span class="id"> elim</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> all2rel_cons</span><span class="id"> //</span><span class="id"> r_refl</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Pairwise</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise</span><span class="id"> {T}</span><span class="id"> r</span><span class="id"> xs</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_cons</span><span class="id"> {T}</span><span class="id"> r</span><span class="id"> x</span><span class="id"> xs</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_cat</span><span class="id"> {T}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_rcons</span><span class="id"> {T}</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> x</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise2</span><span class="id"> {T}</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_mask</span><span class="id"> {T</span><span class="id"> r}</span><span class="id"> m</span><span class="id"> {xs}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_filter</span><span class="id"> {T</span><span class="id"> r}</span><span class="id"> a</span><span class="id"> {xs}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwiseP</span><span class="id"> {T</span><span class="id"> r}</span><span class="id"> x0</span><span class="id"> {xs}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_all2rel</span><span class="id"> {T</span><span class="id"> r}</span><span class="id"> r_refl</span><span class="id"> r_sym</span><span class="id"> xs</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_in_pairwise</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> P</span><span class="id"> &amp;,</span><span class="id"> subrel</span><span class="id"> r</span><span class="id"> r'}</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> xs,</span><span class="id"> all</span><span class="id"> P</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r'</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> rr';</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> IHxs</span><span class="id"> /andP</span><span class="id"> [Px</span><span class="id"> Pxs]</span><span class="id"> /andP</span><span class="id"> [+</span><span class="id"> {}/IHxs-&gt;]</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> andbT;</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> Pxs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x'</span><span class="id"> xs</span><span class="id"> IHxs</span><span class="id"> /andP</span><span class="id"> [?</span><span class="id"> ?]</span><span class="id"> /andP</span><span class="id"> [+</span><span class="id"> /IHxs-&gt;]</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> andbT;</span><span class="id"> apply:</span><span class="id"> rr'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> sub_pairwise</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> xs</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">subrel</span><span class="id"> r</span><span class="id"> r'</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r'</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> rr';</span><span class="id"> apply/sub_in_pairwise/all_predT;</span><span class="id"> apply:</span><span class="id"> in2W</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_in_pairwise</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">P</span><span class="id"> :</span><span class="id"> {pred</span><span class="id"> T}</span>) (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">{in</span><span class="id"> P</span><span class="id"> &amp;,</span><span class="id"> r</span><span class="id"> =2</span><span class="id"> r'}</span><span class="id"> -&gt;</span><span class="gallina-kwd"> forall</span><span class="id"> xs,</span><span class="id"> all</span><span class="id"> P</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> =</span><span class="id"> pairwise</span><span class="id"> r'</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> rr'</span><span class="id"> xs</span><span class="id"> Pxs</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/idP/idP;</span><span class="id"> apply/sub_in_pairwise/Pxs</span><span class="id"> =&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> ?;</span><span class="id"> rewrite</span><span class="id"> rr'</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_pairwise</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">r</span><span class="id"> =2</span><span class="id"> r'</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> =i</span><span class="id"> pairwise</span><span class="id"> r'</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> rr'</span><span class="id"> xs;</span><span class="id"> apply/eq_in_pairwise/all_predT</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_map</span><span class="id"> {T</span><span class="id"> T'</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">f</span><span class="id"> :</span><span class="id"> T'</span><span class="id"> -&gt;</span><span class="id"> T</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>)<span class="id"> xs</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pairwise</span><span class="id"> r</span> (<span class="id">map</span><span class="id"> f</span><span class="id"> xs</span>)<span class="id"> =</span><span class="id"> pairwise</span> (<span class="id">relpre</span><span class="id"> f</span><span class="id"> r</span>)<span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> all_map</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_relI</span><span class="id"> {T</span><span class="id"> :</span><span class="id"> Type}</span> (<span class="id">r</span><span class="id"> r'</span><span class="id"> :</span><span class="id"> rel</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">pairwise</span><span class="id"> [rel</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> r</span><span class="id"> x</span><span class="id"> y</span><span class="id"> &amp;&amp;</span><span class="id"> r'</span><span class="id"> x</span><span class="id"> y]</span><span class="id"> s</span><span class="id"> =</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> s</span><span class="id"> &amp;&amp;</span><span class="id"> pairwise</span><span class="id"> r'</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> andbACA</span><span class="id"> all_predI</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> EqPairwise</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">T</span><span class="id"> :</span><span class="id"> eqType</span>) (<span class="id">r</span><span class="id"> :</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> T</span><span class="id"> -&gt;</span><span class="id"> bool</span>).<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> subseq_pairwise</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> :</span><span class="id"> subseq</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case/subseqP</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> _</span><span class="id"> -&gt;;</span><span class="id"> apply:</span><span class="id"> pairwise_mask</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> uniq_pairwise</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> xs</span><span class="id"> =</span><span class="id"> pairwise</span><span class="id"> [rel</span><span class="id"> x</span><span class="id"> y</span><span class="id"> |</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y]</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> congr</span><span class="id"> andb;</span><span class="id"> rewrite</span><span class="id"> -has_pred1</span><span class="id"> -all_predC</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> xs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x'</span><span class="id"> xs</span><span class="id"> -&gt;;</span><span class="id"> case:</span><span class="id"> eqVneq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_uniq</span><span class="id"> xs</span><span class="id"> :</span><span class="id"> irreflexive</span><span class="id"> r</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> uniq</span><span class="id"> xs</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> r_irr;</span><span class="id"> rewrite</span><span class="id"> uniq_pairwise;</span><span class="id"> apply/sub_pairwise</span><span class="id"> =&gt;</span><span class="id"> x</span><span class="id"> y</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraTneq</span><span class="id"> =&gt;</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> r_irr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_eq</span><span class="id"> :</span><span class="id"> antisymmetric</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> xs</span><span class="id"> ys,</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> -&gt;</span><span class="id"> pairwise</span><span class="id"> r</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span><span class="id"> xs</span><span class="id"> ys</span><span class="id"> -&gt;</span><span class="id"> xs</span><span class="id"> =</span><span class="id"> ys</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> r_asym;</span><span class="id"> elim=&gt;</span><span class="id"> [|x</span><span class="id"> xs</span><span class="id"> IHxs]</span><span class="id"> [|y</span><span class="id"> ys]</span><span class="id"> //=;</span><span class="id"> try</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> ?</span><span class="id"> ?</span><span class="id"> /perm_size</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /andP</span><span class="id"> [r_x_xs</span><span class="id"> pxs]</span><span class="id"> /andP</span><span class="id"> [r_y_ys</span><span class="id"> pys]</span><span class="id"> eq_xs_ys</span>.<br/>
<span class="id">move:</span> (<span class="id">mem_head</span><span class="id"> y</span><span class="id"> ys</span>) (<span class="id">mem_head</span><span class="id"> x</span><span class="id"> xs</span>).<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">perm_mem</span><span class="id"> eq_xs_ys</span>)<span class="id"> [x</span><span class="id"> \in</span><span class="id"> _]</span>(<span class="id">perm_mem</span><span class="id"> eq_xs_ys</span>)<span class="id"> !inE</span>.<br/>
<span class="id">case:</span><span class="id"> eqVneq</span><span class="id"> eq_xs_ys</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [-&gt;|ne_xy]</span><span class="id"> eq_xs_ys</span><span class="id"> ys_x</span><span class="id"> xs_y</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">IHxs</span><span class="id"> ys</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> case/eqP:</span><span class="id"> ne_xy;</span><span class="id"> apply:</span><span class="id"> r_asym;</span><span class="id"> rewrite</span> (<span class="id">allP</span><span class="id"> r_x_xs</span>)<span class="id"> ?</span>(<span class="id">allP</span><span class="id"> r_y_ys</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> pairwise_trans</span><span class="id"> s</span><span class="id"> :</span><span class="id"> antisymmetric</span><span class="id"> r</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">pairwise</span><span class="id"> r</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> s</span><span class="id"> &amp;</span><span class="id"> &amp;,</span><span class="id"> transitive</span><span class="id"> r}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> /</span>(_<span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="id">/eqP</span><span class="id"> r_anti</span><span class="id"> +</span><span class="id"> y</span><span class="id"> x</span><span class="id"> z</span><span class="id"> =&gt;</span><span class="id"> /pairwiseP-/</span>(_<span class="id"> y</span>)<span class="id"> ltP</span><span class="id"> ys</span><span class="id"> xs</span><span class="id"> zs</span>.<br/>
<span class="id">have</span><span class="id"> [-&gt;</span><span class="id"> //|neqxy]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> x</span><span class="id"> y;</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> //|neqzy]</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> z</span><span class="id"> y</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> lxy</span><span class="id"> lyz;</span><span class="id"> move:</span><span class="id"> ys</span><span class="id"> xs</span><span class="id"> zs</span><span class="id"> lxy</span><span class="id"> neqxy</span><span class="id"> lyz</span><span class="id"> neqzy</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> /</span>(<span class="id">nthP</span><span class="id"> y</span>)<span class="id">[j</span><span class="id"> jlt</span><span class="id"> &lt;-]</span><span class="id"> /</span>(<span class="id">nthP</span><span class="id"> y</span>)<span class="id">[i</span><span class="id"> ilt</span><span class="id"> &lt;-]</span><span class="id"> /</span>(<span class="id">nthP</span><span class="id"> y</span>)<span class="id">[k</span><span class="id"> klt</span><span class="id"> &lt;-]</span>.<br/>
<span class="id">have</span><span class="id"> [ltij|ltji|-&gt;]</span><span class="id"> :=</span><span class="id"> ltngtP</span><span class="id"> i</span><span class="id"> j;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> leij;</span><span class="id"> rewrite</span><span class="id"> r_anti//</span><span class="id"> leij</span><span class="id"> ltP</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> lejj;</span><span class="id"> rewrite</span><span class="id"> r_anti//</span><span class="id"> lejj</span>.<br/>
<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> have</span><span class="id"> [ltjk|ltkj|-&gt;]</span><span class="id"> :=</span><span class="id"> ltngtP</span><span class="id"> j</span><span class="id"> k;</span><span class="id"> last</span><span class="id"> 2</span><span class="id"> first</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> lejk;</span><span class="id"> rewrite</span><span class="id"> r_anti//</span><span class="id"> lejk</span><span class="id"> ltP</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> lekk;</span><span class="id"> rewrite</span><span class="id"> r_anti//</span><span class="id"> lekk</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> apply:</span> (<span class="id">ltP</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> ltn_trans</span><span class="id"> ltjk</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> EqPairwise</span>.<br/>
<br/>
<span class="vernacular">Arguments</span><span class="id"> subseq_pairwise</span><span class="id"> {T</span><span class="id"> r</span><span class="id"> xs</span><span class="id"> ys}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> uniq_pairwise</span><span class="id"> {T}</span><span class="id"> xs</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_uniq</span><span class="id"> {T</span><span class="id"> r</span><span class="id"> xs}</span>.<br/>
<span class="vernacular">Arguments</span><span class="id"> pairwise_eq</span><span class="id"> {T</span><span class="id"> r}</span><span class="id"> r_asym</span><span class="id"> {xs</span><span class="id"> ys}</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Permutations</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> T</span><span class="id"> :</span><span class="id"> eqType</span>.<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> T</span>) (<span class="id">s</span><span class="id"> t</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>) (<span class="id">bs</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> nat</span>)) (<span class="id">acc</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">seq</span><span class="id"> T</span>)).<br/>
<br/>
<span class="vernacular">Fixpoint</span><span class="id"> incr_tally</span><span class="id"> bs</span><span class="id"> x</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> bs</span><span class="id"> isn't</span><span class="id"> b</span><span class="id"> ::</span><span class="id"> bs</span><span class="gallina-kwd"> then</span><span class="id"> [::</span> (<span class="id">x,</span><span class="id"> 1</span>)<span class="id">]</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> x</span><span class="id"> ==</span><span class="id"> b</span>.<span class="id">1</span><span class="gallina-kwd"> then</span> (<span class="id">x,</span><span class="id"> b</span>.<span class="id">2</span>.<span class="id">+1</span>)<span class="id"> ::</span><span class="id"> bs</span><span class="gallina-kwd"> else</span><span class="id"> b</span><span class="id"> ::</span><span class="id"> incr_tally</span><span class="id"> bs</span><span class="id"> x</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> tally</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> foldl</span><span class="id"> incr_tally</span><span class="id"> [::]</span><span class="id"> s</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> wf_tally</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[qualify</span><span class="id"> a</span><span class="id"> bs</span><span class="id"> :</span><span class="id"> seq</span> (<span class="id">T</span><span class="id"> *</span><span class="id"> nat</span>)<span class="id"> |</span><span class="id"> uniq</span> (<span class="id">unzip1</span><span class="id"> bs</span>)<span class="id"> &amp;&amp;</span> (<span class="id">0</span><span class="id"> \notin</span><span class="id"> unzip2</span><span class="id"> bs</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> tally_seq</span><span class="id"> bs</span><span class="id"> :=</span><span class="id"> flatten</span><span class="id"> [seq</span><span class="id"> nseq</span><span class="id"> b</span>.<span class="id">2</span><span class="id"> b</span>.<span class="id">1</span><span class="id"> |</span><span class="id"> b</span><span class="id"> &lt;-</span><span class="id"> bs]</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> tseq</span><span class="id"> :=</span><span class="id"> tally_seq</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_tally_seq</span><span class="id"> bs</span><span class="id"> :</span><span class="id"> size</span> (<span class="id">tally_seq</span><span class="id"> bs</span>)<span class="id"> =</span><span class="id"> sumn</span> (<span class="id">unzip2</span><span class="id"> bs</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> size_flatten</span><span class="id"> /shape</span><span class="id"> -map_comp;</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> size_nseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tally_seqK</span><span class="id"> :</span><span class="id"> {in</span><span class="id"> wf_tally,</span><span class="id"> cancel</span><span class="id"> tally_seq</span><span class="id"> tally}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> bs</span><span class="id"> /andP[];</span><span class="id"> elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> [|n]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> /andP[bs'x</span><span class="id"> Ubs]</span><span class="id"> bs'0</span>.<br/>
<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> /tseq</span><span class="id"> /tally</span><span class="id"> /=</span><span class="id"> -[n</span>.<span class="id">+1]addn1</span><span class="gallina-kwd"> in</span><span class="id"> bs'0</span><span class="id"> *</span>.<br/>
<span class="id">elim:</span><span class="id"> n</span><span class="id"> 1</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> m;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> eqxx</span><span class="id"> IHn</span><span class="id"> addnS</span>.<br/>
<span class="id">rewrite</span><span class="id"> -{}[in</span><span class="id"> RHS]IHbs</span><span class="id"> {Ubs</span><span class="id"> bs'0}//</span><span class="id"> /tally</span><span class="id"> /tally_seq</span><span class="id"> add0n</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> bs'x</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> [|[y</span><span class="id"> n]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> /[1!inE]</span><span class="id"> /norP[y'x</span><span class="id"> bs'x]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> bs1</span><span class="id"> /=;</span><span class="id"> [rewrite</span><span class="id"> IHbs</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> ifN</span><span class="id"> //</span><span class="id"> IHn]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> incr_tallyP</span><span class="id"> x</span><span class="id"> :</span><span class="id"> {homo</span><span class="id"> incr_tally^~</span><span class="id"> x</span><span class="id"> :</span><span class="id"> bs</span><span class="id"> /</span><span class="id"> bs</span><span class="id"> \in</span><span class="id"> wf_tally}</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> bs</span><span class="id"> /andP[];</span><span class="id"> rewrite</span><span class="id"> unfold_in</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> [|[y</span><span class="id"> [|n]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> /andP[bs'y</span><span class="id"> Ubs]</span><span class="id"> /[1!inE]</span><span class="id"> /=</span><span class="id"> bs'0</span>.<br/>
<span class="id">have</span><span class="id"> [&lt;-</span><span class="id"> |</span><span class="id"> y'x]</span><span class="id"> /=</span><span class="id"> :=</span><span class="id"> eqVneq</span><span class="id"> y;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> bs'y</span><span class="id"> Ubs</span>.<br/>
<span class="id">rewrite</span><span class="id"> -andbA</span><span class="id"> {}IHbs</span><span class="id"> {Ubs</span><span class="id"> bs'0}//</span><span class="id"> andbT</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> bs'y</span><span class="id"> =&gt;</span><span class="id"> [|b</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> ?y'x</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> /norP[b'y</span><span class="id"> bs'y]</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> inE</span><span class="id"> negb_or</span><span class="id"> ?y'x</span><span class="id"> //</span><span class="id"> b'y</span><span class="id"> IHbs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tallyP</span><span class="id"> s</span><span class="id"> :</span><span class="id"> tally</span><span class="id"> s</span><span class="id"> \is</span><span class="id"> a</span><span class="id"> wf_tally</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /tally;</span><span class="id"> set</span><span class="id"> bs</span><span class="id"> :=</span><span class="id"> [::];</span><span class="id"> have:</span><span class="id"> bs</span><span class="id"> \in</span><span class="id"> wf_tally</span><span class="gallina-kwd"> by</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> s</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> bs</span><span class="id"> /</span>(<span class="id">incr_tallyP</span><span class="id"> x</span>)<span class="id">/IHs</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tallyK</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">tally_seq</span> (<span class="id">tally</span><span class="id"> s</span>))<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> -[s</span><span class="gallina-kwd"> in</span><span class="id"> perm_eq</span><span class="id"> _</span><span class="id"> s]cats0</span><span class="id"> -[nil]/</span>(<span class="id">tseq</span><span class="id"> [::]</span>)<span class="id"> /tally</span>.<br/>
<span class="id">elim:</span><span class="id"> s</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> x</span><span class="id"> s</span><span class="id"> IHs</span><span class="id"> bs;</span><span class="id"> rewrite</span><span class="id"> {IHs}</span>(<span class="id">permPl</span> (<span class="id">IHs</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> perm_sym</span><span class="id"> -cat1s</span><span class="id"> perm_catCA</span><span class="id"> {s}perm_cat2l</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> b</span><span class="id"> bs</span><span class="id"> IHbs;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> _]</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -cat1s</span><span class="id"> perm_catCA</span><span class="id"> perm_cat2l</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tallyEl</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">unzip1</span> (<span class="id">tally</span><span class="id"> s</span>)) (<span class="id">undup</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /andP[Ubs</span><span class="id"> bs'0]</span><span class="id"> :=</span><span class="id"> tallyP</span><span class="id"> s;</span><span class="id"> set</span><span class="id"> bs</span><span class="id"> :=</span><span class="id"> tally</span><span class="id"> s</span><span class="gallina-kwd"> in</span><span class="id"> Ubs</span><span class="id"> bs'0</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> uniq_perm</span><span class="id"> ?undup_uniq</span><span class="id"> {Ubs}//</span><span class="id"> =&gt;</span><span class="id"> x</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_undup</span><span class="id"> -</span>(<span class="id">perm_mem</span> (<span class="id">tallyK</span><span class="id"> s</span>))<span class="id"> -/bs</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> [|[y</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="gallina-kwd"> in</span><span class="id"> bs'0</span><span class="id"> *</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> IHbs</span><span class="id"> //</span><span class="id"> mem_cat</span><span class="id"> mem_nseq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> tallyE</span><span class="id"> s</span><span class="id"> :</span><span class="id"> perm_eq</span> (<span class="id">tally</span><span class="id"> s</span>)<span class="id"> [seq</span> (<span class="id">x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /andP[Ubs</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> tallyP</span><span class="id"> s;</span><span class="id"> pose</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> [fun</span><span class="id"> s</span><span class="id"> x</span><span class="id"> =&gt;</span> (<span class="id">x,</span><span class="id"> count_mem</span><span class="id"> x</span> (<span class="id">tseq</span><span class="id"> s</span>))<span class="id">]</span>.<br/>
<span class="id">suffices</span><span class="id"> /permPl-&gt;:</span><span class="id"> perm_eq</span> (<span class="id">tally</span><span class="id"> s</span>) (<span class="id">map</span> (<span class="id">b</span> (<span class="id">tally</span><span class="id"> s</span>)) (<span class="id">unzip1</span> (<span class="id">tally</span><span class="id"> s</span>))).<br/>
&nbsp;&nbsp;<span class="id">congr</span><span class="id"> perm_eq:</span> (<span class="id">perm_map</span> (<span class="id">b</span> (<span class="id">tally</span><span class="id"> s</span>)) (<span class="id">tallyEl</span><span class="id"> s</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> /=</span> (<span class="id">permP</span> (<span class="id">tallyK</span><span class="id"> s</span>)).<br/>
<span class="id">elim:</span> (<span class="id">tally</span><span class="id"> s</span>)<span class="id"> Ubs</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> m]</span><span class="id"> bs</span><span class="id"> IH]</span><span class="id"> //=</span><span class="id"> /andP[bs'x</span><span class="id"> /IH-IHbs</span><span class="id"> {IH}]</span>.<br/>
<span class="id">rewrite</span><span class="id"> /tseq</span><span class="id"> /=</span><span class="id"> -/</span>(<span class="id">tseq</span><span class="id"> _</span>)<span class="id"> count_cat</span><span class="id"> count_nseq</span><span class="id"> /=</span><span class="id"> eqxx</span><span class="id"> mul1n</span>.<br/>
<span class="id">rewrite</span> (<span class="id">count_memPn</span><span class="id"> _</span>)<span class="id"> ?addn0</span><span class="id"> ?perm_cons;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contra</span><span class="id"> bs'x;</span><span class="id"> elim:</span><span class="id"> {b</span><span class="id"> IHbs}bs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> b</span><span class="id"> bs</span><span class="id"> IHbs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_cat</span><span class="id"> mem_nseq</span><span class="id"> inE</span><span class="id"> andbC;</span><span class="id"> case:</span> (_<span class="id"> ==</span><span class="id"> _</span>).<br/>
<span class="id">congr</span><span class="id"> perm_eq:</span><span class="id"> IHbs;</span><span class="id"> apply/eq_in_map=&gt;</span><span class="id"> y</span><span class="id"> bs_y;</span><span class="id"> congr</span> (<span class="id">y,</span><span class="id"> _</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> count_cat</span><span class="id"> count_nseq</span><span class="id"> /=</span> (<span class="id">negPf</span> (<span class="id">memPnC</span><span class="id"> bs'x</span><span class="id"> y</span><span class="id"> bs_y</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_tally</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> :</span><span class="id"> perm_eq</span><span class="id"> s1</span><span class="id"> s2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">tally</span><span class="id"> s1</span>) (<span class="id">tally</span><span class="id"> s2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> eq_s12;</span><span class="id"> apply:</span> (<span class="id">@perm_trans</span><span class="id"> _</span><span class="id"> [seq</span> (<span class="id">x,</span><span class="id"> count_mem</span><span class="id"> x</span><span class="id"> s2</span>)<span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s1]</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> congr</span><span class="id"> perm_eq:</span> (<span class="id">tallyE</span><span class="id"> s1</span>)<span class="id">;</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span> (<span class="id">permP</span><span class="id"> eq_s12</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">permPr</span> (<span class="id">tallyE</span><span class="id"> s2</span>))<span class="id">;</span><span class="id"> apply/perm_map/perm_undup/</span>(<span class="id">perm_mem</span><span class="id"> eq_s12</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_tally_seq</span><span class="id"> bs1</span><span class="id"> bs2</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> bs1</span><span class="id"> bs2</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">tally_seq</span><span class="id"> bs1</span>) (<span class="id">tally_seq</span><span class="id"> bs2</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> Ebs12;</span><span class="id"> rewrite</span><span class="id"> perm_flatten</span><span class="id"> ?perm_map</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> perm_tseq</span><span class="id"> :=</span><span class="id"> perm_tally_seq</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_count_undup</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">flatten</span><span class="id"> [seq</span><span class="id"> nseq</span> (<span class="id">count_mem</span><span class="id"> x</span><span class="id"> s</span>)<span class="id"> x</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s]</span>)<span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">permPr</span> (<span class="id">tallyK</span><span class="id"> s</span>)) (<span class="id">permPr</span> (<span class="id">perm_tseq</span> (<span class="id">tallyE</span><span class="id"> s</span>)))<span class="id"> /tseq</span><span class="id"> -map_comp</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fixpoint</span><span class="id"> cons_perms_</span><span class="id"> perms_rec</span> (<span class="id">s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T</span>)<span class="id"> bs</span><span class="id"> bs2</span><span class="id"> acc</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> bs</span><span class="id"> isn't</span><span class="id"> b</span><span class="id"> ::</span><span class="id"> bs1</span><span class="gallina-kwd"> then</span><span class="id"> acc</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> b</span><span class="id"> isn't</span> (<span class="id">x,</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="gallina-kwd"> then</span><span class="id"> cons_perms_</span><span class="id"> perms_rec</span><span class="id"> s</span><span class="id"> bs1</span><span class="id"> bs2</span><span class="id"> acc</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> acc_xs</span><span class="id"> :=</span><span class="id"> perms_rec</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>) ((<span class="id">x,</span><span class="id"> m</span>)<span class="id"> ::</span><span class="id"> bs1</span><span class="id"> ++</span><span class="id"> bs2</span>)<span class="id"> acc</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">cons_perms_</span><span class="id"> perms_rec</span><span class="id"> s</span><span class="id"> bs1</span> (<span class="id">b</span><span class="id"> ::</span><span class="id"> bs2</span>)<span class="id"> acc_xs</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Fixpoint</span><span class="id"> perms_rec</span><span class="id"> n</span><span class="id"> s</span><span class="id"> bs</span><span class="id"> acc</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> n</span><span class="id"> isn't</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> then</span><span class="id"> s</span><span class="id"> ::</span><span class="id"> acc</span><span class="gallina-kwd"> else</span><span class="id"> cons_perms_</span> (<span class="id">perms_rec</span><span class="id"> n</span>)<span class="id"> s</span><span class="id"> bs</span><span class="id"> [::]</span><span class="id"> acc</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> cons_perms</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">cons_perms_</span> (<span class="id">perms_rec</span><span class="id"> n</span>)<span class="id"> [::]</span>).<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> permutations</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> perms_rec</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> [::]</span> (<span class="id">tally</span><span class="id"> s</span>)<span class="id"> [::]</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> permsP</span><span class="id"> s</span><span class="id"> :</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> bs,</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> permutations</span><span class="id"> s</span><span class="id"> =</span><span class="id"> perms_rec</span><span class="id"> n</span><span class="id"> [::]</span><span class="id"> bs</span><span class="id"> [::],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">size</span> (<span class="id">tseq</span><span class="id"> bs</span>)<span class="id"> ==</span><span class="id"> n,</span><span class="id"> perm_eq</span> (<span class="id">tseq</span><span class="id"> bs</span>)<span class="id"> s</span><span class="id"> &amp;</span><span class="id"> uniq</span> (<span class="id">unzip1</span><span class="id"> bs</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> /andP[Ubs</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> tallyP</span><span class="id"> s;</span><span class="gallina-kwd"> exists</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">,</span> (<span class="id">tally</span><span class="id"> s</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">perm_size</span> (<span class="id">tallyK</span><span class="id"> s</span>))<span class="id"> tallyK</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> bsCA</span><span class="id"> :=</span> (<span class="id">permEl</span> (<span class="id">perm_catCA</span><span class="id"> _</span><span class="id"> [::</span><span class="id"> _]</span><span class="id"> _</span>)).<br/>
<span class="vernacular">Let</span><span class="id"> cons_permsE</span><span class="id"> :</span><span class="gallina-kwd"> forall</span><span class="id"> n</span><span class="id"> x</span><span class="id"> bs</span><span class="id"> bs1</span><span class="id"> bs2,</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> cp</span><span class="id"> :=</span><span class="id"> cons_perms</span><span class="id"> n</span><span class="id"> bs</span><span class="id"> bs2</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> perms</span><span class="id"> s</span><span class="id"> :=</span><span class="id"> perms_rec</span><span class="id"> n</span><span class="id"> s</span><span class="id"> bs1</span><span class="id"> [::]</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">cp</span> (<span class="id">perms</span><span class="id"> [::</span><span class="id"> x]</span>)<span class="id"> =</span><span class="id"> cp</span><span class="id"> [::]</span><span class="id"> ++</span><span class="id"> [seq</span><span class="id"> rcons</span><span class="id"> t</span><span class="id"> x</span><span class="id"> |</span><span class="id"> t</span><span class="id"> &lt;-</span><span class="id"> perms</span><span class="id"> [::]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">pose</span><span class="id"> is_acc</span><span class="id"> f</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> acc,</span><span class="id"> f</span><span class="id"> acc</span><span class="id"> =</span><span class="id"> f</span><span class="id"> [::]</span><span class="id"> ++</span><span class="id"> acc</span>. <span class="comment">(*&nbsp;f&nbsp;is&nbsp;accumulating.&nbsp;*)</span><br/>
<span class="id">have</span><span class="id"> cpE:</span><span class="gallina-kwd"> forall</span><span class="id"> f</span><span class="id"> &amp;</span><span class="gallina-kwd"> forall</span><span class="id"> s</span><span class="id"> bs,</span><span class="id"> is_acc</span> (<span class="id">f</span><span class="id"> s</span><span class="id"> bs</span>)<span class="id">,</span><span class="id"> is_acc</span> (<span class="id">cons_perms_</span><span class="id"> f</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> s</span><span class="id"> bs</span><span class="id"> bs2</span><span class="id"> f</span><span class="id"> fE</span><span class="id"> acc;</span><span class="id"> elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="gallina-kwd"> in</span><span class="id"> s</span><span class="id"> bs2</span><span class="id"> acc</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> fE</span><span class="id"> IHbs</span><span class="id"> catA</span><span class="id"> -IHbs</span>.<br/>
<span class="id">have</span><span class="id"> prE:</span><span class="id"> is_acc</span> (<span class="id">perms_rec</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>)<span class="gallina-kwd"> by</span><span class="id"> elim=&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> s</span><span class="id"> bs;</span><span class="id"> apply:</span><span class="id"> cpE</span>.<br/>
<span class="id">pose</span><span class="id"> has_suffix</span><span class="id"> f</span><span class="id"> :=</span><span class="gallina-kwd"> forall</span><span class="id"> s</span><span class="id"> :</span><span class="id"> seq</span><span class="id"> T,</span><span class="id"> f</span><span class="id"> s</span><span class="id"> =</span><span class="id"> [seq</span><span class="id"> t</span><span class="id"> ++</span><span class="id"> s</span><span class="id"> |</span><span class="id"> t</span><span class="id"> &lt;-</span><span class="id"> f</span><span class="id"> [::]]</span>.<br/>
<span class="id">suffices</span><span class="id"> prEs</span><span class="id"> n</span><span class="id"> bs:</span><span class="id"> has_suffix</span> (<span class="gallina-kwd">fun</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> perms_rec</span><span class="id"> n</span><span class="id"> s</span><span class="id"> bs</span><span class="id"> [::]</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n</span><span class="id"> x</span><span class="id"> bs</span><span class="id"> bs1</span><span class="id"> bs2</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> cpE</span><span class="id"> //</span><span class="id"> prEs</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> under</span><span class="id"> eq_map</span><span class="id"> do</span><span class="id"> rewrite</span><span class="id"> cats1</span>.<br/>
<span class="id">elim:</span><span class="id"> n</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="id"> bs</span><span class="id"> s;</span><span class="id"> elim:</span><span class="id"> bs</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> bs1</span>.<br/>
<span class="id">rewrite</span><span class="id"> cpE</span><span class="id"> //</span><span class="id"> IHbs</span><span class="id"> IHn</span><span class="id"> [in</span><span class="id"> RHS]cpE</span><span class="id"> //</span><span class="id"> [in</span><span class="id"> RHS]IHn</span><span class="id"> map_cat</span><span class="id"> -map_comp</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> congr</span> (_<span class="id"> ++</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> eq_map</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -catA</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> mem_permutations</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> permutations</span><span class="id"> s</span>)<span class="id"> =</span><span class="id"> perm_eq</span><span class="id"> t</span><span class="id"> s</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have{s}</span><span class="id"> [n</span><span class="id"> [bs</span><span class="id"> [-&gt;</span><span class="id"> Dn</span><span class="id"> /permPr&lt;-</span><span class="id"> _]]]</span><span class="id"> :=</span><span class="id"> permsP</span><span class="id"> s</span>.<br/>
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> [|n</span><span class="id"> IHn]</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> t</span><span class="id"> bs</span><span class="id"> Dn</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span> (<span class="id">nilP</span><span class="id"> Dn</span>)<span class="id">;</span><span class="id"> apply/eqP/perm_nilP</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[bs</span><span class="gallina-kwd"> in</span><span class="id"> tseq</span><span class="id"> bs]cats0</span><span class="gallina-kwd"> in</span><span class="id"> Dn</span><span class="id"> *;</span><span class="id"> have</span><span class="id"> x0</span><span class="id"> :</span><span class="id"> T</span><span class="gallina-kwd"> by</span><span class="id"> case:</span> (<span class="id">tseq</span><span class="id"> _</span>)<span class="id"> Dn</span>.<br/>
<span class="id">rewrite</span><span class="id"> -[RHS]</span>(<span class="id">@andb_idl</span> (<span class="id">last</span><span class="id"> x0</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> tseq</span><span class="id"> bs</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">case/lastP:</span><span class="id"> t</span><span class="id"> {IHn}</span><span class="id"> =&gt;</span><span class="id"> [|t</span><span class="id"> x]</span><span class="id"> Dt;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_size</span><span class="id"> Dt</span>)<span class="gallina-kwd"> in</span><span class="id"> Dn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[bs]cats0</span><span class="id"> -</span>(<span class="id">perm_mem</span><span class="id"> Dt</span>)<span class="id"> last_rcons</span><span class="id"> mem_rcons</span><span class="id"> mem_head</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> bs2</span><span class="gallina-kwd"> in</span><span class="id"> Dn</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> cons_permsE</span><span class="id"> -!cat_cons</span><span class="id"> !mem_cat</span> (<span class="id">mem_nseq</span><span class="id"> m</span>.<span class="id">+1</span>)<span class="id"> orbC</span><span class="id"> andb_orl</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}IHbs</span><span class="id"> ?</span>(<span class="id">perm_size</span> (<span class="id">perm_tseq</span><span class="id"> bsCA</span>))<span class="id"> //=</span> (<span class="id">permPr</span> (<span class="id">perm_tseq</span><span class="id"> bsCA</span>)).<br/>
<span class="id">congr</span> (_<span class="id"> ||</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply/mapP/andP=&gt;</span><span class="id"> [[t1</span><span class="id"> Dt1</span><span class="id"> -&gt;]</span><span class="id"> |</span><span class="id"> [/eqP]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> last_rcons</span><span class="id"> perm_rcons</span><span class="id"> perm_cons</span><span class="id"> IHn</span><span class="gallina-kwd"> in</span><span class="id"> Dt1</span><span class="id"> *</span>.<br/>
<span class="id">case/lastP:</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> /perm_size//|t</span><span class="id"> y];</span><span class="id"> rewrite</span><span class="id"> last_rcons</span><span class="id"> perm_rcons</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm_cons;</span><span class="gallina-kwd"> exists</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> ?IHn</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permutations_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span> (<span class="id">permutations</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have{s}</span><span class="id"> [n</span><span class="id"> [bs</span><span class="id"> [-&gt;</span><span class="id"> Dn</span><span class="id"> _</span><span class="id"> Ubs]]]</span><span class="id"> :=</span><span class="id"> permsP</span><span class="id"> s</span>.<br/>
<span class="id">elim:</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n</span><span class="id"> IHn</span><span class="gallina-kwd"> in</span><span class="id"> bs</span><span class="id"> Dn</span><span class="id"> Ubs</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> -[bs]cats0</span><span class="id"> /unzip1</span><span class="gallina-kwd"> in</span><span class="id"> Dn</span><span class="id"> Ubs</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> [::]</span><span class="id"> =&gt;</span><span class="id"> [|[x</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> bs2</span><span class="gallina-kwd"> in</span><span class="id"> Dn</span><span class="id"> Ubs</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/andP:</span><span class="id"> Ubs</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /IHbs-&gt;</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> cons_permsE</span><span class="id"> cat_uniq</span><span class="id"> has_sym</span><span class="id"> andbCA</span><span class="id"> andbC</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}IHbs;</span><span class="id"> first</span><span class="id"> 1</span><span class="id"> last;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">perm_size</span> (<span class="id">perm_tseq</span><span class="id"> bsCA</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">perm_uniq</span> (<span class="id">perm_map</span><span class="id"> _</span><span class="id"> bsCA</span>)).<br/>
<span class="id">rewrite</span> (<span class="id">map_inj_uniq</span> (<span class="id">rcons_injl</span><span class="id"> x</span>))<span class="id"> {}IHn</span><span class="id"> {Dn}//=</span>.<br/>
<span class="id">have:</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> unzip1</span><span class="id"> bs</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> contraL</span><span class="id"> Ubs;</span><span class="id"> rewrite</span><span class="id"> map_cat</span><span class="id"> mem_cat</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">move:</span><span class="id"> {bs2</span><span class="id"> m</span><span class="id"> Ubs}</span>(<span class="id">perms_rec</span><span class="id"> n</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>) (_<span class="id"> ::</span><span class="id"> bs2</span>)<span class="id"> =&gt;</span><span class="id"> ts</span>.<br/>
<span class="id">elim:</span><span class="id"> bs</span><span class="id"> =&gt;</span><span class="id"> [|[y</span><span class="id"> [|m]]</span><span class="id"> bs</span><span class="id"> IHbs]</span><span class="id"> //=</span><span class="id"> /[1!inE]</span><span class="id"> bs2</span><span class="id"> /norP[x'y</span><span class="id"> /IHbs//]</span>.<br/>
<span class="id">rewrite</span><span class="id"> cons_permsE</span><span class="id"> has_cat</span><span class="id"> negb_or</span><span class="id"> has_map</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/hasPn=&gt;</span><span class="id"> t</span><span class="id"> _;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> x'y</span><span class="id"> =&gt;</span><span class="id"> /mapP[t1</span><span class="id"> _</span><span class="id"> /rcons_inj[_</span><span class="id"> -&gt;]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Notation</span><span class="id"> perms</span><span class="id"> :=</span><span class="id"> permutations</span>.<br/>
<span class="vernacular">Lemma</span><span class="id"> permutationsE</span><span class="id"> s</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">0</span><span class="id"> &lt;</span><span class="id"> size</span><span class="id"> s</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">perms</span><span class="id"> s</span>)<span class="id"> [seq</span><span class="id"> x</span><span class="id"> ::</span><span class="id"> t</span><span class="id"> |</span><span class="id"> x</span><span class="id"> &lt;-</span><span class="id"> undup</span><span class="id"> s,</span><span class="id"> t</span><span class="id"> &lt;-</span><span class="id"> perms</span> (<span class="id">rem</span><span class="id"> x</span><span class="id"> s</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> nt_s;</span><span class="id"> apply/uniq_perm=&gt;</span><span class="id"> [||t];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> permutations_uniq</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/allpairs_uniq_dep=&gt;</span><span class="id"> [|x</span><span class="id"> _|];</span><span class="id"> rewrite</span><span class="id"> ?undup_uniq</span> <span class="id"> ?permutations_uniq</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> [_</span><span class="id"> _]</span><span class="id"> [x</span><span class="id"> t]</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_permutations;</span><span class="id"> apply/idP/allpairsPdep=&gt;</span><span class="id"> [Dt</span><span class="id"> |</span><span class="id"> [x</span><span class="id"> [t1</span><span class="id"> []]]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">perm_size</span><span class="id"> Dt</span>)<span class="gallina-kwd"> in</span><span class="id"> nt_s;</span><span class="id"> case:</span><span class="id"> t</span><span class="id"> nt_s</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> x</span><span class="id"> t</span><span class="id"> _</span><span class="gallina-kwd"> in</span><span class="id"> Dt</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> s_x:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_mem</span><span class="id"> Dt</span>)<span class="id"> mem_head</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> x,</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> mem_undup</span><span class="id"> mem_permutations;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>) (<span class="id">permPl</span><span class="id"> Dt</span>)<span class="id"> perm_to_rem</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_undup</span><span class="id"> mem_permutations</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> s_x</span><span class="id"> Dt1</span><span class="id"> -&gt;</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">permPl</span><span class="id"> Dt1</span>)<span class="id"> perm_sym</span><span class="id"> perm_to_rem</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permutationsErot</span><span class="id"> x</span><span class="id"> s</span> (<span class="id">le_x</span><span class="id"> :=</span><span class="gallina-kwd"> fun</span><span class="id"> t</span><span class="id"> =&gt;</span><span class="id"> iota</span><span class="id"> 0</span> (<span class="id">index</span><span class="id"> x</span><span class="id"> t</span><span class="id"> +</span><span class="id"> 1</span>))<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span> (<span class="id">perms</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> s</span>))<span class="id"> [seq</span><span class="id"> rot</span><span class="id"> i</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> t</span>)<span class="id"> |</span><span class="id"> t</span><span class="id"> &lt;-</span><span class="id"> perms</span><span class="id"> s,</span><span class="id"> i</span><span class="id"> &lt;-</span><span class="id"> le_x</span><span class="id"> t]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> take'x</span><span class="id"> t</span><span class="id"> i:</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> index</span><span class="id"> x</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> t</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> \notin</span><span class="id"> take</span><span class="id"> i</span><span class="id"> t</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> le_i_x;</span><span class="id"> have</span><span class="id"> le_i_t:</span><span class="id"> i</span><span class="id"> &lt;=</span><span class="id"> size</span><span class="id"> t</span><span class="id"> :=</span><span class="id"> leq_trans</span><span class="id"> le_i_x</span> (<span class="id">index_size</span><span class="id"> x</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">nthP</span><span class="id"> x</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -[j</span><span class="id"> lt_j_i</span><span class="id"> /eqP];</span><span class="id"> rewrite</span><span class="id"> size_takel</span><span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> lt_j_i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nth_take</span><span class="id"> //</span><span class="id"> [_</span><span class="id"> ==</span><span class="id"> _]</span>(<span class="id">before_find</span><span class="id"> x</span> (<span class="id">leq_trans</span><span class="id"> lt_j_i</span><span class="id"> le_i_x</span>)).<br/>
<span class="id">pose</span><span class="id"> xrot</span><span class="id"> t</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> rot</span><span class="id"> i</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> t</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> xrotV</span><span class="id"> t</span><span class="id"> :=</span><span class="id"> index</span><span class="id"> x</span> (<span class="id">rev</span> (<span class="id">rot</span><span class="id"> 1</span><span class="id"> t</span>)).<br/>
<span class="id">have</span><span class="id"> xrotK</span><span class="id"> t:</span><span class="id"> {in</span><span class="id"> le_x</span><span class="id"> t,</span><span class="id"> cancel</span> (<span class="id">xrot</span><span class="id"> t</span>)<span class="id"> xrotV}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> mem_iota</span><span class="id"> addn1</span><span class="id"> /xrotV</span><span class="id"> =&gt;</span><span class="id"> /take'x[le_i_t</span><span class="id"> ti'x]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -rotD</span><span class="id"> ?rev_cat</span><span class="id"> //=</span><span class="id"> rev_cons</span><span class="id"> cat_rcons</span><span class="id"> index_cat</span><span class="id"> mem_rev</span><span class="id"> size_rev</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ifN</span><span class="id"> //</span><span class="id"> size_takel</span><span class="id"> //=</span><span class="id"> eqxx</span><span class="id"> addn0</span>.<br/>
<span class="id">apply/uniq_perm=&gt;</span><span class="id"> [||t];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> permutations_uniq</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/allpairs_uniq_dep=&gt;</span><span class="id"> [|t</span><span class="id"> _|];</span><span class="id"> rewrite</span><span class="id"> ?permutations_uniq</span><span class="id"> ?iota_uniq</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /allpairsPdep[t</span><span class="id"> [i</span><span class="id"> [_</span><span class="id"> ?</span><span class="id"> -&gt;]]]</span><span class="id"> /allpairsPdep[u</span><span class="id"> [j</span><span class="id"> [_</span><span class="id"> ?</span><span class="id"> -&gt;]]]</span><span class="id"> Etu</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Eij:</span><span class="id"> i</span><span class="id"> =</span><span class="id"> j</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">xrotK</span><span class="id"> t</span><span class="id"> i</span>)<span class="id"> //</span><span class="id"> /xrot</span><span class="id"> Etu</span><span class="id"> xrotK</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span><span class="id"> Etu;</span><span class="id"> rewrite</span><span class="id"> Eij</span><span class="id"> =&gt;</span><span class="id"> /rot_inj[-&gt;]</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_permutations;</span><span class="id"> apply/esym;</span><span class="id"> apply/allpairsPdep/idP=&gt;</span><span class="id"> [[u</span><span class="id"> [i]]</span><span class="id"> |</span><span class="id"> Dt]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_permutations</span><span class="id"> =&gt;</span><span class="id"> -[Du</span><span class="id"> _</span><span class="id"> /</span>(<span class="id">canLR</span> (<span class="id">rotK</span><span class="id"> i</span>))<span class="id">];</span><span class="id"> rewrite</span><span class="id"> /rotr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> set</span><span class="id"> j</span><span class="id"> :=</span> (<span class="id">j</span><span class="gallina-kwd"> in</span><span class="id"> rot</span><span class="id"> j</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> Dt;</span><span class="id"> apply/perm_consP;</span><span class="gallina-kwd"> exists</span><span class="id"> j,</span><span class="id"> u</span>.<br/>
<span class="id">pose</span><span class="id"> r</span><span class="id"> :=</span><span class="id"> rev</span> (<span class="id">rot</span><span class="id"> 1</span><span class="id"> t</span>)<span class="id">;</span><span class="id"> pose</span><span class="id"> i</span><span class="id"> :=</span><span class="id"> index</span><span class="id"> x</span><span class="id"> r;</span><span class="id"> pose</span><span class="id"> u</span><span class="id"> :=</span><span class="id"> rev</span> (<span class="id">take</span><span class="id"> i</span><span class="id"> r</span>).<br/>
<span class="id">have</span><span class="id"> r_x:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_rev</span><span class="id"> mem_rot</span> (<span class="id">perm_mem</span><span class="id"> Dt</span>)<span class="id"> mem_head</span>.<br/>
<span class="id">have</span><span class="id"> [v</span><span class="id"> Duv]:</span><span class="id"> {v</span><span class="id"> |</span><span class="id"> rot</span><span class="id"> i</span> (<span class="id">x</span><span class="id"> ::</span><span class="id"> u</span><span class="id"> ++</span><span class="id"> v</span>)<span class="id"> =</span><span class="id"> t};</span><span class="id"> first</span><span class="gallina-kwd"> exists</span> (<span class="id">rev</span> (<span class="id">drop</span><span class="id"> i</span>.<span class="id">+1</span><span class="id"> r</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -rev_cat</span><span class="id"> -rev_rcons</span><span class="id"> -rot1_cons</span><span class="id"> -cat_cons</span><span class="id"> -</span>(<span class="id">nth_index</span><span class="id"> x</span><span class="id"> r_x</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -drop_nth</span><span class="id"> ?index_mem</span><span class="id"> //</span><span class="id"> rot_rot</span><span class="id"> !rev_rot</span><span class="id"> revK</span><span class="id"> rotK</span><span class="id"> rotrK</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">u</span><span class="id"> ++</span><span class="id"> v</span>)<span class="id">,</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> mem_permutations</span><span class="id"> -</span>(<span class="id">perm_cons</span><span class="id"> x</span>)<span class="id"> -</span>(<span class="id">perm_rot</span><span class="id"> i</span>)<span class="id"> Duv</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_iota</span><span class="id"> addn1</span><span class="id"> ltnS</span><span class="id"> /=</span><span class="id"> index_cat</span><span class="id"> mem_rev</span><span class="id"> size_rev</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> /take'x[le_i_t</span><span class="id"> ti'x]</span><span class="id"> :=</span><span class="id"> leqnn</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> ifN</span><span class="id"> ?size_takel</span><span class="id"> ?leq_addr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> size_permutations</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> size</span> (<span class="id">permutations</span><span class="id"> s</span>)<span class="id"> =</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id">`!</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move</span><span class="id"> Dn:</span> (<span class="id">size</span><span class="id"> s</span>)<span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> Us;</span><span class="id"> elim:</span><span class="id"> n</span><span class="id"> s</span><span class="id"> =&gt;</span><span class="id"> [[]|n</span><span class="id"> IHn</span><span class="id"> s]</span><span class="id"> //=</span><span class="gallina-kwd"> in</span><span class="id"> Dn</span><span class="id"> Us</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span> (<span class="id">perm_size</span> (<span class="id">permutationsE</span><span class="id"> _</span>))<span class="id"> ?Dn</span><span class="id"> //</span><span class="id"> undup_id</span><span class="id"> //</span><span class="id"> factS</span><span class="id"> -Dn</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">size_iota</span><span class="id"> 0</span><span class="id"> n`!</span>)<span class="id"> -</span>(<span class="id">size_allpairs</span> (<span class="id">fun=&gt;id</span>))<span class="id"> !size_allpairs_dep</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/congr1/eq_in_map=&gt;</span><span class="id"> x</span><span class="id"> sx;</span><span class="id"> rewrite</span><span class="id"> size_iota</span><span class="id"> IHn</span><span class="id"> ?size_rem</span><span class="id"> ?Dn</span><span class="id"> ?rem_uniq</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> permutations_all_uniq</span><span class="id"> s</span><span class="id"> :</span><span class="id"> uniq</span><span class="id"> s</span><span class="id"> -&gt;</span><span class="id"> all</span><span class="id"> uniq</span> (<span class="id">permutations</span><span class="id"> s</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> Us;</span><span class="id"> apply/allP=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> mem_permutations</span><span class="id"> =&gt;</span><span class="id"> /perm_uniq-&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> perm_permutations</span><span class="id"> s</span><span class="id"> t</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">perm_eq</span><span class="id"> s</span><span class="id"> t</span><span class="id"> -&gt;</span><span class="id"> perm_eq</span> (<span class="id">permutations</span><span class="id"> s</span>) (<span class="id">permutations</span><span class="id"> t</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> Est;</span><span class="id"> apply/uniq_perm;</span><span class="id"> try</span><span class="id"> exact:</span><span class="id"> permutations_uniq</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> !mem_permutations</span> (<span class="id">permPr</span><span class="id"> Est</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Permutations</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
