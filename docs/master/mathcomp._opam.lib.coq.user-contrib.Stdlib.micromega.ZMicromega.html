
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.Stdlib.micromega.ZMicromega</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.Stdlib.micromega.ZMicromega" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><details id="mathcomp.algebra.num_theory"><summary>num_theory</summary>
          <ul>
          <li><a href="mathcomp.algebra.num_theory.numdomain.html">numdomain</a></li>
<li><a href="mathcomp.algebra.num_theory.numfield.html">numfield</a></li>
<li><a href="mathcomp.algebra.num_theory.orderedzmod.html">orderedzmod</a></li>
<li><a href="mathcomp.algebra.num_theory.ssrnum.html">ssrnum</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.boot"><summary>boot</summary>
          <ul>
          <li><a href="mathcomp.boot.all_boot.html">all_boot</a></li>
<li><a href="mathcomp.boot.bigop.html">bigop</a></li>
<li><a href="mathcomp.boot.binomial.html">binomial</a></li>
<li><a href="mathcomp.boot.choice.html">choice</a></li>
<li><a href="mathcomp.boot.div.html">div</a></li>
<li><a href="mathcomp.boot.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.boot.finfun.html">finfun</a></li>
<li><a href="mathcomp.boot.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.boot.finset.html">finset</a></li>
<li><a href="mathcomp.boot.fintype.html">fintype</a></li>
<li><a href="mathcomp.boot.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.boot.monoid.html">monoid</a></li>
<li><a href="mathcomp.boot.nmodule.html">nmodule</a></li>
<li><a href="mathcomp.boot.path.html">path</a></li>
<li><a href="mathcomp.boot.prime.html">prime</a></li>
<li><a href="mathcomp.boot.seq.html">seq</a></li>
<li><a href="mathcomp.boot.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.boot.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.boot.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.boot.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.boot.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.boot.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.boot.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.boot.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.order"><summary>order</summary>
          <ul>
          <li><a href="mathcomp.order.all_order.html">all_order</a></li>
<li><a href="mathcomp.order.order.html">order</a></li>
<li><a href="mathcomp.order.preorder.html">preorder</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.Stdlib.micromega.ZMicromega</h1>
<pre class="ssrdoc">
        *      The Rocq Prover / The Rocq Development Team
 v      *         Copyright INRIA, CNRS and contributors
&lt;O___,, * (see version control and CREDITS file for authors &amp; dates)
  \VV/  *************************************************************
   //   *    This file is distributed under the terms of the
        *     GNU Lesser General Public License Version 2.1
        *     (see LICENSE file for the text of the license)
</pre>
<pre class="ssrdoc">
From Stdlib Require Import List.
From Stdlib Require Import Bool.
From Stdlib Require Import OrderedRing.
From Stdlib Require Import RingMicromega.
From Stdlib Require Import ZArithRing.
From Stdlib Require Import ZCoeff.
From Stdlib Require Import Refl.
From Stdlib Require Import BinInt.
From Stdlib Require InitialRing.
From Stdlib.micromega Require Import Tauto.
Local Open Scope Z_scope.
Ltac flatten_bool :=
  repeat match goal with
           [ id : (_ &amp;&amp; _)%bool = true |- _ ] =&gt;  destruct (andb_prop _ _ id); clear id
         |  [ id : (_ || _)%bool = true |- _ ] =&gt;  destruct (orb_prop _ _ id); clear id
         end.
Ltac inv H := inversion H ; try subst ; clear H.
Lemma eq_le_iff : forall x, 0 = x  &lt;-&gt; (0 &lt;= x /\ x &lt;= 0).
Proof.
  intros.
  split ; intros H.
  - subst.
    split; reflexivity.
  - destruct H.
    apply Z.le_antisymm; auto.
Qed.
Lemma lt_le_iff x : 0 &lt; x &lt;-&gt; 0 &lt;= x - 1.
Proof. rewrite &lt;-Z.lt_succ_r, Z.sub_1_r, Z.succ_pred; reflexivity. Qed.
Lemma le_0_iff x y : x &lt;= y &lt;-&gt; 0 &lt;= y - x.
Proof. symmetry. apply Z.le_0_sub. Qed.
Lemma le_neg x : ((0 &lt;= x) -&gt; False) &lt;-&gt; 0 &lt; -x.
Proof. setoid_rewrite Z.nle_gt. rewrite Z.opp_pos_neg. reflexivity. Qed.
Lemma eq_cnf x : (0 &lt;= x - 1 -&gt; False) /\ (0 &lt;= -1 - x -&gt; False) &lt;-&gt; x = 0.
Proof.
  rewrite (Z.sub_opp_l 1).
  setoid_rewrite &lt;-lt_le_iff.
  rewrite Z.opp_pos_neg.
  setoid_rewrite Z.nlt_ge.
  split; intros.
  { apply Z.le_antisymm; try apply H. }
  { subst x. split; reflexivity. }
Qed.
From Stdlib Require Import EnvRing.
Lemma Zsor : SOR 0 1 Z.add Z.mul Z.sub Z.opp (@eq Z) Z.le Z.lt.
Proof.
  constructor ; intros ; subst; try reflexivity.
  - apply InitialRing.Zsth.
  - apply InitialRing.Zth.
  - auto using Z.le_antisymm.
  - eauto using Z.le_trans.
  - apply Z.le_neq.
  - apply Z.lt_trichotomy.
  - apply Z.add_le_mono_l; assumption.
  - apply Z.mul_pos_pos ; auto.
  - discriminate.
Qed.
Lemma ZSORaddon :
  SORaddon 0 1 Z.add Z.mul Z.sub Z.opp  (@eq Z) Z.le (* ring elements
  0%Z 1%Z Z.add Z.mul Z.sub Z.opp (* coefficients
  Z.eqb Z.leb
  (fun x =&gt; x) (fun x =&gt; x) (pow_N 1 Z.mul).
Proof.
  constructor.
  - constructor ; intros ; try reflexivity.
    apply Z.eqb_eq ; auto.
  - constructor.
    reflexivity.
  - intros x y.
    rewrite &lt;-Z.eqb_eq. congruence.
  - apply Z.leb_le.
Qed.
Fixpoint Zeval_expr (env : PolEnv Z) (e: PExpr Z) : Z :=
  match e with
    | PEc c =&gt; c
    | PEX x =&gt; env x
    | PEadd e1 e2 =&gt; Zeval_expr env e1 + Zeval_expr env e2
    | PEmul e1 e2 =&gt; Zeval_expr env e1 * Zeval_expr env e2
    | PEpow e1 n  =&gt; Z.pow (Zeval_expr env e1) (Z.of_N n)
    | PEsub e1 e2 =&gt; (Zeval_expr env e1) - (Zeval_expr env e2)
    | PEopp e   =&gt; Z.opp (Zeval_expr env e)
  end.
Strategy expand [ Zeval_expr ].
Definition eval_expr := eval_pexpr  Z.add Z.mul Z.sub Z.opp (fun x =&gt; x) (fun x =&gt; x) (pow_N 1 Z.mul).
Fixpoint Zeval_const  (e: PExpr Z) : option Z :=
  match e with
  | PEc c =&gt; Some c
  | PEX x =&gt; None
  | PEadd e1 e2 =&gt; map_option2 (fun x y =&gt; Some (x + y))
                               (Zeval_const e1) (Zeval_const e2)
  | PEmul e1 e2 =&gt; map_option2 (fun x y =&gt; Some (x * y))
                               (Zeval_const e1) (Zeval_const e2)
  | PEpow e1 n  =&gt; map_option (fun x =&gt; Some (Z.pow x (Z.of_N n)))
                                 (Zeval_const e1)
  | PEsub e1 e2 =&gt; map_option2 (fun x y =&gt; Some (x - y))
                               (Zeval_const e1)  (Zeval_const e2)
  | PEopp e   =&gt; map_option (fun x =&gt; Some (Z.opp x)) (Zeval_const e)
  end.
Lemma ZNpower : forall r n, r ^ Z.of_N n = pow_N 1 Z.mul r n.
Proof.
  intros r n; destruct n as [|p].
  - reflexivity.
  - simpl.
    unfold Z.pow_pos.
    rewrite &lt;-Z.mul_1_l.
    generalize 1.
    induction p as [p IHp|p IHp|]; simpl; intros ;
      rewrite ?IHp, ?Z.mul_assoc; auto using Z.mul_comm, f_equal2.
Qed.
Lemma Zeval_expr_compat : forall env e, Zeval_expr env e = eval_expr env e.
Proof.
  intros env e; induction e ; simpl ; try congruence.
  - reflexivity.
  - rewrite ZNpower. congruence.
Qed.
Definition Zeval_pop2 (o : Op2) : Z -&gt; Z -&gt; Prop :=
match o with
| OpEq =&gt;  @eq Z
| OpNEq =&gt; fun x y  =&gt; ~ x = y
| OpLe =&gt; Z.le
| OpGe =&gt; Z.ge
| OpLt =&gt; Z.lt
| OpGt =&gt; Z.gt
end.
Definition Zeval_bop2 (o : Op2) : Z -&gt; Z -&gt; bool :=
match o with
| OpEq =&gt;  Z.eqb
| OpNEq =&gt; fun x y =&gt; negb (Z.eqb x y)
| OpLe =&gt; Z.leb
| OpGe =&gt; Z.geb
| OpLt =&gt; Z.ltb
| OpGt =&gt; Z.gtb
end.
Lemma pop2_bop2 :
  forall (op : Op2) (q1 q2 : Z), is_true (Zeval_bop2 op q1 q2) &lt;-&gt; Zeval_pop2 op q1 q2.
Proof.
  unfold is_true.
  intro op; destruct op ; simpl; intros q1 q2.
  - apply Z.eqb_eq.
  - rewrite &lt;- Z.eqb_eq.
    rewrite negb_true_iff.
    destruct (q1 =? q2) ; intuition congruence.
  - apply Z.leb_le.
  - rewrite Z.geb_le. rewrite Z.ge_le_iff. tauto.
  - apply Z.ltb_lt.
  - rewrite &lt;- Z.gtb_gt; tauto.
Qed.
Definition Zeval_op2 (k: Tauto.kind) :  Op2 -&gt;  Z -&gt; Z -&gt; Tauto.rtyp k:=
  if k as k0 return (Op2 -&gt; Z -&gt; Z -&gt; Tauto.rtyp k0)
  then Zeval_pop2 else Zeval_bop2.
Lemma Zeval_op2_hold : forall k op q1 q2,
    Tauto.hold k (Zeval_op2 k op q1 q2) &lt;-&gt; Zeval_pop2 op q1 q2.
Proof.
  intro k; destruct k.
  - simpl ; tauto.
  - simpl. apply pop2_bop2.
Qed.
Definition Zeval_formula (env : PolEnv Z) (k: Tauto.kind) (f : Formula Z):=
  let (lhs, op, rhs) := f in
    (Zeval_op2 k op) (Zeval_expr env lhs) (Zeval_expr env rhs).
Definition Zeval_formula' :=
  eval_formula  Z.add Z.mul Z.sub Z.opp (@eq Z) Z.le Z.lt (fun x =&gt; x) (fun x =&gt; x) (pow_N 1 Z.mul).
Lemma Zeval_formula_compat : forall env k f, Tauto.hold k (Zeval_formula env k f) &lt;-&gt; Zeval_formula env Tauto.isProp f.
Proof.
  intros env k; destruct k ; simpl.
  - tauto.
  - intros f; destruct f ; simpl.
    rewrite &lt;- (Zeval_op2_hold Tauto.isBool).
    simpl. tauto.
Qed.
Lemma Zeval_formula_compat' : forall env f,  Zeval_formula env Tauto.isProp f &lt;-&gt; Zeval_formula' env f.
Proof.
  intros env f.
  unfold Zeval_formula.
  destruct f as [Flhs  Fop Frhs].
  repeat rewrite Zeval_expr_compat.
  unfold Zeval_formula' ; simpl.
  unfold eval_expr.
  generalize (eval_pexpr Z.add Z.mul Z.sub Z.opp (fun x : Z =&gt; x)
        (fun x : N =&gt; x) (pow_N 1 Z.mul) env Flhs).
  generalize ((eval_pexpr Z.add Z.mul Z.sub Z.opp (fun x : Z =&gt; x)
        (fun x : N =&gt; x) (pow_N 1 Z.mul) env Frhs)).
  destruct Fop ; simpl; intros;
    intuition auto using Z.le_ge, Z.ge_le, Z.lt_gt, Z.gt_lt.
Qed.
Definition eval_nformula :=
  eval_nformula 0 Z.add Z.mul  (@eq Z) Z.le Z.lt (fun x =&gt; x) .
Definition Zeval_op1 (o : Op1) : Z -&gt; Prop :=
match o with
| Equal =&gt; fun x : Z =&gt; x = 0
| NonEqual =&gt; fun x : Z =&gt; x &lt;&gt; 0
| Strict =&gt; fun x : Z =&gt; 0 &lt; x
| NonStrict =&gt; fun x : Z =&gt; 0 &lt;= x
end.
Lemma Zeval_nformula_dec : forall env d, (eval_nformula env d) \/ ~ (eval_nformula env d).
Proof.
  intros.
  apply (eval_nformula_dec Zsor).
Qed.
Definition ZWitness := Psatz Z.
Definition ZWeakChecker := check_normalised_formulas 0 1 Z.add Z.mul Z.eqb Z.leb.
Lemma ZWeakChecker_sound :   forall (l : list (NFormula Z)) (cm : ZWitness),
  ZWeakChecker l cm = true -&gt;
  forall env, make_impl (eval_nformula env) l False.
Proof.
  intros l cm H.
  intro.
  unfold eval_nformula.
  apply (checker_nf_sound Zsor ZSORaddon l cm).
  unfold ZWeakChecker in H.
  exact H.
Qed.
Definition psub  := psub Z0  Z.add Z.sub Z.opp Z.eqb.
Declare Equivalent Keys psub RingMicromega.psub.
Definition popp  := popp Z.opp.
Declare Equivalent Keys popp RingMicromega.popp.
Definition padd  := padd Z0  Z.add Z.eqb.
Declare Equivalent Keys padd RingMicromega.padd.
Definition pmul := pmul 0 1 Z.add Z.mul Z.eqb.
Definition normZ  := norm 0 1 Z.add Z.mul Z.sub Z.opp Z.eqb.
Declare Equivalent Keys normZ RingMicromega.norm.
Definition eval_pol := eval_pol Z.add Z.mul (fun x =&gt; x).
Declare Equivalent Keys eval_pol RingMicromega.eval_pol.
Lemma eval_pol_sub : forall env lhs rhs, eval_pol env (psub  lhs rhs) = eval_pol env lhs - eval_pol env rhs.
Proof.
  intros.
  apply (eval_pol_sub Zsor ZSORaddon).
Qed.
Lemma eval_pol_add : forall env lhs rhs, eval_pol env (padd  lhs rhs) = eval_pol env lhs + eval_pol env rhs.
Proof.
  intros.
  apply (eval_pol_add Zsor ZSORaddon).
Qed.
Lemma eval_pol_mul : forall env lhs rhs, eval_pol env (pmul  lhs rhs) = eval_pol env lhs * eval_pol env rhs.
Proof.
  intros.
  apply (eval_pol_mul Zsor ZSORaddon).
Qed.
Lemma eval_pol_norm : forall env e, eval_expr env e = eval_pol env (normZ e) .
Proof.
  intros.
  apply (eval_pol_norm Zsor ZSORaddon).
Qed.
Definition Zunsat := check_inconsistent 0  Z.eqb Z.leb.
Definition Zdeduce := nformula_plus_nformula 0 Z.add Z.eqb.
Lemma Zunsat_sound : forall f,
    Zunsat f = true -&gt; forall env, eval_nformula env f -&gt; False.
Proof.
  unfold Zunsat.
  intros f H env ?.
  destruct f.
  eapply check_inconsistent_sound with (1 := Zsor) (2 := ZSORaddon) in H; eauto.
Qed.
Definition xnnormalise (t : Formula Z) : NFormula Z :=
  let (lhs,o,rhs) := t in
  let lhs := normZ lhs in
  let rhs := normZ rhs in
  match o with
  | OpEq  =&gt; (psub rhs lhs,  Equal)
  | OpNEq =&gt; (psub rhs lhs,  NonEqual)
  | OpGt  =&gt; (psub lhs rhs,  Strict)
  | OpLt  =&gt; (psub rhs lhs,  Strict)
  | OpGe  =&gt; (psub lhs rhs,  NonStrict)
  | OpLe =&gt;  (psub rhs lhs,  NonStrict)
  end.
Lemma xnnormalise_correct :
  forall env f,
    eval_nformula env (xnnormalise f) &lt;-&gt; Zeval_formula env Tauto.isProp f.
Proof.
  intros env f.
  rewrite Zeval_formula_compat'.
  unfold xnnormalise.
  destruct f as [lhs o rhs].
  destruct o eqn:O ; cbn ; rewrite ?eval_pol_sub;
    rewrite &lt;- !eval_pol_norm ; simpl in *;
      unfold eval_expr;
      generalize (   eval_pexpr  Z.add Z.mul Z.sub Z.opp (fun x : Z =&gt; x)
                                 (fun x : N =&gt; x) (pow_N 1 Z.mul) env lhs);
      generalize (eval_pexpr  Z.add Z.mul Z.sub Z.opp (fun x : Z =&gt; x)
                              (fun x : N =&gt; x) (pow_N 1 Z.mul) env rhs); intros z z0.
  - split ; intros.
    + assert (z0 + (z - z0) = z0 + 0) as H0 by congruence.
      rewrite Z.add_0_r in H0.
      rewrite &lt;- H0.
      rewrite Z.add_sub_assoc, Z.add_comm, &lt;-Z.add_sub_assoc, Z.sub_diag; apply Z.add_0_r.
    + subst.
      apply Z.sub_diag.
  - split ; intros H H0.
    + subst. apply H. apply Z.sub_diag.
    + apply H.
      assert (z0 + (z - z0) = z0 + 0) as H1 by congruence.
      rewrite Z.add_0_r in H1.
      rewrite &lt;- H1.
      rewrite Z.add_sub_assoc, Z.add_comm, &lt;-Z.add_sub_assoc, Z.sub_diag; apply Z.add_0_r.
  - symmetry. apply le_0_iff.
  - symmetry. apply le_0_iff.
  - apply Z.lt_0_sub.
  - apply Z.lt_0_sub.
Qed.
Definition xnormalise (f: NFormula Z) : list (NFormula Z) :=
  let (e,o) := f in
  match o with
  | Equal     =&gt; (psub e (Pc 1),NonStrict) :: (psub (Pc (-1)) e, NonStrict) :: nil
  | NonStrict =&gt;  ((psub (Pc (-1)) e,NonStrict)::nil)
  | Strict    =&gt;  ((psub (Pc 0)) e, NonStrict)::nil
  | NonEqual  =&gt;  (e, Equal)::nil
  end.
Lemma eval_pol_Pc : forall env z,
    eval_pol env (Pc z) = z.
Proof.
  reflexivity.
Qed.
Lemma xnormalise_correct : forall env f,
    (make_conj (fun x =&gt; eval_nformula env x -&gt; False) (xnormalise f)) &lt;-&gt; eval_nformula env f.
Proof.
  intros env f.
  destruct f as [e o]; destruct o eqn:Op; cbn - [psub];
    repeat rewrite eval_pol_sub; fold eval_pol; repeat rewrite eval_pol_Pc;
      generalize (eval_pol env e) as x; intro.
  - apply eq_cnf.
  - unfold not. tauto.
  - rewrite le_neg. rewrite (Z.sub_0_l x), Z.opp_involutive; reflexivity.
  - rewrite le_neg, lt_le_iff.
    rewrite Z.sub_opp_l, Z.sub_sub_distr. reflexivity.
Qed.
From Stdlib.micromega Require Import Tauto.
From Stdlib Require Import BinNums.
Definition cnf_of_list {T: Type} (tg : T) (l : list (NFormula Z)) :=
  List.fold_right (fun x acc =&gt;
                     if Zunsat x then acc else ((x,tg)::nil)::acc)
                  (cnf_tt _ _)  l.
Lemma cnf_of_list_correct :
  forall {T : Type} (tg:T)  (f : list (NFormula Z)) env,
  eval_cnf eval_nformula env (cnf_of_list tg f) &lt;-&gt;
  make_conj (fun x : NFormula Z =&gt; eval_nformula env x -&gt; False) f.
Proof.
  unfold cnf_of_list.
  intros T tg f env.
  set (F := (fun (x : NFormula Z) (acc : list (list (NFormula Z * T))) =&gt;
        if Zunsat x then acc else ((x, tg) :: nil) :: acc)).
  set (E := ((fun x : NFormula Z =&gt; eval_nformula env x -&gt; False))).
  induction f as [|a f IHf].
  - compute.
    tauto.
  - rewrite make_conj_cons.
    simpl.
    unfold F at 1.
    destruct (Zunsat a) eqn:EQ.
    + rewrite IHf.
      unfold E at 1.
      specialize (Zunsat_sound _ EQ env).
      tauto.
    +
      rewrite &lt;- eval_cnf_cons_iff.
      rewrite IHf.
      simpl.
      unfold E at 2.
      unfold eval_tt. simpl.
      tauto.
Qed.
Definition normalise {T : Type} (t:Formula Z) (tg:T) : cnf (NFormula Z) T :=
  let f := xnnormalise t in
  if Zunsat f then cnf_ff _ _
  else cnf_of_list tg (xnormalise f).
Lemma normalise_correct : forall (T: Type) env t (tg:T), eval_cnf eval_nformula env (normalise t tg) &lt;-&gt; Zeval_formula env Tauto.isProp t.
Proof.
  intros T env t tg.
  rewrite &lt;- xnnormalise_correct.
  unfold normalise.
  generalize (xnnormalise t) as f;intro f.
  destruct (Zunsat f) eqn:U.
  - assert (US := Zunsat_sound _  U env).
    rewrite eval_cnf_ff.
    tauto.
  - rewrite cnf_of_list_correct.
    apply xnormalise_correct.
Qed.
Definition xnegate (f:NFormula Z) : list (NFormula Z)  :=
  let (e,o) := f in
    match o with
      | Equal  =&gt; (e,Equal) :: nil
      | NonEqual =&gt; (psub e (Pc 1),NonStrict) :: (psub (Pc (-1)) e, NonStrict) :: nil
      | NonStrict =&gt; (e,NonStrict)::nil
      | Strict    =&gt; (psub e (Pc 1),NonStrict)::nil
    end.
Definition negate {T : Type} (t:Formula Z) (tg:T) : cnf (NFormula Z) T :=
  let f := xnnormalise t in
  if Zunsat f then cnf_tt _ _
  else cnf_of_list tg (xnegate f).
Lemma xnegate_correct : forall env f,
    (make_conj (fun x =&gt; eval_nformula env x -&gt; False) (xnegate f)) &lt;-&gt; ~ eval_nformula env f.
Proof.
  intros env f.
  destruct f as [e o]; destruct o eqn:Op; cbn - [psub];
    repeat rewrite eval_pol_sub; fold eval_pol; repeat rewrite eval_pol_Pc;
      generalize (eval_pol env e) as x; intro x.
  - tauto.
  - rewrite eq_cnf.
    destruct (Z.eq_decidable x 0);tauto.
  - rewrite lt_le_iff.
    tauto.
  - tauto.
Qed.
Lemma negate_correct : forall T env t (tg:T), eval_cnf eval_nformula env (negate t tg) &lt;-&gt; ~ Zeval_formula env Tauto.isProp t.
Proof.
  intros T env t tg.
  rewrite &lt;- xnnormalise_correct.
  unfold negate.
  generalize (xnnormalise t) as f;intro f.
  destruct (Zunsat f) eqn:U.
  - assert (US := Zunsat_sound _  U env).
    rewrite eval_cnf_tt.
    tauto.
  - rewrite cnf_of_list_correct.
    apply xnegate_correct.
Qed.
Definition cnfZ (Annot: Type) (TX : Tauto.kind -&gt; Type)  (AF : Type) (k: Tauto.kind) (f : TFormula (Formula Z) Annot TX AF k) :=
  rxcnf Zunsat Zdeduce normalise negate true f.
Definition ZweakTautoChecker (w: list ZWitness) (f : BFormula (Formula Z) Tauto.isProp) : bool :=
  @tauto_checker (Formula Z)  (NFormula Z) unit Zunsat Zdeduce normalise negate  ZWitness (fun cl =&gt; ZWeakChecker (List.map fst cl)) f w.
To get a complete checker, the proof format has to be enriched
From Stdlib Require Import Zdiv.
Local Open Scope Z_scope.
Definition ceiling (a b:Z) : Z :=
  let (q,r) := Z.div_eucl a b in
    match r with
      | Z0 =&gt; q
      | _  =&gt; q + 1
    end.
From Stdlib Require Import Znumtheory.
Lemma Zdivide_ceiling : forall a b, (b | a) -&gt; ceiling a b = Z.div a b.
Proof.
  unfold ceiling.
  intros a b H.
  apply Zdivide_mod in H.
  case_eq (Z.div_eucl a b).
  intros z z0 H0.
  change z with (fst (z,z0)).
  rewrite &lt;- H0.
  change (fst (Z.div_eucl a b)) with (Z.div a b).
  change z0 with (snd (z,z0)).
  rewrite &lt;- H0.
  change (snd (Z.div_eucl a b)) with (Z.modulo a b).
  rewrite H.
  reflexivity.
Qed.
Lemma narrow_interval_lower_bound a b x :
  a &gt; 0 -&gt; a * x  &gt;= b -&gt; x &gt;= ceiling b a.
Proof.
  rewrite !Z.ge_le_iff.
  unfold ceiling.
  intros Ha H.
  generalize (Z_div_mod b a Ha).
  destruct (Z.div_eucl b a) as (q,r). intros (-&gt;,(H1,H2)).
  destruct r as [|r|r].
  - rewrite Z.add_0_r in H.
    apply Z.mul_le_mono_pos_l in H; auto with zarith.
  - assert (0 &lt; Z.pos r) by easy.
    rewrite Z.add_1_r, Z.le_succ_l.
    apply Z.mul_lt_mono_pos_l with a.
    + auto using Z.gt_lt.
    + eapply Z.lt_le_trans. 2: eassumption.
      now apply Z.lt_add_pos_r.
  - now elim H1.
Qed.
(** NB: narrow_interval_upper_bound is Zdiv.Zdiv_le_lower_bound
Inductive ZArithProof :=
| DoneProof
| RatProof : ZWitness -&gt; ZArithProof -&gt; ZArithProof
| CutProof : ZWitness -&gt; ZArithProof -&gt; ZArithProof
| SplitProof : PolC Z -&gt; ZArithProof -&gt; ZArithProof -&gt; ZArithProof
| EnumProof : ZWitness -&gt; ZWitness -&gt; list ZArithProof -&gt; ZArithProof
| ExProof   : positive -&gt; ZArithProof -&gt; ZArithProof
(*ExProof x : exists z t, x = z - t /\ z &gt;= 0 /\ t &gt;= 0
.
Register ZArithProof as micromega.ZArithProof.type.
Register DoneProof   as micromega.ZArithProof.DoneProof.
Register RatProof    as micromega.ZArithProof.RatProof.
Register CutProof    as micromega.ZArithProof.CutProof.
Register SplitProof  as micromega.ZArithProof.SplitProof.
Register EnumProof   as micromega.ZArithProof.EnumProof.
Register ExProof     as micromega.ZArithProof.ExProof.
In order to compute the 'cut', we need to express a polynomial P as a * Q + b.
   - b is the constant
   - a is the gcd of the other coefficient.

From Stdlib Require Import Znumtheory.
Definition isZ0 (x:Z) :=
  match x with
    | Z0 =&gt; true
    | _  =&gt; false
  end.
Lemma isZ0_0 : forall x, isZ0 x = true &lt;-&gt; x = 0.
Proof.
  intros x; destruct x ; simpl ; intuition congruence.
Qed.
Lemma isZ0_n0 : forall x, isZ0 x = false &lt;-&gt; x &lt;&gt; 0.
Proof.
  intros x; destruct x ; simpl ; intuition congruence.
Qed.
Definition ZgcdM (x y : Z) := Z.max (Z.gcd x y) 1.
Fixpoint Zgcd_pol (p : PolC Z) : (Z * Z) :=
  match p with
    | Pc c =&gt; (0,c)
    | Pinj _ p =&gt; Zgcd_pol p
    | PX p _ q =&gt;
      let (g1,c1) := Zgcd_pol p in
        let (g2,c2) := Zgcd_pol q in
          (ZgcdM (ZgcdM g1 c1) g2 , c2)
  end.
(*Eval compute in (Zgcd_pol ((PX (Pc (-2)) 1 (Pc 4)))).
Fixpoint Zdiv_pol (p:PolC Z) (x:Z) : PolC Z :=
  match p with
    | Pc c =&gt; Pc (Z.div c x)
    | Pinj j p =&gt; Pinj j (Zdiv_pol p x)
    | PX p j q =&gt; PX (Zdiv_pol p x) j (Zdiv_pol q x)
  end.
Inductive Zdivide_pol (x:Z): PolC Z -&gt; Prop :=
| Zdiv_Pc : forall c, (x | c) -&gt; Zdivide_pol x (Pc c)
| Zdiv_Pinj : forall p, Zdivide_pol x p -&gt;  forall j, Zdivide_pol x (Pinj j p)
| Zdiv_PX   : forall p q, Zdivide_pol x p -&gt; Zdivide_pol x q -&gt; forall j, Zdivide_pol x (PX p j q).
Lemma Zdiv_pol_correct : forall a p, 0 &lt; a -&gt; Zdivide_pol a p  -&gt;
  forall env, eval_pol env p =  a * eval_pol env (Zdiv_pol p a).
Proof.
  intros a p H H0.
  induction H0 as [? ?|? ? IHZdivide_pol j|? ? ? IHZdivide_pol1 ? IHZdivide_pol2 j].
  - (* Pc
    simpl.
    intros.
    apply Zdivide_Zdiv_eq ; auto.
  - (* Pinj
    simpl.
    intros.
    apply IHZdivide_pol.
  - (* PX
    simpl.
    intros.
    rewrite IHZdivide_pol1.
    rewrite IHZdivide_pol2.
    ring.
Qed.
Lemma Zgcd_pol_ge : forall p, fst (Zgcd_pol p) &gt;= 0.
Proof.
  intros p; induction p as [c|p p1 IHp1|p1 IHp1 ? p3 IHp3]. 1-2: easy.
  simpl.
  case_eq (Zgcd_pol p1).
  case_eq (Zgcd_pol p3).
  intros.
  simpl.
  unfold ZgcdM.
  apply Z.le_ge; transitivity 1.
  - easy.
  - apply Z.le_max_r.
Qed.
Lemma Zdivide_pol_Zdivide : forall p x y, Zdivide_pol x p -&gt; (y | x) -&gt;  Zdivide_pol y p.
Proof.
  intros p x y H H0.
  induction H.
  - constructor.
    apply Z.divide_trans with (1:= H0) ; assumption.
  - constructor. auto.
  - constructor ; auto.
Qed.
Lemma Zdivide_pol_one : forall p, Zdivide_pol 1 p.
Proof.
  intros p; induction p as [c| |]; constructor ; auto.
  exists c. ring.
Qed.
Lemma Zgcd_minus : forall a b c, (a | c - b ) -&gt; (Z.gcd a b | c).
Proof.
  intros a b c (q,Hq).
  destruct (Zgcd_is_gcd a b) as [(a',Ha) (b',Hb) _].
  set (g:=Z.gcd a b) in *; clearbody g.
  exists (q * a' + b').
  symmetry in Hq. rewrite &lt;- Z.add_move_r in Hq.
  rewrite &lt;- Hq, Hb, Ha. ring.
Qed.
Lemma Zdivide_pol_sub : forall p a b,
  0 &lt; Z.gcd a b -&gt;
  Zdivide_pol a (PsubC Z.sub p b) -&gt;
   Zdivide_pol (Z.gcd a b) p.
Proof.
  intros p; induction p as [c|? p IHp|p ? ? ? IHp2].
  - simpl.
    intros a b H H0. inversion H0.
    constructor.
    apply Zgcd_minus ; auto.
  - intros ? ? H H0.
    constructor.
    simpl in H0. inversion H0 ; subst; clear H0.
    apply IHp ; auto.
  - simpl. intros a b H H0.
    inv H0.
    constructor.
    + apply Zdivide_pol_Zdivide with (1:= (ltac:(assumption) : Zdivide_pol a p)).
      destruct (Zgcd_is_gcd a b) ; assumption.
    + apply IHp2 ; assumption.
Qed.
Lemma Zdivide_pol_sub_0 : forall p a,
  Zdivide_pol a (PsubC Z.sub p 0) -&gt;
   Zdivide_pol a p.
Proof.
  intros p; induction p as [c|? p IHp|? IHp1 ? ? IHp2].
  - simpl.
    intros ? H. inversion H.
    constructor. rewrite Z.sub_0_r in *. assumption.
  - intros ? H.
    constructor.
    simpl in H. inversion H ; subst; clear H.
    apply IHp ; auto.
  - simpl. intros ? H.
    inv H.
    constructor.
    + auto.
    + apply IHp2 ; assumption.
Qed.
Lemma Zgcd_pol_div : forall p g c,
  Zgcd_pol p = (g, c) -&gt; Zdivide_pol g (PsubC Z.sub p c).
Proof.
  intros p; induction p as [c|? ? IHp|p1 IHp1 ? p3 IHp2]; simpl.
  - (* Pc
    intros ? ? H. inv H.
    constructor.
    exists 0. now ring.
  - (* Pinj
    intros.
    constructor.  apply IHp ; auto.
  - (* PX
    intros g c.
    case_eq (Zgcd_pol p1) ; case_eq (Zgcd_pol p3) ; intros z z0 H z1 z2 H0 H1.
    inv H1.
    unfold ZgcdM at 1.
    destruct (Z.max_spec (Z.gcd (ZgcdM z1 z2) z) 1) as [HH1 | HH1]; cycle 1;
      destruct HH1 as [HH1 HH1'] ; rewrite HH1'.
    + constructor.
      * apply (Zdivide_pol_Zdivide _ (ZgcdM z1 z2)).
        -- unfold ZgcdM.
           destruct (Z.max_spec  (Z.gcd z1 z2)  1) as [HH2 | HH2]; cycle 1.
           ++ destruct HH2 as [H1 H2].
              rewrite H2.
              apply Zdivide_pol_sub ; auto.
              apply Z.lt_le_trans with 1.
              ** reflexivity.
              ** trivial.
           ++ destruct HH2 as [H1 H2]. rewrite H2.
              apply Zdivide_pol_one.
        -- unfold ZgcdM in HH1. unfold ZgcdM.
           destruct (Z.max_spec  (Z.gcd z1 z2)  1) as [HH2 | HH2]; cycle 1.
           ++ destruct HH2 as [H1 H2]. rewrite H2 in *.
              destruct (Zgcd_is_gcd (Z.gcd z1 z2) z); auto.
           ++ destruct HH2 as [H1 H2]. rewrite H2.
              destruct (Zgcd_is_gcd 1  z); auto.
      * apply (Zdivide_pol_Zdivide _ z).
        -- apply (IHp2 _ _ H); auto.
        -- destruct (Zgcd_is_gcd (ZgcdM z1 z2) z); auto.
    + constructor.
      * apply Zdivide_pol_one.
      * apply Zdivide_pol_one.
Qed.
Lemma Zgcd_pol_correct_lt : forall p env g c, Zgcd_pol p = (g,c) -&gt; 0 &lt; g -&gt; eval_pol env p = g * (eval_pol env (Zdiv_pol (PsubC Z.sub p c) g))  + c.
Proof.
  intros.
  rewrite &lt;- Zdiv_pol_correct ; auto.
  - rewrite (RingMicromega.PsubC_ok Zsor ZSORaddon).
    unfold eval_pol. ring.
    (*
  - apply Zgcd_pol_div ; auto.
Qed.
Definition makeCuttingPlane (p : PolC Z) : PolC  Z * Z :=
  let (g,c) := Zgcd_pol p in
    if Z.gtb g Z0
      then (Zdiv_pol (PsubC Z.sub p c) g , Z.opp (ceiling (Z.opp c) g))
      else (p,Z0).
Definition genCuttingPlane (f : NFormula Z) : option (PolC Z * Z * Op1) :=
  let (e,op) := f in
    match op with
      | Equal =&gt; let (g,c) := Zgcd_pol e in
        if andb (Z.gtb g Z0) (andb (negb (Z.eqb c Z0)) (negb (Z.eqb (Z.gcd g c) g)))
          then None (* inconsistent
          else (* Could be optimised Zgcd_pol is recomputed
            let (p,c) := makeCuttingPlane e  in
              Some (p,c,Equal)
      | NonEqual =&gt; Some (e,Z0,op)
      | Strict   =&gt;  let (p,c) := makeCuttingPlane (PsubC Z.sub e 1) in
        Some (p,c,NonStrict)
      | NonStrict =&gt; let (p,c) := makeCuttingPlane e  in
        Some (p,c,NonStrict)
    end.
Definition nformula_of_cutting_plane (t : PolC Z * Z * Op1) : NFormula Z :=
  let (e_z, o) := t in
    let (e,z) := e_z in
      (padd e (Pc z) , o).
Definition is_pol_Z0 (p : PolC Z) : bool :=
  match p with
    | Pc Z0 =&gt; true
    |   _   =&gt; false
  end.
Lemma is_pol_Z0_eval_pol : forall p, is_pol_Z0 p = true -&gt; forall env, eval_pol env p = 0.
Proof.
  unfold is_pol_Z0.
  intros p; destruct p as [z| |]; try discriminate.
  destruct z ; try discriminate.
  reflexivity.
Qed.
Definition eval_Psatz  : list (NFormula Z) -&gt; ZWitness -&gt;  option (NFormula Z) :=
  eval_Psatz 0 1 Z.add Z.mul Z.eqb Z.leb.
Definition valid_cut_sign (op:Op1) :=
  match op with
    | Equal =&gt; true
    | NonStrict =&gt; true
    | _         =&gt; false
  end.
Definition bound_var (v : positive) : Formula Z :=
  Build_Formula (PEX v) OpGe (PEc 0).
Definition mk_eq_pos (x : positive) (y:positive) (t : positive) : Formula Z :=
  Build_Formula (PEX x) OpEq (PEsub (PEX y) (PEX t)).
Fixpoint vars (jmp : positive) (p : Pol Z) : list positive :=
  match p with
  | Pc c =&gt; nil
  | Pinj j p =&gt; vars (Pos.add j jmp) p
  | PX p j q =&gt; jmp::(vars jmp p)++vars (Pos.succ jmp) q
  end.
Fixpoint max_var (jmp : positive) (p : Pol Z) : positive :=
  match p with
  | Pc _ =&gt; jmp
  | Pinj j p =&gt; max_var (Pos.add j jmp) p
  | PX p j q =&gt; Pos.max (max_var jmp p) (max_var (Pos.succ jmp) q)
  end.
Lemma pos_le_add : forall y x,
    (x &lt;= y + x)%positive.
Proof.
  intros y x.
  assert  ((Z.pos x) &lt;= Z.pos (x + y))%Z as H.
  - rewrite &lt;- (Z.add_0_r (Zpos x)).
    rewrite &lt;- Pos2Z.add_pos_pos.
    apply Z.add_le_mono_l.
    compute. congruence.
  - rewrite Pos.add_comm in H.
    apply H.
Qed.
Lemma max_var_le : forall p v,
    (v &lt;= max_var v p)%positive.
Proof.
  intros p; induction p as [?|p ? IHp|? IHp1 ? ? IHp2]; simpl.
  - intros.
    apply Pos.le_refl.
  - intros v.
    specialize (IHp (p+v)%positive).
    eapply Pos.le_trans ; eauto.
    assert (xH + v &lt;= p + v)%positive.
    { apply Pos.add_le_mono.
      - apply Pos.le_1_l.
      - apply Pos.le_refl.
    }
    eapply Pos.le_trans ; eauto.
    apply pos_le_add.
  - intros v.
    apply Pos.max_case_strong;intros ; auto.
    specialize (IHp2 (Pos.succ v)%positive).
    eapply Pos.le_trans ; eauto.
Qed.
Lemma max_var_correct : forall p j v,
    In v (vars j p) -&gt; Pos.le v (max_var j p).
Proof.
  intros p; induction p; simpl.
  - tauto.
  - auto.
  - intros j v H.
    rewrite in_app_iff in H.
    destruct H as [H |[ H | H]].
    + subst.
      apply Pos.max_case_strong;intros ; auto.
      * apply max_var_le.
      * eapply Pos.le_trans ; eauto.
        apply max_var_le.
    + apply Pos.max_case_strong;intros ; auto.
      eapply Pos.le_trans ; eauto.
    + apply Pos.max_case_strong;intros ; auto.
      eapply Pos.le_trans ; eauto.
Qed.
Definition max_var_nformulae (l : list (NFormula Z)) :=
  List.fold_left  (fun acc f =&gt; Pos.max acc (max_var xH (fst f))) l xH.
Section MaxVar.
  Definition F (acc : positive) (f : Pol Z * Op1) := Pos.max acc (max_var 1 (fst f)).
  Lemma max_var_nformulae_mono_aux :
    forall l v acc,
      (v &lt;= acc -&gt;
       v &lt;= fold_left F l acc)%positive.
  Proof.
    intros l; induction l as [|a l IHl] ; simpl ; [easy|].
    intros.
    apply IHl.
    unfold F.
    apply Pos.max_case_strong;intros ; auto.
    eapply Pos.le_trans ; eauto.
  Qed.
  Lemma max_var_nformulae_mono_aux' :
    forall l acc acc',
      (acc &lt;= acc' -&gt;
       fold_left F l acc &lt;= fold_left F l acc')%positive.
  Proof.
    intros l; induction l as [|a l IHl]; simpl ; [easy|].
    intros.
    apply IHl.
    unfold F.
    apply Pos.max_le_compat_r; auto.
  Qed.
  Lemma max_var_nformulae_correct_aux : forall l p o v,
      In (p,o) l -&gt; In v (vars xH p) -&gt; Pos.le v (fold_left F l 1)%positive.
  Proof.
  intros l p o v H H0.
  generalize 1%positive as acc.
  revert p o v H H0.
  induction l as [|a l IHl].
  - simpl. tauto.
  - simpl.
    intros p o v H H0 ?.
    destruct H ; subst.
    + unfold F at 2.
      simpl.
      apply max_var_correct in H0.
      apply max_var_nformulae_mono_aux.
      apply Pos.max_case_strong;intros ; auto.
      eapply Pos.le_trans ; eauto.
    + eapply IHl ; eauto.
  Qed.
End MaxVar.
Lemma max_var_nformalae_correct : forall l p o v,
      In (p,o) l -&gt; In v (vars xH p) -&gt; Pos.le v (max_var_nformulae l)%positive.
Proof.
  intros l p o v.
  apply max_var_nformulae_correct_aux.
Qed.
Fixpoint max_var_psatz (w : Psatz Z) : positive :=
  match w with
  | PsatzIn _ n =&gt; xH
  | PsatzSquare p =&gt; max_var xH (Psquare 0 1 Z.add Z.mul Z.eqb p)
  | PsatzMulC p w =&gt; Pos.max (max_var xH p) (max_var_psatz w)
  | PsatzMulE w1 w2 =&gt; Pos.max (max_var_psatz w1) (max_var_psatz w2)
  | PsatzAdd w1 w2  =&gt; Pos.max (max_var_psatz w1) (max_var_psatz w2)
  | _   =&gt; xH
  end.
Fixpoint max_var_prf (w : ZArithProof) : positive :=
  match w with
  | DoneProof =&gt; xH
  | RatProof w pf | CutProof w pf =&gt; Pos.max (max_var_psatz w) (max_var_prf pf)
  | SplitProof p pf1 pf2 =&gt; Pos.max (max_var xH p) (Pos.max (max_var_prf pf1) (max_var_prf pf1))
  | EnumProof w1 w2 l =&gt; List.fold_left
                           (fun acc prf =&gt; Pos.max acc (max_var_prf prf)) l
                           (Pos.max (max_var_psatz w1) (max_var_psatz w2))
  | ExProof _ pf =&gt; max_var_prf pf
  end.
Fixpoint ZChecker  (l:list (NFormula Z)) (pf : ZArithProof)  {struct pf} : bool :=
  match pf with
    | DoneProof =&gt; false
    | RatProof w pf =&gt;
      match eval_Psatz l w  with
        | None =&gt; false
        | Some f =&gt;
          if Zunsat f then true
            else ZChecker (f::l) pf
      end
    | CutProof w pf =&gt;
      match eval_Psatz l w with
        | None =&gt; false
        | Some f =&gt;
          match genCuttingPlane f with
            | None =&gt; true
            | Some cp =&gt; ZChecker (nformula_of_cutting_plane cp::l) pf
          end
      end
    | SplitProof p pf1 pf2 =&gt;
      match genCuttingPlane (p,NonStrict) , genCuttingPlane (popp p, NonStrict) with
      | None , _ | _ , None =&gt; false
      | Some cp1 , Some cp2 =&gt;
        ZChecker (nformula_of_cutting_plane cp1::l) pf1
        &amp;&amp;
        ZChecker (nformula_of_cutting_plane cp2::l) pf2
      end
    | ExProof x prf =&gt;
      let fr := max_var_nformulae l in
      if Pos.leb x fr then
      let z    := Pos.succ fr in
      let t    := Pos.succ z in
      let nfx  := xnnormalise (mk_eq_pos x z t) in
      let posz := xnnormalise (bound_var z) in
      let post := xnnormalise (bound_var t) in
      ZChecker (nfx::posz::post::l) prf
      else false
      | EnumProof w1 w2 pf =&gt;
       match eval_Psatz l w1 , eval_Psatz l w2 with
         |  Some f1 , Some f2 =&gt;
           match genCuttingPlane f1 , genCuttingPlane f2 with
             |Some (e1,z1,op1) , Some (e2,z2,op2) =&gt;
               if (valid_cut_sign op1 &amp;&amp; valid_cut_sign op2 &amp;&amp; is_pol_Z0 (padd e1 e2))
                 then
                   (fix label (pfs:list ZArithProof) :=
                   fun lb ub =&gt;
                     match pfs with
                       | nil =&gt; if Z.gtb lb ub then true else false
                       | pf::rsr =&gt; andb (ZChecker ((psub e1 (Pc lb), Equal) :: l) pf) (label rsr (Z.add lb 1%Z) ub)
                     end)   pf (Z.opp z1)  z2
                  else false
              |   _    ,   _   =&gt; true
           end
          |   _   ,  _ =&gt; false
    end
end.
Fixpoint bdepth (pf : ZArithProof) : nat :=
  match pf with
    | DoneProof  =&gt; O
    | RatProof _ p =&gt;  S (bdepth p)
    | CutProof _  p =&gt;   S  (bdepth p)
    | SplitProof _ p1 p2 =&gt; S (Nat.max (bdepth p1) (bdepth p2))
    | EnumProof _ _ l =&gt; S (List.fold_right (fun pf x =&gt; Nat.max (bdepth pf) x)   O l)
    | ExProof _ p   =&gt; S (bdepth p)
  end.
From Stdlib Require Import PeanoNat Wf_nat.
Lemma in_bdepth : forall l a b  y, In y l -&gt;  ltof ZArithProof bdepth y (EnumProof a b  l).
Proof.
  intros l; induction l as [|a l IHl].
  - (* nil
    simpl.
    tauto.
  - (* cons
    simpl.
    intros a0 b y H.
    destruct H as [H|H].
    + subst.
      unfold ltof.
      simpl.
      generalize (         (fold_right
                              (fun (pf : ZArithProof) (x : nat) =&gt; Nat.max (bdepth pf) x) 0%nat l)).
      intros.
      generalize (bdepth y) ; intros.
      rewrite Nat.lt_succ_r. apply Nat.le_max_l.
    + generalize (IHl a0 b  y  H).
      unfold ltof.
      simpl.
      generalize (      (fold_right (fun (pf : ZArithProof) (x : nat) =&gt; Nat.max (bdepth pf) x) 0%nat
                                    l)).
      intros.
      eapply Nat.lt_le_trans.
      * eassumption.
      * rewrite &lt;- Nat.succ_le_mono.
        apply Nat.le_max_r.
Qed.
Lemma ltof_bdepth_split_l :
  forall p pf1 pf2,
         ltof ZArithProof bdepth pf1 (SplitProof p pf1 pf2).
Proof.
  intros.
  unfold ltof. simpl.
  rewrite Nat.lt_succ_r.
  apply Nat.le_max_l.
Qed.
Lemma ltof_bdepth_split_r :
  forall p pf1 pf2,
         ltof ZArithProof bdepth pf2 (SplitProof p pf1 pf2).
Proof.
  intros.
  unfold ltof. simpl.
  rewrite Nat.lt_succ_r.
  apply Nat.le_max_r.
Qed.
Lemma eval_Psatz_sound : forall env w l f',
  make_conj (eval_nformula env) l -&gt;
  eval_Psatz l w  = Some f' -&gt;  eval_nformula env f'.
Proof.
  intros env w l f' H H0.
  apply (fun H =&gt; eval_Psatz_Sound Zsor ZSORaddon l _ H w) ; auto.
  apply make_conj_in ; auto.
Qed.
Lemma makeCuttingPlane_ns_sound : forall env e e' c,
  eval_nformula env (e, NonStrict) -&gt;
  makeCuttingPlane e = (e',c) -&gt;
  eval_nformula env (nformula_of_cutting_plane (e', c, NonStrict)).
Proof.
  unfold nformula_of_cutting_plane.
  unfold eval_nformula. unfold RingMicromega.eval_nformula.
  unfold eval_op1.
  intros env e e' c H H0.
  rewrite (RingMicromega.eval_pol_add Zsor ZSORaddon).
  simpl.
  (*
  unfold makeCuttingPlane in H0.
  revert H0.
  case_eq (Zgcd_pol e) ; intros g c0.
  case Z.gtb_spec.
  - intros H0 H1 H2.
    inv H2.
    change (RingMicromega.eval_pol Z.add Z.mul (fun x : Z =&gt; x)) with eval_pol in *.
    apply (Zgcd_pol_correct_lt _ env) in H1. 2: auto using Z.gt_lt.
    apply Z.le_add_le_sub_l, Z.ge_le; rewrite Z.add_0_r.
    apply (narrow_interval_lower_bound g (- c0) (eval_pol env (Zdiv_pol (PsubC Z.sub e c0) g))); auto using Z.lt_gt.
    apply Z.le_ge.
    rewrite &lt;- Z.sub_0_l.
    apply Z.le_sub_le_add_r.
    rewrite &lt;- H1.
    assumption.
    (* g &lt;= 0
  - intros H0 H1 H2. inv H2. auto with zarith.
Qed.
Lemma cutting_plane_sound : forall env f p,
  eval_nformula env f -&gt;
  genCuttingPlane f = Some p -&gt;
   eval_nformula env (nformula_of_cutting_plane p).
Proof.
  unfold genCuttingPlane.
  intros env f; destruct f as [e op].
  destruct op.
  - (* Equal
    intros p; destruct p as [[e' z] op].
    case_eq (Zgcd_pol e) ; intros g c.
    case_eq (Z.gtb g 0 &amp;&amp; (negb (Z.eqb c 0) &amp;&amp; negb (Z.eqb (Z.gcd g c) g))) ; [discriminate|].
    case_eq (makeCuttingPlane e).
    intros ? ? H H0 H1 H2 H3.
    inv H3.
    unfold makeCuttingPlane in H.
    rewrite H1 in H.
    revert H.
    change (eval_pol env e = 0) in H2.
    case_eq (Z.gtb g 0).
    + intros H H3.
      rewrite Z.gtb_lt in H.
      rewrite Zgcd_pol_correct_lt with (1:= H1)  in H2. 2: auto using Z.gt_lt.
      unfold nformula_of_cutting_plane.
      change (eval_pol env (padd e' (Pc z)) = 0).
      inv H3.
      rewrite eval_pol_add.
      set (x:=eval_pol env (Zdiv_pol (PsubC Z.sub e c) g)) in *; clearbody x.
      simpl.
      rewrite andb_false_iff in H0.
      destruct H0 as [H0|H0].
      * rewrite &lt;-Z.gtb_lt in H ; congruence.
      * rewrite andb_false_iff in H0.
        destruct H0 as [H0|H0].
        -- rewrite negb_false_iff in H0.
           apply Z.eqb_eq in H0.
           subst. simpl.
           rewrite Z.add_0_r, Z.mul_eq_0 in H2.
           intuition subst; easy.
        -- rewrite negb_false_iff in H0.
           apply Z.eqb_eq in H0.
           rewrite Zdivide_ceiling; cycle 1.
           { apply Z.divide_opp_r. rewrite &lt;-H0. apply Z.gcd_divide_r. }
           apply Z.sub_move_0_r.
           apply Z.div_unique_exact.
           ++ now intros -&gt;.
           ++ now rewrite Z.add_move_0_r in H2.
    + intros H H3.
      unfold nformula_of_cutting_plane.
      inv H3.
      change (eval_pol env (padd e' (Pc 0)) = 0).
      rewrite eval_pol_add.
      simpl.
      now rewrite Z.add_0_r.
  - (* NonEqual
    intros ? H H0.
    inv H0.
    unfold eval_nformula in *.
    unfold RingMicromega.eval_nformula in *.
    unfold nformula_of_cutting_plane.
    unfold eval_op1 in *.
    rewrite (RingMicromega.eval_pol_add Zsor ZSORaddon).
    simpl. now rewrite Z.add_0_r.
  - (* Strict
    intros p; destruct p as [[e' z] op].
    case_eq (makeCuttingPlane (PsubC Z.sub e 1)).
    intros ? ? H H0 H1.
    inv H1.
    apply (makeCuttingPlane_ns_sound env) with (2:= H).
    simpl in *.
    rewrite (RingMicromega.PsubC_ok Zsor ZSORaddon).
    now apply Z.lt_le_pred.
  - (* NonStrict
    intros p; destruct p as [[e' z] op].
    case_eq (makeCuttingPlane e).
    intros ? ? H H0 H1.
    inv H1.
    apply (makeCuttingPlane_ns_sound env) with (2:= H).
    assumption.
Qed.
Lemma  genCuttingPlaneNone : forall env f,
  genCuttingPlane f = None -&gt;
  eval_nformula env f -&gt; False.
Proof.
  unfold genCuttingPlane.
  intros env f; destruct f as [p o].
  destruct o.
  - case_eq (Zgcd_pol p) ; intros g c.
    case_eq (Z.gtb g 0 &amp;&amp; (negb (Z.eqb c 0) &amp;&amp; negb (Z.eqb (Z.gcd g c) g))).
    + intros H H0 H1 H2.
      flatten_bool.
      match goal with [ H' : (g &gt;? 0) = true |- ?G ] =&gt; rename H' into H3 end.
      match goal with [ H' : negb (Z.eqb c 0) = true |- ?G ] =&gt; rename H' into H end.
      match goal with [ H' : negb (Z.eqb (Z.gcd g c) g) = true |- ?G ] =&gt; rename H' into H5 end.
      rewrite negb_true_iff in H5.
      apply Z.eqb_neq in H5.
      rewrite Z.gtb_lt in H3.
      rewrite negb_true_iff in H.
      apply Z.eqb_neq in H.
      change (eval_pol env p = 0) in H2.
      rewrite Zgcd_pol_correct_lt with (1:= H0) in H2. 2: auto using Z.gt_lt.
      set (x:=eval_pol env (Zdiv_pol (PsubC Z.sub p c) g)) in *; clearbody x.
      contradict H5.
      apply Zis_gcd_gcd.
      * apply Z.lt_le_incl; assumption.
      * constructor; auto with zarith.
        exists (-x).
        rewrite Z.mul_opp_l, Z.mul_comm.
        now apply Z.add_move_0_l.
        (*
    + destruct (makeCuttingPlane p);  discriminate.
  - discriminate.
  - destruct (makeCuttingPlane (PsubC Z.sub p 1)) ; discriminate.
  - destruct (makeCuttingPlane p) ; discriminate.
Qed.
Lemma eval_nformula_mk_eq_pos : forall env x z t,
    env x = env z - env t -&gt;
    eval_nformula env (xnnormalise (mk_eq_pos x z t)).
Proof.
  intros.
  rewrite xnnormalise_correct.
  simpl. auto.
Qed.
Lemma eval_nformula_bound_var : forall env x,
    env x &gt;= 0 -&gt;
    eval_nformula env (xnnormalise (bound_var x)).
Proof.
  intros.
  rewrite xnnormalise_correct.
  simpl. auto.
Qed.
Definition agree_env (fr : positive) (env env' : positive -&gt; Z) : Prop :=
  forall x, Pos.le x fr -&gt; env x = env' x.
Lemma agree_env_subset : forall v1 v2 env env',
    agree_env v1 env env' -&gt;
    Pos.le v2 v1 -&gt;
    agree_env v2 env env'.
Proof.
  unfold agree_env.
  intros v1 v2 env env' H ? ? ?.
  apply H.
  eapply Pos.le_trans ; eauto.
Qed.
Lemma agree_env_jump : forall fr j env env',
    agree_env (fr + j) env env' -&gt;
    agree_env fr (Env.jump j env) (Env.jump j env').
Proof.
  intros fr j env env' H.
  unfold agree_env ; intro.
  intros.
  unfold Env.jump.
  apply H.
  apply Pos.add_le_mono_r; auto.
Qed.
Lemma agree_env_tail : forall fr env env',
    agree_env (Pos.succ fr) env env' -&gt;
    agree_env fr (Env.tail env) (Env.tail env').
Proof.
  intros fr env env' H.
  unfold Env.tail.
  apply agree_env_jump.
  rewrite &lt;- Pos.add_1_r in H.
  apply H.
Qed.
Lemma max_var_acc : forall p i j,
    (max_var (i + j) p = max_var i p + j)%positive.
Proof.
  intros p; induction p as [|? ? IHp|? IHp1 ? ? IHp2]; simpl.
  - reflexivity.
  - intros.
    rewrite ! IHp.
    rewrite Pos.add_assoc.
    reflexivity.
  - intros.
    rewrite !Pplus_one_succ_l.
    rewrite ! IHp1.
    rewrite ! IHp2.
    rewrite ! Pos.add_assoc.
    rewrite &lt;- Pos.add_max_distr_r.
    reflexivity.
Qed.
Lemma agree_env_eval_nformula :
  forall env env' e
         (AGREE : agree_env (max_var xH (fst e))  env env'),
    eval_nformula env e  &lt;-&gt;  eval_nformula env' e.
Proof.
  intros env env' e; destruct e as [p o].
  simpl; intros AGREE.
  assert ((RingMicromega.eval_pol Z.add Z.mul (fun x : Z =&gt; x) env p)
          =
          (RingMicromega.eval_pol Z.add Z.mul (fun x : Z =&gt; x) env' p)) as H.
  {
    revert env env' AGREE.
    generalize xH.
    induction p as [?|p ? IHp|? IHp1 ? ? IHp2]; simpl.
    - reflexivity.
    - intros p1 **.
      apply (IHp p1).
      apply agree_env_jump.
      eapply agree_env_subset; eauto.
      rewrite (Pos.add_comm p).
      rewrite max_var_acc.
      apply Pos.le_refl.
      - intros p ? ? AGREE.
        f_equal;[f_equal|].
        + apply (IHp1 p).
          eapply agree_env_subset; eauto.
          apply Pos.le_max_l.
        + f_equal.
          unfold Env.hd.
          unfold Env.nth.
          apply AGREE.
          apply Pos.le_1_l.
        + apply (IHp2 p).
          apply agree_env_tail.
          eapply agree_env_subset; eauto.
          rewrite !Pplus_one_succ_r.
          rewrite max_var_acc.
          apply Pos.le_max_r.
  }
  rewrite H. tauto.
Qed.
Lemma agree_env_eval_nformulae :
  forall env env' l
         (AGREE : agree_env (max_var_nformulae l) env env'),
         make_conj (eval_nformula env) l &lt;-&gt;
         make_conj (eval_nformula env') l.
Proof.
  intros env env' l; induction l as [|a l IHl].
  - simpl. tauto.
  - intros.
    rewrite ! make_conj_cons.
    assert (eval_nformula env a &lt;-&gt; eval_nformula env' a) as H.
    {
      apply agree_env_eval_nformula.
      eapply agree_env_subset ; eauto.
      unfold max_var_nformulae.
      simpl.
      rewrite Pos.max_1_l.
      apply max_var_nformulae_mono_aux.
      apply Pos.le_refl.
    }
    rewrite H.
    apply  and_iff_compat_l.
    apply IHl.
    eapply agree_env_subset ; eauto.
    unfold max_var_nformulae.
    simpl.
    apply max_var_nformulae_mono_aux'.
    apply Pos.le_1_l.
Qed.
Lemma eq_true_iff_eq :
  forall b1 b2 : bool, (b1 = true &lt;-&gt; b2 = true) &lt;-&gt; b1 = b2.
Proof.
  intros b1 b2; destruct b1,b2 ; intuition congruence.
Qed.
Lemma eval_nformula_split : forall env p,
    eval_nformula env (p,NonStrict) \/ eval_nformula env (popp p,NonStrict).
Proof.
  unfold popp.
  simpl. intros. rewrite (eval_pol_opp Zsor ZSORaddon).
  rewrite Z.opp_nonneg_nonpos.
  apply Z.le_ge_cases.
Qed.
Lemma ZChecker_sound : forall w l,
    ZChecker l w = true -&gt; forall env, make_impl  (eval_nformula env)  l False.
Proof.
  intros w; induction w as [w H] using (well_founded_ind (well_founded_ltof _ bdepth)).
  destruct w as [ | w pf | w pf | p pf1 pf2 | w1 w2 pf | x pf].
  - (* DoneProof
  simpl. discriminate.
  - (* RatProof
  simpl.
  intros l. case_eq (eval_Psatz l w) ; [| discriminate].
  intros f Hf.
  case_eq (Zunsat f).
  + intros H0 ? ?.
  apply (checker_nf_sound Zsor ZSORaddon l w).
  unfold check_normalised_formulas.  unfold eval_Psatz in Hf. rewrite Hf.
  unfold Zunsat in H0. assumption.
  + intros H0 H1 env.
    assert (make_impl  (eval_nformula env) (f::l) False) as H2.
    { apply H with (2:= H1).
      unfold ltof.
      simpl.
      auto with arith.
    }
    destruct f.
    rewrite &lt;- make_conj_impl in H2.
    rewrite make_conj_cons in H2.
    rewrite &lt;- make_conj_impl.
    intro.
    apply H2.
    split ; auto.
    apply eval_Psatz_sound with (2:= Hf) ; assumption.
  - (* CutProof
    simpl.
    intros l.
    case_eq (eval_Psatz l w) ; [ | discriminate].
    intros f' Hlc.
    case_eq (genCuttingPlane f').
    + intros p H0 H1 env.
      assert (make_impl (eval_nformula env) (nformula_of_cutting_plane p::l) False) as H2.
      { eapply (H pf)  ; auto.
        unfold ltof.
        simpl.
        auto with arith.
      }
      rewrite &lt;- make_conj_impl in H2.
      rewrite make_conj_cons in H2.
      rewrite &lt;- make_conj_impl.
      intro.
      apply H2.
      split ; auto.
      apply (eval_Psatz_sound env) in Hlc.
      * apply cutting_plane_sound with (1:= Hlc) (2:= H0).
      * auto.
    + (* genCuttingPlane = None
      intros H0 H1 env.
      rewrite &lt;- make_conj_impl.
      intros H2.
      apply eval_Psatz_sound with (2:= Hlc) in H2.
      apply genCuttingPlaneNone with (2:= H2) ; auto.
  - (* SplitProof
    intros l.
    cbn - [genCuttingPlane].
    case_eq (genCuttingPlane (p, NonStrict)) ; [| discriminate].
    case_eq (genCuttingPlane (popp p, NonStrict)) ; [| discriminate].
    intros cp1 GCP1 cp2 GCP2 ZC1 env.
    flatten_bool.
    match goal with [ H' : ZChecker _ pf1 = true |- _ ] =&gt; rename H' into H0 end.
    match goal with [ H' : ZChecker _ pf2 = true |- _ ] =&gt; rename H' into H1 end.
    destruct (eval_nformula_split env p).
    + apply (fun H' ck =&gt; H _ H' _ ck env) in H0.
      * rewrite &lt;- make_conj_impl in *.
        intro ; apply H0.
        rewrite make_conj_cons. split; auto.
        apply (cutting_plane_sound _ (p,NonStrict)) ; auto.
      * apply ltof_bdepth_split_l.
    + apply (fun H' ck =&gt; H _ H' _ ck env) in H1.
      * rewrite &lt;- make_conj_impl in *.
        intro ; apply H1.
        rewrite make_conj_cons. split; auto.
        apply (cutting_plane_sound _ (popp p,NonStrict)) ; auto.
      * apply ltof_bdepth_split_r.
  - (* EnumProof
    intros l.
    simpl.
    case_eq (eval_Psatz l w1) ; [  | discriminate].
    case_eq (eval_Psatz l w2) ; [  | discriminate].
    intros f1 Hf1 f2 Hf2.
    case_eq (genCuttingPlane f2).
    + intros p; destruct p as [ [p1 z1] op1].
      case_eq (genCuttingPlane f1).
      * intros p; destruct p as [ [p2 z2] op2].
        case_eq (valid_cut_sign op1 &amp;&amp; valid_cut_sign op2 &amp;&amp; is_pol_Z0 (padd p1 p2)).
        -- intros Hcond.
           flatten_bool.
           match goal with [ H1 : is_pol_Z0 (padd p1 p2) = true |- _ ] =&gt; rename H1 into HZ0 end.
           match goal with [ H2 : valid_cut_sign op1 = true |- _ ] =&gt; rename H2 into Hop1 end.
           match goal with [ H3 : valid_cut_sign op2 = true |- _ ] =&gt; rename H3 into Hop2 end.
           intros HCutL HCutR Hfix env.
           (* get the bounds of the enum
           rewrite &lt;- make_conj_impl.
           intro H0.
           assert (-z1 &lt;= eval_pol env p1 &lt;= z2) as H1. {
             split.
             - apply  (eval_Psatz_sound env) in Hf2 ; auto.
               apply cutting_plane_sound with (1:= Hf2) in HCutR.
               unfold nformula_of_cutting_plane in HCutR.
               unfold eval_nformula in HCutR.
               unfold RingMicromega.eval_nformula in HCutR.
               change (RingMicromega.eval_pol Z.add Z.mul (fun x : Z =&gt; x)) with eval_pol in HCutR.
               unfold eval_op1 in HCutR.
               destruct op1 ; simpl in Hop1 ; try discriminate;
                 rewrite eval_pol_add in HCutR; simpl in HCutR.
               + rewrite Z.add_move_0_l in HCutR; rewrite HCutR, Z.opp_involutive; reflexivity.
               + now apply Z.le_sub_le_add_r in HCutR.
               (*
             - apply (fun H =&gt; is_pol_Z0_eval_pol _ H env) in HZ0.
               rewrite eval_pol_add, Z.add_move_r, Z.sub_0_l in HZ0.
               rewrite HZ0.
               apply  (eval_Psatz_sound env) in Hf1 ; auto.
               apply cutting_plane_sound with (1:= Hf1) in HCutL.
               unfold nformula_of_cutting_plane in HCutL.
               unfold eval_nformula in HCutL.
               unfold RingMicromega.eval_nformula in HCutL.
               change (RingMicromega.eval_pol Z.add Z.mul (fun x : Z =&gt; x)) with eval_pol in HCutL.
               unfold eval_op1 in HCutL.
               rewrite eval_pol_add in HCutL. simpl in HCutL.
               destruct op2 ; simpl in Hop2 ; try discriminate.
               + rewrite Z.add_move_r, Z.sub_0_l in HCutL.
                 now rewrite HCutL, Z.opp_involutive.
               + now rewrite &lt;- Z.le_sub_le_add_l in HCutL.
           }
           revert Hfix.
           match goal with
           | |- context[?F pf (-z1) z2 = true] =&gt; set (FF := F)
           end.
           intros Hfix.
           assert (HH :forall x, -z1 &lt;= x &lt;= z2 -&gt; exists pr,
                        (In pr pf /\
                           ZChecker ((PsubC Z.sub p1 x,Equal) :: l) pr = true)%Z). {
             clear HZ0 Hop1 Hop2 HCutL HCutR H0 H1.
             revert Hfix.
             generalize (-z1). clear z1. intro z1.
             revert z1 z2.
             induction pf as [|a pf IHpf];simpl ;intros z1 z2 Hfix x **.
             - revert Hfix.
               now case (Z.gtb_spec); [ | easy ]; intros LT; elim (Zorder.Zlt_not_le _ _ LT); transitivity x.
             - flatten_bool.
               match goal with [ H' : _ &lt;= x &lt;= _ |- _ ] =&gt; rename H' into H0 end.
               match goal with [ H' : FF pf (z1 + 1) z2 = true |- _ ] =&gt; rename H' into H2 end.
               destruct (ZArith_dec.Z_le_lt_eq_dec _ _ (proj1 H0)) as [ LT | -&gt; ].
               2: exists a; auto.
               rewrite &lt;- Z.le_succ_l in LT.
               assert (LE: (Z.succ z1 &lt;= x &lt;= z2)%Z) by intuition.
               elim IHpf with (2:=H2) (3:= LE).
               + intros x0 ?.
                 exists x0 ; split;tauto.
               + intros until 1.
                 apply H ; auto.
                 cbv [ltof] in *.
                 cbn [bdepth] in *.
                 eauto using Nat.lt_le_trans, le_n_S, Nat.le_max_r.
           }
           (*/asser
           destruct (HH _ H1) as [pr [Hin Hcheker]].
           assert (make_impl (eval_nformula env) ((PsubC Z.sub p1 (eval_pol env p1),Equal) :: l) False) as H2. {
             eapply (H pr)  ;auto.
             apply in_bdepth ; auto.
           }
           rewrite &lt;- make_conj_impl in H2.
           apply H2.
           rewrite  make_conj_cons.
           split ;auto.
           unfold  eval_nformula.
           unfold RingMicromega.eval_nformula.
           simpl.
           rewrite (RingMicromega.PsubC_ok Zsor ZSORaddon).
           unfold eval_pol. ring.
        -- discriminate.
      * (* No cutting plane
        intros H0 H1 H2 env.
        rewrite &lt;- make_conj_impl.
        intros H3.
        apply eval_Psatz_sound with (2:= Hf1) in H3.
        apply genCuttingPlaneNone with (2:= H3) ; auto.
    + (* No Cutting plane (bis)
      intros H0 H1 env.
      rewrite &lt;- make_conj_impl.
      intros H2.
      apply eval_Psatz_sound with (2:= Hf2) in H2.
      apply genCuttingPlaneNone with (2:= H2) ; auto.
  - intros l.
    unfold ZChecker.
    fold ZChecker.
    set (fr := (max_var_nformulae l)%positive).
    set (z1 := (Pos.succ fr)) in *.
    set (t1 := (Pos.succ z1)) in *.
    destruct (x &lt;=? fr)%positive eqn:LE ; [|congruence].
    intros H0 env.
    set (env':= fun v =&gt; if Pos.eqb v z1
                      then if Z.leb (env x) 0 then 0 else env x
                      else if Pos.eqb v t1
                           then if Z.leb (env x) 0 then -(env x) else 0
                           else env v).
    apply (fun H' ck =&gt; H _ H' _ ck env') in H0.
    + rewrite &lt;- make_conj_impl in *.
      intro H1.
      rewrite !make_conj_cons in H0.
      apply H0 ; repeat split.
      *
        apply eval_nformula_mk_eq_pos.
        unfold env'.
        rewrite! Pos.eqb_refl.
        replace (x=?z1)%positive with false.
        1:replace (x=?t1)%positive with false.
        1:replace (t1=?z1)%positive with false.
        1:destruct (env x &lt;=? 0); ring.
        { unfold t1.
          symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; symmetry; apply Pos.succ_discr.
        }
        {
          unfold t1, z1.
          symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; intros -&gt;.
          apply Pos.leb_le, Pos.lt_succ_r in LE; rewrite &lt;-?Pos.succ_lt_mono in *.
          pose proof Pos.lt_not_add_l fr 1; rewrite Pos.add_1_r in *; contradiction.
        }
        {
          unfold z1.
          symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; intros -&gt;.
          apply Pos.leb_le, Pos.lt_succ_r in LE; rewrite &lt;-?Pos.succ_lt_mono in *.
          case (Pos.lt_irrefl _ LE).
        }
      *
        apply eval_nformula_bound_var.
        unfold env'.
        rewrite! Pos.eqb_refl.
        destruct (env x &lt;=? 0) eqn:EQ.
        -- compute. congruence.
        -- rewrite Z.leb_gt in EQ.
           apply Z.ge_le_iff, Z.lt_le_incl; trivial.
      *
        apply eval_nformula_bound_var.
        unfold env'.
        rewrite! Pos.eqb_refl.
        replace (t1 =? z1)%positive with false.
        -- destruct (env x &lt;=? 0) eqn:EQ.
           ++ rewrite Z.leb_le in EQ.
              apply Z.ge_le_iff. rewrite Z.opp_le_mono, Z.opp_involutive; trivial.
           ++ compute; congruence.
        -- unfold t1.
           clear.
           symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; symmetry; apply Pos.succ_discr.
      *
        rewrite (agree_env_eval_nformulae _ env') in H1;auto.
        unfold agree_env; intros x0 H2.
        unfold env'.
        replace (x0 =? z1)%positive with false.
        1:replace (x0 =? t1)%positive with false.
        1:reflexivity.
        {
          unfold t1, z1.
          symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; intros -&gt;.
          apply Pos.lt_succ_r in H2; rewrite &lt;-?Pos.succ_lt_mono in *.
          pose proof Pos.lt_not_add_l (max_var_nformulae l) 1; rewrite Pos.add_1_r in *; contradiction.
        }
        {
          unfold z1, fr in *.
          symmetry; apply not_true_iff_false; rewrite Pos.eqb_eq; intros -&gt;.
          apply Pos.lt_succ_r in H2; rewrite &lt;-?Pos.succ_lt_mono in *.
          case (Pos.lt_irrefl _ H2).
        }
    + unfold ltof.
      simpl.
      apply Nat.lt_succ_diag_r.
Qed.
Definition ZTautoChecker  (f : BFormula (Formula Z) Tauto.isProp) (w: list ZArithProof): bool :=
  @tauto_checker (Formula Z) (NFormula Z) unit Zunsat Zdeduce normalise negate  ZArithProof (fun cl =&gt; ZChecker (List.map fst cl)) f w.
Lemma ZTautoChecker_sound : forall f w, ZTautoChecker f w = true -&gt; forall env, eval_bf  (Zeval_formula env)  f.
Proof.
  intros f w.
  unfold ZTautoChecker.
  apply (tauto_checker_sound _ _ _ _ eval_nformula).
  - apply Zeval_nformula_dec.
  - intros t ? env.
  unfold eval_nformula. unfold RingMicromega.eval_nformula.
  destruct t.
  apply (check_inconsistent_sound Zsor ZSORaddon) ; auto.
  - unfold Zdeduce. intros ? ? ? H **. revert H.
     apply (nformula_plus_nformula_correct Zsor ZSORaddon); auto.
  -
    intros ? ? ? ? H.
    rewrite normalise_correct  in H.
    rewrite Zeval_formula_compat; auto.
  -
    intros ? ? ? ? H.
    rewrite negate_correct in H ; auto.
    rewrite Tauto.hold_eNOT.
    rewrite Zeval_formula_compat; auto.
  - intros t w0.
    unfold eval_tt.
    intros H env.
    rewrite (make_impl_map (eval_nformula env)).
    + eapply ZChecker_sound; eauto.
    + tauto.
Qed.
Fixpoint xhyps_of_pt (base:nat) (acc : list nat) (pt:ZArithProof)  : list nat :=
  match pt with
    | DoneProof =&gt; acc
    | RatProof c pt =&gt; xhyps_of_pt (S base ) (xhyps_of_psatz base acc c) pt
    | CutProof c pt =&gt; xhyps_of_pt (S base ) (xhyps_of_psatz base acc c) pt
    | SplitProof p pt1 pt2 =&gt; xhyps_of_pt (S base) (xhyps_of_pt (S base) acc pt1) pt2
    | EnumProof c1 c2 l =&gt;
      let acc := xhyps_of_psatz base (xhyps_of_psatz base acc c2) c1 in
        List.fold_left (xhyps_of_pt (S base)) l acc
    | ExProof _ pt  =&gt;  xhyps_of_pt (S (S (S base ))) acc pt
  end.
Definition hyps_of_pt (pt : ZArithProof) : list nat := xhyps_of_pt 0 nil pt.
Open Scope Z_scope.
(** To ease bindings from ml code *
Definition make_impl := Refl.make_impl.
Definition make_conj := Refl.make_conj.
From Stdlib Require VarMap.
(*Definition varmap_type := VarMap.t Z.
Definition env := PolEnv Z.
Definition node := @VarMap.Branch Z.
Definition empty := @VarMap.Empty Z.
Definition leaf := @VarMap.Elt Z.
Definition coneMember := ZWitness.
Definition eval := eval_formula.
#[deprecated(note="Use [prod positive nat]", since="9.0")]
Definition prod_pos_nat := prod positive nat.
#[deprecated(use=Z.to_N, since="9.0")]
Notation n_of_Z := Z.to_N (only parsing).
</pre>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
