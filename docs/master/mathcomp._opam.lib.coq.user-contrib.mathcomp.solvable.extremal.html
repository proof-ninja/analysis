
<!DOCTYPE html>
<html>

<head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
<title>Module mathcomp._opam.lib.coq.user-contrib.mathcomp.solvable.extremal</title>
<meta name="description" content="Documentation of Coq module mathcomp._opam.lib.coq.user-contrib.mathcomp.solvable.extremal" />
<link  rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.css">
<script src="https://cdn.jsdelivr.net/npm/markdown-it/dist/markdown-it.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/katex/dist/katex.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/markdown-it-texmath/texmath.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/darkmode-js@1.5.7/lib/darkmode-js.min.js"></script>
<link href="rocqnavi.css" rel="stylesheet" type="text/css" />
<script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.3.1/jquery.min.js"></script>
<script type="text/javascript" src="rocqnavi.js"> </script>
</head>

<body onload="init()">

  <main>
    <div class="sidebar">
      <h2>Files</h2>
      <li><details id="Corelib"><summary>Corelib</summary>
          <ul>
          <li><details id="Corelib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Corelib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Corelib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Corelib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Corelib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Corelib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Corelib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Corelib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Corelib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Corelib.Classes.Init.html">Init</a></li>
<li><a href="Corelib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Corelib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Corelib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Corelib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Corelib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Corelib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Corelib.Compat.Coq820.html">Coq820</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Corelib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Corelib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Corelib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Corelib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Corelib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Corelib.Init.Byte.html">Byte</a></li>
<li><a href="Corelib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Corelib.Init.Decimal.html">Decimal</a></li>
<li><a href="Corelib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Corelib.Init.Logic.html">Logic</a></li>
<li><a href="Corelib.Init.Ltac.html">Ltac</a></li>
<li><a href="Corelib.Init.Nat.html">Nat</a></li>
<li><a href="Corelib.Init.Notations.html">Notations</a></li>
<li><a href="Corelib.Init.Number.html">Number</a></li>
<li><a href="Corelib.Init.Peano.html">Peano</a></li>
<li><a href="Corelib.Init.Prelude.html">Prelude</a></li>
<li><a href="Corelib.Init.Specif.html">Specif</a></li>
<li><a href="Corelib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Corelib.Init.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Init.Tauto.html">Tauto</a></li>
<li><a href="Corelib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Corelib.Lists.ListDef.html">ListDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Corelib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Corelib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Corelib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Corelib.Numbers.BinNums.html">BinNums</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Corelib.Program.Basics.html">Basics</a></li>
<li><a href="Corelib.Program.Tactics.html">Tactics</a></li>
<li><a href="Corelib.Program.Utils.html">Utils</a></li>
<li><a href="Corelib.Program.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Corelib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Corelib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Corelib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Corelib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Corelib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Corelib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Corelib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Corelib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Corelib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Corelib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Corelib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Corelib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Corelib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Corelib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Corelib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Corelib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="HB"><summary>HB</summary>
          <ul>
          <li><a href="HB.structures.html">structures</a></li>
          </ul>
          </details>
          </li>
<li><details id="Ltac2"><summary>Ltac2</summary>
          <ul>
          <li><details id="Ltac2.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Ltac2.Compat.Coq818.html">Coq818</a></li>
<li><a href="Ltac2.Compat.Coq819.html">Coq819</a></li>
          </ul>
          </details>
          </li>
<li><a href="Ltac2.Array.html">Array</a></li>
<li><a href="Ltac2.Bool.html">Bool</a></li>
<li><a href="Ltac2.Char.html">Char</a></li>
<li><a href="Ltac2.Constant.html">Constant</a></li>
<li><a href="Ltac2.Constr.html">Constr</a></li>
<li><a href="Ltac2.Constructor.html">Constructor</a></li>
<li><a href="Ltac2.Control.html">Control</a></li>
<li><a href="Ltac2.Env.html">Env</a></li>
<li><a href="Ltac2.Evar.html">Evar</a></li>
<li><a href="Ltac2.FMap.html">FMap</a></li>
<li><a href="Ltac2.FSet.html">FSet</a></li>
<li><a href="Ltac2.Float.html">Float</a></li>
<li><a href="Ltac2.Fresh.html">Fresh</a></li>
<li><a href="Ltac2.Ident.html">Ident</a></li>
<li><a href="Ltac2.Ind.html">Ind</a></li>
<li><a href="Ltac2.Init.html">Init</a></li>
<li><a href="Ltac2.Int.html">Int</a></li>
<li><a href="Ltac2.Lazy.html">Lazy</a></li>
<li><a href="Ltac2.List.html">List</a></li>
<li><a href="Ltac2.Ltac1.html">Ltac1</a></li>
<li><a href="Ltac2.Ltac2.html">Ltac2</a></li>
<li><a href="Ltac2.Message.html">Message</a></li>
<li><a href="Ltac2.Meta.html">Meta</a></li>
<li><a href="Ltac2.Notations.html">Notations</a></li>
<li><a href="Ltac2.Option.html">Option</a></li>
<li><a href="Ltac2.Pattern.html">Pattern</a></li>
<li><a href="Ltac2.Printf.html">Printf</a></li>
<li><a href="Ltac2.Proj.html">Proj</a></li>
<li><a href="Ltac2.Pstring.html">Pstring</a></li>
<li><a href="Ltac2.RedFlags.html">RedFlags</a></li>
<li><a href="Ltac2.Ref.html">Ref</a></li>
<li><a href="Ltac2.Std.html">Std</a></li>
<li><a href="Ltac2.String.html">String</a></li>
<li><a href="Ltac2.TransparentState.html">TransparentState</a></li>
<li><a href="Ltac2.Uint63.html">Uint63</a></li>
<li><a href="Ltac2.Unification.html">Unification</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib"><summary>Stdlib</summary>
          <ul>
          <li><details id="Stdlib.All"><summary>All</summary>
          <ul>
          <li><a href="Stdlib.All.All.html">All</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Arith"><summary>Arith</summary>
          <ul>
          <li><a href="Stdlib.Arith.Arith.html">Arith</a></li>
<li><a href="Stdlib.Arith.Arith_base.html">Arith_base</a></li>
<li><a href="Stdlib.Arith.Between.html">Between</a></li>
<li><a href="Stdlib.Arith.Bool_nat.html">Bool_nat</a></li>
<li><a href="Stdlib.Arith.Cantor.html">Cantor</a></li>
<li><a href="Stdlib.Arith.Compare.html">Compare</a></li>
<li><a href="Stdlib.Arith.Compare_dec.html">Compare_dec</a></li>
<li><a href="Stdlib.Arith.EqNat.html">EqNat</a></li>
<li><a href="Stdlib.Arith.Euclid.html">Euclid</a></li>
<li><a href="Stdlib.Arith.Factorial.html">Factorial</a></li>
<li><a href="Stdlib.Arith.PeanoNat.html">PeanoNat</a></li>
<li><a href="Stdlib.Arith.Peano_dec.html">Peano_dec</a></li>
<li><a href="Stdlib.Arith.Wf_nat.html">Wf_nat</a></li>
<li><a href="Stdlib.Arith.Zerob.html">Zerob</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Array"><summary>Array</summary>
          <ul>
          <li><a href="Stdlib.Array.ArrayAxioms.html">ArrayAxioms</a></li>
<li><a href="Stdlib.Array.PArray.html">PArray</a></li>
<li><a href="Stdlib.Array.PrimArray.html">PrimArray</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.BinNums"><summary>BinNums</summary>
          <ul>
          <li><a href="Stdlib.BinNums.IntDef.html">IntDef</a></li>
<li><a href="Stdlib.BinNums.NatDef.html">NatDef</a></li>
<li><a href="Stdlib.BinNums.PosDef.html">PosDef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Bool"><summary>Bool</summary>
          <ul>
          <li><a href="Stdlib.Bool.Bool.html">Bool</a></li>
<li><a href="Stdlib.Bool.BoolEq.html">BoolEq</a></li>
<li><a href="Stdlib.Bool.DecBool.html">DecBool</a></li>
<li><a href="Stdlib.Bool.IfProp.html">IfProp</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Classes"><summary>Classes</summary>
          <ul>
          <li><a href="Stdlib.Classes.CEquivalence.html">CEquivalence</a></li>
<li><a href="Stdlib.Classes.CMorphisms.html">CMorphisms</a></li>
<li><a href="Stdlib.Classes.CRelationClasses.html">CRelationClasses</a></li>
<li><a href="Stdlib.Classes.DecidableClass.html">DecidableClass</a></li>
<li><a href="Stdlib.Classes.EquivDec.html">EquivDec</a></li>
<li><a href="Stdlib.Classes.Equivalence.html">Equivalence</a></li>
<li><a href="Stdlib.Classes.Init.html">Init</a></li>
<li><a href="Stdlib.Classes.Morphisms.html">Morphisms</a></li>
<li><a href="Stdlib.Classes.Morphisms_Prop.html">Morphisms_Prop</a></li>
<li><a href="Stdlib.Classes.Morphisms_Relations.html">Morphisms_Relations</a></li>
<li><a href="Stdlib.Classes.RelationClasses.html">RelationClasses</a></li>
<li><a href="Stdlib.Classes.RelationPairs.html">RelationPairs</a></li>
<li><a href="Stdlib.Classes.SetoidClass.html">SetoidClass</a></li>
<li><a href="Stdlib.Classes.SetoidDec.html">SetoidDec</a></li>
<li><a href="Stdlib.Classes.SetoidTactics.html">SetoidTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Compat"><summary>Compat</summary>
          <ul>
          <li><a href="Stdlib.Compat.AdmitAxiom.html">AdmitAxiom</a></li>
<li><a href="Stdlib.Compat.Coq818.html">Coq818</a></li>
<li><a href="Stdlib.Compat.Coq819.html">Coq819</a></li>
<li><a href="Stdlib.Compat.Coq820.html">Coq820</a></li>
<li><a href="Stdlib.Compat.Stdlib818.html">Stdlib818</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.FSets"><summary>FSets</summary>
          <ul>
          <li><a href="Stdlib.FSets.FMapAVL.html">FMapAVL</a></li>
<li><a href="Stdlib.FSets.FMapFacts.html">FMapFacts</a></li>
<li><a href="Stdlib.FSets.FMapFullAVL.html">FMapFullAVL</a></li>
<li><a href="Stdlib.FSets.FMapInterface.html">FMapInterface</a></li>
<li><a href="Stdlib.FSets.FMapList.html">FMapList</a></li>
<li><a href="Stdlib.FSets.FMapPositive.html">FMapPositive</a></li>
<li><a href="Stdlib.FSets.FMapWeakList.html">FMapWeakList</a></li>
<li><a href="Stdlib.FSets.FMaps.html">FMaps</a></li>
<li><a href="Stdlib.FSets.FSetAVL.html">FSetAVL</a></li>
<li><a href="Stdlib.FSets.FSetBridge.html">FSetBridge</a></li>
<li><a href="Stdlib.FSets.FSetCompat.html">FSetCompat</a></li>
<li><a href="Stdlib.FSets.FSetDecide.html">FSetDecide</a></li>
<li><a href="Stdlib.FSets.FSetEqProperties.html">FSetEqProperties</a></li>
<li><a href="Stdlib.FSets.FSetFacts.html">FSetFacts</a></li>
<li><a href="Stdlib.FSets.FSetInterface.html">FSetInterface</a></li>
<li><a href="Stdlib.FSets.FSetList.html">FSetList</a></li>
<li><a href="Stdlib.FSets.FSetPositive.html">FSetPositive</a></li>
<li><a href="Stdlib.FSets.FSetProperties.html">FSetProperties</a></li>
<li><a href="Stdlib.FSets.FSetToFiniteSet.html">FSetToFiniteSet</a></li>
<li><a href="Stdlib.FSets.FSetWeakList.html">FSetWeakList</a></li>
<li><a href="Stdlib.FSets.FSets.html">FSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Floats"><summary>Floats</summary>
          <ul>
          <li><a href="Stdlib.Floats.FloatAxioms.html">FloatAxioms</a></li>
<li><a href="Stdlib.Floats.FloatClass.html">FloatClass</a></li>
<li><a href="Stdlib.Floats.FloatLemmas.html">FloatLemmas</a></li>
<li><a href="Stdlib.Floats.FloatOps.html">FloatOps</a></li>
<li><a href="Stdlib.Floats.Floats.html">Floats</a></li>
<li><a href="Stdlib.Floats.PrimFloat.html">PrimFloat</a></li>
<li><a href="Stdlib.Floats.SpecFloat.html">SpecFloat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Init"><summary>Init</summary>
          <ul>
          <li><a href="Stdlib.Init.Byte.html">Byte</a></li>
<li><a href="Stdlib.Init.Datatypes.html">Datatypes</a></li>
<li><a href="Stdlib.Init.Decimal.html">Decimal</a></li>
<li><a href="Stdlib.Init.Hexadecimal.html">Hexadecimal</a></li>
<li><a href="Stdlib.Init.Logic.html">Logic</a></li>
<li><a href="Stdlib.Init.Ltac.html">Ltac</a></li>
<li><a href="Stdlib.Init.Nat.html">Nat</a></li>
<li><a href="Stdlib.Init.Notations.html">Notations</a></li>
<li><a href="Stdlib.Init.Number.html">Number</a></li>
<li><a href="Stdlib.Init.Peano.html">Peano</a></li>
<li><a href="Stdlib.Init.Prelude.html">Prelude</a></li>
<li><a href="Stdlib.Init.Specif.html">Specif</a></li>
<li><a href="Stdlib.Init.Sumbool.html">Sumbool</a></li>
<li><a href="Stdlib.Init.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Init.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.Init.Wf.html">Wf</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Lists"><summary>Lists</summary>
          <ul>
          <li><a href="Stdlib.Lists.List.html">List</a></li>
<li><a href="Stdlib.Lists.ListDec.html">ListDec</a></li>
<li><a href="Stdlib.Lists.ListDef.html">ListDef</a></li>
<li><a href="Stdlib.Lists.ListSet.html">ListSet</a></li>
<li><a href="Stdlib.Lists.ListTactics.html">ListTactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Logic"><summary>Logic</summary>
          <ul>
          <li><a href="Stdlib.Logic.Adjointification.html">Adjointification</a></li>
<li><a href="Stdlib.Logic.Berardi.html">Berardi</a></li>
<li><a href="Stdlib.Logic.ChoiceFacts.html">ChoiceFacts</a></li>
<li><a href="Stdlib.Logic.Classical.html">Classical</a></li>
<li><a href="Stdlib.Logic.ClassicalChoice.html">ClassicalChoice</a></li>
<li><a href="Stdlib.Logic.ClassicalDescription.html">ClassicalDescription</a></li>
<li><a href="Stdlib.Logic.ClassicalEpsilon.html">ClassicalEpsilon</a></li>
<li><a href="Stdlib.Logic.ClassicalFacts.html">ClassicalFacts</a></li>
<li><a href="Stdlib.Logic.ClassicalUniqueChoice.html">ClassicalUniqueChoice</a></li>
<li><a href="Stdlib.Logic.Classical_Pred_Type.html">Classical_Pred_Type</a></li>
<li><a href="Stdlib.Logic.Classical_Prop.html">Classical_Prop</a></li>
<li><a href="Stdlib.Logic.ConstructiveEpsilon.html">ConstructiveEpsilon</a></li>
<li><a href="Stdlib.Logic.Decidable.html">Decidable</a></li>
<li><a href="Stdlib.Logic.Description.html">Description</a></li>
<li><a href="Stdlib.Logic.Diaconescu.html">Diaconescu</a></li>
<li><a href="Stdlib.Logic.Epsilon.html">Epsilon</a></li>
<li><a href="Stdlib.Logic.Eqdep.html">Eqdep</a></li>
<li><a href="Stdlib.Logic.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="Stdlib.Logic.Eqdep_dec.html">Eqdep_dec</a></li>
<li><a href="Stdlib.Logic.ExtensionalFunctionRepresentative.html">ExtensionalFunctionRepresentative</a></li>
<li><a href="Stdlib.Logic.ExtensionalityFacts.html">ExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.FunctionalExtensionality.html">FunctionalExtensionality</a></li>
<li><a href="Stdlib.Logic.HLevels.html">HLevels</a></li>
<li><a href="Stdlib.Logic.Hurkens.html">Hurkens</a></li>
<li><a href="Stdlib.Logic.IndefiniteDescription.html">IndefiniteDescription</a></li>
<li><a href="Stdlib.Logic.JMeq.html">JMeq</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevance.html">ProofIrrelevance</a></li>
<li><a href="Stdlib.Logic.ProofIrrelevanceFacts.html">ProofIrrelevanceFacts</a></li>
<li><a href="Stdlib.Logic.PropExtensionality.html">PropExtensionality</a></li>
<li><a href="Stdlib.Logic.PropExtensionalityFacts.html">PropExtensionalityFacts</a></li>
<li><a href="Stdlib.Logic.PropFacts.html">PropFacts</a></li>
<li><a href="Stdlib.Logic.RelationalChoice.html">RelationalChoice</a></li>
<li><a href="Stdlib.Logic.SetIsType.html">SetIsType</a></li>
<li><a href="Stdlib.Logic.SetoidChoice.html">SetoidChoice</a></li>
<li><a href="Stdlib.Logic.StrictProp.html">StrictProp</a></li>
<li><a href="Stdlib.Logic.WKL.html">WKL</a></li>
<li><a href="Stdlib.Logic.WeakFan.html">WeakFan</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.MSets"><summary>MSets</summary>
          <ul>
          <li><a href="Stdlib.MSets.MSetAVL.html">MSetAVL</a></li>
<li><a href="Stdlib.MSets.MSetDecide.html">MSetDecide</a></li>
<li><a href="Stdlib.MSets.MSetEqProperties.html">MSetEqProperties</a></li>
<li><a href="Stdlib.MSets.MSetFacts.html">MSetFacts</a></li>
<li><a href="Stdlib.MSets.MSetGenTree.html">MSetGenTree</a></li>
<li><a href="Stdlib.MSets.MSetInterface.html">MSetInterface</a></li>
<li><a href="Stdlib.MSets.MSetList.html">MSetList</a></li>
<li><a href="Stdlib.MSets.MSetPositive.html">MSetPositive</a></li>
<li><a href="Stdlib.MSets.MSetProperties.html">MSetProperties</a></li>
<li><a href="Stdlib.MSets.MSetRBT.html">MSetRBT</a></li>
<li><a href="Stdlib.MSets.MSetToFiniteSet.html">MSetToFiniteSet</a></li>
<li><a href="Stdlib.MSets.MSetWeakList.html">MSetWeakList</a></li>
<li><a href="Stdlib.MSets.MSets.html">MSets</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.NArith"><summary>NArith</summary>
          <ul>
          <li><a href="Stdlib.NArith.BinNat.html">BinNat</a></li>
<li><a href="Stdlib.NArith.BinNatDef.html">BinNatDef</a></li>
<li><a href="Stdlib.NArith.NArith.html">NArith</a></li>
<li><a href="Stdlib.NArith.NArith_base.html">NArith_base</a></li>
<li><a href="Stdlib.NArith.Ndec.html">Ndec</a></li>
<li><a href="Stdlib.NArith.Ndiv_def.html">Ndiv_def</a></li>
<li><a href="Stdlib.NArith.Ngcd_def.html">Ngcd_def</a></li>
<li><a href="Stdlib.NArith.Nnat.html">Nnat</a></li>
<li><a href="Stdlib.NArith.Nsqrt_def.html">Nsqrt_def</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers"><summary>Numbers</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic"><summary>Cyclic</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Cyclic.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Abstract.CyclicAxioms.html">CyclicAxioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.DoubleType.html">DoubleType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Abstract.NZCyclic.html">NZCyclic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Cyclic.Int63"><summary>Int63</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Cyclic.Int63.CarryType.html">CarryType</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Cyclic63.html">Cyclic63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.PrimInt63.html">PrimInt63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Ring63.html">Ring63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63.html">Sint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Sint63Axioms.html">Sint63Axioms</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63.html">Uint63</a></li>
<li><a href="Stdlib.Numbers.Cyclic.Int63.Uint63Axioms.html">Uint63Axioms</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer"><summary>Integer</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Integer.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Abstract.ZAdd.html">ZAdd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAddOrder.html">ZAddOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZAxioms.html">ZAxioms</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBase.html">ZBase</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZBits.html">ZBits</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivEucl.html">ZDivEucl</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivFloor.html">ZDivFloor</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZDivTrunc.html">ZDivTrunc</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZGcd.html">ZGcd</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLcm.html">ZLcm</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZLt.html">ZLt</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMaxMin.html">ZMaxMin</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMul.html">ZMul</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZMulOrder.html">ZMulOrder</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZParity.html">ZParity</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZPow.html">ZPow</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZProperties.html">ZProperties</a></li>
<li><a href="Stdlib.Numbers.Integer.Abstract.ZSgnAbs.html">ZSgnAbs</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.Binary.ZBinary.html">ZBinary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Integer.NatPairs"><summary>NatPairs</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Integer.NatPairs.ZNatPairs.html">ZNatPairs</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.NatInt"><summary>NatInt</summary>
          <ul>
          <li><a href="Stdlib.Numbers.NatInt.NZAdd.html">NZAdd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAddOrder.html">NZAddOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZAxioms.html">NZAxioms</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBase.html">NZBase</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZBits.html">NZBits</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDiv.html">NZDiv</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZDomain.html">NZDomain</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZGcd.html">NZGcd</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZLog.html">NZLog</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMul.html">NZMul</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZMulOrder.html">NZMulOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZOrder.html">NZOrder</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZParity.html">NZParity</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZPow.html">NZPow</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZProperties.html">NZProperties</a></li>
<li><a href="Stdlib.Numbers.NatInt.NZSqrt.html">NZSqrt</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural"><summary>Natural</summary>
          <ul>
          <li><details id="Stdlib.Numbers.Natural.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Abstract.NAdd.html">NAdd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAddOrder.html">NAddOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NAxioms.html">NAxioms</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBase.html">NBase</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NBits.html">NBits</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDefOps.html">NDefOps</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv.html">NDiv</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NDiv0.html">NDiv0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NGcd.html">NGcd</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NIso.html">NIso</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm.html">NLcm</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLcm0.html">NLcm0</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NLog.html">NLog</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMaxMin.html">NMaxMin</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NMulOrder.html">NMulOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NOrder.html">NOrder</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NParity.html">NParity</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NPow.html">NPow</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NProperties.html">NProperties</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSqrt.html">NSqrt</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NStrongRec.html">NStrongRec</a></li>
<li><a href="Stdlib.Numbers.Natural.Abstract.NSub.html">NSub</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Numbers.Natural.Binary"><summary>Binary</summary>
          <ul>
          <li><a href="Stdlib.Numbers.Natural.Binary.NBinary.html">NBinary</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Numbers.AltBinNotations.html">AltBinNotations</a></li>
<li><a href="Stdlib.Numbers.BinNums.html">BinNums</a></li>
<li><a href="Stdlib.Numbers.DecimalFacts.html">DecimalFacts</a></li>
<li><a href="Stdlib.Numbers.DecimalN.html">DecimalN</a></li>
<li><a href="Stdlib.Numbers.DecimalNat.html">DecimalNat</a></li>
<li><a href="Stdlib.Numbers.DecimalPos.html">DecimalPos</a></li>
<li><a href="Stdlib.Numbers.DecimalQ.html">DecimalQ</a></li>
<li><a href="Stdlib.Numbers.DecimalR.html">DecimalR</a></li>
<li><a href="Stdlib.Numbers.DecimalString.html">DecimalString</a></li>
<li><a href="Stdlib.Numbers.DecimalZ.html">DecimalZ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalFacts.html">HexadecimalFacts</a></li>
<li><a href="Stdlib.Numbers.HexadecimalN.html">HexadecimalN</a></li>
<li><a href="Stdlib.Numbers.HexadecimalNat.html">HexadecimalNat</a></li>
<li><a href="Stdlib.Numbers.HexadecimalPos.html">HexadecimalPos</a></li>
<li><a href="Stdlib.Numbers.HexadecimalQ.html">HexadecimalQ</a></li>
<li><a href="Stdlib.Numbers.HexadecimalR.html">HexadecimalR</a></li>
<li><a href="Stdlib.Numbers.HexadecimalString.html">HexadecimalString</a></li>
<li><a href="Stdlib.Numbers.HexadecimalZ.html">HexadecimalZ</a></li>
<li><a href="Stdlib.Numbers.NaryFunctions.html">NaryFunctions</a></li>
<li><a href="Stdlib.Numbers.NumPrelude.html">NumPrelude</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.PArith"><summary>PArith</summary>
          <ul>
          <li><a href="Stdlib.PArith.BinPos.html">BinPos</a></li>
<li><a href="Stdlib.PArith.BinPosDef.html">BinPosDef</a></li>
<li><a href="Stdlib.PArith.PArith.html">PArith</a></li>
<li><a href="Stdlib.PArith.POrderedType.html">POrderedType</a></li>
<li><a href="Stdlib.PArith.Pnat.html">Pnat</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Program"><summary>Program</summary>
          <ul>
          <li><a href="Stdlib.Program.Basics.html">Basics</a></li>
<li><a href="Stdlib.Program.Combinators.html">Combinators</a></li>
<li><a href="Stdlib.Program.Equality.html">Equality</a></li>
<li><a href="Stdlib.Program.Program.html">Program</a></li>
<li><a href="Stdlib.Program.Subset.html">Subset</a></li>
<li><a href="Stdlib.Program.Syntax.html">Syntax</a></li>
<li><a href="Stdlib.Program.Tactics.html">Tactics</a></li>
<li><a href="Stdlib.Program.Utils.html">Utils</a></li>
<li><a href="Stdlib.Program.Wf.html">Wf</a></li>
<li><a href="Stdlib.Program.WfExtensionality.html">WfExtensionality</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.QArith"><summary>QArith</summary>
          <ul>
          <li><a href="Stdlib.QArith.QArith.html">QArith</a></li>
<li><a href="Stdlib.QArith.QArith_base.html">QArith_base</a></li>
<li><a href="Stdlib.QArith.QOrderedType.html">QOrderedType</a></li>
<li><a href="Stdlib.QArith.Qabs.html">Qabs</a></li>
<li><a href="Stdlib.QArith.Qcabs.html">Qcabs</a></li>
<li><a href="Stdlib.QArith.Qcanon.html">Qcanon</a></li>
<li><a href="Stdlib.QArith.Qfield.html">Qfield</a></li>
<li><a href="Stdlib.QArith.Qminmax.html">Qminmax</a></li>
<li><a href="Stdlib.QArith.Qpower.html">Qpower</a></li>
<li><a href="Stdlib.QArith.Qreduction.html">Qreduction</a></li>
<li><a href="Stdlib.QArith.Qring.html">Qring</a></li>
<li><a href="Stdlib.QArith.Qround.html">Qround</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals"><summary>Reals</summary>
          <ul>
          <li><details id="Stdlib.Reals.Abstract"><summary>Abstract</summary>
          <ul>
          <li><a href="Stdlib.Reals.Abstract.ConstructiveAbs.html">ConstructiveAbs</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLUB.html">ConstructiveLUB</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveLimits.html">ConstructiveLimits</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveMinMax.html">ConstructiveMinMax</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructivePower.html">ConstructivePower</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveReals.html">ConstructiveReals</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveRealsMorphisms.html">ConstructiveRealsMorphisms</a></li>
<li><a href="Stdlib.Reals.Abstract.ConstructiveSum.html">ConstructiveSum</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Reals.Cauchy"><summary>Cauchy</summary>
          <ul>
          <li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyAbs.html">ConstructiveCauchyAbs</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyReals.html">ConstructiveCauchyReals</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveCauchyRealsMult.html">ConstructiveCauchyRealsMult</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveExtra.html">ConstructiveExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.ConstructiveRcomplete.html">ConstructiveRcomplete</a></li>
<li><a href="Stdlib.Reals.Cauchy.PosExtra.html">PosExtra</a></li>
<li><a href="Stdlib.Reals.Cauchy.QExtra.html">QExtra</a></li>
          </ul>
          </details>
          </li>
<li><a href="Stdlib.Reals.Alembert.html">Alembert</a></li>
<li><a href="Stdlib.Reals.AltSeries.html">AltSeries</a></li>
<li><a href="Stdlib.Reals.ArithProp.html">ArithProp</a></li>
<li><a href="Stdlib.Reals.Binomial.html">Binomial</a></li>
<li><a href="Stdlib.Reals.Cauchy_prod.html">Cauchy_prod</a></li>
<li><a href="Stdlib.Reals.ClassicalConstructiveReals.html">ClassicalConstructiveReals</a></li>
<li><a href="Stdlib.Reals.ClassicalDedekindReals.html">ClassicalDedekindReals</a></li>
<li><a href="Stdlib.Reals.Cos_plus.html">Cos_plus</a></li>
<li><a href="Stdlib.Reals.Cos_rel.html">Cos_rel</a></li>
<li><a href="Stdlib.Reals.DiscrR.html">DiscrR</a></li>
<li><a href="Stdlib.Reals.Exp_prop.html">Exp_prop</a></li>
<li><a href="Stdlib.Reals.Integration.html">Integration</a></li>
<li><a href="Stdlib.Reals.MVT.html">MVT</a></li>
<li><a href="Stdlib.Reals.Machin.html">Machin</a></li>
<li><a href="Stdlib.Reals.NewtonInt.html">NewtonInt</a></li>
<li><a href="Stdlib.Reals.Nsatz.html">Nsatz</a></li>
<li><a href="Stdlib.Reals.PSeries_reg.html">PSeries_reg</a></li>
<li><a href="Stdlib.Reals.PartSum.html">PartSum</a></li>
<li><a href="Stdlib.Reals.Qreals.html">Qreals</a></li>
<li><a href="Stdlib.Reals.RIneq.html">RIneq</a></li>
<li><a href="Stdlib.Reals.RList.html">RList</a></li>
<li><a href="Stdlib.Reals.ROrderedType.html">ROrderedType</a></li>
<li><a href="Stdlib.Reals.R_Ifp.html">R_Ifp</a></li>
<li><a href="Stdlib.Reals.R_sqr.html">R_sqr</a></li>
<li><a href="Stdlib.Reals.R_sqrt.html">R_sqrt</a></li>
<li><a href="Stdlib.Reals.Ranalysis.html">Ranalysis</a></li>
<li><a href="Stdlib.Reals.Ranalysis1.html">Ranalysis1</a></li>
<li><a href="Stdlib.Reals.Ranalysis2.html">Ranalysis2</a></li>
<li><a href="Stdlib.Reals.Ranalysis3.html">Ranalysis3</a></li>
<li><a href="Stdlib.Reals.Ranalysis4.html">Ranalysis4</a></li>
<li><a href="Stdlib.Reals.Ranalysis5.html">Ranalysis5</a></li>
<li><a href="Stdlib.Reals.Ranalysis_reg.html">Ranalysis_reg</a></li>
<li><a href="Stdlib.Reals.Ratan.html">Ratan</a></li>
<li><a href="Stdlib.Reals.Raxioms.html">Raxioms</a></li>
<li><a href="Stdlib.Reals.Rbase.html">Rbase</a></li>
<li><a href="Stdlib.Reals.Rbasic_fun.html">Rbasic_fun</a></li>
<li><a href="Stdlib.Reals.Rcomplete.html">Rcomplete</a></li>
<li><a href="Stdlib.Reals.Rdefinitions.html">Rdefinitions</a></li>
<li><a href="Stdlib.Reals.Rderiv.html">Rderiv</a></li>
<li><a href="Stdlib.Reals.Reals.html">Reals</a></li>
<li><a href="Stdlib.Reals.Rfunctions.html">Rfunctions</a></li>
<li><a href="Stdlib.Reals.Rgeom.html">Rgeom</a></li>
<li><a href="Stdlib.Reals.RiemannInt.html">RiemannInt</a></li>
<li><a href="Stdlib.Reals.RiemannInt_SF.html">RiemannInt_SF</a></li>
<li><a href="Stdlib.Reals.Rlimit.html">Rlimit</a></li>
<li><a href="Stdlib.Reals.Rlogic.html">Rlogic</a></li>
<li><a href="Stdlib.Reals.Rminmax.html">Rminmax</a></li>
<li><a href="Stdlib.Reals.Rpow_def.html">Rpow_def</a></li>
<li><a href="Stdlib.Reals.Rpower.html">Rpower</a></li>
<li><a href="Stdlib.Reals.Rprod.html">Rprod</a></li>
<li><a href="Stdlib.Reals.Rregisternames.html">Rregisternames</a></li>
<li><a href="Stdlib.Reals.Rseries.html">Rseries</a></li>
<li><a href="Stdlib.Reals.Rsigma.html">Rsigma</a></li>
<li><a href="Stdlib.Reals.Rsqrt_def.html">Rsqrt_def</a></li>
<li><a href="Stdlib.Reals.Rtopology.html">Rtopology</a></li>
<li><a href="Stdlib.Reals.Rtrigo.html">Rtrigo</a></li>
<li><a href="Stdlib.Reals.Rtrigo1.html">Rtrigo1</a></li>
<li><a href="Stdlib.Reals.Rtrigo_alt.html">Rtrigo_alt</a></li>
<li><a href="Stdlib.Reals.Rtrigo_calc.html">Rtrigo_calc</a></li>
<li><a href="Stdlib.Reals.Rtrigo_def.html">Rtrigo_def</a></li>
<li><a href="Stdlib.Reals.Rtrigo_facts.html">Rtrigo_facts</a></li>
<li><a href="Stdlib.Reals.Rtrigo_fun.html">Rtrigo_fun</a></li>
<li><a href="Stdlib.Reals.Rtrigo_reg.html">Rtrigo_reg</a></li>
<li><a href="Stdlib.Reals.Runcountable.html">Runcountable</a></li>
<li><a href="Stdlib.Reals.SeqProp.html">SeqProp</a></li>
<li><a href="Stdlib.Reals.SeqSeries.html">SeqSeries</a></li>
<li><a href="Stdlib.Reals.SplitAbsolu.html">SplitAbsolu</a></li>
<li><a href="Stdlib.Reals.SplitRmult.html">SplitRmult</a></li>
<li><a href="Stdlib.Reals.Sqrt_reg.html">Sqrt_reg</a></li>
<li><a href="Stdlib.Reals.Zfloor.html">Zfloor</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Relations"><summary>Relations</summary>
          <ul>
          <li><a href="Stdlib.Relations.Operators_Properties.html">Operators_Properties</a></li>
<li><a href="Stdlib.Relations.Relation_Definitions.html">Relation_Definitions</a></li>
<li><a href="Stdlib.Relations.Relation_Operators.html">Relation_Operators</a></li>
<li><a href="Stdlib.Relations.Relations.html">Relations</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Setoids"><summary>Setoids</summary>
          <ul>
          <li><a href="Stdlib.Setoids.Setoid.html">Setoid</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sets"><summary>Sets</summary>
          <ul>
          <li><a href="Stdlib.Sets.Classical_sets.html">Classical_sets</a></li>
<li><a href="Stdlib.Sets.Constructive_sets.html">Constructive_sets</a></li>
<li><a href="Stdlib.Sets.Cpo.html">Cpo</a></li>
<li><a href="Stdlib.Sets.Ensembles.html">Ensembles</a></li>
<li><a href="Stdlib.Sets.Finite_sets.html">Finite_sets</a></li>
<li><a href="Stdlib.Sets.Finite_sets_facts.html">Finite_sets_facts</a></li>
<li><a href="Stdlib.Sets.Image.html">Image</a></li>
<li><a href="Stdlib.Sets.Infinite_sets.html">Infinite_sets</a></li>
<li><a href="Stdlib.Sets.Integers.html">Integers</a></li>
<li><a href="Stdlib.Sets.Multiset.html">Multiset</a></li>
<li><a href="Stdlib.Sets.Partial_Order.html">Partial_Order</a></li>
<li><a href="Stdlib.Sets.Permut.html">Permut</a></li>
<li><a href="Stdlib.Sets.Powerset.html">Powerset</a></li>
<li><a href="Stdlib.Sets.Powerset_Classical_facts.html">Powerset_Classical_facts</a></li>
<li><a href="Stdlib.Sets.Powerset_facts.html">Powerset_facts</a></li>
<li><a href="Stdlib.Sets.Relations_1.html">Relations_1</a></li>
<li><a href="Stdlib.Sets.Relations_1_facts.html">Relations_1_facts</a></li>
<li><a href="Stdlib.Sets.Relations_2.html">Relations_2</a></li>
<li><a href="Stdlib.Sets.Relations_2_facts.html">Relations_2_facts</a></li>
<li><a href="Stdlib.Sets.Relations_3.html">Relations_3</a></li>
<li><a href="Stdlib.Sets.Relations_3_facts.html">Relations_3_facts</a></li>
<li><a href="Stdlib.Sets.Uniset.html">Uniset</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Sorting"><summary>Sorting</summary>
          <ul>
          <li><a href="Stdlib.Sorting.CPermutation.html">CPermutation</a></li>
<li><a href="Stdlib.Sorting.Heap.html">Heap</a></li>
<li><a href="Stdlib.Sorting.Mergesort.html">Mergesort</a></li>
<li><a href="Stdlib.Sorting.PermutEq.html">PermutEq</a></li>
<li><a href="Stdlib.Sorting.PermutSetoid.html">PermutSetoid</a></li>
<li><a href="Stdlib.Sorting.Permutation.html">Permutation</a></li>
<li><a href="Stdlib.Sorting.SetoidList.html">SetoidList</a></li>
<li><a href="Stdlib.Sorting.SetoidPermutation.html">SetoidPermutation</a></li>
<li><a href="Stdlib.Sorting.Sorted.html">Sorted</a></li>
<li><a href="Stdlib.Sorting.Sorting.html">Sorting</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Streams"><summary>Streams</summary>
          <ul>
          <li><a href="Stdlib.Streams.StreamMemo.html">StreamMemo</a></li>
<li><a href="Stdlib.Streams.Streams.html">Streams</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Strings"><summary>Strings</summary>
          <ul>
          <li><a href="Stdlib.Strings.Ascii.html">Ascii</a></li>
<li><a href="Stdlib.Strings.BinaryString.html">BinaryString</a></li>
<li><a href="Stdlib.Strings.Byte.html">Byte</a></li>
<li><a href="Stdlib.Strings.HexString.html">HexString</a></li>
<li><a href="Stdlib.Strings.OctalString.html">OctalString</a></li>
<li><a href="Stdlib.Strings.PString.html">PString</a></li>
<li><a href="Stdlib.Strings.PrimString.html">PrimString</a></li>
<li><a href="Stdlib.Strings.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="Stdlib.Strings.String.html">String</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Structures"><summary>Structures</summary>
          <ul>
          <li><a href="Stdlib.Structures.BoolOrder.html">BoolOrder</a></li>
<li><a href="Stdlib.Structures.DecidableType.html">DecidableType</a></li>
<li><a href="Stdlib.Structures.DecidableTypeEx.html">DecidableTypeEx</a></li>
<li><a href="Stdlib.Structures.Equalities.html">Equalities</a></li>
<li><a href="Stdlib.Structures.EqualitiesFacts.html">EqualitiesFacts</a></li>
<li><a href="Stdlib.Structures.GenericMinMax.html">GenericMinMax</a></li>
<li><a href="Stdlib.Structures.OrderedType.html">OrderedType</a></li>
<li><a href="Stdlib.Structures.OrderedTypeAlt.html">OrderedTypeAlt</a></li>
<li><a href="Stdlib.Structures.OrderedTypeEx.html">OrderedTypeEx</a></li>
<li><a href="Stdlib.Structures.Orders.html">Orders</a></li>
<li><a href="Stdlib.Structures.OrdersAlt.html">OrdersAlt</a></li>
<li><a href="Stdlib.Structures.OrdersEx.html">OrdersEx</a></li>
<li><a href="Stdlib.Structures.OrdersFacts.html">OrdersFacts</a></li>
<li><a href="Stdlib.Structures.OrdersLists.html">OrdersLists</a></li>
<li><a href="Stdlib.Structures.OrdersTac.html">OrdersTac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Unicode"><summary>Unicode</summary>
          <ul>
          <li><a href="Stdlib.Unicode.Utf8.html">Utf8</a></li>
<li><a href="Stdlib.Unicode.Utf8_core.html">Utf8_core</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Vectors"><summary>Vectors</summary>
          <ul>
          <li><a href="Stdlib.Vectors.Bvector.html">Bvector</a></li>
<li><a href="Stdlib.Vectors.Fin.html">Fin</a></li>
<li><a href="Stdlib.Vectors.FinFun.html">FinFun</a></li>
<li><a href="Stdlib.Vectors.Vector.html">Vector</a></li>
<li><a href="Stdlib.Vectors.VectorDef.html">VectorDef</a></li>
<li><a href="Stdlib.Vectors.VectorEq.html">VectorEq</a></li>
<li><a href="Stdlib.Vectors.VectorSpec.html">VectorSpec</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.Wellfounded"><summary>Wellfounded</summary>
          <ul>
          <li><a href="Stdlib.Wellfounded.Disjoint_Union.html">Disjoint_Union</a></li>
<li><a href="Stdlib.Wellfounded.Inclusion.html">Inclusion</a></li>
<li><a href="Stdlib.Wellfounded.Inverse_Image.html">Inverse_Image</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Exponentiation.html">Lexicographic_Exponentiation</a></li>
<li><a href="Stdlib.Wellfounded.Lexicographic_Product.html">Lexicographic_Product</a></li>
<li><a href="Stdlib.Wellfounded.List_Extension.html">List_Extension</a></li>
<li><a href="Stdlib.Wellfounded.Transitive_Closure.html">Transitive_Closure</a></li>
<li><a href="Stdlib.Wellfounded.Union.html">Union</a></li>
<li><a href="Stdlib.Wellfounded.Well_Ordering.html">Well_Ordering</a></li>
<li><a href="Stdlib.Wellfounded.Wellfounded.html">Wellfounded</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ZArith"><summary>ZArith</summary>
          <ul>
          <li><a href="Stdlib.ZArith.BinInt.html">BinInt</a></li>
<li><a href="Stdlib.ZArith.BinIntDef.html">BinIntDef</a></li>
<li><a href="Stdlib.ZArith.Int.html">Int</a></li>
<li><a href="Stdlib.ZArith.Wf_Z.html">Wf_Z</a></li>
<li><a href="Stdlib.ZArith.ZArith.html">ZArith</a></li>
<li><a href="Stdlib.ZArith.ZArith_base.html">ZArith_base</a></li>
<li><a href="Stdlib.ZArith.ZArith_dec.html">ZArith_dec</a></li>
<li><a href="Stdlib.ZArith.Zabs.html">Zabs</a></li>
<li><a href="Stdlib.ZArith.Zbitwise.html">Zbitwise</a></li>
<li><a href="Stdlib.ZArith.Zbool.html">Zbool</a></li>
<li><a href="Stdlib.ZArith.Zcompare.html">Zcompare</a></li>
<li><a href="Stdlib.ZArith.Zcomplements.html">Zcomplements</a></li>
<li><a href="Stdlib.ZArith.Zdiv.html">Zdiv</a></li>
<li><a href="Stdlib.ZArith.Zdiv_facts.html">Zdiv_facts</a></li>
<li><a href="Stdlib.ZArith.Zeuclid.html">Zeuclid</a></li>
<li><a href="Stdlib.ZArith.Zeven.html">Zeven</a></li>
<li><a href="Stdlib.ZArith.Zgcd_alt.html">Zgcd_alt</a></li>
<li><a href="Stdlib.ZArith.Zhints.html">Zhints</a></li>
<li><a href="Stdlib.ZArith.Zmax.html">Zmax</a></li>
<li><a href="Stdlib.ZArith.Zmin.html">Zmin</a></li>
<li><a href="Stdlib.ZArith.Zminmax.html">Zminmax</a></li>
<li><a href="Stdlib.ZArith.Zmisc.html">Zmisc</a></li>
<li><a href="Stdlib.ZArith.Znat.html">Znat</a></li>
<li><a href="Stdlib.ZArith.Znumtheory.html">Znumtheory</a></li>
<li><a href="Stdlib.ZArith.Zorder.html">Zorder</a></li>
<li><a href="Stdlib.ZArith.Zpow_alt.html">Zpow_alt</a></li>
<li><a href="Stdlib.ZArith.Zpow_def.html">Zpow_def</a></li>
<li><a href="Stdlib.ZArith.Zpow_facts.html">Zpow_facts</a></li>
<li><a href="Stdlib.ZArith.Zpower.html">Zpower</a></li>
<li><a href="Stdlib.ZArith.Zquot.html">Zquot</a></li>
<li><a href="Stdlib.ZArith.Zwf.html">Zwf</a></li>
<li><a href="Stdlib.ZArith.auxiliary.html">auxiliary</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.btauto"><summary>btauto</summary>
          <ul>
          <li><a href="Stdlib.btauto.Algebra.html">Algebra</a></li>
<li><a href="Stdlib.btauto.Btauto.html">Btauto</a></li>
<li><a href="Stdlib.btauto.Reflect.html">Reflect</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.derive"><summary>derive</summary>
          <ul>
          <li><a href="Stdlib.derive.Derive.html">Derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.extraction"><summary>extraction</summary>
          <ul>
          <li><a href="Stdlib.extraction.ExtrHaskellBasic.html">ExtrHaskellBasic</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInt.html">ExtrHaskellNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatInteger.html">ExtrHaskellNatInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellNatNum.html">ExtrHaskellNatNum</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellString.html">ExtrHaskellString</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInt.html">ExtrHaskellZInt</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZInteger.html">ExtrHaskellZInteger</a></li>
<li><a href="Stdlib.extraction.ExtrHaskellZNum.html">ExtrHaskellZNum</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlFloats.html">ExtrOCamlFloats</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlInt63.html">ExtrOCamlInt63</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPArray.html">ExtrOCamlPArray</a></li>
<li><a href="Stdlib.extraction.ExtrOCamlPString.html">ExtrOCamlPString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlBasic.html">ExtrOcamlBasic</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlChar.html">ExtrOcamlChar</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlIntConv.html">ExtrOcamlIntConv</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatBigInt.html">ExtrOcamlNatBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNatInt.html">ExtrOcamlNatInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlNativeString.html">ExtrOcamlNativeString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlString.html">ExtrOcamlString</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZBigInt.html">ExtrOcamlZBigInt</a></li>
<li><a href="Stdlib.extraction.ExtrOcamlZInt.html">ExtrOcamlZInt</a></li>
<li><a href="Stdlib.extraction.Extraction.html">Extraction</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.funind"><summary>funind</summary>
          <ul>
          <li><a href="Stdlib.funind.FunInd.html">FunInd</a></li>
<li><a href="Stdlib.funind.Recdef.html">Recdef</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.micromega"><summary>micromega</summary>
          <ul>
          <li><a href="Stdlib.micromega.DeclConstant.html">DeclConstant</a></li>
<li><a href="Stdlib.micromega.DeclConstantZ.html">DeclConstantZ</a></li>
<li><a href="Stdlib.micromega.Env.html">Env</a></li>
<li><a href="Stdlib.micromega.EnvRing.html">EnvRing</a></li>
<li><a href="Stdlib.micromega.Fourier.html">Fourier</a></li>
<li><a href="Stdlib.micromega.Fourier_util.html">Fourier_util</a></li>
<li><a href="Stdlib.micromega.Lia.html">Lia</a></li>
<li><a href="Stdlib.micromega.Lqa.html">Lqa</a></li>
<li><a href="Stdlib.micromega.Lra.html">Lra</a></li>
<li><a href="Stdlib.micromega.OrderedRing.html">OrderedRing</a></li>
<li><a href="Stdlib.micromega.Psatz.html">Psatz</a></li>
<li><a href="Stdlib.micromega.QMicromega.html">QMicromega</a></li>
<li><a href="Stdlib.micromega.RMicromega.html">RMicromega</a></li>
<li><a href="Stdlib.micromega.Refl.html">Refl</a></li>
<li><a href="Stdlib.micromega.RingMicromega.html">RingMicromega</a></li>
<li><a href="Stdlib.micromega.Tauto.html">Tauto</a></li>
<li><a href="Stdlib.micromega.VarMap.html">VarMap</a></li>
<li><a href="Stdlib.micromega.ZArith_hints.html">ZArith_hints</a></li>
<li><a href="Stdlib.micromega.ZCoeff.html">ZCoeff</a></li>
<li><a href="Stdlib.micromega.ZMicromega.html">ZMicromega</a></li>
<li><a href="Stdlib.micromega.Zify.html">Zify</a></li>
<li><a href="Stdlib.micromega.ZifyBool.html">ZifyBool</a></li>
<li><a href="Stdlib.micromega.ZifyClasses.html">ZifyClasses</a></li>
<li><a href="Stdlib.micromega.ZifyComparison.html">ZifyComparison</a></li>
<li><a href="Stdlib.micromega.ZifyInst.html">ZifyInst</a></li>
<li><a href="Stdlib.micromega.ZifyN.html">ZifyN</a></li>
<li><a href="Stdlib.micromega.ZifyNat.html">ZifyNat</a></li>
<li><a href="Stdlib.micromega.ZifyPow.html">ZifyPow</a></li>
<li><a href="Stdlib.micromega.ZifySint63.html">ZifySint63</a></li>
<li><a href="Stdlib.micromega.ZifyUint63.html">ZifyUint63</a></li>
<li><a href="Stdlib.micromega.Ztac.html">Ztac</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.nsatz"><summary>nsatz</summary>
          <ul>
          <li><a href="Stdlib.nsatz.NsatzTactic.html">NsatzTactic</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.omega"><summary>omega</summary>
          <ul>
          <li><a href="Stdlib.omega.OmegaLemmas.html">OmegaLemmas</a></li>
<li><a href="Stdlib.omega.PreOmega.html">PreOmega</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.rtauto"><summary>rtauto</summary>
          <ul>
          <li><a href="Stdlib.rtauto.Bintree.html">Bintree</a></li>
<li><a href="Stdlib.rtauto.Rtauto.html">Rtauto</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.setoid_ring"><summary>setoid_ring</summary>
          <ul>
          <li><a href="Stdlib.setoid_ring.Algebra_syntax.html">Algebra_syntax</a></li>
<li><a href="Stdlib.setoid_ring.ArithRing.html">ArithRing</a></li>
<li><a href="Stdlib.setoid_ring.BinList.html">BinList</a></li>
<li><a href="Stdlib.setoid_ring.Cring.html">Cring</a></li>
<li><a href="Stdlib.setoid_ring.Field.html">Field</a></li>
<li><a href="Stdlib.setoid_ring.Field_tac.html">Field_tac</a></li>
<li><a href="Stdlib.setoid_ring.Field_theory.html">Field_theory</a></li>
<li><a href="Stdlib.setoid_ring.InitialRing.html">InitialRing</a></li>
<li><a href="Stdlib.setoid_ring.Integral_domain.html">Integral_domain</a></li>
<li><a href="Stdlib.setoid_ring.NArithRing.html">NArithRing</a></li>
<li><a href="Stdlib.setoid_ring.Ncring.html">Ncring</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_initial.html">Ncring_initial</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_polynom.html">Ncring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ncring_tac.html">Ncring_tac</a></li>
<li><a href="Stdlib.setoid_ring.RealField.html">RealField</a></li>
<li><a href="Stdlib.setoid_ring.Ring.html">Ring</a></li>
<li><a href="Stdlib.setoid_ring.Ring_base.html">Ring_base</a></li>
<li><a href="Stdlib.setoid_ring.Ring_polynom.html">Ring_polynom</a></li>
<li><a href="Stdlib.setoid_ring.Ring_tac.html">Ring_tac</a></li>
<li><a href="Stdlib.setoid_ring.Ring_theory.html">Ring_theory</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Q.html">Rings_Q</a></li>
<li><a href="Stdlib.setoid_ring.Rings_R.html">Rings_R</a></li>
<li><a href="Stdlib.setoid_ring.Rings_Z.html">Rings_Z</a></li>
<li><a href="Stdlib.setoid_ring.ZArithRing.html">ZArithRing</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssr"><summary>ssr</summary>
          <ul>
          <li><a href="Stdlib.ssr.ssrbool.html">ssrbool</a></li>
<li><a href="Stdlib.ssr.ssrclasses.html">ssrclasses</a></li>
<li><a href="Stdlib.ssr.ssreflect.html">ssreflect</a></li>
<li><a href="Stdlib.ssr.ssrfun.html">ssrfun</a></li>
<li><a href="Stdlib.ssr.ssrsetoid.html">ssrsetoid</a></li>
<li><a href="Stdlib.ssr.ssrunder.html">ssrunder</a></li>
          </ul>
          </details>
          </li>
<li><details id="Stdlib.ssrmatching"><summary>ssrmatching</summary>
          <ul>
          <li><a href="Stdlib.ssrmatching.ssrmatching.html">ssrmatching</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi"><summary>elpi</summary>
          <ul>
          <li><details id="elpi.apps"><summary>apps</summary>
          <ul>
          <li><details id="elpi.apps.NES"><summary>NES</summary>
          <ul>
          <li><details id="elpi.apps.NES.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.NES.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.NES.NES.html">NES</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.coercion"><summary>coercion</summary>
          <ul>
          <li><a href="elpi.apps.coercion.coercion.html">coercion</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.cs"><summary>cs</summary>
          <ul>
          <li><a href="elpi.apps.cs.cs.html">cs</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive"><summary>derive</summary>
          <ul>
          <li><details id="elpi.apps.derive.derive"><summary>derive</summary>
          <ul>
          <li><a href="elpi.apps.derive.derive.EqdepFacts.html">EqdepFacts</a></li>
<li><a href="elpi.apps.derive.derive.bcongr.html">bcongr</a></li>
<li><a href="elpi.apps.derive.derive.cast.html">cast</a></li>
<li><a href="elpi.apps.derive.derive.eq.html">eq</a></li>
<li><a href="elpi.apps.derive.derive.eqK.html">eqK</a></li>
<li><a href="elpi.apps.derive.derive.eqOK.html">eqOK</a></li>
<li><a href="elpi.apps.derive.derive.eqType_ast.html">eqType_ast</a></li>
<li><a href="elpi.apps.derive.derive.eqb.html">eqb</a></li>
<li><a href="elpi.apps.derive.derive.eqbOK.html">eqbOK</a></li>
<li><a href="elpi.apps.derive.derive.eqb_core_defs.html">eqb_core_defs</a></li>
<li><a href="elpi.apps.derive.derive.eqbcorrect.html">eqbcorrect</a></li>
<li><a href="elpi.apps.derive.derive.eqcorrect.html">eqcorrect</a></li>
<li><a href="elpi.apps.derive.derive.experimental.html">experimental</a></li>
<li><a href="elpi.apps.derive.derive.fields.html">fields</a></li>
<li><a href="elpi.apps.derive.derive.idx2inv.html">idx2inv</a></li>
<li><a href="elpi.apps.derive.derive.induction.html">induction</a></li>
<li><a href="elpi.apps.derive.derive.invert.html">invert</a></li>
<li><a href="elpi.apps.derive.derive.isK.html">isK</a></li>
<li><a href="elpi.apps.derive.derive.legacy.html">legacy</a></li>
<li><a href="elpi.apps.derive.derive.lens.html">lens</a></li>
<li><a href="elpi.apps.derive.derive.lens_laws.html">lens_laws</a></li>
<li><a href="elpi.apps.derive.derive.map.html">map</a></li>
<li><a href="elpi.apps.derive.derive.param1.html">param1</a></li>
<li><a href="elpi.apps.derive.derive.param1_congr.html">param1_congr</a></li>
<li><a href="elpi.apps.derive.derive.param1_functor.html">param1_functor</a></li>
<li><a href="elpi.apps.derive.derive.param1_trivial.html">param1_trivial</a></li>
<li><a href="elpi.apps.derive.derive.param2.html">param2</a></li>
<li><a href="elpi.apps.derive.derive.projK.html">projK</a></li>
<li><a href="elpi.apps.derive.derive.std.html">std</a></li>
<li><a href="elpi.apps.derive.derive.tag.html">tag</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.derive.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.derive.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.derive.derive.html">derive</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.eltac"><summary>eltac</summary>
          <ul>
          <li><a href="elpi.apps.eltac.apply.html">apply</a></li>
<li><a href="elpi.apps.eltac.assumption.html">assumption</a></li>
<li><a href="elpi.apps.eltac.case.html">case</a></li>
<li><a href="elpi.apps.eltac.clear.html">clear</a></li>
<li><a href="elpi.apps.eltac.constructor.html">constructor</a></li>
<li><a href="elpi.apps.eltac.cycle.html">cycle</a></li>
<li><a href="elpi.apps.eltac.discriminate.html">discriminate</a></li>
<li><a href="elpi.apps.eltac.fail.html">fail</a></li>
<li><a href="elpi.apps.eltac.generalize.html">generalize</a></li>
<li><a href="elpi.apps.eltac.injection.html">injection</a></li>
<li><a href="elpi.apps.eltac.intro.html">intro</a></li>
<li><a href="elpi.apps.eltac.rewrite.html">rewrite</a></li>
<li><a href="elpi.apps.eltac.tactics.html">tactics</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.locker"><summary>locker</summary>
          <ul>
          <li><details id="elpi.apps.locker.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.locker.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.locker.locker.html">locker</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.rbuild"><summary>rbuild</summary>
          <ul>
          <li><details id="elpi.apps.rbuild.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.rbuild.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.rbuild.rbuild.html">rbuild</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi.apps.tc"><summary>tc</summary>
          <ul>
          <li><details id="elpi.apps.tc.elpi"><summary>elpi</summary>
          <ul>
          <li><a href="elpi.apps.tc.elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.apps.tc.add_commands.html">add_commands</a></li>
<li><a href="elpi.apps.tc.db.html">db</a></li>
<li><a href="elpi.apps.tc.tc.html">tc</a></li>
<li><a href="elpi.apps.tc.wip.html">wip</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
<li><details id="elpi.core"><summary>core</summary>
          <ul>
          <li><a href="elpi.core.Bool.html">Bool</a></li>
<li><a href="elpi.core.ListDef.html">ListDef</a></li>
<li><a href="elpi.core.Morphisms.html">Morphisms</a></li>
<li><a href="elpi.core.PosDef.html">PosDef</a></li>
<li><a href="elpi.core.PrimFloat.html">PrimFloat</a></li>
<li><a href="elpi.core.PrimInt63.html">PrimInt63</a></li>
<li><a href="elpi.core.PrimString.html">PrimString</a></li>
<li><a href="elpi.core.PrimStringAxioms.html">PrimStringAxioms</a></li>
<li><a href="elpi.core.RelationClasses.html">RelationClasses</a></li>
<li><a href="elpi.core.Setoid.html">Setoid</a></li>
<li><a href="elpi.core.Uint63Axioms.html">Uint63Axioms</a></li>
<li><a href="elpi.core.ssrbool.html">ssrbool</a></li>
<li><a href="elpi.core.ssreflect.html">ssreflect</a></li>
<li><a href="elpi.core.ssrfun.html">ssrfun</a></li>
          </ul>
          </details>
          </li>
<li><a href="elpi.elpi.html">elpi</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_elpi"><summary>elpi_elpi</summary>
          <ul>
          <li><a href="elpi_elpi.dummy.html">dummy</a></li>
          </ul>
          </details>
          </li>
<li><details id="elpi_examples"><summary>elpi_examples</summary>
          <ul>
          <li><a href="elpi_examples.example_abs_evars.html">example_abs_evars</a></li>
<li><a href="elpi_examples.example_curry_howard_tactics.html">example_curry_howard_tactics</a></li>
<li><a href="elpi_examples.example_data_base.html">example_data_base</a></li>
<li><a href="elpi_examples.example_fuzzer.html">example_fuzzer</a></li>
<li><a href="elpi_examples.example_generalize.html">example_generalize</a></li>
<li><a href="elpi_examples.example_import_projections.html">example_import_projections</a></li>
<li><a href="elpi_examples.example_record_expansion.html">example_record_expansion</a></li>
<li><a href="elpi_examples.example_record_to_sigma.html">example_record_to_sigma</a></li>
<li><a href="elpi_examples.example_reduction_surgery.html">example_reduction_surgery</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_HOAS.html">tutorial_coq_elpi_HOAS</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_command.html">tutorial_coq_elpi_command</a></li>
<li><a href="elpi_examples.tutorial_coq_elpi_tactic.html">tutorial_coq_elpi_tactic</a></li>
<li><a href="elpi_examples.tutorial_elpi_lang.html">tutorial_elpi_lang</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp"><summary>mathcomp</summary>
          <ul>
          <li><details id="mathcomp.algebra"><summary>algebra</summary>
          <ul>
          <li><details id="mathcomp.algebra.num_theory"><summary>num_theory</summary>
          <ul>
          <li><a href="mathcomp.algebra.num_theory.numdomain.html">numdomain</a></li>
<li><a href="mathcomp.algebra.num_theory.numfield.html">numfield</a></li>
<li><a href="mathcomp.algebra.num_theory.orderedzmod.html">orderedzmod</a></li>
<li><a href="mathcomp.algebra.num_theory.ssrnum.html">ssrnum</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.algebra.all_algebra.html">all_algebra</a></li>
<li><a href="mathcomp.algebra.archimedean.html">archimedean</a></li>
<li><a href="mathcomp.algebra.countalg.html">countalg</a></li>
<li><a href="mathcomp.algebra.finalg.html">finalg</a></li>
<li><a href="mathcomp.algebra.fraction.html">fraction</a></li>
<li><a href="mathcomp.algebra.intdiv.html">intdiv</a></li>
<li><a href="mathcomp.algebra.interval.html">interval</a></li>
<li><a href="mathcomp.algebra.interval_inference.html">interval_inference</a></li>
<li><a href="mathcomp.algebra.matrix.html">matrix</a></li>
<li><a href="mathcomp.algebra.mxalgebra.html">mxalgebra</a></li>
<li><a href="mathcomp.algebra.mxpoly.html">mxpoly</a></li>
<li><a href="mathcomp.algebra.mxred.html">mxred</a></li>
<li><a href="mathcomp.algebra.poly.html">poly</a></li>
<li><a href="mathcomp.algebra.polyXY.html">polyXY</a></li>
<li><a href="mathcomp.algebra.polydiv.html">polydiv</a></li>
<li><a href="mathcomp.algebra.qpoly.html">qpoly</a></li>
<li><a href="mathcomp.algebra.rat.html">rat</a></li>
<li><a href="mathcomp.algebra.ring_quotient.html">ring_quotient</a></li>
<li><a href="mathcomp.algebra.sesquilinear.html">sesquilinear</a></li>
<li><a href="mathcomp.algebra.spectral.html">spectral</a></li>
<li><a href="mathcomp.algebra.ssralg.html">ssralg</a></li>
<li><a href="mathcomp.algebra.ssrint.html">ssrint</a></li>
<li><a href="mathcomp.algebra.vector.html">vector</a></li>
<li><a href="mathcomp.algebra.zmodp.html">zmodp</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis"><summary>analysis</summary>
          <ul>
          <li><details id="mathcomp.analysis.homotopy_theory"><summary>homotopy_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.homotopy_theory.continuous_path.html">continuous_path</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.homotopy.html">homotopy</a></li>
<li><a href="mathcomp.analysis.homotopy_theory.wedge_sigT.html">wedge_sigT</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.lebesgue_integral_theory"><summary>lebesgue_integral_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_Rintegral.html">lebesgue_Rintegral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integrable.html">lebesgue_integrable</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral.html">lebesgue_integral</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_definition.html">lebesgue_integral_definition</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_differentiation.html">lebesgue_integral_differentiation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_dominated_convergence.html">lebesgue_integral_dominated_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_fubini.html">lebesgue_integral_fubini</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_monotone_convergence.html">lebesgue_integral_monotone_convergence</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_nonneg.html">lebesgue_integral_nonneg</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.lebesgue_integral_under.html">lebesgue_integral_under</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.measurable_fun_approximation.html">measurable_fun_approximation</a></li>
<li><a href="mathcomp.analysis.lebesgue_integral_theory.simple_functions.html">simple_functions</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.measure_theory"><summary>measure_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.measure_theory.counting_measure.html">counting_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.dirac_measure.html">dirac_measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_function.html">measurable_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measurable_structure.html">measurable_structure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure.html">measure</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_extension.html">measure_extension</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_function.html">measure_function</a></li>
<li><a href="mathcomp.analysis.measure_theory.measure_negligible.html">measure_negligible</a></li>
<li><a href="mathcomp.analysis.measure_theory.probability_measure.html">probability_measure</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.normedtype_theory"><summary>normedtype_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.normedtype_theory.complete_normed_module.html">complete_normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.ereal_normedtype.html">ereal_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.matrix_normedtype.html">matrix_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normed_module.html">normed_module</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.normedtype.html">normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.num_normedtype.html">num_normedtype</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.pseudometric_normed_Zmodule.html">pseudometric_normed_Zmodule</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.urysohn.html">urysohn</a></li>
<li><a href="mathcomp.analysis.normedtype_theory.vitali_lemma.html">vitali_lemma</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis.showcase.pnt.html">pnt</a></li>
<li><a href="mathcomp.analysis.showcase.summability.html">summability</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis.topology_theory"><summary>topology_theory</summary>
          <ul>
          <li><a href="mathcomp.analysis.topology_theory.bool_topology.html">bool_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.compact.html">compact</a></li>
<li><a href="mathcomp.analysis.topology_theory.connected.html">connected</a></li>
<li><a href="mathcomp.analysis.topology_theory.discrete_topology.html">discrete_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.matrix_topology.html">matrix_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.nat_topology.html">nat_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.num_topology.html">num_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.one_point_compactification.html">one_point_compactification</a></li>
<li><a href="mathcomp.analysis.topology_theory.order_topology.html">order_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.product_topology.html">product_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.pseudometric_structure.html">pseudometric_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.quotient_topology.html">quotient_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.separation_axioms.html">separation_axioms</a></li>
<li><a href="mathcomp.analysis.topology_theory.sigT_topology.html">sigT_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subspace_topology.html">subspace_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.subtype_topology.html">subtype_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.supremum_topology.html">supremum_topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology.html">topology</a></li>
<li><a href="mathcomp.analysis.topology_theory.topology_structure.html">topology_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.uniform_structure.html">uniform_structure</a></li>
<li><a href="mathcomp.analysis.topology_theory.weak_topology.html">weak_topology</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis.all_analysis.html">all_analysis</a></li>
<li><a href="mathcomp.analysis.borel_hierarchy.html">borel_hierarchy</a></li>
<li><a href="mathcomp.analysis.cantor.html">cantor</a></li>
<li><a href="mathcomp.analysis.charge.html">charge</a></li>
<li><a href="mathcomp.analysis.convex.html">convex</a></li>
<li><a href="mathcomp.analysis.derive.html">derive</a></li>
<li><a href="mathcomp.analysis.ereal.html">ereal</a></li>
<li><a href="mathcomp.analysis.ess_sup_inf.html">ess_sup_inf</a></li>
<li><a href="mathcomp.analysis.esum.html">esum</a></li>
<li><a href="mathcomp.analysis.exp.html">exp</a></li>
<li><a href="mathcomp.analysis.ftc.html">ftc</a></li>
<li><a href="mathcomp.analysis.function_spaces.html">function_spaces</a></li>
<li><a href="mathcomp.analysis.gauss_integral.html">gauss_integral</a></li>
<li><a href="mathcomp.analysis.hoelder.html">hoelder</a></li>
<li><a href="mathcomp.analysis.kernel.html">kernel</a></li>
<li><a href="mathcomp.analysis.landau.html">landau</a></li>
<li><a href="mathcomp.analysis.lebesgue_measure.html">lebesgue_measure</a></li>
<li><a href="mathcomp.analysis.lebesgue_stieltjes_measure.html">lebesgue_stieltjes_measure</a></li>
<li><a href="mathcomp.analysis.measurable_realfun.html">measurable_realfun</a></li>
<li><a href="mathcomp.analysis.numfun.html">numfun</a></li>
<li><a href="mathcomp.analysis.pi_irrational.html">pi_irrational</a></li>
<li><a href="mathcomp.analysis.probability.html">probability</a></li>
<li><a href="mathcomp.analysis.realfun.html">realfun</a></li>
<li><a href="mathcomp.analysis.sequences.html">sequences</a></li>
<li><a href="mathcomp.analysis.trigo.html">trigo</a></li>
<li><a href="mathcomp.analysis.tvs.html">tvs</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.analysis_stdlib"><summary>analysis_stdlib</summary>
          <ul>
          <li><details id="mathcomp.analysis_stdlib.showcase"><summary>showcase</summary>
          <ul>
          <li><a href="mathcomp.analysis_stdlib.showcase.uniform_bigO.html">uniform_bigO</a></li>
          </ul>
          </details>
          </li>
<li><a href="mathcomp.analysis_stdlib.Rstruct_topology.html">Rstruct_topology</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.bigenough"><summary>bigenough</summary>
          <ul>
          <li><a href="mathcomp.bigenough.bigenough.html">bigenough</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.boot"><summary>boot</summary>
          <ul>
          <li><a href="mathcomp.boot.all_boot.html">all_boot</a></li>
<li><a href="mathcomp.boot.bigop.html">bigop</a></li>
<li><a href="mathcomp.boot.binomial.html">binomial</a></li>
<li><a href="mathcomp.boot.choice.html">choice</a></li>
<li><a href="mathcomp.boot.div.html">div</a></li>
<li><a href="mathcomp.boot.eqtype.html">eqtype</a></li>
<li><a href="mathcomp.boot.finfun.html">finfun</a></li>
<li><a href="mathcomp.boot.fingraph.html">fingraph</a></li>
<li><a href="mathcomp.boot.finset.html">finset</a></li>
<li><a href="mathcomp.boot.fintype.html">fintype</a></li>
<li><a href="mathcomp.boot.generic_quotient.html">generic_quotient</a></li>
<li><a href="mathcomp.boot.monoid.html">monoid</a></li>
<li><a href="mathcomp.boot.nmodule.html">nmodule</a></li>
<li><a href="mathcomp.boot.path.html">path</a></li>
<li><a href="mathcomp.boot.prime.html">prime</a></li>
<li><a href="mathcomp.boot.seq.html">seq</a></li>
<li><a href="mathcomp.boot.ssrAC.html">ssrAC</a></li>
<li><a href="mathcomp.boot.ssrbool.html">ssrbool</a></li>
<li><a href="mathcomp.boot.ssreflect.html">ssreflect</a></li>
<li><a href="mathcomp.boot.ssrfun.html">ssrfun</a></li>
<li><a href="mathcomp.boot.ssrmatching.html">ssrmatching</a></li>
<li><a href="mathcomp.boot.ssrnat.html">ssrnat</a></li>
<li><a href="mathcomp.boot.ssrnotations.html">ssrnotations</a></li>
<li><a href="mathcomp.boot.tuple.html">tuple</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.classical"><summary>classical</summary>
          <ul>
          <li><a href="mathcomp.classical.all_classical.html">all_classical</a></li>
<li><a href="mathcomp.classical.boolp.html">boolp</a></li>
<li><a href="mathcomp.classical.cardinality.html">cardinality</a></li>
<li><a href="mathcomp.classical.classical_orders.html">classical_orders</a></li>
<li><a href="mathcomp.classical.classical_sets.html">classical_sets</a></li>
<li><a href="mathcomp.classical.contra.html">contra</a></li>
<li><a href="mathcomp.classical.filter.html">filter</a></li>
<li><a href="mathcomp.classical.fsbigop.html">fsbigop</a></li>
<li><a href="mathcomp.classical.functions.html">functions</a></li>
<li><a href="mathcomp.classical.internal_Eqdep_dec.html">internal_Eqdep_dec</a></li>
<li><a href="mathcomp.classical.mathcomp_extra.html">mathcomp_extra</a></li>
<li><a href="mathcomp.classical.set_interval.html">set_interval</a></li>
<li><a href="mathcomp.classical.unstable.html">unstable</a></li>
<li><a href="mathcomp.classical.wochoice.html">wochoice</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.experimental_reals"><summary>experimental_reals</summary>
          <ul>
          <li><a href="mathcomp.experimental_reals.discrete.html">discrete</a></li>
<li><a href="mathcomp.experimental_reals.distr.html">distr</a></li>
<li><a href="mathcomp.experimental_reals.realseq.html">realseq</a></li>
<li><a href="mathcomp.experimental_reals.realsum.html">realsum</a></li>
<li><a href="mathcomp.experimental_reals.xfinmap.html">xfinmap</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.field"><summary>field</summary>
          <ul>
          <li><a href="mathcomp.field.algC.html">algC</a></li>
<li><a href="mathcomp.field.algebraics_fundamentals.html">algebraics_fundamentals</a></li>
<li><a href="mathcomp.field.algnum.html">algnum</a></li>
<li><a href="mathcomp.field.all_field.html">all_field</a></li>
<li><a href="mathcomp.field.closed_field.html">closed_field</a></li>
<li><a href="mathcomp.field.cyclotomic.html">cyclotomic</a></li>
<li><a href="mathcomp.field.falgebra.html">falgebra</a></li>
<li><a href="mathcomp.field.fieldext.html">fieldext</a></li>
<li><a href="mathcomp.field.finfield.html">finfield</a></li>
<li><a href="mathcomp.field.galois.html">galois</a></li>
<li><a href="mathcomp.field.qfpoly.html">qfpoly</a></li>
<li><a href="mathcomp.field.separable.html">separable</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.fingroup"><summary>fingroup</summary>
          <ul>
          <li><a href="mathcomp.fingroup.action.html">action</a></li>
<li><a href="mathcomp.fingroup.all_fingroup.html">all_fingroup</a></li>
<li><a href="mathcomp.fingroup.automorphism.html">automorphism</a></li>
<li><a href="mathcomp.fingroup.fingroup.html">fingroup</a></li>
<li><a href="mathcomp.fingroup.gproduct.html">gproduct</a></li>
<li><a href="mathcomp.fingroup.morphism.html">morphism</a></li>
<li><a href="mathcomp.fingroup.perm.html">perm</a></li>
<li><a href="mathcomp.fingroup.presentation.html">presentation</a></li>
<li><a href="mathcomp.fingroup.quotient.html">quotient</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.finmap"><summary>finmap</summary>
          <ul>
          <li><a href="mathcomp.finmap.finmap.html">finmap</a></li>
<li><a href="mathcomp.finmap.multiset.html">multiset</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.order"><summary>order</summary>
          <ul>
          <li><a href="mathcomp.order.all_order.html">all_order</a></li>
<li><a href="mathcomp.order.order.html">order</a></li>
<li><a href="mathcomp.order.preorder.html">preorder</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals"><summary>reals</summary>
          <ul>
          <li><a href="mathcomp.reals.all_reals.html">all_reals</a></li>
<li><a href="mathcomp.reals.constructive_ereal.html">constructive_ereal</a></li>
<li><a href="mathcomp.reals.prodnormedzmodule.html">prodnormedzmodule</a></li>
<li><a href="mathcomp.reals.real_interval.html">real_interval</a></li>
<li><a href="mathcomp.reals.reals.html">reals</a></li>
<li><a href="mathcomp.reals.signed.html">signed</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.reals_stdlib"><summary>reals_stdlib</summary>
          <ul>
          <li><a href="mathcomp.reals_stdlib.Rstruct.html">Rstruct</a></li>
<li><a href="mathcomp.reals_stdlib.nsatz_realtype.html">nsatz_realtype</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.solvable"><summary>solvable</summary>
          <ul>
          <li><a href="mathcomp.solvable.abelian.html">abelian</a></li>
<li><a href="mathcomp.solvable.all_solvable.html">all_solvable</a></li>
<li><a href="mathcomp.solvable.alt.html">alt</a></li>
<li><a href="mathcomp.solvable.burnside_app.html">burnside_app</a></li>
<li><a href="mathcomp.solvable.center.html">center</a></li>
<li><a href="mathcomp.solvable.commutator.html">commutator</a></li>
<li><a href="mathcomp.solvable.cyclic.html">cyclic</a></li>
<li><a href="mathcomp.solvable.extraspecial.html">extraspecial</a></li>
<li><a href="mathcomp.solvable.extremal.html">extremal</a></li>
<li><a href="mathcomp.solvable.finmodule.html">finmodule</a></li>
<li><a href="mathcomp.solvable.frobenius.html">frobenius</a></li>
<li><a href="mathcomp.solvable.gfunctor.html">gfunctor</a></li>
<li><a href="mathcomp.solvable.gseries.html">gseries</a></li>
<li><a href="mathcomp.solvable.hall.html">hall</a></li>
<li><a href="mathcomp.solvable.jordanholder.html">jordanholder</a></li>
<li><a href="mathcomp.solvable.maximal.html">maximal</a></li>
<li><a href="mathcomp.solvable.nilpotent.html">nilpotent</a></li>
<li><a href="mathcomp.solvable.pgroup.html">pgroup</a></li>
<li><a href="mathcomp.solvable.primitive_action.html">primitive_action</a></li>
<li><a href="mathcomp.solvable.sylow.html">sylow</a></li>
          </ul>
          </details>
          </li>
<li><details id="mathcomp.ssreflect"><summary>ssreflect</summary>
          <ul>
          <li><a href="mathcomp.ssreflect.all_ssreflect.html">all_ssreflect</a></li>
          </ul>
          </details>
          </li>
          </ul>
          </details>
          </li>
    </div>

  <div class="coq">

    <div class="content">
      <p><a href="./index.html">Top</a></p>
      <h1 class="title">Module mathcomp._opam.lib.coq.user-contrib.mathcomp.solvable.extremal</h1>
<span class="vernacular">From</span><span class="id"> HB</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> structures</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssreflect</span><span class="id"> ssrbool</span><span class="id"> ssrfun</span><span class="id"> eqtype</span><span class="id"> ssrnat</span><span class="id"> seq</span><span class="id"> div</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> choice</span><span class="id"> fintype</span><span class="id"> bigop</span><span class="id"> finset</span><span class="id"> prime</span><span class="id"> binomial</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> fingroup</span><span class="id"> morphism</span><span class="id"> perm</span><span class="id"> automorphism</span><span class="id"> presentation</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> quotient</span><span class="id"> action</span><span class="id"> commutator</span><span class="id"> gproduct</span><span class="id"> gfunctor</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> ssralg</span><span class="id"> countalg</span><span class="id"> finalg</span><span class="id"> zmodp</span><span class="id"> cyclic</span><span class="id"> pgroup</span><span class="id"> center</span><span class="id"> gseries</span>.<br/>
<span class="vernacular">From</span><span class="id"> mathcomp</span><span class="vernacular"> Require</span><span class="vernacular"> Import</span><span class="id"> nilpotent</span><span class="id"> sylow</span><span class="id"> abelian</span><span class="id"> finmodule</span><span class="id"> matrix</span><span class="id"> maximal</span>.<br/>
<br/>
<pre class="ssrdoc">
   This file contains the definition and properties of extremal p-groups;
it covers and is mostly based on the beginning of Aschbacher, section 23,
as well as several exercises of this section.
  We define canonical representatives for the group classes that cover the
extremal p-groups (non-abelian p-groups with a cyclic maximal subgroup):
'Mod_m == the modular group of order m, for m = p ^ n, p prime and n &gt;= 3.
  'D_m == the dihedral group of order m, for m = 2n &gt;= 4.
  'Q_m == the generalized quaternion group of order m, for m = 2 ^ n &gt;= 8.
 'SD_m == the semi-dihedral group of order m, for m = 2 ^ n &gt;= 16.
In each case the notation is defined in the %type, %g and %G scopes, where
it denotes a finGroupType, a full gset and the full group for that type.
However each notation is only meaningful under the given conditions, in
'D_m is only an extremal group for m = 2 ^ n &gt;= 8, and 'D_8 = 'Mod_8 (they
are, in fact, beta-convertible).
  We also define
 extremal_generators G p n (x, y) &lt;-&gt; G has order p ^ n, x in G has order
           p ^ n.-1, and y is in G \ &lt;[x]&gt;: thus &lt;[x]&gt; has index p in G,
           so if p is prime, &lt;[x]&gt; is maximal in G, G is generated by x
           and y, and G is extremal or abelian.
 extremal_class G == the class of extremal groups G belongs to: one of
          ModularGroup, Dihedral, Quaternion, SemiDihedral or NotExtremal.
 extremal2 G &lt;=&gt; extremal_class G is one of Dihedral, Quaternion, or
          SemiDihedral; this allows 'D_4 and 'D_8, but excludes 'Mod_(2^n)
          for n &gt; 3.
 modular_group_generators p n (x, y) &lt;-&gt; y has order p and acts on x via
          x ^ y = x ^+ (p ^ n.-2).+1. This is the complement to
         extremal_generators G p n (x, y) for modular groups.
We provide cardinality, presentation, generator and structure theorems for
each class of extremal group. The extremal_generators predicate is used to
supply structure theorems with all the required data about G; this is
completed by an isomorphism assumption (e.g., G \isog 'D_(2 ^ n)), and
sometimes other properties (e.g., #[y] == 2 in the semidihedral case). The
generators assumption can be deduced generically from the isomorphism
assumption, or it can be proved manually for a specific choice of x and y.
 The extremal_class function is used to formulate synthetic theorems that
cover several classes of extremal groups (e.g., Aschbacher ex. 8.3).
</pre>
<br/>
<span class="gallina-kwd">Set</span><span class="vernacular"> Implicit</span><span class="vernacular"> Arguments</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Strict</span><span class="vernacular"> Implicit</span>.<br/>
<span class="vernacular">Unset</span><span class="vernacular"> Printing</span><span class="vernacular"> Implicit</span><span class="vernacular"> Defensive</span>.<br/>
<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span> <span class="id">&quot;n %:R&quot;</span><span class="id"> :=</span> (<span class="id">n</span><span class="id"> %:R%R</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Open</span><span class="vernacular"> Scope</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Import</span><span class="id"> GRing</span>.<span class="id">Theory</span>.<br/>
<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;''Mod_' m&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> m</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''Mod_' m&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;''D_' m&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> m</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''D_' m&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;''SD_' m&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> m</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''SD_' m&quot;</span>).<br/>
<span class="vernacular">Reserved</span><span class="vernacular"> Notation</span> <span class="id">&quot;''Q_' m&quot;</span> (<span class="gallina-kwd">at</span><span class="id"> level</span><span class="id"> 0,</span><span class="id"> m</span><span class="gallina-kwd"> at</span><span class="id"> level</span><span class="id"> 2,</span><span class="id"> format</span> <span class="id">&quot;''Q_' m&quot;</span>).<br/>
<br/>
<span class="vernacular">Module</span><span class="id"> Extremal</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> Construction</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'Z_p</span><span class="id"> :=</span><span class="id"> Zp1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> b</span><span class="id"> :</span><span class="id"> 'Z_q</span><span class="id"> :=</span><span class="id"> Zp1</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> &lt;[b]&gt;</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> aut_of</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">odflt</span><span class="id"> 1</span><span class="id"> [pick</span><span class="id"> s</span><span class="gallina-kwd"> in</span><span class="id"> Aut</span><span class="id"> B</span><span class="id"> |</span><span class="id"> p</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> &amp;</span> (<span class="id">#[s]</span><span class="id"> %|</span><span class="id"> p</span>)<span class="id"> &amp;&amp;</span> (<span class="id">s</span><span class="id"> b</span><span class="id"> ==</span><span class="id"> b</span><span class="id"> ^+</span><span class="id"> e</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> aut_dvdn</span><span class="id"> :</span><span class="id"> #[aut_of]</span><span class="id"> %|</span><span class="id"> #[a]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> order_Zp1</span><span class="id"> /aut_of;</span><span class="id"> case:</span><span class="id"> pickP</span><span class="id"> =&gt;</span><span class="id"> [s</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> order1</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/and4P=&gt;</span><span class="id"> _</span><span class="id"> p_gt1</span><span class="id"> p_s</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> Zp_cast</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> act_morphism</span><span class="id"> :=</span><span class="id"> eltm_morphism</span><span class="id"> aut_dvdn</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> base_act</span><span class="id"> :=</span> (<span class="id">[Aut</span><span class="id"> B]</span><span class="id"> \o</span><span class="id"> act_morphism</span>)<span class="id">%gact</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> act_dom</span><span class="id"> :</span><span class="id"> &lt;[a]&gt;</span><span class="id"> \subset</span><span class="id"> act_dom</span><span class="id"> base_act</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> cycle_subG</span><span class="id"> 2!inE</span><span class="id"> cycle_id</span><span class="id"> /=</span><span class="id"> eltm_id</span><span class="id"> /aut_of</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> pickP</span><span class="id"> =&gt;</span><span class="id"> [op</span><span class="id"> /andP[]</span><span class="id"> |</span><span class="id"> _]</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> group1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> gact</span><span class="id"> :=</span> (<span class="id">base_act</span><span class="id"> \</span><span class="id"> act_dom</span>)<span class="id">%gact</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Construction</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">lock</span><span class="vernacular"> Definition</span><span class="id"> gtype</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span><span class="id"> :</span><span class="id"> finGroupType</span><span class="id"> :=</span><span class="id"> sdprod_by</span> (<span class="id">gact</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> gtype_unlockable</span><span class="id"> :=</span><span class="id"> Unlockable</span><span class="id"> gtype</span>.<span class="id">unlock</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ConstructionCont</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Let</span><span class="id"> a</span><span class="id"> :</span><span class="id"> 'Z_p</span><span class="id"> :=</span><span class="id"> Zp1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> b</span><span class="id"> :</span><span class="id"> 'Z_q</span><span class="id"> :=</span><span class="id"> Zp1</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> &lt;[b]&gt;</span>.<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> gtype</span><span class="id"> :=</span> (<span class="id">gtype</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> gact</span><span class="id"> :=</span> (<span class="id">gact</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> aut_of</span><span class="id"> :=</span> (<span class="id">aut_of</span><span class="id"> q</span><span class="id"> p</span><span class="id"> e</span>) (<span class="id">only</span><span class="id"> parsing</span>).<br/>
<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">p_gt1</span><span class="id"> :</span><span class="id"> p</span><span class="id"> &gt;</span><span class="id"> 1</span>) (<span class="id">q_gt1</span><span class="id"> :</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card</span><span class="id"> :</span><span class="id"> #|[set:</span><span class="id"> gtype]|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> *</span><span class="id"> q</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> [gtype</span>.<span class="id">body]unlock</span><span class="id"> -</span>(<span class="id">sdprod_card</span> (<span class="id">sdprod_sdpair</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> !card_injm</span><span class="id"> ?injm_sdpair1</span><span class="id"> ?injm_sdpair2</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulnC</span><span class="id"> -!orderE</span><span class="id"> !order_Zp1</span><span class="id"> !Zp_cast</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp</span><span class="id"> :</span> (<span class="gallina-kwd">exists</span><span class="id"> s,</span><span class="id"> [/\</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> Aut</span><span class="id"> B,</span><span class="id"> #[s]</span><span class="id"> %|</span><span class="id"> p</span><span class="id"> &amp;</span><span class="id"> s</span><span class="id"> b</span><span class="id"> =</span><span class="id"> b</span><span class="id"> ^+</span><span class="id"> e]</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[set:</span><span class="id"> gtype]</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> e</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> [gtype</span>.<span class="id">body]unlock</span><span class="id"> =&gt;</span><span class="id"> [[s</span><span class="id"> [AutBs</span><span class="id"> dvd_s_p</span><span class="id"> sb]]]</span>.<br/>
<span class="id">have</span><span class="id"> memB:</span><span class="id"> _</span><span class="id"> \in</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> c;</span><span class="id"> rewrite</span><span class="id"> -Zp_cycle</span><span class="id"> inE</span>.<br/>
<span class="id">have</span><span class="id"> Aa:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> &lt;[a]&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> [oa</span><span class="id"> ob]:</span><span class="id"> #[a]</span><span class="id"> =</span><span class="id"> p</span><span class="id"> /\</span><span class="id"> #[b]</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !order_Zp1</span><span class="id"> !Zp_cast</span>.<br/>
<span class="id">have</span><span class="id"> def_s:</span><span class="id"> aut_of</span><span class="id"> =</span><span class="id"> s</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /aut_of;</span><span class="id"> case:</span><span class="id"> pickP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [t</span><span class="id"> |</span><span class="id"> ];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(_<span class="id"> s</span>)<span class="id">;</span><span class="id"> case/and4P;</span><span class="id"> rewrite</span><span class="id"> sb</span>.<br/>
&nbsp;&nbsp;<span class="id">case/and4P=&gt;</span><span class="id"> AutBt</span><span class="id"> _</span><span class="id"> _</span><span class="id"> tb;</span><span class="id"> apply:</span> (<span class="id">eq_Aut</span><span class="id"> AutBt</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> b_i</span>.<br/>
&nbsp;&nbsp;<span class="id">case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">autmE</span><span class="id"> AutBt</span>)<span class="id"> -</span>(<span class="id">autmE</span><span class="id"> AutBs</span>)<span class="id"> !morphX</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !autmE</span><span class="id"> //</span><span class="id"> sb</span> (<span class="id">eqP</span><span class="id"> tb</span>).<br/>
<span class="id">apply:</span><span class="id"> intro_isoGrp</span><span class="id"> =&gt;</span><span class="id"> [|gT</span><span class="id"> G]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">sdpair1</span><span class="id"> _</span><span class="id"> b,</span><span class="id"> sdpair2</span><span class="id"> _</span><span class="id"> a</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!morphim_cycle</span><span class="id"> ?norm_joinEr</span><span class="id"> ?im_sdpair</span><span class="id"> ?im_sdpair_norm</span><span class="id"> ?eqxx</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!order_dvdn</span><span class="id"> !order_injm</span><span class="id"> ?injm_sdpair1</span><span class="id"> ?injm_sdpair2</span><span class="id"> //</span><span class="id"> oa</span><span class="id"> ob</span><span class="id"> !dvdnn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -sdpair_act</span><span class="id"> //</span><span class="id"> [act</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]apermE</span><span class="id"> /=</span><span class="id"> eltm_id</span><span class="id"> -morphX</span><span class="id"> //</span><span class="id"> -sb</span><span class="id"> -def_s</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=</span><span class="id"> /eqP[defG</span><span class="id"> xq1</span><span class="id"> yp1</span><span class="id"> xy]</span>.<br/>
<span class="id">have</span><span class="id"> fxP:</span><span class="id"> #[x]</span><span class="id"> %|</span><span class="id"> #[b]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> order_dvdn</span><span class="id"> ob</span><span class="id"> xq1</span>.<br/>
<span class="id">have</span><span class="id"> fyP:</span><span class="id"> #[y]</span><span class="id"> %|</span><span class="id"> #[a]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> order_dvdn</span><span class="id"> oa</span><span class="id"> yp1</span>.<br/>
<span class="id">have</span><span class="id"> fP:</span><span class="id"> {in</span><span class="id"> &lt;[b]&gt;</span><span class="id"> &amp;</span><span class="id"> &lt;[a]&gt;,</span><span class="id"> morph_act</span><span class="id"> gact</span><span class="id"> 'J</span> (<span class="id">eltm</span><span class="id"> fxP</span>) (<span class="id">eltm</span><span class="id"> fyP</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> bj</span><span class="id"> ai;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;{bj};</span><span class="id"> case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;{ai}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> !eltmE</span><span class="id"> def_s</span><span class="id"> gactX</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> conjXg</span><span class="id"> morphX</span><span class="id"> //=;</span><span class="id"> congr</span> (_<span class="id"> ^+</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /autact</span><span class="id"> /=</span><span class="id"> apermE;</span><span class="id"> elim:</span><span class="id"> i</span><span class="id"> {j}</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [|i</span><span class="id"> IHi]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> perm1</span><span class="id"> eltm_id</span><span class="id"> conjg1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !expgS</span><span class="id"> permM</span><span class="id"> sb</span><span class="id"> -</span>(<span class="id">autmE</span> (<span class="id">groupX</span><span class="id"> i</span><span class="id"> AutBs</span>))<span class="id"> !morphX</span><span class="id"> //=</span><span class="id"> {}IHi</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -conjXg</span><span class="id"> -xy</span><span class="id"> -conjgM</span>.<br/>
<span class="id">apply/homgP;</span><span class="gallina-kwd"> exists</span> (<span class="id">xsdprod_morphism</span><span class="id"> fP</span>).<br/>
<span class="id">rewrite</span><span class="id"> im_xsdprodm</span><span class="id"> !morphim_cycle</span><span class="id"> //=</span><span class="id"> !eltm_id</span><span class="id"> -norm_joinEr</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> norms_cycle</span><span class="id"> xy</span><span class="id"> mem_cycle</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ConstructionCont</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> Extremal</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> SpecializeExtremals</span>.<br/>
<br/>
<span class="vernacular">Import</span><span class="id"> Extremal</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> m</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Let</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> pdiv</span><span class="id"> m</span>.<br/>
<span class="vernacular">Let</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> m</span><span class="id"> %/</span><span class="id"> p</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> modular_gtype</span><span class="id"> :=</span><span class="id"> gtype</span><span class="id"> q</span><span class="id"> p</span> (<span class="id">q</span><span class="id"> %/</span><span class="id"> p</span>).<span class="id">+1</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> dihedral_gtype</span><span class="id"> :=</span><span class="id"> gtype</span><span class="id"> q</span><span class="id"> 2</span><span class="id"> q</span>.<span class="id">-1</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> semidihedral_gtype</span><span class="id"> :=</span><span class="id"> gtype</span><span class="id"> q</span><span class="id"> 2</span> (<span class="id">q</span><span class="id"> %/</span><span class="id"> p</span>).<span class="id">-1</span>.<br/>
<span class="vernacular">Definition</span><span class="id"> quaternion_kernel</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">&lt;&lt;[set</span><span class="id"> u</span><span class="id"> |</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> ==</span><span class="id"> 1]</span><span class="id"> :\:</span><span class="id"> [set</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> |</span><span class="id"> u</span><span class="gallina-kwd"> in</span><span class="id"> [set:</span><span class="id"> gtype</span><span class="id"> q</span><span class="id"> 4</span><span class="id"> q</span>.<span class="id">-1]]&gt;&gt;</span>.<br/>
<br/>
<span class="vernacular">End</span><span class="id"> SpecializeExtremals</span>.<br/>
<br/>
<span class="id">HB</span>.<span class="id">lock</span><span class="vernacular"> Definition</span><span class="id"> quaternion_gtype</span><span class="id"> n</span><span class="id"> :</span><span class="id"> finGroupType</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">coset_of</span> (<span class="id">quaternion_kernel</span><span class="id"> n</span>).<br/>
<span class="vernacular">Canonical</span><span class="id"> quaternion_unlock</span><span class="id"> :=</span><span class="id"> Unlockable</span><span class="id"> quaternion_gtype</span>.<span class="id">unlock</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Mod_' m&quot;</span><span class="id"> :=</span> (<span class="id">modular_gtype</span><span class="id"> m</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Mod_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'Mod_m]</span><span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Mod_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'Mod_m]%G</span><span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''D_' m&quot;</span><span class="id"> :=</span> (<span class="id">dihedral_gtype</span><span class="id"> m</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''D_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'D_m]</span><span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''D_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'D_m]%G</span><span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''SD_' m&quot;</span><span class="id"> :=</span> (<span class="id">semidihedral_gtype</span><span class="id"> m</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''SD_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'SD_m]</span><span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''SD_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'SD_m]%G</span><span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Q_' m&quot;</span><span class="id"> :=</span> (<span class="id">quaternion_gtype</span><span class="id"> m</span>)<span class="id"> :</span><span class="id"> type_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Q_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'Q_m]</span><span class="id"> :</span><span class="id"> group_scope</span>.<br/>
<span class="vernacular">Notation</span> <span class="id">&quot;''Q_' m&quot;</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span><span class="id"> 'Q_m]%G</span><span class="id"> :</span><span class="id"> Group_scope</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ExtremalTheory</span>.<br/>
<br/>
<span class="vernacular">Implicit</span><span class="id"> Types</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">p</span><span class="id"> q</span><span class="id"> m</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cyclic_pgroup_Aut_structure</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> :!=:</span><span class="id"> 1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> #|G|</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> n</span><span class="id"> :=</span> (<span class="id">logn</span><span class="id"> p</span><span class="id"> q</span>).<span class="id">-1</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> Aut</span><span class="id"> G</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> P</span><span class="id"> :=</span><span class="id"> 'O_p</span>(<span class="id">A</span>)<span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> F</span><span class="id"> :=</span><span class="id"> 'O_p^'</span>(<span class="id">A</span>)<span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> m</span><span class="id"> :</span><span class="id"> {perm</span><span class="id"> gT}</span><span class="id"> -&gt;</span><span class="id"> 'Z_q,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> [/\</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> a</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> m</span><span class="id"> a</span><span class="id"> =</span><span class="id"> a</span><span class="id"> x},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> 1%R</span><span class="id"> /\</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /</span><span class="id"> a</span><span class="id"> *</span><span class="id"> b</span><span class="id"> &gt;-&gt;</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id">%R}},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> m}</span><span class="id"> /\</span><span class="id"> image</span><span class="id"> m</span><span class="id"> A</span><span class="id"> =i</span><span class="id"> GRing</span>.<span class="id">unit,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> {in</span><span class="id"> A,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> /</span><span class="id"> a</span><span class="id"> ^+</span><span class="id"> k</span><span class="id"> &gt;-&gt;</span> (<span class="id">a</span><span class="id"> ^+</span><span class="id"> k</span>)<span class="id">%R}}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> A,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> /</span><span class="id"> a^-1</span><span class="id"> &gt;-&gt;</span> (<span class="id">a^-1</span>)<span class="id">%R}}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> abelian</span><span class="id"> A,</span><span class="id"> cyclic</span><span class="id"> F,</span><span class="id"> #|F|</span><span class="id"> =</span><span class="id"> p</span>.<span class="id">-1</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> [faithful</span><span class="id"> F,</span><span class="id"> on</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id"> |</span><span class="id"> [Aut</span><span class="id"> G]]]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> ==</span><span class="id"> 0</span><span class="gallina-kwd"> then</span><span class="id"> A</span><span class="id"> =</span><span class="id"> F</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> t,</span><span class="id"> [/\</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2,</span><span class="id"> m</span><span class="id"> t</span><span class="id"> =</span> (<span class="id">-</span><span class="id"> 1</span>)<span class="id">%R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> if</span><span class="id"> odd</span><span class="id"> p</span><span class="gallina-kwd"> then</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> cyclic</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> cyclic</span><span class="id"> P,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> s,</span><span class="id"> [/\</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[s]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N,</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span><span class="id"> p</span>.<span class="id">+1%:R</span><span class="id"> &amp;</span><span class="id"> P</span><span class="id"> =</span><span class="id"> &lt;[s]&gt;]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> exists</span><span class="id"> s0,</span><span class="id"> [/\</span><span class="id"> s0</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[s0]</span><span class="id"> =</span><span class="id"> p,</span><span class="id"> m</span><span class="id"> s0</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>).<span class="id">+1%:R</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> 'Ohm_1</span>(<span class="id">P</span>)<span class="id"> =</span><span class="id"> &lt;[s0]&gt;]]</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> ==</span><span class="id"> 1%N</span><span class="gallina-kwd"> then</span><span class="id"> A</span><span class="id"> =</span><span class="id"> &lt;[t]&gt;</span><br/>
&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">else</span><span class="gallina-kwd"> exists</span><span class="id"> s,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[s]</span><span class="id"> =</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N,</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span><span class="id"> 5%:R,</span><span class="id"> &lt;[s]&gt;</span><span class="id"> \x</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> A</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> exists</span><span class="id"> s0,</span><span class="id"> [/\</span><span class="id"> s0</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[s0]</span><span class="id"> =</span><span class="id"> 2,</span><span class="id"> m</span><span class="id"> s0</span><span class="id"> =</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>).<span class="id">+1%:R,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">m</span> (<span class="id">s0</span><span class="id"> *</span><span class="id"> t</span>)<span class="id"> =</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>).<span class="id">-1%:R</span><span class="id"> &amp;</span><span class="id"> 'Ohm_1</span>(<span class="id">&lt;[s]&gt;</span>)<span class="id"> =</span><span class="id"> &lt;[s0]&gt;]]]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> cycG</span><span class="id"> ntG</span><span class="id"> q</span><span class="id"> n0</span><span class="id"> A</span><span class="id"> P</span><span class="id"> F;</span><span class="id"> have</span><span class="id"> [p_pr</span><span class="id"> p_dvd_G</span><span class="id"> [n</span><span class="id"> oG]]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> pG</span><span class="id"> ntG</span>.<br/>
<span class="id">have</span><span class="id"> [x0</span><span class="id"> defG]</span><span class="id"> :=</span><span class="id"> cyclicP</span><span class="id"> cycG;</span><span class="id"> have</span><span class="id"> Gx0:</span><span class="id"> x0</span><span class="id"> \in</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defG</span><span class="id"> cycle_id</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}/q</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> //=</span><span class="gallina-kwd"> in</span><span class="id"> n0</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> {}/n0</span>.<br/>
<span class="id">have</span><span class="id"> [p_gt1</span><span class="id"> min_p]</span><span class="id"> :=</span><span class="id"> primeP</span><span class="id"> p_pr;</span><span class="id"> have</span><span class="id"> p_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> p_gt1</span>.<br/>
<span class="id">have</span><span class="id"> q_gt1:</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cardG_gt1</span>.<br/>
<span class="id">have</span><span class="id"> cAA:</span><span class="id"> abelian</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> Aut_cyclic_abelian</span><span class="id"> cycG;</span><span class="id"> have</span><span class="id"> nilA</span><span class="id"> :=</span><span class="id"> abelian_nil</span><span class="id"> cAA</span>.<br/>
<span class="id">have</span><span class="id"> oA:</span><span class="id"> #|A|</span><span class="id"> =</span> (<span class="id">p</span>.<span class="id">-1</span><span class="id"> *</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_Aut_cyclic</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> totient_pfactor</span>.<br/>
<span class="id">have</span><span class="id"> [sylP</span><span class="id"> hallF]:</span><span class="id"> p</span>.<span class="id">-Sylow</span>(<span class="id">A</span>)<span class="id"> P</span><span class="id"> /\</span><span class="id"> p^'</span>.<span class="id">-Hall</span>(<span class="id">A</span>)<span class="id"> F</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !nilpotent_pcore_Hall</span>.<br/>
<span class="id">have</span><span class="id"> [defPF</span><span class="id"> tiPF]:</span><span class="id"> P</span><span class="id"> *</span><span class="id"> F</span><span class="id"> =</span><span class="id"> A</span><span class="id"> /\</span><span class="id"> P</span><span class="id"> :&amp;:</span><span class="id"> F</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/dprodP:</span> (<span class="id">nilpotent_pcoreC</span><span class="id"> p</span><span class="id"> nilA</span>).<br/>
<span class="id">have</span><span class="id"> oP:</span><span class="id"> #|P|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_Hall</span><span class="id"> sylP</span>)<span class="id"> oA</span><span class="id"> p_part</span><span class="id"> logn_Gauss</span><span class="id"> ?coprimenP</span><span class="id"> ?pfactorK</span>.<br/>
<span class="id">have</span><span class="id"> oF:</span><span class="id"> #|F|</span><span class="id"> =</span><span class="id"> p</span>.<span class="id">-1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@eqn_pmul2l</span><span class="id"> #|P|</span>)<span class="id"> ?cardG_gt0</span><span class="id"> //</span><span class="id"> -TI_cardMg</span><span class="id"> //</span><span class="id"> defPF</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oA</span><span class="id"> oP</span><span class="id"> mulnC</span>.<br/>
<span class="id">have</span><span class="id"> [m'</span><span class="id"> [inj_m'</span><span class="id"> defA</span><span class="id"> def_m']]:</span><span class="gallina-kwd"> exists</span><span class="id"> m'</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> units_Zp</span><span class="id"> q</span><span class="id"> &gt;-&gt;</span><span class="id"> {perm</span><span class="id"> gT}},</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'injm</span><span class="id"> m',</span><span class="id"> m'</span><span class="id"> @*</span><span class="id"> setT</span><span class="id"> =</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> x</span><span class="id"> u,</span><span class="id"> m'</span><span class="id"> u</span><span class="id"> x</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> val</span><span class="id"> u}]</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> /A</span><span class="id"> /q</span><span class="id"> defG;</span><span class="gallina-kwd"> exists</span> (<span class="id">Zp_unit_morphism</span><span class="id"> x0</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [-&gt;]:=</span><span class="id"> isomP</span> (<span class="id">Zp_unit_isom</span><span class="id"> x0</span>)<span class="id">;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> Gy</span><span class="id"> u;</span><span class="id"> rewrite</span><span class="id"> permE</span><span class="id"> Gy</span>.<br/>
<span class="id">pose</span><span class="id"> m</span> (<span class="id">a</span><span class="id"> :</span><span class="id"> {perm</span><span class="id"> gT}</span>)<span class="id"> :</span><span class="id"> 'Z_q</span><span class="id"> :=</span><span class="id"> val</span> (<span class="id">invm</span><span class="id"> inj_m'</span><span class="id"> a</span>).<br/>
<span class="id">have{def_m'}</span><span class="id"> def_m:</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> a</span><span class="id"> x,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> m</span><span class="id"> a</span><span class="id"> =</span><span class="id"> a</span><span class="id"> x}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> x</span><span class="id"> Aa</span><span class="id"> Gx</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -{2}[a]</span>(<span class="id">invmK</span><span class="id"> inj_m'</span>)<span class="id"> ?defA</span><span class="id"> ?def_m'</span>.<br/>
<span class="id">have</span><span class="id"> m1:</span><span class="id"> m</span><span class="id"> 1</span><span class="id"> =</span><span class="id"> 1%R</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> morph1</span>.<br/>
<span class="id">have</span><span class="id"> mM:</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /</span><span class="id"> a</span><span class="id"> *</span><span class="id"> b</span><span class="id"> &gt;-&gt;</span> (<span class="id">a</span><span class="id"> *</span><span class="id"> b</span>)<span class="id">%R}}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Aa</span><span class="id"> Ab;</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> morphM</span><span class="id"> ?defA</span>.<br/>
<span class="id">have</span><span class="id"> mX</span><span class="id"> k:</span><span class="id"> {in</span><span class="id"> A,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> /</span><span class="id"> a</span><span class="id"> ^+</span><span class="id"> k</span><span class="id"> &gt;-&gt;</span> (<span class="id">a</span><span class="id"> ^+</span><span class="id"> k</span>)<span class="id">%R}}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> elim:</span><span class="id"> k</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> k</span><span class="id"> IHk</span><span class="id"> a</span><span class="id"> Aa;</span><span class="id"> rewrite</span><span class="id"> expgS</span><span class="id"> exprS</span><span class="id"> mM</span><span class="id"> ?groupX</span><span class="id"> ?IHk</span>.<br/>
<span class="id">have</span><span class="id"> inj_m:</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> injective</span><span class="id"> m}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> can_in_inj</span> (<span class="gallina-kwd">fun</span><span class="id"> u</span><span class="id"> =&gt;</span><span class="id"> m'</span> (<span class="id">insubd</span> (<span class="id">1</span><span class="id"> :</span><span class="id"> {unit</span><span class="id"> 'Z_q}</span>)<span class="id"> u</span>))<span class="id"> _</span><span class="id"> =&gt;</span><span class="id"> a</span><span class="id"> Aa</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> valKd</span><span class="id"> invmK</span><span class="id"> ?defA</span>.<br/>
<span class="id">have{defA}</span><span class="id"> im_m:</span><span class="id"> image</span><span class="id"> m</span><span class="id"> A</span><span class="id"> =i</span><span class="id"> GRing</span>.<span class="id">unit</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> u;</span><span class="id"> apply/imageP/idP=&gt;</span><span class="id"> [[a</span><span class="id"> Aa</span><span class="id"> -&gt;]|</span><span class="id"> Uu];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> valP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">m'</span> (<span class="id">Sub</span><span class="id"> u</span><span class="id"> Uu</span>))<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defA</span><span class="id"> mem_morphim</span><span class="id"> ?inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> invmE</span><span class="id"> ?inE</span>.<br/>
<span class="id">have</span><span class="id"> mV:</span><span class="id"> {in</span><span class="id"> A,</span><span class="id"> {morph</span><span class="id"> m</span><span class="id"> :</span><span class="id"> a</span><span class="id"> /</span><span class="id"> a^-1</span><span class="id"> &gt;-&gt;</span> (<span class="id">a^-1</span>)<span class="id">%R}}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> a</span><span class="id"> Aa</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -div1r;</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">mulrK</span> (<span class="id">valP</span><span class="id"> _</span>))<span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -mM</span><span class="id"> ?groupV</span><span class="id"> ?mulVg</span>.<br/>
<span class="id">have</span><span class="id"> inv_m</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> 'Z_q</span>)<span class="id"> :</span><span class="id"> coprime</span><span class="id"> q</span><span class="id"> u</span><span class="id"> -&gt;</span><span class="id"> {a</span><span class="id"> |</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> m</span><span class="id"> a</span><span class="id"> =</span><span class="id"> u}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -?unitZpE</span><span class="id"> //</span><span class="id"> natr_Zp</span><span class="id"> -im_m</span><span class="id"> =&gt;</span><span class="id"> m_u</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span> (<span class="id">iinv</span><span class="id"> m_u</span>)<span class="id">;</span><span class="id"> [apply:</span><span class="id"> mem_iinv</span><span class="id"> |</span><span class="id"> rewrite</span><span class="id"> f_iinv]</span>.<br/>
<span class="id">have</span><span class="id"> [cycF</span><span class="id"> ffulF]:</span><span class="id"> cyclic</span><span class="id"> F</span><span class="id"> /\</span><span class="id"> [faithful</span><span class="id"> F,</span><span class="id"> on</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id"> |</span><span class="id"> [Aut</span><span class="id"> G]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Um0</span><span class="id"> a:</span> ((<span class="id">m</span><span class="id"> a</span>)<span class="id">%:R</span><span class="id"> :</span><span class="id"> 'F_p</span>)<span class="id"> \in</span><span class="id"> GRing</span>.<span class="id">unit</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:</span><span class="id"> m</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> GRing</span>.<span class="id">unit</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> valP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{1}[m</span><span class="id"> a]natr_Zp</span><span class="id"> unitFpE</span><span class="id"> ?unitZpE</span><span class="id"> //</span><span class="id"> {1}/q</span><span class="id"> oG</span><span class="id"> coprime_pexpl</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> fm0</span><span class="id"> a</span><span class="id"> :=</span><span class="id"> FinRing</span>.<span class="id">unit</span><span class="id"> 'F_p</span> (<span class="id">Um0</span><span class="id"> a</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> natZqp</span><span class="id"> u:</span> (<span class="id">u%:R</span><span class="id"> :</span><span class="id"> 'Z_q</span>)<span class="id">%:R</span><span class="id"> =</span><span class="id"> u</span><span class="id"> %:R</span><span class="id"> :&gt;</span><span class="id"> 'F_p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> val_Zp_nat</span><span class="id"> //</span><span class="id"> -Fp_nat_mod</span><span class="id"> //</span><span class="id"> modn_dvdm</span><span class="id"> ?Fp_nat_mod</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> m0M:</span><span class="id"> {in</span><span class="id"> A</span><span class="id"> &amp;,</span><span class="id"> {morph</span><span class="id"> fm0</span><span class="id"> :</span><span class="id"> a</span><span class="id"> b</span><span class="id"> /</span><span class="id"> a</span><span class="id"> *</span><span class="id"> b}}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> a</span><span class="id"> b</span><span class="id"> Aa</span><span class="id"> Ab;</span><span class="id"> apply:</span><span class="id"> val_inj;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -natrM</span><span class="id"> mM</span><span class="id"> //=</span><span class="id"> -val_Zp_nat</span>.<br/>
&nbsp;&nbsp;<span class="id">pose</span><span class="id"> m0</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> A</span><span class="id"> &gt;-&gt;</span><span class="id"> {unit</span><span class="id"> 'F_p}}</span><span class="id"> :=</span><span class="id"> Morphism</span><span class="id"> m0M</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> im_m0:</span><span class="id"> m0</span><span class="id"> @*</span><span class="id"> A</span><span class="id"> =</span><span class="id"> [set:</span><span class="id"> {unit</span><span class="id"> 'F_p}]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> [[/=</span><span class="id"> u</span><span class="id"> Uu]];</span><span class="id"> rewrite</span><span class="id"> in_setT</span><span class="id"> morphimEdom;</span><span class="id"> apply/imsetP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [|a</span><span class="id"> Aa</span><span class="id"> m_a]</span><span class="id"> :=</span><span class="id"> inv_m</span><span class="id"> u%:R</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> {1}[q]oG</span><span class="id"> coprime_pexpl</span><span class="id"> //</span><span class="id"> -unitFpE</span><span class="id"> //</span><span class="id"> natZqp</span><span class="id"> natr_Zp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> a</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> val_inj;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> m_a</span><span class="id"> natZqp</span><span class="id"> natr_Zp</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [x1</span><span class="id"> defG1]:</span><span class="gallina-kwd"> exists</span><span class="id"> x1,</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x1]&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/cyclicP;</span><span class="id"> apply:</span><span class="id"> cyclicS</span> (<span class="id">Ohm_sub</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> cycG</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ox1:</span><span class="id"> #[x1]</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderE</span><span class="id"> -defG1</span> (<span class="id">Ohm1_cyclic_pgroup_prime</span><span class="id"> _</span><span class="id"> pG</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Gx1:</span><span class="id"> x1</span><span class="id"> \in</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cycle_subG</span><span class="id"> -defG1</span><span class="id"> Ohm_sub</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ker_m0:</span><span class="id"> 'ker</span><span class="id"> m0</span><span class="id"> =</span><span class="id"> 'C</span>(<span class="id">'Ohm_1</span>(<span class="id">G</span>)<span class="id"> |</span><span class="id"> [Aut</span><span class="id"> G]</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> in_setI;</span><span class="id"> apply:</span><span class="id"> andb_id2l</span><span class="id"> =&gt;</span><span class="id"> Aa</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 3!inE</span><span class="id"> /=</span><span class="id"> -2!val_eqE</span><span class="id"> /=</span><span class="id"> val_Fp_nat</span><span class="id"> //</span><span class="id"> [1</span><span class="id"> %%</span><span class="id"> _]modn_small</span><span class="id"> //</span><span class="id"> defG1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/idP/subsetP=&gt;</span><span class="id"> [ma1</span><span class="id"> x1i</span><span class="id"> |</span><span class="id"> ma1]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;{x1i};</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> gactX</span><span class="id"> //</span><span class="id"> -[_</span><span class="id"> a]def_m</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[in</span><span class="id"> eqbLHS]</span>(<span class="id">expg_mod_order</span><span class="id"> x1</span>)<span class="id"> ox1</span> (<span class="id">eqP</span><span class="id"> ma1</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> ma1</span><span class="id"> x1</span> (<span class="id">cycle_id</span><span class="id"> x1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -[_</span><span class="id"> a]def_m</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eq_expg_mod_order</span><span class="id"> x1</span><span class="id"> _</span><span class="id"> 1</span>)<span class="id"> ox1</span> (<span class="id">modn_small</span><span class="id"> p_gt1</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> card_units_Fp:</span><span class="id"> #|[set:</span><span class="id"> {unit</span><span class="id"> 'F_p}]|</span><span class="id"> =</span><span class="id"> p</span>.<span class="id">-1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_units_Zp</span><span class="id"> //</span><span class="id"> pdiv_id</span><span class="id"> //</span> (<span class="id">@totient_pfactor</span><span class="id"> p</span><span class="id"> 1</span>)<span class="id"> ?muln1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ker_m0_P:</span><span class="id"> 'ker</span><span class="id"> m0</span><span class="id"> =</span><span class="id"> P</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> nilpotent_Hall_pcore</span><span class="id"> nilA</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> pHallE</span><span class="id"> -</span>(<span class="id">card_Hall</span><span class="id"> sylP</span>)<span class="id"> oP</span><span class="id"> subsetIl</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@eqn_pmul2r</span><span class="id"> #|m0</span><span class="id"> @*</span><span class="id"> A|</span>)<span class="id"> ?cardG_gt0</span><span class="id"> //;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{1}</span>(<span class="id">card_isog</span> (<span class="id">first_isog</span><span class="id"> _</span>))<span class="id"> card_quotient</span><span class="id"> ?ker_norm</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Lagrange</span><span class="id"> ?subsetIl</span><span class="id"> //</span><span class="id"> oA</span><span class="id"> im_m0</span><span class="id"> mulnC</span><span class="id"> card_units_Fp</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> inj_m0:</span><span class="id"> 'ker_F</span><span class="id"> m0</span><span class="id"> \subset</span><span class="id"> [1]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> ker_m0_P</span><span class="id"> tiPF</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /faithful</span><span class="id"> -ker_m0</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> isogF:</span><span class="id"> F</span><span class="id"> \isog</span><span class="id"> [set:</span><span class="id"> {unit</span><span class="id"> 'F_p}]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> sFA:</span><span class="id"> F</span><span class="id"> \subset</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> pcore_sub</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/isogP;</span><span class="gallina-kwd"> exists</span> (<span class="id">restrm_morphism</span><span class="id"> sFA</span><span class="id"> m0</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ker_restrm</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> subsetT</span><span class="id"> card_injm</span><span class="id"> ?ker_restrm</span><span class="id"> //=</span><span class="id"> oF</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_units_Fp</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">isog_cyclic</span><span class="id"> isogF</span>)<span class="id"> pdiv_id</span><span class="id"> //</span><span class="id"> -ox1</span> (<span class="id">isog_cyclic</span> (<span class="id">Zp_unit_isog</span><span class="id"> x1</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> Aut_prime_cyclic</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> ox1</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> m;</span><span class="id"> split=&gt;</span><span class="id"> {im_m</span><span class="id"> mV}//;</span><span class="id"> have</span><span class="id"> [n0</span><span class="id"> |</span><span class="id"> n_gt0]</span><span class="id"> :=</span><span class="id"> posnP</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> pcore_sub</span><span class="id"> oF</span><span class="id"> oA</span><span class="id"> n0</span><span class="id"> muln1</span><span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> [t</span><span class="id"> At</span><span class="id"> mt]:</span><span class="id"> {t</span><span class="id"> |</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> m</span><span class="id"> t</span><span class="id"> =</span><span class="id"> -1}%R</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> inv_m;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> Zp_cast</span><span class="id"> //</span><span class="id"> coprime_modr</span><span class="id"> modn_small</span><span class="id"> //</span><span class="id"> subn1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> coprimenP</span><span class="id"> //</span><span class="id"> ltnW</span>.<br/>
<span class="id">have</span><span class="id"> ot:</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> order_gt1</span><span class="id"> dvdn_leq</span><span class="id"> ?order_dvdn</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> move/</span>(<span class="id">congr1</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> mt</span><span class="id"> m1</span><span class="id"> eq_sym</span><span class="id"> -subr_eq0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> opprK</span><span class="id"> -val_eqE</span><span class="id"> /=</span><span class="id"> Zp_cast</span><span class="id"> ?modn_small</span><span class="id"> //</span><span class="id"> /q</span><span class="id"> oG</span><span class="id"> ltnW</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">leq_trans</span> (_<span class="id"> :</span><span class="id"> 2</span><span class="id"> ^</span><span class="id"> 2</span><span class="id"> &lt;=</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> 2</span>))<span class="id"> ?leq_sqr</span><span class="id"> ?leq_exp2l</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> apply:</span><span class="id"> inj_m;</span><span class="id"> rewrite</span><span class="id"> ?groupX</span><span class="id"> ?group1</span><span class="id"> ?mX</span><span class="id"> //</span><span class="id"> mt</span><span class="id"> -signr_odd</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> t;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">case</span><span class="id"> G4:</span> (<span class="id">~~</span><span class="id"> odd</span><span class="id"> p</span><span class="id"> &amp;&amp;</span> (<span class="id">n</span><span class="id"> ==</span><span class="id"> 1%N</span>)).<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">even_prime</span><span class="id"> p_pr</span>)<span class="id"> G4</span><span class="id"> =&gt;</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> -&gt;</span><span class="id"> //];</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="id"> /=;</span><span class="id"> move/eqP=&gt;</span><span class="id"> n1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> n1</span><span class="id"> /=;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> cycle_subG</span><span class="id"> At</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> oA</span><span class="id"> ot</span><span class="id"> p2</span><span class="id"> n1</span>.<br/>
<span class="id">pose</span><span class="id"> e0</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> :=</span><span class="id"> ~~</span><span class="id"> odd</span><span class="id"> p</span>.<br/>
<span class="id">have{inv_m}</span><span class="id"> [s</span><span class="id"> As</span><span class="id"> ms]:</span><span class="id"> {s</span><span class="id"> |</span><span class="id"> s</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> m</span><span class="id"> s</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> e0</span>.<span class="id">+1</span>).<span class="id">+1%:R}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> inv_m;</span><span class="id"> rewrite</span><span class="id"> val_Zp_nat</span><span class="id"> //</span><span class="id"> coprime_modr</span><span class="id"> /q</span><span class="id"> oG</span><span class="id"> coprime_pexpl</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@coprime_pexpl</span><span class="id"> e0</span>.<span class="id">+1</span>)<span class="id"> //</span><span class="id"> coprimenS</span>.<br/>
<span class="id">have</span><span class="id"> lt_e0_n:</span><span class="id"> e0</span><span class="id"> &lt;</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /e0;</span><span class="id"> case:</span> (<span class="id">~~</span><span class="id"> _</span>)<span class="id"> G4</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> rewrite</span><span class="id"> ltn_neqAle</span><span class="id"> eq_sym</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
<span class="id">pose</span><span class="id"> s0</span><span class="id"> :=</span><span class="id"> s</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> e0</span>.<span class="id">+1</span>)).<br/>
<span class="id">have</span><span class="id"> [ms0</span><span class="id"> os0]:</span><span class="id"> m</span><span class="id"> s0</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>).<span class="id">+1%:R</span><span class="id"> /\</span><span class="id"> #[s0]</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> m_se</span><span class="id"> e:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> =</span><span class="id"> 1</span><span class="id"> %[mod</span><span class="id"> p]</span><span class="id"> &amp;</span><span class="id"> m</span> (<span class="id">s</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> e</span>))<span class="id"> =</span> (<span class="id">k</span><span class="id"> *</span><span class="id"> p</span><span class="id"> ^</span> (<span class="id">e</span><span class="id"> +</span><span class="id"> e0</span>.<span class="id">+1</span>)).<span class="id">+1%:R</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> elim:</span><span class="id"> e</span><span class="id"> =&gt;</span><span class="id"> [|e</span><span class="id"> [k</span><span class="id"> k1</span><span class="id"> IHe]];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> 1%N;</span><span class="id"> rewrite</span><span class="id"> ?mul1n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expnSr</span><span class="id"> expgM</span><span class="id"> mX</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> {}IHe</span><span class="id"> -natrX</span><span class="id"> -</span>(<span class="id">add1n</span> (<span class="id">k</span><span class="id"> *</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expnDn</span><span class="id"> -</span>(<span class="id">prednK</span><span class="id"> p_gt0</span>)<span class="id"> 2!big_ord_recl</span><span class="id"> /=</span><span class="id"> prednK</span><span class="id"> //</span><span class="id"> !exp1n</span><span class="id"> bin1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> bin0</span><span class="id"> muln1</span><span class="id"> mul1n</span><span class="id"> mulnCA</span><span class="id"> -expnS</span> (<span class="id">addSn</span><span class="id"> e</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">set</span><span class="id"> f</span><span class="id"> :=</span> (<span class="id">e</span><span class="id"> +</span><span class="id"> _</span>)<span class="id">%N;</span><span class="id"> set</span><span class="id"> sum</span><span class="id"> :=</span> (<span class="id">\sum_i</span><span class="id"> _</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">sum</span><span class="id"> %/</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> f</span>.<span class="id">+2</span><span class="id"> *</span><span class="id"> p</span><span class="id"> +</span><span class="id"> k</span>)<span class="id">%N;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> modnMDl</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">addnC</span><span class="id"> k</span>)<span class="id"> mulnDl</span><span class="id"> -mulnA</span><span class="id"> -expnS</span><span class="id"> divnK</span><span class="id"> //</span><span class="id"> {}/sum</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply</span><span class="id"> big_ind</span><span class="id"> =&gt;</span><span class="id"> [||[i</span><span class="id"> _]</span><span class="id"> /=</span><span class="id"> _];</span><span class="id"> [exact:</span><span class="id"> dvdn0</span><span class="id"> |</span><span class="id"> exact:</span><span class="id"> dvdn_add</span><span class="id"> |]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> exp1n</span><span class="id"> mul1n</span><span class="id"> /bump</span><span class="id"> !add1n</span><span class="id"> expnMn</span><span class="id"> mulnCA</span><span class="id"> dvdn_mull</span><span class="id"> //</span><span class="id"> -expnM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">ltnP</span><span class="id"> f</span>.<span class="id">+1</span> (<span class="id">f</span><span class="id"> *</span><span class="id"> i</span>.<span class="id">+2</span>))<span class="id"> =&gt;</span><span class="id"> [le_f_fi|]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_mull</span><span class="id"> ?dvdn_exp2l</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1}mulnS</span><span class="id"> -</span>(<span class="id">addn1</span><span class="id"> f</span>)<span class="id"> leq_add2l</span><span class="id"> {}/f</span><span class="id"> addnS</span><span class="id"> /e0</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> i</span><span class="id"> e</span><span class="id"> =&gt;</span><span class="id"> []</span><span class="id"> //</span><span class="id"> []</span><span class="id"> //;</span><span class="id"> case</span><span class="id"> odd_p:</span> (<span class="id">odd</span><span class="id"> p</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bin2odd</span><span class="id"> //</span><span class="id"> mulnAC</span><span class="id"> dvdn_mulr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[|d]]</span><span class="id"> :=</span><span class="id"> m_se</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> e0</span>.<span class="id">+1</span>)<span class="id">%N;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mod0n</span><span class="id"> modn_small</span>.<br/>
&nbsp;&nbsp;<span class="id">move/eqP;</span><span class="id"> rewrite</span><span class="id"> -/s0</span><span class="id"> eqn_mod_dvd</span><span class="id"> ?subn1</span><span class="id"> //=;</span><span class="id"> case/dvdnP=&gt;</span><span class="id"> f</span><span class="id"> -&gt;</span><span class="id"> {d}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> subnK</span><span class="id"> //</span><span class="id"> mulSn</span><span class="id"> -mulnA</span><span class="id"> -expnS</span><span class="id"> -addSn</span><span class="id"> natrD</span><span class="id"> natrM</span><span class="id"> -oG</span><span class="id"> pchar_Zp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulr0</span><span class="id"> addr0</span><span class="id"> =&gt;</span><span class="id"> m_s0;</span><span class="id"> split</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [d</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> m_se</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> e0</span>)<span class="id">%N;</span><span class="id"> rewrite</span><span class="id"> -subnSK</span><span class="id"> //</span><span class="id"> expnSr</span><span class="id"> expgM</span><span class="id"> -/s0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addSn</span><span class="id"> subnK</span><span class="id"> //</span><span class="id"> -oG</span> <span class="id"> mulrS</span><span class="id"> natrM</span><span class="id"> pchar_Zp</span><span class="id"> //</span><span class="id"> {d}mulr0</span><span class="id"> addr0</span>.<br/>
&nbsp;&nbsp;<span class="id">move/eqP;</span><span class="id"> rewrite</span><span class="id"> -m1</span> (<span class="id">inj_in_eq</span><span class="id"> inj_m</span>)<span class="id"> ?group1</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> -order_dvdn</span>.<br/>
&nbsp;&nbsp;<span class="id">move/min_p;</span><span class="id"> rewrite</span><span class="id"> order_eq1;</span><span class="id"> case/predU1P=&gt;</span><span class="id"> [s0_1</span><span class="id"> |</span><span class="id"> ];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move/eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">move/eqP:</span><span class="id"> m_s0;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> s0_1</span><span class="id"> m1</span><span class="id"> -subr_eq0</span><span class="id"> mulrSr</span><span class="id"> addrK</span><span class="id"> -val_eqE</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> pf_gt0:</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> _</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> e;</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span><span class="id"> p_gt0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> val_Zp_nat</span><span class="id"> //</span><span class="id"> /q</span><span class="id"> oG</span><span class="id"> [_</span><span class="id"> ==</span><span class="id"> _]pfactor_dvdn</span><span class="id"> //</span><span class="id"> pfactorK</span><span class="id"> ?ltnn</span>.<br/>
<span class="id">have</span><span class="id"> os:</span><span class="id"> #[s]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> e0</span>))<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> #[s]</span><span class="id"> %|</span><span class="id"> p</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> e0</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> order_dvdn</span><span class="id"> -subnSK</span><span class="id"> //</span><span class="id"> expnSr</span><span class="id"> expgM</span><span class="id"> -order_dvdn</span><span class="id"> os0</span>.<br/>
&nbsp;&nbsp;<span class="id">case/dvdn_pfactor=&gt;</span><span class="id"> //</span><span class="id"> d;</span><span class="id"> rewrite</span><span class="id"> leq_eqVlt</span>.<br/>
&nbsp;&nbsp;<span class="id">case/predU1P=&gt;</span><span class="id"> [-&gt;</span><span class="id"> //</span><span class="id"> |</span><span class="id"> lt_d</span><span class="id"> os];</span><span class="id"> case/idPn:</span> (<span class="id">p_gt1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -os0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> order_gt1</span><span class="id"> negbK</span><span class="id"> -order_dvdn</span><span class="id"> os</span><span class="id"> dvdn_exp2l</span><span class="id"> //</span><span class="id"> -ltnS</span><span class="id"> -subSn</span>.<br/>
<span class="id">have</span><span class="id"> p_s:</span><span class="id"> p</span>.<span class="id">-elt</span><span class="id"> s</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /p_elt</span><span class="id"> os</span><span class="id"> pnatX</span><span class="id"> ?pnat_id</span>.<br/>
<span class="id">have</span><span class="id"> defS1:</span><span class="id"> 'Ohm_1</span>(<span class="id">&lt;[s]&gt;</span>)<span class="id"> =</span><span class="id"> &lt;[s0]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> cycle_subG</span><span class="id"> -orderE</span><span class="id"> os0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">Ohm1_cyclic_pgroup_prime</span><span class="id"> _</span><span class="id"> p_s</span>)<span class="id"> ?cycle_cyclic</span><span class="id"> ?leqnn</span><span class="id"> ?cycle_eq1</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> p_s</span>)<span class="id"> mem_gen</span><span class="id"> ?groupX</span><span class="id"> //=</span><span class="id"> !inE</span><span class="id"> mem_cycle</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> os0</span><span class="id"> ?dvdnn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP=&gt;</span><span class="id"> s1;</span><span class="id"> rewrite</span><span class="id"> -os0</span><span class="id"> /s0</span><span class="id"> s1</span><span class="id"> expg1n</span><span class="id"> order1</span><span class="gallina-kwd"> in</span><span class="id"> p_gt1</span>.<br/>
<span class="id">case:</span> (<span class="id">even_prime</span><span class="id"> p_pr</span>)<span class="id"> =&gt;</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> oddp];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {+}/e0</span><span class="id"> oddp</span><span class="id"> subn0</span><span class="gallina-kwd"> in</span><span class="id"> s0</span><span class="id"> os0</span><span class="id"> ms0</span><span class="id"> os</span><span class="id"> ms</span><span class="id"> defS1</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [f</span><span class="id"> defF]</span><span class="id"> :=</span><span class="id"> cyclicP</span><span class="id"> cycF;</span><span class="id"> have</span><span class="id"> defP:</span><span class="id"> P</span><span class="id"> =</span><span class="id"> &lt;[s]&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> -orderE</span><span class="id"> oP</span><span class="id"> os</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subG</span> (<span class="id">mem_normal_Hall</span><span class="id"> sylP</span>)<span class="id"> ?pcore_normal</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defP;</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> 1</span><span class="id"> [by</span><span class="gallina-kwd"> exists</span><span class="id"> s</span><span class="id"> |</span><span class="gallina-kwd"> by</span><span class="gallina-kwd"> exists</span><span class="id"> s0;</span><span class="id"> rewrite</span><span class="id"> ?groupX]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defPF</span><span class="id"> defP</span><span class="id"> defF</span><span class="id"> -cycleM</span><span class="id"> ?cycle_cyclic</span><span class="id"> //</span><span class="id"> /order</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> red;</span><span class="id"> rewrite</span> (<span class="id">centsP</span><span class="id"> cAA</span>)<span class="id"> //</span><span class="id"> -cycle_subG</span><span class="id"> -defF</span><span class="id"> pcore_sub</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defF</span><span class="id"> -defP</span> (<span class="id">pnat_coprime</span> (<span class="id">pcore_pgroup</span><span class="id"> _</span><span class="id"> _</span>) (<span class="id">pcore_pgroup</span><span class="id"> _</span><span class="id"> _</span>)).<br/>
<span class="id">rewrite</span><span class="id"> {+}/e0</span><span class="id"> p2</span><span class="id"> subn1</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> s0</span><span class="id"> os0</span><span class="id"> ms0</span><span class="id"> os</span><span class="id"> ms</span><span class="id"> G4</span><span class="id"> defS1</span><span class="id"> lt_e0_n</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> G4;</span><span class="gallina-kwd"> exists</span><span class="id"> s;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> s0;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?groupX</span><span class="id"> //;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> mM</span><span class="id"> ?groupX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ms0</span><span class="id"> mt</span><span class="id"> eq_sym</span><span class="id"> mulrN1</span><span class="id"> -subr_eq0</span><span class="id"> opprK</span><span class="id"> -natrD</span><span class="id"> -addSnnS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prednK</span><span class="id"> ?expn_gt0</span><span class="id"> //</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> -expnS</span><span class="id"> -p2</span><span class="id"> -oG</span><span class="id"> pchar_Zp</span>.<br/>
<span class="id">suffices</span><span class="id"> TIst:</span><span class="id"> &lt;[s]&gt;</span><span class="id"> :&amp;:</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dprodE</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sub_abelian_cent2</span><span class="id"> cAA</span>)<span class="id"> ?cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> mulG_subG</span><span class="id"> !cycle_subG</span><span class="id"> As</span><span class="id"> At</span><span class="id"> oA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> TI_cardMg</span><span class="id"> //</span><span class="id"> -!orderE</span><span class="id"> os</span><span class="id"> ot</span><span class="id"> p2</span><span class="id"> mul1n</span><span class="id"> /=</span><span class="id"> -expnSr</span><span class="id"> prednK</span>.<br/>
<span class="id">rewrite</span><span class="id"> setIC;</span><span class="id"> apply:</span><span class="id"> prime_TIg;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> ot</span>.<br/>
<span class="id">rewrite</span><span class="id"> cycle_subG;</span><span class="id"> apply/negP=&gt;</span><span class="id"> St</span>.<br/>
<span class="id">have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> &lt;[s0]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defS1</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> p_s</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> St</span><span class="id"> -order_dvdn</span><span class="id"> ot</span><span class="id"> p2</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> &lt;[s0]&gt;</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> 1;</span><span class="id"> s0]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> subUset</span><span class="id"> !sub1set</span><span class="id"> group1</span><span class="id"> cycle_id</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> cards2</span><span class="id"> eq_sym</span><span class="id"> -order_gt1</span><span class="id"> os0</span>.<br/>
<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> -order_eq1</span><span class="id"> ot</span><span class="id"> /=;</span><span class="id"> move/eqP;</span><span class="id"> move/</span>(<span class="id">congr1</span><span class="id"> m</span>)<span class="id">;</span><span class="id"> move/eqP</span>.<br/>
<span class="id">rewrite</span><span class="id"> mt</span><span class="id"> ms0</span><span class="id"> eq_sym</span><span class="id"> -subr_eq0</span><span class="id"> opprK</span><span class="id"> -mulrSr</span>.<br/>
<span class="id">rewrite</span><span class="id"> -val_eqE</span><span class="id"> [val</span><span class="id"> _]val_Zp_nat</span><span class="id"> //=</span><span class="id"> /q</span><span class="id"> oG</span><span class="id"> p2</span><span class="id"> modn_small</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -addn3</span><span class="id"> expnS</span><span class="id"> mul2n</span><span class="id"> -addnn</span><span class="id"> leq_add2l</span> (<span class="id">ltn_exp2l</span><span class="id"> 1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> extremal_generators</span><span class="id"> gT</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>)<span class="id"> p</span><span class="id"> n</span><span class="id"> xy</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> :=</span><span class="id"> xy</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> #|A|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N,</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> A,</span><span class="id"> #[x]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> A</span><span class="id"> :\:</span><span class="id"> &lt;[x]&gt;]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> extremal_generators_facts</span><span class="id"> gT</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> p</span><span class="id"> n</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">prime</span><span class="id"> p</span><span class="id"> -&gt;</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> p</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> G,</span><span class="id"> maximal</span><span class="id"> &lt;[x]&gt;</span><span class="id"> G,</span><span class="id"> &lt;[x]&gt;</span><span class="id"> &lt;|</span><span class="id"> G,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&lt;[x]&gt;</span><span class="id"> *</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> &lt;[y]&gt;</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">&lt;[x]&gt;</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> p_pr</span><span class="id"> [oG</span><span class="id"> Gx</span><span class="id"> ox]</span><span class="id"> /setDP[Gy</span><span class="id"> notXy]</span>.<br/>
<span class="id">have</span><span class="id"> pG:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pgroup</span><span class="id"> oG</span><span class="id"> pnatX</span><span class="id"> pnat_id</span>.<br/>
<span class="id">have</span><span class="id"> maxX:</span><span class="id"> maximal</span><span class="id"> &lt;[x]&gt;</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> p_index_maximal</span><span class="id"> -?divgS</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> oG</span><span class="id"> ox</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">n</span>)<span class="id"> oG</span><span class="id"> =&gt;</span><span class="id"> [|n'</span><span class="id"> _];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -expnB</span><span class="id"> ?subSnn</span><span class="id"> ?leqnSn</span><span class="id"> ?prime_gt0</span>.<br/>
&nbsp;&nbsp;<span class="id">move/eqP;</span><span class="id"> rewrite</span><span class="id"> -trivg_card1;</span><span class="id"> case/trivgPn</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> //</span> (<span class="id">group1_contra</span><span class="id"> notXy</span>).<br/>
<span class="id">have</span><span class="id"> nsXG</span><span class="id"> :=</span><span class="id"> p_maximal_normal</span><span class="id"> pG</span><span class="id"> maxX;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> mulg_normal_maximal;</span><span class="id"> rewrite</span><span class="id"> ?cycle_subG</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subG</span> (<span class="id">subsetP</span> (<span class="id">normal_norm</span><span class="id"> nsXG</span>)).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ModularGroup</span>.<br/>
<br/>
<span class="vernacular">Variables</span><span class="id"> p</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Let</span><span class="id"> m</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> r</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span>.<br/>
<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">p_pr</span><span class="id"> :</span><span class="id"> prime</span><span class="id"> p</span>) (<span class="id">n_gt2</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span>).<br/>
<span class="vernacular">Let</span><span class="id"> p_gt1</span><span class="id"> :=</span><span class="id"> prime_gt1</span><span class="id"> p_pr</span>.<br/>
<span class="vernacular">Let</span><span class="id"> p_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> p_gt1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> def_n</span><span class="id"> :=</span><span class="id"> esym</span> (<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
<span class="vernacular">Let</span><span class="id"> def_p</span><span class="id"> :</span><span class="id"> pdiv</span><span class="id"> m</span><span class="id"> =</span><span class="id"> p</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> def_n</span><span class="id"> pdiv_pfactor</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> def_q</span><span class="id"> :</span><span class="id"> m</span><span class="id"> %/</span><span class="id"> p</span><span class="id"> =</span><span class="id"> q</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> /q</span><span class="id"> def_n</span><span class="id"> expnS</span><span class="id"> mulKn</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> def_r</span><span class="id"> :</span><span class="id"> q</span><span class="id"> %/</span><span class="id"> p</span><span class="id"> =</span><span class="id"> r</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /r</span><span class="id"> /q</span><span class="id"> def_n</span><span class="id"> expnS</span><span class="id"> mulKn</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> ltqm</span><span class="id"> :</span><span class="id"> q</span><span class="id"> &lt;</span><span class="id"> m</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltn_exp2l</span><span class="id"> //</span><span class="id"> def_n</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> ltrq</span><span class="id"> :</span><span class="id"> r</span><span class="id"> &lt;</span><span class="id"> q</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltn_exp2l</span><span class="id"> //</span><span class="id"> def_n</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> r_gt0</span><span class="id"> :</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> r</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span><span class="id"> ?p_gt0</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> q_gt1</span><span class="id"> :</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id"> exact:</span><span class="id"> leq_ltn_trans</span><span class="id"> r_gt0</span><span class="id"> ltrq</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_modular_group</span><span class="id"> :</span><span class="id"> #|'Mod_</span>(<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Extremal</span>.<span class="id">card</span><span class="id"> def_p</span><span class="id"> ?def_q</span><span class="id"> //</span><span class="id"> -expnS</span><span class="id"> def_n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp_modular_group</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">'Mod_</span>(<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">+1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /modular_gtype</span><span class="id"> def_p</span><span class="id"> def_q</span><span class="id"> def_r;</span><span class="id"> apply:</span><span class="id"> Extremal</span>.<span class="id">Grp</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
<span class="id">set</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> &lt;[_]&gt;;</span><span class="id"> have</span><span class="id"> Bb:</span><span class="id"> Zp1</span><span class="id"> \in</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> oB:</span><span class="id"> #|B|</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> order_Zp1</span><span class="id"> Zp_cast</span>.<br/>
<span class="id">have</span><span class="id"> cycB:</span><span class="id"> cyclic</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cycle_cyclic</span>.<br/>
<span class="id">have</span><span class="id"> pB:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pgroup</span><span class="id"> oB</span><span class="id"> pnatX</span><span class="id"> ?pnat_id</span>.<br/>
<span class="id">have</span><span class="id"> ntB:</span><span class="id"> B</span><span class="id"> !=</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oB</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> cyclic_pgroup_Aut_structure</span><span class="id"> pB</span><span class="id"> cycB</span><span class="id"> ntB</span>.<br/>
<span class="id">rewrite</span><span class="id"> oB</span><span class="id"> pfactorK</span><span class="id"> //=</span><span class="id"> -/B</span><span class="id"> -</span>(<span class="id">expg_znat</span><span class="id"> r</span>.<span class="id">+1</span><span class="id"> Bb</span>)<span class="id"> oB</span><span class="id"> =&gt;</span><span class="id"> mB</span><span class="id"> [[def_mB</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> _]</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}def_n</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [[t</span><span class="id"> [At</span><span class="id"> ot</span><span class="id"> mBt]]]</span>.<br/>
<span class="id">have</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> even_prime</span><span class="id"> p_pr;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [s</span><span class="id"> [As</span><span class="id"> os</span><span class="id"> mBs</span><span class="id"> _]];</span><span class="gallina-kwd"> exists</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> os</span><span class="id"> -mBs</span><span class="id"> def_mB</span>.<br/>
<span class="id">rewrite</span><span class="id"> {1}p2</span><span class="id"> /=</span><span class="id"> -2!eqSS</span><span class="id"> -addn2</span><span class="id"> -2!{1}subn1</span><span class="id"> -subnDA</span><span class="id"> subnK</span><span class="id"> 1?ltnW</span><span class="id"> //</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [n3</span><span class="id"> _</span><span class="id"> |</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [s</span><span class="id"> [As</span><span class="id"> os</span><span class="id"> mBs</span><span class="id"> _</span><span class="id"> _]{t</span><span class="id"> At</span><span class="id"> ot</span><span class="id"> mBt}]]]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> At</span><span class="id"> ot</span><span class="id"> -def_mB</span><span class="id"> //</span><span class="id"> mBt</span><span class="id"> /q</span><span class="id"> /r</span><span class="id"> p2</span><span class="id"> n3</span>.<br/>
<span class="gallina-kwd">by</span><span class="gallina-kwd"> exists</span><span class="id"> s;</span><span class="id"> rewrite</span><span class="id"> As</span><span class="id"> os</span><span class="id"> -def_mB</span><span class="id"> //</span><span class="id"> mBs</span><span class="id"> /r</span><span class="id"> p2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> modular_group_generators</span><span class="id"> gT</span> (<span class="id">xy</span><span class="id"> :</span><span class="id"> gT</span><span class="id"> *</span><span class="id"> gT</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">let:</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> :=</span><span class="id"> xy</span><span class="gallina-kwd"> in</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> p</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">+1</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> generators_modular_group</span><span class="id"> gT</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \isog</span><span class="id"> 'Mod_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> xy,</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> p</span><span class="id"> n</span><span class="id"> xy</span><span class="id"> &amp;</span><span class="id"> modular_group_generators</span><span class="id"> xy</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">case/</span>(<span class="id">isoGrpP</span><span class="id"> _</span><span class="id"> Grp_modular_group</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> card_modular_group</span><span class="id"> //</span><span class="id"> -/m</span><span class="id"> =&gt;</span><span class="id"> oG</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=</span><span class="id"> /eqP[defG</span><span class="id"> xq</span><span class="id"> yp</span><span class="id"> xy]</span>.<br/>
<span class="id">rewrite</span><span class="id"> norm_joinEr</span><span class="id"> ?norms_cycle</span><span class="id"> ?xy</span><span class="id"> ?mem_cycle</span><span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> defG</span>.<br/>
<span class="id">have</span><span class="id"> [Gx</span><span class="id"> Gy]:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> /\</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/andP;</span><span class="id"> rewrite</span><span class="id"> -!cycle_subG</span><span class="id"> -mulG_subG</span><span class="id"> defG</span>.<br/>
<span class="id">have</span><span class="id"> notXy:</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> &lt;[x]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> ltqm;</span><span class="id"> rewrite</span><span class="id"> -cycle_subG</span><span class="id"> -oG</span><span class="id"> -defG;</span><span class="id"> move/mulGidPl-&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> dvdn_leq</span><span class="id"> ?</span>(<span class="id">ltnW</span><span class="id"> q_gt1</span>)<span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> oy:</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> nt_prime_order</span> (<span class="id">group1_contra</span><span class="id"> notXy</span>).<br/>
<span class="gallina-kwd">exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> ?notXy</span><span class="id"> //</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">eqn_pmul2r</span><span class="id"> p_gt0</span>)<span class="id"> -expnSr</span><span class="id"> -{1}oy</span> (<span class="id">ltn_predK</span><span class="id"> n_gt2</span>)<span class="id"> -/m</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -TI_cardMg</span><span class="id"> ?defG</span><span class="id"> ?oG</span><span class="id"> //</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> oy</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modular_group_structure</span><span class="id"> gT</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extremal_generators</span><span class="id"> G</span><span class="id"> p</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">G</span><span class="id"> \isog</span><span class="id"> 'Mod_m</span><span class="id"> -&gt;</span><span class="id"> modular_group_generators</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> &lt;[x]&gt;</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> [/\</span><span class="id"> X</span><span class="id"> &gt;&lt;|</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> G,</span><span class="id"> ~~</span><span class="id"> abelian</span><span class="id"> G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> j,</span><span class="id"> z</span><span class="id"> ^</span> (<span class="id">y</span><span class="id"> ^+</span><span class="id"> j</span>)<span class="id"> =</span><span class="id"> z</span><span class="id"> ^+</span> (<span class="id">j</span><span class="id"> *</span><span class="id"> r</span>).<span class="id">+1}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;,</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> &amp;</span><span class="id"> #|'Z</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> r],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;,</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> p</span><span class="id"> &amp;</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> 2],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> 'Mho^k</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">]&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> if</span> (<span class="id">p,</span><span class="id"> n</span>)<span class="id"> ==</span> (<span class="id">2,</span><span class="id"> 3</span>)<span class="gallina-kwd"> then</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> 0</span><span class="id"> &lt;</span><span class="id"> k</span><span class="id"> &lt;</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&lt;[x</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> k</span>.<span class="id">+1</span>))<span class="id">]&gt;</span><span class="id"> \x</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_k</span>(<span class="id">G</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">/\</span><span class="id"> #|'Ohm_k</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> k</span>.<span class="id">+1</span>)<span class="id">%N]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> genG</span><span class="id"> isoG</span><span class="id"> [oy</span><span class="id"> xy]</span><span class="id"> X</span>.<br/>
<span class="id">have</span><span class="id"> [oG</span><span class="id"> Gx</span><span class="id"> ox</span><span class="id"> /setDP[Gy</span><span class="id"> notXy]]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/m</span><span class="id"> -/q</span><span class="gallina-kwd"> in</span><span class="id"> ox</span><span class="id"> oG</span>.<br/>
<span class="id">have</span><span class="id"> [pG</span><span class="id"> _</span><span class="id"> nsXG</span><span class="id"> defXY</span><span class="id"> nXY]</span><span class="id"> :=</span><span class="id"> extremal_generators_facts</span><span class="id"> p_pr</span><span class="id"> genG</span>.<br/>
<span class="id">have</span><span class="id"> [sXG</span><span class="id"> nXG]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsXG;</span><span class="id"> have</span><span class="id"> sYG:</span><span class="id"> &lt;[y]&gt;</span><span class="id"> \subset</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cycle_subG</span>.<br/>
<span class="id">have</span><span class="id"> n1_gt1:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> [rewrite</span><span class="id"> def_n];</span><span class="id"> have</span><span class="id"> n1_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n1_gt1</span>.<br/>
<span class="id">have</span><span class="id"> def_n1</span><span class="id"> :=</span><span class="id"> prednK</span><span class="id"> n1_gt0</span>.<br/>
<span class="id">have</span><span class="id"> def_m:</span> (<span class="id">q</span><span class="id"> *</span><span class="id"> p</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> m</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -expnSr</span><span class="id"> /m</span><span class="id"> def_n</span>.<br/>
<span class="id">have</span><span class="id"> notcxy:</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> 'C[x]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span> (<span class="id">introT</span><span class="id"> eqP</span><span class="id"> xy</span>)<span class="id">;</span><span class="id"> move/cent1P=&gt;</span><span class="id"> cxy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /conjg</span><span class="id"> -cxy</span><span class="id"> //</span><span class="id"> eq_mulVg1</span><span class="id"> expgS</span><span class="id"> !mulKg</span><span class="id"> -order_dvdn</span><span class="id"> ox</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pfactor_dvdn</span><span class="id"> ?expn_gt0</span><span class="id"> ?p_gt0</span><span class="id"> //</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -ltnNge</span><span class="id"> prednK</span>.<br/>
<span class="id">have</span><span class="id"> tiXY:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> :&amp;:</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> -?orderE</span><span class="id"> ?oy</span><span class="id"> //;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> notcxy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subG;</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> rewrite</span><span class="id"> cycle_subG</span><span class="id"> cent1id</span>.<br/>
<span class="id">have</span><span class="id"> notcGG:</span><span class="id"> ~~</span><span class="id"> abelian</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defXY</span><span class="id"> abelianM</span><span class="id"> !cycle_abelian</span><span class="id"> cent_cycle</span><span class="id"> cycle_subG</span>.<br/>
<span class="id">have</span><span class="id"> cXpY:</span><span class="id"> &lt;[y]&gt;</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">&lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cent_cycle</span><span class="id"> cycle_subG</span><span class="id"> cent1C</span> (<span class="id">sameP</span><span class="id"> cent1P</span><span class="id"> commgP</span>)<span class="id"> /commg</span><span class="id"> conjXg</span><span class="id"> xy</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> mulSn</span><span class="id"> expgD</span><span class="id"> mulKg</span><span class="id"> -expnSr</span><span class="id"> def_n1</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> expg_order</span>.<br/>
<span class="id">have</span><span class="id"> oxp:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> p]</span><span class="id"> =</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> ?dvdn_exp</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> [sZG</span><span class="id"> nZG]</span><span class="id"> :=</span><span class="id"> andP</span> (<span class="id">center_normal</span><span class="id"> G</span>).<br/>
<span class="id">have</span><span class="id"> defZ:</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> subsetI</span><span class="id"> -{2}defXY</span><span class="id"> centM</span><span class="id"> subsetI</span><span class="id"> cent_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2!cycle_subG</span><span class="id"> !groupX</span><span class="id"> ?cent1id</span><span class="id"> //=</span><span class="id"> centsC</span><span class="id"> cXpY</span><span class="id"> /=</span><span class="id"> -orderE</span><span class="id"> oxp</span><span class="id"> leqNgt</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contra</span><span class="id"> notcGG</span><span class="id"> =&gt;</span><span class="id"> gtZr;</span><span class="id"> apply:</span><span class="id"> cyclic_center_factor_abelian</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">dvdn_prime_cyclic</span><span class="id"> p_pr</span>)<span class="id"> //</span><span class="id"> card_quotient</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dvdn_pmul2l</span> (<span class="id">cardG_gt0</span><span class="id"> 'Z</span>(<span class="id">G</span>)))<span class="id"> Lagrange</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -def_m</span><span class="id"> dvdn_pmul2r</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case/p_natP:</span> (<span class="id">pgroupS</span><span class="id"> sZG</span><span class="id"> pG</span>)<span class="id"> gtZr</span><span class="id"> =&gt;</span><span class="id"> k</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltn_exp2l</span><span class="id"> //</span><span class="id"> def_n1;</span><span class="id"> apply:</span><span class="id"> dvdn_exp2l</span>.<br/>
<span class="id">have</span><span class="id"> Zxr:</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span><span class="id"> \in</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /r</span><span class="id"> def_n</span><span class="id"> expnS</span><span class="id"> expgM</span><span class="id"> defZ</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> rxy:</span><span class="id"> [~</span><span class="id"> x,</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /commg</span><span class="id"> xy</span><span class="id"> expgS</span><span class="id"> mulKg</span>.<br/>
<span class="id">have</span><span class="id"> defG':</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setIP:</span><span class="id"> Zxr</span><span class="id"> =&gt;</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -rxy</span><span class="id"> -defXY</span><span class="id"> -</span>(<span class="id">norm_joinEr</span><span class="id"> nXY</span>).<br/>
&nbsp;&nbsp;<span class="id">exact:</span><span class="id"> der1_joing_cycles</span>.<br/>
<span class="id">have</span><span class="id"> oG':</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defG'</span><span class="id"> -orderE</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> /q</span><span class="id"> -def_n1</span><span class="id"> ?dvdn_exp2l</span><span class="id"> //</span><span class="id"> expnS</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> sG'Z:</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> \subset</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defG'</span><span class="id"> cycle_subG</span>.<br/>
<span class="id">have</span><span class="id"> nil2_G:</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> andbC</span><span class="id"> ltnNge</span><span class="id"> nil_class1</span><span class="id"> notcGG</span><span class="id"> nil_class2</span>.<br/>
<span class="id">have</span><span class="id"> XYp:</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> &lt;[y]&gt;,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><br/>
&nbsp;&nbsp;&nbsp;(<span class="id">z</span><span class="id"> *</span><span class="id"> t</span>)<span class="id"> ^+</span><span class="id"> p</span><span class="id"> \in</span><span class="id"> z</span><span class="id"> ^+</span><span class="id"> p</span><span class="id"> *:</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r</span><span class="id"> ^+</span><span class="id"> 'C</span>(<span class="id">p,</span><span class="id"> 2</span>)<span class="id">]&gt;}</span>.<br/>
<span class="id">-</span><span class="id"> move=&gt;</span><span class="id"> z</span><span class="id"> t</span><span class="id"> Xz</span><span class="id"> Yt;</span><span class="id"> have</span><span class="id"> Gz</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sXG</span><span class="id"> z</span><span class="id"> Xz;</span><span class="id"> have</span><span class="id"> Gt</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sYG</span><span class="id"> t</span><span class="id"> Yt</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Rtz:</span><span class="id"> [~</span><span class="id"> t,</span><span class="id"> z]</span><span class="id"> \in</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> mem_commg</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cGtz:</span><span class="id"> [~</span><span class="id"> t,</span><span class="id"> z]</span><span class="id"> \in</span><span class="id"> 'C</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> case/setIP:</span> (<span class="id">subsetP</span><span class="id"> sG'Z</span><span class="id"> _</span><span class="id"> Rtz</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expMg_Rmul</span><span class="id"> /commute</span><span class="id"> ?</span>(<span class="id">centP</span><span class="id"> cGtz</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> t</span><span class="id"> ^+</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> -oy</span><span class="id"> order_dvdG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defG'</span><span class="gallina-kwd"> in</span><span class="id"> Rtz;</span><span class="id"> case/cycleP:</span><span class="id"> Rtz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mem_lcoset</span><span class="id"> mulg1</span><span class="id"> mulKg</span><span class="id"> expgAC</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> defMho:</span><span class="id"> 'Mho^1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> cycle_subG</span> (<span class="id">Mho_p_elt</span><span class="id"> 1</span>)<span class="id"> ?</span>(<span class="id">mem_p_elt</span><span class="id"> pG</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> andbT</span> (<span class="id">MhoE</span><span class="id"> 1</span><span class="id"> pG</span>)<span class="id"> gen_subG</span><span class="id"> -defXY;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> ztp</span>.<br/>
&nbsp;&nbsp;<span class="id">case/imsetP=&gt;</span><span class="id"> zt;</span><span class="id"> case/imset2P=&gt;</span><span class="id"> z</span><span class="id"> t</span><span class="id"> Xz</span><span class="id"> Yt</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {zt</span><span class="id"> ztp}</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subsetP</span> (<span class="id">XYp</span><span class="id"> z</span><span class="id"> t</span><span class="id"> Xz</span><span class="id"> Yt</span>)<span class="id">;</span><span class="id"> case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expgAC</span><span class="id"> mul_subG</span><span class="id"> ?sub1set</span><span class="id"> ?mem_cycle</span><span class="id"> //=</span><span class="id"> -defZ</span><span class="id"> cycle_subG</span><span class="id"> groupX</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> try</span><span class="id"> exact:</span><span class="id"> extend_cyclic_Mho</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> sdprodE</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> z;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;{z}</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> conjXg</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> actX;</span><span class="id"> congr</span> (_<span class="id"> ^+</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> j</span><span class="id"> {i}</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> j</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> conjXg</span><span class="id"> xy</span><span class="id"> -!expgM</span><span class="id"> mulnS</span><span class="id"> mulSn</span><span class="id"> addSn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addnA</span><span class="id"> -mulSn</span><span class="id"> -addSn</span><span class="id"> expgD</span><span class="id"> mulnCA</span> (<span class="id">mulnC</span><span class="id"> j</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {3}/r</span><span class="id"> def_n</span><span class="id"> expnS</span><span class="id"> mulnA</span><span class="id"> -expnSr</span><span class="id"> def_n1</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> -mulnA</span><span class="id"> expgM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expg_order</span><span class="id"> expg1n</span><span class="id"> mulg1</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pG</span>)<span class="id"> defMho</span><span class="id"> -defZ</span> (<span class="id">joing_idPr</span><span class="id"> _</span>)<span class="id"> ?defZ</span>.<br/>
<span class="id">have</span><span class="id"> G1y:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Gy</span><span class="id"> -order_dvdn</span><span class="id"> oy</span><span class="id"> /=</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [[p2</span><span class="id"> n3]</span><span class="id"> |</span><span class="id"> notG8</span><span class="id"> k];</span><span class="id"> last</span><span class="id"> case/andP=&gt;</span><span class="id"> k_gt0</span><span class="id"> lt_k_n1</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> Ohm_sub</span><span class="id"> -{1}defXY</span><span class="id"> mulG_subG</span><span class="id"> !cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> G1y</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span><span class="id"> G1y</span>)<span class="id"> /=</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> groupM</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /q</span><span class="id"> /r</span><span class="id"> p2</span><span class="id"> n3</span><span class="gallina-kwd"> in</span><span class="id"> oy</span><span class="id"> ox</span><span class="id"> xy</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expgS</span><span class="id"> -mulgA</span><span class="id"> -{1}</span>(<span class="id">invg2id</span><span class="id"> oy</span>)<span class="id"> -conjgE</span><span class="id"> xy</span><span class="id"> -expgS</span><span class="id"> -order_dvdn</span><span class="id"> ox</span>.<br/>
<span class="id">have</span><span class="id"> le_k_n2:</span><span class="id"> k</span><span class="id"> &lt;=</span><span class="id"> n</span>.<span class="id">-2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -def_n1</span><span class="gallina-kwd"> in</span><span class="id"> lt_k_n1</span>.<br/>
<span class="id">suffices{lt_k_n1}</span><span class="id"> defGk:</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> k</span>.<span class="id">+1</span>))<span class="id">]&gt;</span><span class="id"> \x</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_k</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> case/dprodP:</span><span class="id"> defGk</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> &lt;-</span><span class="id"> _</span><span class="id"> tiXkY;</span><span class="id"> rewrite</span><span class="id"> expnSr</span><span class="id"> TI_cardMg</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!orderE</span><span class="id"> oy</span> (<span class="id">subnDA</span><span class="id"> 1</span>)<span class="id"> subn1</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> ?dvdn_exp2l</span><span class="id"> ?leq_subr</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /q</span><span class="id"> -{1}</span>(<span class="id">subnK</span> (<span class="id">ltnW</span><span class="id"> lt_k_n1</span>))<span class="id"> expnD</span><span class="id"> mulKn</span><span class="id"> //</span><span class="id"> expn_gt0</span><span class="id"> p_gt0</span>.<br/>
<span class="id">suffices{k</span><span class="id"> k_gt0</span><span class="id"> le_k_n2}</span><span class="id"> defGn2:</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;</span><span class="id"> \x</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_</span>(<span class="id">n</span>.<span class="id">-2</span>)(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Ohm_dprod</span><span class="id"> k</span><span class="id"> defGn2;</span><span class="id"> have</span><span class="id"> p_xp</span><span class="id"> :=</span><span class="id"> mem_p_elt</span><span class="id"> pG</span> (<span class="id">groupX</span><span class="id"> p</span><span class="id"> Gx</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">Ohm_p_cycle</span><span class="id"> _</span><span class="id"> p_xp</span>) (<span class="id">Ohm_p_cycle</span><span class="id"> _</span> (<span class="id">mem_p_elt</span><span class="id"> pG</span><span class="id"> Gy</span>))<span class="id"> oxp</span><span class="id"> oy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> pfactorK</span><span class="id"> ?</span>(<span class="id">pfactorK</span><span class="id"> 1</span>)<span class="id"> //</span> (<span class="id">eqnP</span><span class="id"> k_gt0</span>)<span class="id"> expg1</span><span class="id"> -expgM</span><span class="id"> -expnS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -subSn</span><span class="id"> //</span><span class="id"> -subSS</span><span class="id"> def_n1</span><span class="id"> def_n</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> ?add1n</span><span class="id"> subnSK</span><span class="id"> //</span><span class="id"> subn2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> OhmS</span><span class="id"> ?Ohm_sub</span><span class="id"> //=</span><span class="id"> -{1}Ohm_id</span><span class="id"> OhmS</span><span class="id"> ?Ohm_leq</span>.<br/>
<span class="id">rewrite</span><span class="id"> dprodEY</span><span class="id"> //=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply/trivgP;</span><span class="id"> rewrite</span><span class="id"> -tiXY</span><span class="id"> setSI</span><span class="id"> ?cycleX</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> join_subG</span><span class="id"> !cycle_subG</span><span class="id"> /=</span><span class="id"> [in</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> _]def_n</span>.<br/>
<span class="id">rewrite</span> (<span class="id">subsetP</span> (<span class="id">Ohm_leq</span><span class="id"> G</span> (<span class="id">ltn0Sn</span><span class="id"> _</span>))<span class="id"> y</span>)<span class="id"> //=</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> -/r</span>.<br/>
<span class="id">rewrite</span><span class="id"> mem_gen</span><span class="id"> /=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -order_dvdn</span><span class="id"> oxp</span><span class="id"> groupX</span><span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> gen_subG</span><span class="id"> /=</span><span class="id"> cent_joinEr</span><span class="id"> //</span><span class="id"> -defXY;</span><span class="id"> apply/subsetP=&gt;</span><span class="id"> uv;</span><span class="id"> case/setIP</span>.<br/>
<span class="id">case/imset2P=&gt;</span><span class="id"> u</span><span class="id"> v</span><span class="id"> Xu</span><span class="id"> Yv</span><span class="id"> -&gt;{uv};</span><span class="id"> rewrite</span><span class="id"> /r</span><span class="id"> inE</span><span class="id"> def_n</span><span class="id"> expnS</span><span class="id"> expgM</span>.<br/>
<span class="id">case/lcosetP:</span> (<span class="id">XYp</span><span class="id"> u</span><span class="id"> v</span><span class="id"> Xu</span><span class="id"> Yv</span>)<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> /cycleP[j</span><span class="id"> -&gt;]</span><span class="id"> -&gt;</span>.<br/>
<span class="id">case/cycleP:</span><span class="id"> Xu</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;{u};</span><span class="id"> rewrite</span><span class="id"> -!</span>(<span class="id">expgM,</span><span class="id"> expgD</span>)<span class="id"> -order_dvdn</span><span class="id"> ox</span>.<br/>
<span class="id">rewrite</span> (<span class="id">mulnC</span><span class="id"> r</span>)<span class="id"> /r</span><span class="id"> {1}def_n</span><span class="id"> expnSr</span><span class="id"> mulnA</span><span class="id"> -mulnDl</span><span class="id"> -mulnA</span><span class="id"> -expnS</span>.<br/>
<span class="id">rewrite</span><span class="id"> subnSK</span> <span class="id"> //</span><span class="id"> subn2</span><span class="id"> /q</span><span class="id"> -def_n1</span><span class="id"> expnS</span><span class="id"> dvdn_pmul2r</span><span class="id"> //</span><span class="id"> dvdn_addl</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/dvdnP=&gt;</span><span class="id"> k</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> mem_mulg</span><span class="id"> ?mem_cycle</span>.<br/>
<span class="id">case:</span> (<span class="id">ltngtP</span><span class="id"> n</span><span class="id"> 3</span>)<span class="id"> =&gt;</span><span class="id"> [|n_gt3|n3];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> n_gt2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -subnSK</span><span class="id"> //</span><span class="id"> expnSr</span><span class="id"> mulnA</span><span class="id"> dvdn_mull</span>.<br/>
<span class="id">case:</span> (<span class="id">even_prime</span><span class="id"> p_pr</span>)<span class="id"> notG8</span><span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> |</span><span class="id"> oddp</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> n3</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> bin2odd</span><span class="id"> //</span><span class="id"> -!mulnA</span><span class="id"> dvdn_mulr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ModularGroup</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> DihedralGroup</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> q</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> q_gt1</span><span class="id"> :</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span>.<br/>
<span class="vernacular">Let</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> q</span>.<span class="id">*2</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> def2</span><span class="id"> :</span><span class="id"> pdiv</span><span class="id"> m</span><span class="id"> =</span><span class="id"> 2</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> -mul2n</span><span class="id"> eqn_leq</span><span class="id"> pdiv_min_dvd</span><span class="id"> ?dvdn_mulr</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prime_gt1</span><span class="id"> //</span><span class="id"> pdiv_prime</span><span class="id"> //</span> (<span class="id">@leq_pmul2l</span><span class="id"> 2</span><span class="id"> 1</span>)<span class="id"> ltnW</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> def_q</span><span class="id"> :</span><span class="id"> m</span><span class="id"> %/</span><span class="id"> pdiv</span><span class="id"> m</span><span class="id"> =</span><span class="id"> q</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> def2</span><span class="id"> divn2</span><span class="id"> half_double</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Dihedral_extension</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> p</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Hypotheses</span> (<span class="id">p_gt1</span><span class="id"> :</span><span class="id"> p</span><span class="id"> &gt;</span><span class="id"> 1</span>) (<span class="id">even_p</span><span class="id"> :</span><span class="id"> 2</span><span class="id"> %|</span><span class="id"> p</span>).<br/>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> ED</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gsort</span> (<span class="id">Extremal</span>.<span class="id">gtype</span><span class="id"> q</span><span class="id"> p</span><span class="id"> q</span>.<span class="id">-1</span>)<span class="id">]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_ext_dihedral</span><span class="id"> :</span><span class="id"> #|ED|</span><span class="id"> =</span> (<span class="id">p</span>.<span class="id">/2</span><span class="id"> *</span><span class="id"> m</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Extremal</span>.<span class="id">card</span><span class="id"> //</span><span class="id"> /m</span><span class="id"> -mul2n</span><span class="id"> -divn2</span><span class="id"> mulnA</span><span class="id"> divnK</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp_ext_dihedral</span><span class="id"> :</span><span class="id"> ED</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">suffices</span><span class="id"> isoED:</span><span class="id"> ED</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> p,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q</span>.<span class="id">-1</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> gT</span><span class="id"> G;</span><span class="id"> rewrite</span><span class="id"> isoED</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> eq_existsb</span><span class="id"> =&gt;</span><span class="id"> [[x</span><span class="id"> y]]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span> (_<span class="id"> &amp;&amp;</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> apply:</span><span class="id"> andb_id2l;</span><span class="id"> move/eqP=&gt;</span><span class="id"> xq1;</span><span class="id"> congr</span> (_<span class="id"> &amp;&amp;</span> (_<span class="id"> ==</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span><span class="id"> -expgS</span> (<span class="id">ltn_predK</span><span class="id"> q_gt1</span>)<span class="id"> xq1</span>.<br/>
<span class="id">have</span><span class="id"> unitrN1</span><span class="id"> :</span> (<span class="id">-</span><span class="id"> 1</span>)<span class="id">%R</span><span class="id"> \in</span><span class="id"> GRing</span>.<span class="id">unit</span><span class="gallina-kwd"> by</span><span class="id"> move=&gt;</span><span class="id"> R;</span><span class="id"> rewrite</span><span class="id"> unitrN</span><span class="id"> unitr1</span>.<br/>
<span class="id">pose</span><span class="id"> uN1</span><span class="id"> :=</span><span class="id"> FinRing</span>.<span class="id">unit</span> (<span class="id">'Z_#[Zp1</span><span class="id"> :</span><span class="id"> 'Z_q]</span>) (<span class="id">unitrN1</span><span class="id"> _</span>).<br/>
<span class="id">apply:</span><span class="id"> Extremal</span>.<span class="id">Grp</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span> (<span class="id">Zp_unitm</span><span class="id"> uN1</span>).<br/>
<span class="id">rewrite</span><span class="id"> Aut_aut</span><span class="id"> order_injm</span><span class="id"> ?injm_Zp_unitm</span><span class="id"> ?in_setT</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">dvdn_trans</span><span class="id"> _</span><span class="id"> even_p</span>)<span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> -val_eqE</span><span class="id"> /=</span><span class="id"> mulrNN</span>.<br/>
<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> autE</span><span class="id"> ?cycle_id</span><span class="id"> //</span><span class="id"> eq_expg_mod_order</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> order_Zp1</span><span class="id"> !Zp_cast</span><span class="id"> //</span><span class="id"> !modn_mod</span> (<span class="id">modn_small</span><span class="id"> q_gt1</span>)<span class="id"> subn1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Dihedral_extension</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_dihedral</span><span class="id"> :</span><span class="id"> #|'D_m|</span><span class="id"> =</span><span class="id"> m</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /</span>(<span class="id">'D_m</span>)<span class="id">%type</span><span class="id"> def_q</span><span class="id"> card_ext_dihedral</span><span class="id"> ?mul1n</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp_dihedral</span><span class="id"> :</span><span class="id"> 'D_m</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /</span>(<span class="id">'D_m</span>)<span class="id">%type</span><span class="id"> def_q;</span><span class="id"> apply:</span><span class="id"> Grp_ext_dihedral</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp'_dihedral</span><span class="id"> :</span><span class="id"> 'D_m</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2,</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id"> ^+</span><span class="id"> q</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> gT</span><span class="id"> G;</span><span class="id"> rewrite</span><span class="id"> Grp_dihedral;</span><span class="id"> apply/existsP/existsP=&gt;</span><span class="id"> []</span><span class="id"> [[x</span><span class="id"> y]]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case/eqP=&gt;</span><span class="id"> &lt;-</span><span class="id"> xq1</span><span class="id"> y2</span><span class="id"> xy;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y,</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !xpair_eqE</span><span class="id"> /=</span><span class="id"> eqEsubset</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !join_subG</span><span class="id"> !joing_subr</span><span class="id"> !cycle_subG</span><span class="id"> -{3}</span>(<span class="id">mulgK</span><span class="id"> y</span><span class="id"> x</span>)<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2?groupM</span><span class="id"> ?groupV</span><span class="id"> ?mem_gen</span><span class="id"> ?inE</span><span class="id"> ?cycle_id</span><span class="id"> ?orbT</span><span class="id"> //=</span><span class="id"> -mulgA</span><span class="id"> expgS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> {1}</span>(<span class="id">conjgC</span><span class="id"> x</span>)<span class="id"> xy</span><span class="id"> -mulgA</span><span class="id"> mulKg</span><span class="id"> -</span>(<span class="id">expgS</span><span class="id"> y</span><span class="id"> 1</span>)<span class="id"> y2</span><span class="id"> mulg1</span><span class="id"> xq1</span><span class="id"> !eqxx</span>.<br/>
<span class="id">case/eqP=&gt;</span><span class="id"> &lt;-</span><span class="id"> x2</span><span class="id"> y2</span><span class="id"> xyq;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y,</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> !xpair_eqE</span><span class="id"> /=</span><span class="id"> eqEsubset</span>.<br/>
<span class="id">rewrite</span><span class="id"> !join_subG</span><span class="id"> !joing_subr</span><span class="id"> !cycle_subG</span><span class="id"> -{3}</span>(<span class="id">mulgK</span><span class="id"> y</span><span class="id"> x</span>)<span class="id"> /=</span>.<br/>
<span class="id">rewrite</span><span class="id"> 2?groupM</span><span class="id"> ?groupV</span><span class="id"> ?mem_gen</span><span class="id"> ?inE</span><span class="id"> ?cycle_id</span><span class="id"> ?orbT</span><span class="id"> //=</span><span class="id"> xyq</span><span class="id"> y2</span><span class="id"> !eqxx</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span><span class="id"> !mulgA</span><span class="id"> mulgK</span><span class="id"> -mulgA</span><span class="id"> -!</span>(<span class="id">expgS</span><span class="id"> _</span><span class="id"> 1</span>)<span class="id"> x2</span><span class="id"> y2</span><span class="id"> mulg1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> DihedralGroup</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> involutions_gen_dihedral</span><span class="id"> gT</span> (<span class="id">x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> gT</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> &lt;&lt;[set</span><span class="id"> x;</span><span class="id"> y]&gt;&gt;</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="id">#[x]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> x</span><span class="id"> !=</span><span class="id"> y</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'D_#|G|</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> G</span><span class="id"> ox</span><span class="id"> oy</span><span class="id"> ne_x_y;</span><span class="id"> pose</span><span class="id"> q</span><span class="id"> :=</span><span class="id"> #[x</span><span class="id"> *</span><span class="id"> y]</span>.<br/>
<span class="id">have</span><span class="id"> q_gt1:</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> order_gt1</span><span class="id"> -eq_invg_mul</span><span class="id"> invg_expg</span><span class="id"> ox</span>.<br/>
<span class="id">have</span><span class="id"> homG:</span><span class="id"> G</span><span class="id"> \homg</span><span class="id"> 'D_q</span>.<span class="id">*2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp'_dihedral</span><span class="id"> //;</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> joing_idl</span><span class="id"> joing_idr</span><span class="id"> -{1}ox</span><span class="id"> -oy</span><span class="id"> !expg_order</span><span class="id"> !eqxx</span>.<br/>
<span class="id">suff</span><span class="id"> oG:</span><span class="id"> #|G|</span><span class="id"> =</span><span class="id"> q</span>.<span class="id">*2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> isogEcard</span><span class="id"> oG</span><span class="id"> card_dihedral</span><span class="id"> ?leqnn</span><span class="id"> ?andbT</span>.<br/>
<span class="id">have:</span><span class="id"> #|G|</span><span class="id"> %|</span><span class="id"> q</span>.<span class="id">*2</span> <span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -card_dihedral</span><span class="id"> ?card_homg</span>.<br/>
<span class="id">have</span><span class="id"> Gxy:</span><span class="id"> &lt;[x</span><span class="id"> *</span><span class="id"> y]&gt;</span><span class="id"> \subset</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subG</span><span class="id"> groupM</span><span class="id"> ?mem_gen</span><span class="id"> ?set21</span><span class="id"> ?set22</span>.<br/>
<span class="id">have[k</span><span class="id"> oG]:</span><span class="gallina-kwd"> exists</span><span class="id"> k,</span><span class="id"> #|G|</span><span class="id"> =</span> (<span class="id">k</span><span class="id"> *</span><span class="id"> q</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> apply/dvdnP;</span><span class="id"> rewrite</span><span class="id"> cardSg</span>.<br/>
<span class="id">rewrite</span><span class="id"> oG</span><span class="id"> -mul2n</span><span class="id"> dvdn_pmul2r</span><span class="id"> ?order_gt0</span><span class="id"> ?dvdn_divisors</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> /=</span>.<br/>
<span class="id">case/pred2P=&gt;</span><span class="id"> [k1</span><span class="id"> |</span><span class="id"> -&gt;</span><span class="id"> //];</span><span class="id"> case/negP:</span><span class="id"> ne_x_y</span>.<br/>
<span class="id">have</span><span class="id"> cycG:</span><span class="id"> cyclic</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/cyclicP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> Gxy</span><span class="id"> oG</span><span class="id"> k1</span><span class="id"> mul1n</span><span class="id"> leqnn</span>.<br/>
<span class="id">have:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> ==</span><span class="id"> &lt;[y]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eq_subG_cyclic</span><span class="id"> cycG</span>)<span class="id"> ?genS</span><span class="id"> ?subsetUl</span><span class="id"> ?subsetUr</span><span class="id"> -?orderE</span><span class="id"> ?ox</span><span class="id"> ?oy</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> cycle_subG</span><span class="id"> /=</span><span class="id"> cycle2g</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> -order_eq1</span><span class="id"> ox;</span><span class="id"> case/andP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp_2dihedral</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">'D_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt1;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt1</span>)<span class="id"> expnS</span><span class="id"> mul2n</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> Grp_dihedral;</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_2dihedral</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> #|'D_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">|</span><span class="id"> =</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt1;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt1</span>)<span class="id"> expnS</span><span class="id"> mul2n</span><span class="id"> /=</span><span class="id"> card_dihedral</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt1</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_semidihedral</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><span class="id"> #|'SD_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">|</span><span class="id"> =</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt3</span>.<br/>
<span class="id">rewrite</span><span class="id"> /</span>(<span class="id">'SD__</span>)<span class="id">%type</span><span class="id"> -</span>(<span class="id">subnKC</span> (<span class="id">ltnW</span> (<span class="id">ltnW</span><span class="id"> n_gt3</span>)))<span class="id"> pdiv_pfactor</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> !expnS</span><span class="id"> !mulKn</span><span class="id"> -?expnS</span><span class="id"> ?Extremal</span>.<span class="id">card</span><span class="id"> //=</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> Grp_semidihedral</span><span class="id"> n</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">'SD_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id"> \isog</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>).<span class="id">-1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt3</span>.<br/>
<span class="id">rewrite</span><span class="id"> /</span>(<span class="id">'SD__</span>)<span class="id">%type</span><span class="id"> -</span>(<span class="id">subnKC</span> (<span class="id">ltnW</span> (<span class="id">ltnW</span><span class="id"> n_gt3</span>)))<span class="id"> pdiv_pfactor</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> !expnS</span><span class="id"> !mulKn</span><span class="id"> //</span><span class="id"> -!expnS</span><span class="id"> /=;</span><span class="id"> set</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> _</span>)<span class="id">%N</span>.<br/>
<span class="id">have</span><span class="id"> q_gt1:</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>).<br/>
<span class="id">apply:</span><span class="id"> Extremal</span>.<span class="id">Grp</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> set</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> &lt;[_]&gt;</span>.<br/>
<span class="id">have</span><span class="id"> oB:</span><span class="id"> #|B|</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> order_Zp1</span><span class="id"> Zp_cast</span>.<br/>
<span class="id">have</span><span class="id"> pB:</span><span class="id"> 2</span>.<span class="id">-group</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pgroup</span><span class="id"> oB</span><span class="id"> pnatX</span>.<br/>
<span class="id">have</span><span class="id"> ntB:</span><span class="id"> B</span><span class="id"> !=</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oB</span>.<br/>
<span class="id">have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> cyclic_pgroup_Aut_structure</span><span class="id"> pB</span> (<span class="id">cycle_cyclic</span><span class="id"> _</span>)<span class="id"> ntB</span>.<br/>
<span class="id">rewrite</span><span class="id"> oB</span><span class="id"> /=</span><span class="id"> pfactorK</span><span class="id"> //=</span><span class="id"> -/B</span><span class="id"> =&gt;</span><span class="id"> m</span><span class="id"> [[def_m</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> _]</span>.<br/>
<span class="id">rewrite</span><span class="id"> -{1</span><span class="id"> 2}</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>)<span class="id"> =&gt;</span><span class="id"> [[t</span><span class="id"> [At</span><span class="id"> ot</span><span class="id"> _</span><span class="id"> [s</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> defA]]]]]</span>.<br/>
<span class="id">case/dprodP:</span><span class="id"> defA</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> defA</span><span class="id"> cst</span><span class="id"> _</span>.<br/>
<span class="id">have{cst</span><span class="id"> defA}</span><span class="id"> cAt:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> 'C</span>(<span class="id">Aut</span><span class="id"> B</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defA</span><span class="id"> centM</span><span class="id"> inE</span><span class="id"> -sub_cent1</span><span class="id"> -cent_cycle</span><span class="id"> centsC</span><span class="id"> cst</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cent_cycle</span><span class="id"> cent1id</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> s0</span><span class="id"> [As0</span><span class="id"> os0</span><span class="id"> _</span><span class="id"> def_s0t</span><span class="id"> _];</span><span class="gallina-kwd"> exists</span> (<span class="id">s0</span><span class="id"> *</span><span class="id"> t</span>).<br/>
<span class="id">rewrite</span><span class="id"> -def_m</span><span class="id"> ?groupM</span><span class="id"> ?cycle_id</span><span class="id"> //</span><span class="id"> def_s0t</span><span class="id"> !Zp_expg</span><span class="id"> !mul1n</span><span class="id"> valZpK</span><span class="id"> Zp_nat</span>.<br/>
<span class="id">rewrite</span><span class="id"> order_dvdn</span><span class="id"> expgMn</span><span class="id"> /commute</span><span class="id"> 1?</span>(<span class="id">centP</span><span class="id"> cAt</span>)<span class="id"> //</span><span class="id"> -{1}os0</span><span class="id"> -{1}ot</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !expg_order</span><span class="id"> mul1g</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> Quaternion</span>.<br/>
<br/>
<span class="vernacular">Variable</span><span class="id"> n</span><span class="id"> :</span><span class="id"> nat</span>.<br/>
<span class="vernacular">Hypothesis</span><span class="id"> n_gt2</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span>.<br/>
<span class="vernacular">Let</span><span class="id"> m</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> r</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> GrpQ</span><span class="id"> :=</span><span class="id"> 'Q_m</span><span class="id"> \isog</span><span class="id"> Grp</span> (<span class="id">x</span><span class="id"> :</span><span class="id"> y</span><span class="id"> :</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r,</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1</span>).<br/>
<span class="vernacular">Let</span><span class="id"> defQ</span><span class="id"> :</span> <span class="id"> #|'Q_m|</span><span class="id"> =</span><span class="id"> m</span><span class="id"> /\</span><span class="id"> GrpQ</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">have</span><span class="id"> q_gt1</span><span class="id"> :</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
<span class="id">have</span><span class="id"> def_m</span><span class="id"> :</span> (<span class="id">2</span><span class="id"> *</span><span class="id"> q</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> m</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -expnS</span> (<span class="id">ltn_predK</span><span class="id"> n_gt2</span>).<br/>
<span class="id">have</span><span class="id"> def_q</span><span class="id"> :</span><span class="id"> m</span><span class="id"> %/</span><span class="id"> pdiv</span><span class="id"> m</span><span class="id"> =</span><span class="id"> q</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /m</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt2</span>)<span class="id"> pdiv_pfactor</span><span class="id"> //</span><span class="id"> expnS</span><span class="id"> mulKn</span>.<br/>
<span class="id">have</span><span class="id"> r_gt1</span><span class="id"> :</span><span class="id"> r</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
<span class="id">have</span><span class="id"> def2r</span><span class="id"> :</span> (<span class="id">2</span><span class="id"> *</span><span class="id"> r</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -expnS</span><span class="id"> /q</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
<span class="id">rewrite</span><span class="id"> /GrpQ</span><span class="id"> [quaternion_gtype]unlock</span><span class="id"> /quaternion_kernel</span><span class="id"> {}def_q</span>.<br/>
<span class="id">set</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> _];</span><span class="id"> have:</span><span class="id"> B</span><span class="id"> \homg</span><span class="id"> Grp</span> (<span class="id">u</span><span class="id"> :</span><span class="id"> v</span><span class="id"> :</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> q,</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 4,</span><span class="id"> u</span><span class="id"> ^</span><span class="id"> v</span><span class="id"> =</span><span class="id"> u^-1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -Grp_ext_dihedral</span><span class="id"> ?homg_refl</span>.<br/>
<span class="id">have:</span><span class="id"> #|B|</span><span class="id"> =</span> (<span class="id">q</span><span class="id"> *</span><span class="id"> 4</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> card_ext_dihedral</span><span class="id"> //</span><span class="id"> mulnC</span><span class="id"> -muln2</span><span class="id"> -mulnA</span>.<br/>
<span class="id">rewrite</span><span class="id"> {}/B;</span><span class="id"> move:</span> (<span class="id">Extremal</span>.<span class="id">gtype</span><span class="id"> q</span><span class="id"> 4</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> gT</span>.<br/>
<span class="id">set</span><span class="id"> B</span><span class="id"> :=</span><span class="id"> [set:</span><span class="id"> gT]</span><span class="id"> =&gt;</span><span class="id"> oB;</span><span class="id"> set</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> _</span><span class="id"> :\:</span><span class="id"> _</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[u</span><span class="id"> v]</span><span class="id"> /=</span><span class="id"> /eqP[defB</span><span class="id"> uq</span><span class="id"> v4</span><span class="id"> uv]</span>.<br/>
<span class="id">have</span><span class="id"> nUV:</span><span class="id"> &lt;[v]&gt;</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">&lt;[u]&gt;</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> norms_cycle</span><span class="id"> uv</span><span class="id"> groupV</span><span class="id"> cycle_id</span>.<br/>
<span class="id">rewrite</span><span class="id"> norm_joinEr</span><span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> defB</span>.<br/>
<span class="id">have</span><span class="id"> le_ou:</span><span class="id"> #[u]</span><span class="id"> &lt;=</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> ?expn_gt0</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> uq</span>.<br/>
<span class="id">have</span><span class="id"> le_ov:</span><span class="id"> #[v]</span><span class="id"> &lt;=</span><span class="id"> 4</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> v4</span>.<br/>
<span class="id">have</span><span class="id"> tiUV:</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :&amp;:</span><span class="id"> &lt;[v]&gt;</span><span class="id"> =</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> cardMg_TI</span><span class="id"> //</span><span class="id"> defB</span><span class="id"> oB</span><span class="id"> leq_mul</span>.<br/>
<span class="id">have{le_ou</span><span class="id"> le_ov}</span><span class="id"> [ou</span><span class="id"> ov]:</span><span class="id"> #[u]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> /\</span><span class="id"> #[v]</span><span class="id"> =</span><span class="id"> 4</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> esym</span> (<span class="id">leqif_mul</span> (<span class="id">leqif_eq</span><span class="id"> le_ou</span>) (<span class="id">leqif_eq</span><span class="id"> le_ov</span>)).<span class="id">2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -TI_cardMg</span><span class="id"> //</span><span class="id"> defB</span><span class="id"> -oB</span><span class="id"> eqxx</span><span class="id"> eqn0Ngt</span><span class="id"> cardG_gt0;</span><span class="id"> do</span><span class="id"> 2!case:</span><span class="id"> eqP=&gt;</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> sdB:</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &gt;&lt;|</span><span class="id"> &lt;[v]&gt;</span><span class="id"> =</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sdprodE</span>.<br/>
<span class="id">have</span><span class="id"> uvj</span><span class="id"> j:</span><span class="id"> u</span><span class="id"> ^</span> (<span class="id">v</span><span class="id"> ^+</span><span class="id"> j</span>)<span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> odd</span><span class="id"> j</span><span class="gallina-kwd"> then</span><span class="id"> u^-1</span><span class="gallina-kwd"> else</span><span class="id"> u</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> j</span><span class="id"> =&gt;</span><span class="id"> [|j</span><span class="id"> IHj];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> conjg1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expgS</span><span class="id"> conjgM</span><span class="id"> uv</span><span class="id"> conjVg</span><span class="id"> IHj</span> (<span class="id">fun_if</span><span class="id"> inv</span>)<span class="id"> invgK</span><span class="id"> if_neg</span>.<br/>
<span class="id">have</span><span class="id"> sqrB</span><span class="id"> i</span><span class="id"> j:</span> (<span class="id">u</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> *</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> j</span>)<span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> odd</span><span class="id"> j</span><span class="gallina-kwd"> then</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 2</span><span class="gallina-kwd"> else</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> i</span>.<span class="id">*2</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expgS;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> odd_j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1}</span>(<span class="id">conjgC</span> (<span class="id">u</span><span class="id"> ^+</span><span class="id"> i</span>))<span class="id"> conjXg</span><span class="id"> uvj</span><span class="id"> odd_j</span><span class="id"> expgVn</span><span class="id"> -mulgA</span><span class="id"> mulKg</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgD</span><span class="id"> addnn</span><span class="id"> -</span>(<span class="id">odd_double_half</span><span class="id"> j</span>)<span class="id"> odd_j</span><span class="id"> doubleD</span><span class="id"> addnC</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -[LHS]</span>(<span class="id">expg_mod</span><span class="id"> _</span><span class="id"> v4</span>)<span class="id"> -!muln2</span><span class="id"> -mulnA</span><span class="id"> modnMDl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {2}</span>(<span class="id">conjgC</span> (<span class="id">u</span><span class="id"> ^+</span><span class="id"> i</span>))<span class="id"> conjXg</span><span class="id"> uvj</span><span class="id"> odd_j</span><span class="id"> mulgA</span><span class="id"> -</span>(<span class="id">mulgA</span> (<span class="id">u</span><span class="id"> ^+</span><span class="id"> i</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgD</span><span class="id"> addnn</span><span class="id"> -</span>(<span class="id">odd_double_half</span><span class="id"> j</span>)<span class="id"> odd_j</span><span class="id"> -2!mul2n</span><span class="id"> mulnA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expgM</span><span class="id"> v4</span><span class="id"> expg1n</span><span class="id"> mulg1</span><span class="id"> -expgD</span><span class="id"> addnn</span>.<br/>
<span class="id">pose</span><span class="id"> w</span><span class="id"> :=</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> r</span><span class="id"> *</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 2</span>.<br/>
<span class="id">have</span><span class="id"> Kw:</span><span class="id"> w</span><span class="id"> \in</span><span class="id"> K</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> sqrB</span><span class="id"> /=</span><span class="id"> -mul2n</span><span class="id"> def2r</span><span class="id"> uq</span><span class="id"> eqxx</span><span class="id"> andbT</span><span class="id"> -defB</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/imsetP=&gt;</span><span class="id"> [[_]]</span><span class="id"> /imset2P[_</span><span class="id"> _</span><span class="id"> /cycleP[i</span><span class="id"> -&gt;]</span><span class="id"> /cycleP[j</span><span class="id"> -&gt;]</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> sqrB;</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eq_mulgV1</span><span class="id"> mulgK</span><span class="id"> -order_dvdn</span><span class="id"> ou</span><span class="id"> pfactor_dvdn</span><span class="id"> ?expn_gt0</span><span class="id"> ?pfactorK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ltnNge</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">canF_eq</span> (<span class="id">mulKg</span><span class="id"> _</span>))<span class="id">;</span><span class="id"> apply/eqP=&gt;</span><span class="id"> def_v2</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices:</span><span class="id"> v</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :&amp;:</span><span class="id"> &lt;[v]&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> tiUV</span><span class="id"> inE</span><span class="id"> -order_dvdn</span><span class="id"> ov</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> {1}def_v2</span><span class="id"> groupM</span><span class="id"> ?groupV</span><span class="id"> !mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> ow:</span><span class="id"> #[w]</span><span class="id"> =</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setDP:</span><span class="id"> Kw;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -order_dvdn</span><span class="id"> dvdn_divisors</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> order_eq1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/orP=&gt;</span><span class="id"> /eqP-&gt;</span><span class="id"> //</span><span class="id"> /imsetP[];</span><span class="gallina-kwd"> exists</span><span class="id"> 1;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> ?expg1n</span>.<br/>
<span class="id">have</span><span class="id"> defK:</span><span class="id"> K</span><span class="id"> =</span><span class="id"> [set</span><span class="id"> w]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> sub1set</span><span class="id"> Kw</span><span class="id"> andbT</span><span class="id"> subDset</span><span class="id"> setUC</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> uivj;</span><span class="id"> have:</span><span class="id"> uivj</span><span class="id"> \in</span><span class="id"> B</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{1}defB</span><span class="id"> =&gt;</span><span class="id"> /imset2P[_</span><span class="id"> _</span><span class="id"> /cycleP[i</span><span class="id"> -&gt;]</span><span class="id"> /cycleP[j</span><span class="id"> -&gt;]</span><span class="id"> -&gt;]</span><span class="id"> {uivj}</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> sqrB;</span><span class="id"> set</span><span class="id"> b</span><span class="id"> :=</span><span class="id"> odd</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> -[j]odd_double_half</span><span class="id"> -/b</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> ?ov</span><span class="id"> //</span><span class="id"> ou</span><span class="id"> -def2r</span><span class="id"> -mul2n</span><span class="id"> dvdn_pmul2l</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case/dvdnP=&gt;</span><span class="id"> k</span><span class="id"> -&gt;{i};</span><span class="id"> apply/orP</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> add0n</span><span class="id"> -[j</span>.<span class="id">/2]odd_double_half</span><span class="id"> addnC</span><span class="id"> doubleD</span><span class="id"> -!muln2</span><span class="id"> -mulnA</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">expg_mod_order</span><span class="id"> v</span>)<span class="id"> ov</span><span class="id"> modnMDl;</span><span class="id"> case:</span> (<span class="id">odd</span><span class="id"> _</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">right;</span><span class="id"> rewrite</span><span class="id"> mulg1</span><span class="id"> /r</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>)<span class="id"> expnSr</span><span class="id"> mulnA</span><span class="id"> expgM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> imset_f</span><span class="id"> =&gt;</span><span class="id"> /[1!inE]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">inj_eq</span> (<span class="id">mulIg</span><span class="id"> _</span>))<span class="id"> -expg_mod_order</span><span class="id"> ou</span><span class="id"> -[k]odd_double_half</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addnC</span><span class="id"> -muln2</span><span class="id"> mulnDl</span><span class="id"> -mulnA</span><span class="id"> def2r</span><span class="id"> modnMDl</span><span class="id"> -ou</span><span class="id"> expg_mod_order</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">odd</span><span class="id"> k</span>)<span class="id">;</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right];</span><span class="id"> rewrite</span><span class="id"> ?mul1n</span><span class="id"> ?mul1g</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/imsetP;</span><span class="gallina-kwd"> exists</span><span class="id"> v;</span><span class="id"> rewrite</span><span class="id"> ?inE</span>.<br/>
<span class="id">have</span><span class="id"> nKB:</span><span class="id"> 'N</span>(<span class="id">&lt;&lt;K&gt;&gt;</span>)<span class="id"> =</span><span class="id"> B</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> b;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -genJ</span><span class="id"> genS</span><span class="id"> //</span><span class="id"> {1}defK</span><span class="id"> conjg_set1</span><span class="id"> sub1set</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Kw;</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -!order_dvdn</span><span class="id"> orderJ</span><span class="id"> ow</span><span class="id"> !andbT;</span><span class="id"> apply:</span><span class="id"> contra</span>.<br/>
&nbsp;&nbsp;<span class="id">case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> _</span><span class="id"> def_wb;</span><span class="id"> apply/imsetP;</span><span class="gallina-kwd"> exists</span> (<span class="id">z</span><span class="id"> ^</span><span class="id"> b^-1</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -conjXg</span><span class="id"> -def_wb</span><span class="id"> conjgK</span>.<br/>
<span class="id">rewrite</span><span class="id"> -im_quotient</span><span class="id"> card_quotient</span><span class="id"> //</span><span class="id"> nKB</span><span class="id"> -divgS</span><span class="id"> ?subsetT</span><span class="id"> //</span>.<br/>
<span class="id">split;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oB</span><span class="id"> defK</span><span class="id"> -orderE</span><span class="id"> ow</span> (<span class="id">mulnA</span><span class="id"> q</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> mulnK</span><span class="id"> //</span><span class="id"> mulnC</span>.<br/>
<span class="id">apply:</span><span class="id"> intro_isoGrp</span><span class="id"> =&gt;</span><span class="id"> [|rT</span><span class="id"> H]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">coset</span><span class="id"> _</span><span class="id"> u,</span><span class="id"> coset</span><span class="id"> _</span><span class="id"> v</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!morphX</span><span class="id"> -?morphJ</span><span class="id"> -?morphV</span><span class="id"> /=</span><span class="id"> ?nKB</span><span class="id"> ?in_setT</span><span class="id"> //</span><span class="id"> uq</span><span class="id"> uv</span><span class="id"> morph1</span><span class="id"> !eqxx</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/B</span><span class="id"> -defB</span><span class="id"> -norm_joinEr</span><span class="id"> //</span><span class="id"> quotientY</span><span class="id"> ?nKB</span><span class="id"> ?subsetT</span><span class="id"> //=</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !quotient_cycle</span><span class="id"> /=</span><span class="id"> ?nKB</span><span class="id"> ?in_setT</span><span class="id"> ?eqxx</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">coset_kerl</span><span class="id"> _</span> (<span class="id">mem_gen</span><span class="id"> Kw</span>))<span class="id"> -mulgA</span><span class="id"> -expgD</span><span class="id"> v4</span><span class="id"> mulg1</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=</span><span class="id"> /eqP[defH</span><span class="id"> xq</span><span class="id"> y2</span><span class="id"> xy]</span>.<br/>
<span class="id">have</span><span class="id"> ox:</span><span class="id"> #[x]</span><span class="id"> %|</span><span class="id"> #[u]</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ou</span><span class="id"> order_dvdn</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> oy:</span><span class="id"> #[y]</span><span class="id"> %|</span><span class="id"> #[v]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ov</span><span class="id"> order_dvdn</span> (<span class="id">expgM</span><span class="id"> y</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> y2</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> def2r</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> actB:</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &amp;</span><span class="id"> &lt;[v]&gt;,</span><span class="id"> morph_act</span><span class="id"> 'J</span><span class="id"> 'J</span> (<span class="id">eltm</span><span class="id"> ox</span>) (<span class="id">eltm</span><span class="id"> oy</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> /cycleP[i</span><span class="id"> -&gt;]</span><span class="id"> /cycleP[j</span><span class="id"> -&gt;]</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> conjXg</span><span class="id"> uvj</span><span class="id"> fun_if</span><span class="id"> if_arg</span><span class="id"> fun_if</span><span class="id"> expgVn</span><span class="id"> morphV</span><span class="id"> ?mem_cycle</span><span class="id"> //=</span><span class="id"> !eltmE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgVn</span><span class="id"> -if_arg</span><span class="id"> -fun_if</span><span class="id"> conjXg;</span><span class="id"> congr</span> (_<span class="id"> ^+</span><span class="id"> i</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{2}[j]odd_double_half</span><span class="id"> addnC</span><span class="id"> expgD</span><span class="id"> -mul2n</span><span class="id"> expgM</span><span class="id"> y2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgM</span><span class="id"> conjgM</span> (<span class="id">conjgE</span><span class="id"> x</span>)<span class="id"> commuteX</span><span class="id"> //</span><span class="id"> mulKg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">odd</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?conjg1</span>.<br/>
<span class="id">pose</span><span class="id"> f</span><span class="id"> :=</span><span class="id"> sdprodm</span><span class="id"> sdB</span><span class="id"> actB</span>.<br/>
<span class="id">have</span><span class="id"> Kf:</span><span class="id"> 'ker</span> (<span class="id">coset</span><span class="id"> &lt;&lt;K&gt;&gt;</span>)<span class="id"> \subset</span><span class="id"> 'ker</span><span class="id"> f</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ker_coset</span><span class="id"> defK</span><span class="id"> cycle_subG</span><span class="id"> /=</span><span class="id"> ker_sdprodm</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/imset2P;</span><span class="gallina-kwd"> exists</span> (<span class="id">u</span><span class="id"> ^+</span><span class="id"> r</span>) (<span class="id">v</span><span class="id"> ^+</span><span class="id"> 2</span>)<span class="id">;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> mem_cycle</span><span class="id"> /=</span><span class="id"> !eltmE</span><span class="id"> y2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> canRL</span> (<span class="id">mulgK</span><span class="id"> _</span>)<span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> -mulgA</span><span class="id"> -expgD</span><span class="id"> v4</span><span class="id"> mulg1</span>.<br/>
<span class="id">have</span><span class="id"> Df:</span><span class="id"> 'dom</span><span class="id"> f</span><span class="id"> \subset</span><span class="id"> 'dom</span> (<span class="id">coset</span><span class="id"> &lt;&lt;K&gt;&gt;</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /dom</span><span class="id"> nKB</span><span class="id"> subsetT</span>.<br/>
<span class="id">apply/homgP;</span><span class="gallina-kwd"> exists</span> (<span class="id">factm_morphism</span><span class="id"> Kf</span><span class="id"> Df</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> morphim_factm</span><span class="id"> /=</span><span class="id"> -/B</span>.<br/>
<span class="id">rewrite</span><span class="id"> -{2}defB</span><span class="id"> morphim_sdprodm</span><span class="id"> //</span><span class="id"> !morphim_cycle</span><span class="id"> ?cycle_id</span><span class="id"> //=</span><span class="id"> !eltm_id</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -norm_joinEr</span><span class="id"> //</span><span class="id"> norms_cycle</span><span class="id"> xy</span><span class="id"> groupV</span><span class="id"> cycle_id</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> card_quaternion</span><span class="id"> :</span><span class="id"> #|'Q_m|</span><span class="id"> =</span><span class="id"> m</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> defQ</span>. Qed.</div></details>
<span class="vernacular">Lemma</span><span class="id"> Grp_quaternion</span><span class="id"> :</span><span class="id"> GrpQ</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span><span class="id"> defQ</span>. Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> Quaternion</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> eq_Mod8_D8</span><span class="id"> :</span><span class="id"> 'Mod_8</span><span class="id"> =</span><span class="id"> 'D_8</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> []</span>. Qed.</div></details>
<br/>
<span class="vernacular">Section</span><span class="id"> ExtremalStructure</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>) (<span class="id">n</span><span class="id"> :</span><span class="id"> nat</span>).<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> m</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> q_gt0:</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span>. Qed.</div></details>
<span class="vernacular">Let</span><span class="id"> r</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span>.<br/>
<span class="vernacular">Let</span><span class="id"> r_gt0:</span><span class="id"> r</span><span class="id"> &gt;</span><span class="id"> 0</span><br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span>. Qed.</div></details>
<br/>
<span class="vernacular">Let</span><span class="id"> def2qr</span><span class="id"> :</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> [/\</span><span class="id"> 2</span><span class="id"> *</span><span class="id"> q</span><span class="id"> =</span><span class="id"> m,</span><span class="id"> 2</span><span class="id"> *</span><span class="id"> r</span><span class="id"> =</span><span class="id"> q,</span><span class="id"> q</span><span class="id"> &lt;</span><span class="id"> m</span><span class="id"> &amp;</span><span class="id"> r</span><span class="id"> &lt;</span><span class="id"> q]%N</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /q</span><span class="id"> /m</span><span class="id"> /r;</span><span class="id"> move/subnKC=&gt;</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> !ltn_exp2l</span><span class="id"> ?expnS</span>. Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> generators_2dihedral</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'D_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> xy,</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span><span class="id"> xy</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> let:</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> :=</span><span class="id"> xy</span><span class="gallina-kwd"> in</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt1;</span><span class="id"> have</span><span class="id"> [def2q</span><span class="id"> _</span><span class="id"> ltqm</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> def2qr</span><span class="id"> n_gt1</span>.<br/>
<span class="id">case/</span>(<span class="id">isoGrpP</span><span class="id"> _</span> (<span class="id">Grp_2dihedral</span><span class="id"> n_gt1</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> card_2dihedral</span><span class="id"> //</span><span class="id"> -/</span><span class="id"> m</span><span class="id"> =&gt;</span><span class="id"> oG</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -/q</span><span class="id"> =&gt;</span><span class="id"> /eqP[defG</span><span class="id"> xq</span><span class="id"> y2</span><span class="id"> xy]</span>.<br/>
<span class="id">have{}</span><span class="id"> defG:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> *</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -norm_joinEr</span><span class="id"> //</span><span class="id"> norms_cycle</span><span class="id"> xy</span><span class="id"> groupV</span><span class="id"> cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> notXy:</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> &lt;[x]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> ltqm</span><span class="id"> =&gt;</span><span class="id"> Xy;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> -oG</span><span class="id"> -defG</span><span class="id"> mulGSid</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> oy:</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> nt_prime_order</span> (<span class="id">group1_contra</span><span class="id"> notXy</span>).<br/>
<span class="id">have</span><span class="id"> ox:</span><span class="id"> #[x]</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -oy</span><span class="id"> -mul2n</span><span class="id"> def2q</span><span class="id"> -oG</span><span class="id"> -defG</span><span class="id"> TI_cardMg</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> oy</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> ox</span><span class="id"> !inE</span><span class="id"> notXy</span><span class="id"> -!cycle_subG</span><span class="id"> /=</span><span class="id"> -defG</span> <span class="id"> mulG_subl</span><span class="id"> mulG_subr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> generators_semidihedral</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'SD_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> xy,</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span><span class="id"> xy</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> let:</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> :=</span><span class="id"> xy</span><span class="gallina-kwd"> in</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-1</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt3;</span><span class="id"> have</span><span class="id"> [def2q</span><span class="id"> _</span><span class="id"> ltqm</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> def2qr</span> (<span class="id">ltnW</span> (<span class="id">ltnW</span><span class="id"> n_gt3</span>)).<br/>
<span class="id">case/</span>(<span class="id">isoGrpP</span><span class="id"> _</span> (<span class="id">Grp_semidihedral</span><span class="id"> n_gt3</span>)).<br/>
<span class="id">rewrite</span><span class="id"> card_semidihedral</span><span class="id"> //</span><span class="id"> -/m</span><span class="id"> =&gt;</span><span class="id"> oG</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> =&gt;</span><span class="id"> /eqP[defG</span><span class="id"> xq</span><span class="id"> y2</span><span class="id"> xy]</span>.<br/>
<span class="id">have{}</span><span class="id"> defG:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> *</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -norm_joinEr</span><span class="id"> //</span><span class="id"> norms_cycle</span><span class="id"> xy</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> notXy:</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> &lt;[x]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> ltqm</span><span class="id"> =&gt;</span><span class="id"> Xy;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> -oG</span><span class="id"> -defG</span><span class="id"> mulGSid</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> oy:</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> nt_prime_order</span> (<span class="id">group1_contra</span><span class="id"> notXy</span>).<br/>
<span class="id">have</span><span class="id"> ox:</span><span class="id"> #[x]</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -oy</span><span class="id"> -mul2n</span><span class="id"> def2q</span><span class="id"> -oG</span><span class="id"> -defG</span><span class="id"> TI_cardMg</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> oy</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> //=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> ox</span><span class="id"> !inE</span><span class="id"> notXy</span><span class="id"> -!cycle_subG</span><span class="id"> /=</span><span class="id"> -defG</span> <span class="id"> mulG_subl</span><span class="id"> mulG_subr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> generators_quaternion</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'Q_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> xy,</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span><span class="id"> xy</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> let:</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> :=</span><span class="id"> xy</span><span class="gallina-kwd"> in</span><span class="id"> [/\</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 4,</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span><span class="id"> &amp;</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x^-1]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt2;</span><span class="id"> have</span><span class="id"> [def2q</span><span class="id"> def2r</span><span class="id"> ltqm</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> def2qr</span> (<span class="id">ltnW</span><span class="id"> n_gt2</span>).<br/>
<span class="id">case/</span>(<span class="id">isoGrpP</span><span class="id"> _</span> (<span class="id">Grp_quaternion</span><span class="id"> n_gt2</span>))<span class="id">;</span><span class="id"> rewrite</span><span class="id"> card_quaternion</span><span class="id"> //</span><span class="id"> -/m</span><span class="id"> =&gt;</span><span class="id"> oG</span>.<br/>
<span class="id">case/existsP=&gt;</span><span class="id"> -[x</span><span class="id"> y]</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> =&gt;</span><span class="id"> /eqP[defG</span><span class="id"> xq</span><span class="id"> y2</span><span class="id"> xy]</span>.<br/>
<span class="id">have{}</span><span class="id"> defG:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> *</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -norm_joinEr</span><span class="id"> //</span><span class="id"> norms_cycle</span><span class="id"> xy</span><span class="id"> groupV</span><span class="id"> cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> notXy:</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> &lt;[x]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> ltqm</span><span class="id"> =&gt;</span><span class="id"> Xy;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> -oG</span><span class="id"> -defG</span><span class="id"> mulGSid</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> xq</span>.<br/>
<span class="id">have</span><span class="id"> ox:</span><span class="id"> #[x]</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> dvdn_leq</span><span class="id"> ?order_dvdn</span><span class="id"> ?xq</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">leq_pmul2r</span> (<span class="id">order_gt0</span><span class="id"> y</span>))<span class="id"> mul_cardG</span><span class="id"> defG</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mulnAC</span><span class="id"> mulnC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> leq_pmul2r</span><span class="id"> //</span><span class="id"> dvdn_leq</span><span class="id"> ?muln_gt0</span><span class="id"> ?cardG_gt0</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> expgM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> order_dvdG</span><span class="id"> //=</span><span class="id"> inE</span><span class="id"> {1}y2</span><span class="id"> !mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> oy2:</span><span class="id"> #[y</span><span class="id"> ^+</span><span class="id"> 2]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> y2</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="gallina-kwd">exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> /=;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">orderXprime</span><span class="id"> oy2</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> !inE</span><span class="id"> notXy</span><span class="id"> -!cycle_subG</span><span class="id"> /=</span><span class="id"> -defG</span> <span class="id"> mulG_subl</span><span class="id"> mulG_subr</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Variables</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><span class="id"> gT</span>.<br/>
<span class="vernacular">Implicit</span><span class="gallina-kwd"> Type</span><span class="id"> M</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>.<br/>
<br/>
<span class="vernacular">Let</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> &lt;[x]&gt;</span>.<br/>
<span class="vernacular">Let</span><span class="id"> Y</span><span class="id"> :=</span><span class="id"> &lt;[y]&gt;</span>.<br/>
<span class="vernacular">Let</span><span class="id"> yG</span><span class="id"> :=</span><span class="id"> y</span><span class="id"> ^:</span><span class="id"> G</span>.<br/>
<span class="vernacular">Let</span><span class="id"> xyG</span><span class="id"> :=</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id"> ^:</span><span class="id"> G</span>.<br/>
<span class="vernacular">Let</span><span class="id"> My</span><span class="id"> :=</span><span class="id"> &lt;&lt;yG&gt;&gt;</span>.<br/>
<span class="vernacular">Let</span><span class="id"> Mxy</span><span class="id"> :=</span><span class="id"> &lt;&lt;xyG&gt;&gt;</span>.<br/>
<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> dihedral2_structure</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> -&gt;</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'D_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> [/\</span><span class="id"> X</span><span class="id"> &gt;&lt;|</span><span class="id"> Y</span><span class="id"> =</span><span class="id"> G,</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;,</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id">,</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">-1],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="id"> /\</span> (<span class="gallina-kwd">forall</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> 'Mho^k</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">]&gt;</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> M,</span><span class="id"> maximal</span><span class="id"> M</span><span class="id"> G</span><span class="id"> =</span><span class="id"> pred3</span><span class="id"> X</span><span class="id"> My</span><span class="id"> Mxy</span><span class="id"> M]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> ==</span><span class="id"> 2</span><span class="gallina-kwd"> then</span> (<span class="id">2</span>.<span class="id">-abelem</span><span class="id"> G</span><span class="id"> :</span><span class="gallina-kwd"> Prop</span>)<span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;,</span><span class="id"> #|'Z</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> 2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">My</span><span class="id"> \isog</span><span class="id"> 'D_q,</span><span class="id"> Mxy</span><span class="id"> \isog</span><span class="id"> 'D_q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> cyclic</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> =</span><span class="id"> X]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt1</span><span class="id"> genG</span><span class="id"> isoG;</span><span class="id"> have</span><span class="id"> [def2q</span><span class="id"> def2r</span><span class="id"> ltqm</span><span class="id"> ltrq]</span><span class="id"> :=</span><span class="id"> def2qr</span><span class="id"> n_gt1</span>.<br/>
<span class="id">have</span><span class="id"> [oG</span><span class="id"> Gx</span><span class="id"> ox</span><span class="id"> X'y]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/m</span><span class="id"> -/q</span><span class="id"> -/X</span><span class="gallina-kwd"> in</span><span class="id"> oG</span><span class="id"> ox</span><span class="id"> X'y</span>.<br/>
<span class="id">case/extremal_generators_facts:</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/X</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> pG</span><span class="id"> maxX</span><span class="id"> nsXG</span><span class="id"> defXY</span><span class="id"> nXY</span>.<br/>
<span class="id">have</span><span class="id"> [sXG</span><span class="id"> nXG]:=</span><span class="id"> andP</span><span class="id"> nsXG;</span><span class="id"> have</span><span class="id"> [Gy</span><span class="id"> notXy]:=</span><span class="id"> setDP</span><span class="id"> X'y</span>.<br/>
<span class="id">have</span><span class="id"> ox2:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> 2]</span><span class="id"> =</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mulr</span><span class="id"> ?mulKn</span>.<br/>
<span class="id">have</span><span class="id"> oxr:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> r]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="id">have</span><span class="id"> [[u</span><span class="id"> v]</span><span class="id"> [_</span><span class="id"> Gu</span><span class="id"> ou</span><span class="id"> U'v]</span><span class="id"> [ov</span><span class="id"> uv]]</span><span class="id"> :=</span><span class="id"> generators_2dihedral</span><span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> defUv:</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> &lt;[u]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> rcoset_index2;</span><span class="id"> rewrite</span><span class="id"> -?divgS</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ou</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> invUV:</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &amp;</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> t;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> case/rcosetP=&gt;</span><span class="id"> z';</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> -&gt;{z</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX2</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> conjXg</span><span class="id"> uv</span><span class="id"> expgVn</span>.<br/>
<span class="id">have</span><span class="id"> oU':</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> Uvt;</span><span class="id"> apply:</span><span class="id"> nt_prime_order</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> Uvt</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> defUv</span><span class="id"> !inE</span><span class="id"> group1</span>.<br/>
&nbsp;&nbsp;<span class="id">case/rcosetP:</span><span class="id"> Uvt</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> Uz</span><span class="id"> -&gt;{t};</span><span class="id"> rewrite</span><span class="id"> expgS</span><span class="id"> {1}</span>(<span class="id">conjgC</span><span class="id"> z</span>)<span class="id"> -mulgA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invUV</span><span class="id"> ?rcoset_refl</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> -</span>(<span class="id">expgS</span><span class="id"> v</span><span class="id"> 1</span>)<span class="id"> -ov</span><span class="id"> expg_order</span>.<br/>
<span class="id">have</span><span class="id"> defU:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> -&gt;</span><span class="id"> &lt;[z]&gt;</span><span class="id"> =</span><span class="id"> &lt;[u]&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n_gt2</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> oz;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> -!orderE</span><span class="id"> oz</span><span class="id"> cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraLR</span><span class="id"> n_gt2;</span><span class="id"> rewrite</span><span class="id"> ou</span><span class="id"> leqnn</span><span class="id"> andbT</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt1</span>)<span class="id"> =&gt;</span><span class="id"> notUz</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ltnS</span><span class="id"> -</span>(<span class="id">@ltn_exp2l</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -/q</span><span class="id"> -oz</span><span class="id"> oU'</span><span class="id"> //</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> notUz</span>.<br/>
<span class="id">have</span><span class="id"> n2_abelG:</span> (<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 2</span>)<span class="id"> ||</span><span class="id"> 2</span>.<span class="id">-abelem</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ltn_neqAle</span><span class="id"> eq_sym</span><span class="id"> n_gt1;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n2</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/abelemP=&gt;</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> [|z</span><span class="id"> Gz]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">p2group_abelian</span><span class="id"> pG</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> ?n2</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Uz:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -expg_mod_order</span><span class="id"> oU'</span><span class="id"> //</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> Uz</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span> (<span class="id">dvdn_trans</span> (<span class="id">order_dvdG</span><span class="id"> Uz</span>))<span class="id"> //</span><span class="id"> -orderE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ou</span><span class="id"> /q</span><span class="id"> n2</span>.<br/>
<span class="id">have{oU'}</span><span class="id"> oX':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n_gt2</span><span class="id"> |</span><span class="id"> abelG]</span><span class="id"> :=</span><span class="id"> orP</span><span class="id"> n2_abelG;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [X]defU</span><span class="id"> //</span><span class="id"> -defUv</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> /setDP[Gt</span><span class="id"> notXt];</span><span class="id"> apply:</span><span class="id"> nt_prime_order</span> (<span class="id">group1_contra</span><span class="id"> notXt</span>)<span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/abelemP:</span><span class="id"> abelG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> -&gt;</span>.<br/>
<span class="id">have{invUV}</span><span class="id"> invXX':</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n_gt2</span><span class="id"> |</span><span class="id"> abelG]</span><span class="id"> :=</span><span class="id"> orP</span><span class="id"> n2_abelG;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> [X]defU</span><span class="id"> //</span><span class="id"> -defUv</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|cGG</span><span class="id"> oG2]</span><span class="id"> :=</span><span class="id"> abelemP</span><span class="id"> _</span><span class="id"> abelG</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> z</span><span class="id"> Xt</span><span class="id"> /setDP[Gz</span><span class="id"> _];</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /conjg</span><span class="id"> -</span>(<span class="id">centsP</span><span class="id"> cGG</span><span class="id"> z</span>)<span class="id"> //</span><span class="id"> ?mulKg</span><span class="id"> ?[t</span><span class="id"> *</span><span class="id"> t]oG2</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sXG</span>).<br/>
<span class="id">have</span><span class="id"> nXiG</span><span class="id"> k:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">&lt;[x</span><span class="id"> ^+</span><span class="id"> k]&gt;</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> char_norm_trans</span><span class="id"> nXG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subgroup_char</span><span class="id"> //</span><span class="id"> cycle_subG</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> memL</span><span class="id"> i:</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>)<span class="id"> \in</span><span class="id"> 'L_i</span>.<span class="id">+1</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> IHi;</span><span class="id"> rewrite</span><span class="id"> -groupV</span><span class="id"> expnSr</span><span class="id"> expgM</span><span class="id"> invMg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">invXX'</span><span class="id"> _</span><span class="id"> y</span>)<span class="id"> ?mem_cycle</span><span class="id"> ?cycle_id</span><span class="id"> ?mem_commg</span>.<br/>
<span class="id">have</span><span class="id"> defG':</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> cycle_subG</span> (<span class="id">memL</span><span class="id"> 1%N</span>)<span class="id"> ?der1_min</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">p2group_abelian</span> (<span class="id">quotient_pgroup</span><span class="id"> _</span><span class="id"> pG</span>))<span class="id"> ?card_quotient</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -divgS</span><span class="id"> ?cycle_subG</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ox2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def2q</span><span class="id"> -def2r</span><span class="id"> mulnA</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> defG1:</span><span class="id"> 'Mho^1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span> (<span class="id">MhoE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> eqEsubset</span><span class="id"> !gen_subG</span><span class="id"> sub1set</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_gen;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> imset_f</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> z2;</span><span class="id"> case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> -&gt;{z2}</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Xz:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> X</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">oX'</span><span class="id"> z</span>)<span class="id"> ?expg_order</span><span class="id"> ?group1</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> Xz</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> expgAC</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> defPhi:</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pG</span>)<span class="id"> defG'</span><span class="id"> defG1</span> (<span class="id">joing_idPl</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> def_tG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> :*</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defJt:</span><span class="id"> {in</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> t</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^-</span><span class="id"> 2</span><span class="id"> *</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Xz;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> invMg</span><span class="id"> -mulgA</span> (<span class="id">conjgC</span><span class="id"> _</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">invXX'</span><span class="id"> _</span><span class="id"> t</span>)<span class="id"> ?groupV</span><span class="id"> ?invgK</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defGt:</span><span class="id"> X</span><span class="id"> *</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span>)<span class="id"> ?cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> tz;</span><span class="id"> apply/imsetP/rcosetP=&gt;</span><span class="id"> [[t'z]</span><span class="id"> |</span><span class="id"> [z]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defGt</span><span class="id"> -normC</span><span class="id"> ?cycle_subG</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> nXG</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/imset2P=&gt;</span><span class="id"> _</span><span class="id"> z</span><span class="id"> /cycleP[j</span><span class="id"> -&gt;]</span><span class="id"> Xz</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {tz</span><span class="id"> t'z}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">z</span><span class="id"> ^-</span><span class="id"> 2</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> defJt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;{z}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> groupV</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {z</span><span class="id"> tz};</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^-</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> groupV</span><span class="id"> groupX</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defJt</span><span class="id"> ?groupV</span><span class="id"> ?mem_cycle</span><span class="id"> //</span><span class="id"> expgVn</span><span class="id"> invgK</span><span class="id"> expgAC</span>.<br/>
<span class="id">have</span><span class="id"> defMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> &gt;&lt;|</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sdprodEY</span><span class="id"> ?cycle_subG</span><span class="id"> ?</span>(<span class="id">subsetP</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> //;</span><span class="id"> first</span><span class="id"> 1</span><span class="id"> last</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> -?orderE</span><span class="id"> ?oX'</span><span class="id"> //</span><span class="id"> cycle_subG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> notXt;</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> rewrite</span><span class="id"> cycleX</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_gen</span><span class="id"> ?class_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> def_tG</span><span class="id"> //</span><span class="id"> eqEsubset</span><span class="id"> join_subG</span><span class="id"> !cycle_subG</span><span class="id"> !gen_subG</span><span class="id"> =&gt;</span><span class="id"> tGt</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> tGt</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span><span class="id"> tGt</span>)<span class="id"> mem_gen</span><span class="id"> ?mem_mulg</span><span class="id"> ?cycle_id</span><span class="id"> ?set11</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul_subG</span><span class="id"> ?joing_subl</span><span class="id"> //</span><span class="id"> -gen_subG</span><span class="id"> joing_subr</span>.<br/>
<span class="id">have</span><span class="id"> oMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #|&lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;|</span><span class="id"> =</span><span class="id"> q}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">sdprod_card</span> (<span class="id">defMt</span><span class="id"> t</span><span class="id"> X't</span>))<span class="id"> -!orderE</span><span class="id"> ox2</span><span class="id"> oX'</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulnC</span>.<br/>
<span class="id">have</span><span class="id"> sMtG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> \subset</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> case/setDP=&gt;</span><span class="id"> Gt</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gen_subG</span><span class="id"> class_subG</span>.<br/>
<span class="id">have</span><span class="id"> maxMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> maximal</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> p_index_maximal</span><span class="id"> -?divgS</span><span class="id"> ?sMtG</span><span class="id"> ?oMt</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> X'xy:</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> !groupMl</span><span class="id"> ?cycle_id</span><span class="id"> ?notXy</span>.<br/>
<span class="id">have</span><span class="id"> ti_yG_xyG:</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/pred0P=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //;</span><span class="id"> apply/andP=&gt;</span><span class="id"> [[yGt]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rcoset_sym</span> (<span class="id">rcoset_eqP</span><span class="id"> yGt</span>)<span class="id"> mem_rcoset</span><span class="id"> mulgK;</span><span class="id"> move/order_dvdG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> ox</span><span class="id"> gtnNdvd</span>.<br/>
<span class="id">have</span><span class="id"> s_tG_X':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> class_sub_norm</span><span class="id"> //</span><span class="id"> normsD</span><span class="id"> ?normG</span>.<br/>
<span class="id">have</span><span class="id"> defX':</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> subUset</span><span class="id"> !s_tG_X'</span><span class="id"> //=</span><span class="id"> -</span>(<span class="id">leq_add2l</span><span class="id"> q</span>)<span class="id"> -{1}ox</span><span class="id"> orderE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/X</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span><span class="id"> sXG</span>)<span class="id"> cardsID</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mul2n</span><span class="id"> -addnn</span><span class="id"> leq_add2l</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">leq_add2r</span><span class="id"> #|yG</span><span class="id"> :&amp;:</span><span class="id"> xyG|</span>)<span class="id"> cardsUI</span><span class="id"> disjoint_setI0</span><span class="id"> //</span><span class="id"> cards0</span><span class="id"> addn0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //</span><span class="id"> !card_rcoset</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> def2r</span>.<br/>
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ?sdprodE</span><span class="id"> //</span><span class="id"> setIC</span><span class="id"> //</span><span class="id"> prime_TIg</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> ?oX'</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> defG';</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span> (<span class="id">leq_trans</span> (<span class="id">nil_class_pgroup</span><span class="id"> pG</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> geq_max</span><span class="id"> leqnn</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt1</span>)<span class="id"> subn2</span><span class="id"> ltnNge</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span> (<span class="id">lcn_nil_classP</span><span class="id"> _</span> (<span class="id">pgroup_nil</span><span class="id"> pG</span>))<span class="id"> eqP</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/trivgPn;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?memL</span><span class="id"> //</span><span class="id"> -order_gt1</span><span class="id"> oxr</span>.<br/>
<span class="id">-</span><span class="id"> split;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> extend_cyclic_Mho</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sX'G1:</span><span class="id"> {subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Gt</span><span class="id"> -</span>(<span class="id">oX'</span><span class="id"> t</span>)<span class="id"> //=</span><span class="id"> expg_order</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> Ohm_sub</span><span class="id"> -{1}defXY</span><span class="id"> mulG_subG</span><span class="id"> !cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span> (<span class="id">sX'G1</span><span class="id"> y</span><span class="id"> X'y</span>))<span class="id"> !sX'G1</span>.<br/>
<span class="id">-</span><span class="id"> split=&gt;</span><span class="id"> //=</span><span class="id"> H;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [maxH</span><span class="id"> |];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/or3P=&gt;</span><span class="id"> /eqP-&gt;;</span><span class="id"> rewrite</span><span class="id"> ?maxMt</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sHG</span><span class="id"> nHG]:=</span><span class="id"> andP</span> (<span class="id">p_maximal_normal</span><span class="id"> pG</span><span class="id"> maxH</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oH:</span><span class="id"> #|H|</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -</span>(<span class="id">p_maximal_index</span><span class="id"> pG</span><span class="id"> maxH</span>)<span class="id"> Lagrange</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">eq_sym</span> (<span class="id">gval</span><span class="id"> H</span>))<span class="id"> -eq_sym</span><span class="id"> !eqEcard</span><span class="id"> oH</span><span class="id"> -orderE</span><span class="id"> ox</span><span class="id"> !oMt</span><span class="id"> //</span><span class="id"> !leqnn</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> sHX:</span> (<span class="id">H</span><span class="id"> \subset</span><span class="id"> X</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> case/subsetPn:</span><span class="id"> sHX</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> Ht</span><span class="id"> notXt</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX'</span><span class="id"> inE</span><span class="id"> notXt</span> (<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !andbT</span><span class="id"> !gen_subG</span><span class="id"> /yG</span><span class="id"> /xyG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setUP;</span><span class="id"> move/class_eqP</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> !class_sub_norm</span><span class="id"> ?Ht</span><span class="id"> ?orbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> eqn_leq</span><span class="id"> n_gt1;</span><span class="id"> case:</span><span class="id"> leqP</span><span class="id"> n2_abelG</span><span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> n_gt2</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> andbC</span><span class="id"> -orderE</span><span class="id"> oxr</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span> (<span class="id">center_sub</span><span class="id"> G</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cardG_gt1</span><span class="id"> /=</span><span class="id"> meet_center_nil</span><span class="id"> ?</span>(<span class="id">pgroup_nil</span><span class="id"> pG</span>)<span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oG</span> (<span class="id">leq_trans</span><span class="id"> _</span><span class="id"> ltqm</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> t;</span><span class="id"> case/setIP=&gt;</span><span class="id"> Gt</span><span class="id"> cGt</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> X't:</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/eqP:</span> (<span class="id">invXX'</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">cycle_id</span><span class="id"> x</span>)<span class="id"> X't</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /conjg</span><span class="id"> -</span>(<span class="id">centP</span><span class="id"> cGt</span>)<span class="id"> //</span><span class="id"> mulKg</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span><span class="id"> -order_eq1</span><span class="id"> ox2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eqn_exp2l</span><span class="id"> _</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">move/idPn:</span><span class="id"> X't;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Gt</span><span class="id"> andbT</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> Xt</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Ohm_p_cycle</span><span class="id"> 1</span> (<span class="id">mem_p_elt</span><span class="id"> pG</span><span class="id"> Gx</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ox</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> subn1</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span> (<span class="id">pgroupS</span><span class="id"> sXG</span><span class="id"> pG</span>))<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Xt</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eq_invg_mul</span><span class="id"> -</span>(<span class="id">invXX'</span><span class="id"> _</span><span class="id"> y</span>)<span class="id"> //</span><span class="id"> /conjg</span> (<span class="id">centP</span><span class="id"> cGt</span>)<span class="id"> //</span><span class="id"> mulKg</span>.<br/>
<span class="id">have</span><span class="id"> isoMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> \isog</span><span class="id"> 'D_q}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n1_gt1:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_2dihedral</span><span class="id"> ?oMt</span><span class="id"> //</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp_2dihedral</span><span class="id"> //;</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> t</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> &lt;-</span><span class="id"> nX2T</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> sdprodP</span> (<span class="id">defMt</span><span class="id"> t</span><span class="id"> X't</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> norm_joinEr</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> !xpair_eqE</span><span class="id"> eqxx</span><span class="id"> -expgM</span><span class="id"> def2r</span><span class="id"> -ox</span><span class="id"> -{1}</span>(<span class="id">oX'</span><span class="id"> t</span><span class="id"> X't</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !expg_order</span><span class="id"> !eqxx</span><span class="id"> /=</span><span class="id"> invXX'</span><span class="id"> ?mem_cycle</span>.<br/>
<span class="id">rewrite</span><span class="id"> !isoMt</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> C;</span><span class="id"> case/cyclicP=&gt;</span><span class="id"> z</span><span class="id"> -&gt;{C}</span><span class="id"> sCG</span><span class="id"> iCG</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X]defU</span><span class="id"> //</span><span class="id"> defU</span><span class="id"> -?cycle_subG</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -iCG</span><span class="id"> Lagrange</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
Qed.</div></details>
<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> quaternion_structure</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'Q_m</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> [/\</span><span class="id"> pprod</span><span class="id"> X</span><span class="id"> Y</span><span class="id"> =</span><span class="id"> G,</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 4}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;,</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id">,</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">-1],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;,</span><span class="id"> #|'Z</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> 2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">forall</span><span class="id"> u,</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #[u]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> u</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span><span class="id"> /\</span><span class="id"> 'Ohm_2</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> 'Mho^k</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">]&gt;],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> M,</span><span class="id"> maximal</span><span class="id"> M</span><span class="id"> G</span><span class="id"> =</span><span class="id"> pred3</span><span class="id"> X</span><span class="id"> My</span><span class="id"> Mxy</span><span class="id"> M]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> My</span><span class="id"> \isog</span><span class="id"> 'Q_q,</span><span class="id"> Mxy</span><span class="id"> \isog</span><span class="id"> 'Q_q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> cyclic</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> =</span><span class="id"> X]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt2</span><span class="id"> genG</span><span class="id"> isoG;</span><span class="id"> have</span><span class="id"> [def2q</span><span class="id"> def2r</span><span class="id"> ltqm</span><span class="id"> ltrq]</span><span class="id"> :=</span><span class="id"> def2qr</span> (<span class="id">ltnW</span><span class="id"> n_gt2</span>).<br/>
<span class="id">have</span><span class="id"> [oG</span><span class="id"> Gx</span><span class="id"> ox</span><span class="id"> X'y]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/m</span><span class="id"> -/q</span><span class="id"> -/X</span><span class="gallina-kwd"> in</span><span class="id"> oG</span><span class="id"> ox</span><span class="id"> X'y</span>.<br/>
<span class="id">case/extremal_generators_facts:</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/X</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> pG</span><span class="id"> maxX</span><span class="id"> nsXG</span><span class="id"> defXY</span><span class="id"> nXY</span>.<br/>
<span class="id">have</span><span class="id"> [sXG</span><span class="id"> nXG]:=</span><span class="id"> andP</span><span class="id"> nsXG;</span><span class="id"> have</span><span class="id"> [Gy</span><span class="id"> notXy]:=</span><span class="id"> setDP</span><span class="id"> X'y</span>.<br/>
<span class="id">have</span><span class="id"> oxr:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> r]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="id">have</span><span class="id"> ox2:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> 2]</span><span class="id"> =</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mulr</span><span class="id"> ?mulKn</span>.<br/>
<span class="id">have</span><span class="id"> [[u</span><span class="id"> v]</span><span class="id"> [_</span><span class="id"> Gu</span><span class="id"> ou</span><span class="id"> U'v]</span><span class="id"> [ov</span><span class="id"> v2</span><span class="id"> uv]]</span><span class="id"> :=</span><span class="id"> generators_quaternion</span><span class="id"> n_gt2</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> defUv:</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> &lt;[u]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> rcoset_index2;</span><span class="id"> rewrite</span><span class="id"> -?divgS</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ou</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> invUV:</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &amp;</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> t;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> case/rcosetP=&gt;</span><span class="id"> ?;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> -&gt;{z</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX2</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> conjXg</span><span class="id"> uv</span><span class="id"> expgVn</span>.<br/>
<span class="id">have</span><span class="id"> U'2:</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> r}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t;</span><span class="id"> case/rcosetP=&gt;</span><span class="id"> z</span><span class="id"> Uz</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> expgS</span><span class="id"> {1}</span>(<span class="id">conjgC</span><span class="id"> z</span>)<span class="id"> -mulgA</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> invUV</span><span class="id"> ?rcoset_refl</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> -</span>(<span class="id">expgS</span><span class="id"> v</span><span class="id"> 1</span>)<span class="id"> v2</span>.<br/>
<span class="id">have</span><span class="id"> our:</span><span class="id"> #[u</span><span class="id"> ^+</span><span class="id"> r]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ou</span><span class="id"> -/q</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="id">have</span><span class="id"> def_ur:</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #[t]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> t</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> r}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> Gt</span><span class="id"> /=</span><span class="id"> ot;</span><span class="id"> case</span><span class="id"> Ut:</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/eqP:</span><span class="id"> ot;</span><span class="id"> rewrite</span><span class="id"> eqn_dvd</span><span class="id"> order_dvdn</span><span class="id"> -order_eq1</span><span class="id"> U'2</span><span class="id"> ?our</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> Ut</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> p2u:</span><span class="id"> 2</span>.<span class="id">-elt</span><span class="id"> u</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /p_elt</span><span class="id"> ou</span><span class="id"> pnatX</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">&lt;[u]&gt;</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> p2u</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Ut</span><span class="id"> -order_dvdn</span><span class="id"> ot</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">Ohm_p_cycle</span><span class="id"> _</span><span class="id"> p2u</span>)<span class="id"> ou</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> subn1</span><span class="id"> -/r</span><span class="id"> cycle_traject</span><span class="id"> our</span><span class="id"> !inE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_eq1</span><span class="id"> ot</span><span class="id"> /=</span><span class="id"> mulg1;</span><span class="id"> move/eqP</span>.<br/>
<span class="id">have</span><span class="id"> defU:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> -&gt;</span><span class="id"> &lt;[z]&gt;</span><span class="id"> =</span><span class="id"> &lt;[u]&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> n_gt3</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> oz;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> -!orderE</span><span class="id"> oz</span><span class="id"> cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ou</span><span class="id"> leqnn</span><span class="id"> andbT;</span><span class="id"> apply:</span><span class="id"> contraLR</span><span class="id"> n_gt3</span><span class="id"> =&gt;</span><span class="id"> notUz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt2</span>)<span class="id"> ltnS</span><span class="id"> -</span>(<span class="id">@ltn_exp2l</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -/q</span><span class="id"> -oz</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">@orderXprime</span><span class="id"> _</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> U'2</span><span class="id"> //</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> notUz</span>.<br/>
<span class="id">have</span><span class="id"> def_xr:</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> def_ur;</span><span class="id"> rewrite</span><span class="id"> ?groupX</span>.<br/>
<span class="id">have</span><span class="id"> X'2:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^+</span><span class="id"> r}</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">ltngtP</span><span class="id"> n</span><span class="id"> 3</span>)<span class="id"> =&gt;</span><span class="id"> [|n_gt3|n3</span><span class="id"> t];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> n_gt2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /X</span><span class="id"> defU</span><span class="id"> //</span><span class="id"> -defUv</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setDP=&gt;</span><span class="id"> Gt</span><span class="id"> notXt</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Ut:</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> U'2</span><span class="id"> //</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> Ut</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [t</span><span class="id"> ^+</span><span class="id"> 2]def_ur</span><span class="id"> ?groupX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> order_dvdG</span><span class="id"> Ut;</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> ou</span><span class="id"> /q</span><span class="id"> n3</span><span class="id"> dvdn_divisors</span><span class="id"> ?inE</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> order_eq1</span> (<span class="id">negbTE</span> (<span class="id">group1_contra</span><span class="id"> notXt</span>))<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case/pred2P=&gt;</span><span class="id"> oz;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> oz</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [t]def_ur</span><span class="id"> //</span><span class="id"> -def_xr</span><span class="id"> mem_cycle</span><span class="gallina-kwd"> in</span><span class="id"> notXt</span>.<br/>
<span class="id">have</span><span class="id"> oX':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span><span class="id"> 4}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span> (<span class="id">@orderXprime</span><span class="id"> _</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> X'2</span>.<br/>
<span class="id">have</span><span class="id"> defZ:</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> andbC</span><span class="id"> -orderE</span><span class="id"> oxr</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span> (<span class="id">center_sub</span><span class="id"> G</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cardG_gt1</span><span class="id"> /=</span><span class="id"> meet_center_nil</span><span class="id"> ?</span>(<span class="id">pgroup_nil</span><span class="id"> pG</span>)<span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oG</span> (<span class="id">leq_trans</span><span class="id"> _</span><span class="id"> ltqm</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> z;</span><span class="id"> case/setIP=&gt;</span><span class="id"> Gz</span><span class="id"> cGz;</span><span class="id"> have</span><span class="id"> [Gv</span><span class="id"> _]:=</span><span class="id"> setDP</span><span class="id"> U'v</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Uvz:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/eqP:</span> (<span class="id">invUV</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">cycle_id</span><span class="id"> u</span>)<span class="id"> Uvz</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /conjg</span><span class="id"> -</span>(<span class="id">centP</span><span class="id"> cGz</span>)<span class="id"> //</span><span class="id"> mulKg</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span><span class="id"> -</span>(<span class="id">order_dvdn</span><span class="id"> _</span><span class="id"> 2</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ou</span><span class="id"> pfactor_dvdn</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">move/idPn:</span><span class="id"> Uvz;</span><span class="id"> rewrite</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> Gz</span><span class="id"> andbT</span><span class="id"> negbK</span><span class="id"> def_xr</span><span class="id"> =&gt;</span><span class="id"> Uz</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> p_u:</span><span class="id"> 2</span>.<span class="id">-elt</span><span class="id"> u</span><span class="id"> :=</span><span class="id"> mem_p_elt</span><span class="id"> pG</span><span class="id"> Gu</span>.<br/>
&nbsp;&nbsp;<span class="id">suff:</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">&lt;[u]&gt;</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">Ohm_p_cycle</span><span class="id"> 1</span><span class="id"> p_u</span>)<span class="id"> ou</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> subn1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> p_u</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Uz</span><span class="id"> /=</span><span class="id"> -eq_invg_mul</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">invUV</span><span class="id"> _</span><span class="id"> v</span>)<span class="id"> ?rcoset_refl</span><span class="id"> //</span><span class="id"> /conjg</span> (<span class="id">centP</span><span class="id"> cGz</span>)<span class="id"> ?mulKg</span>.<br/>
<span class="id">have{invUV}</span><span class="id"> invXX':</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z^-1}</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">ltngtP</span><span class="id"> n</span><span class="id"> 3</span>)<span class="id"> =&gt;</span><span class="id"> [|n_gt3|n3</span><span class="id"> t</span><span class="id"> z</span><span class="id"> Xt];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> n_gt2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /X</span><span class="id"> defU</span><span class="id"> //</span><span class="id"> -defUv</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setDP=&gt;</span><span class="id"> Gz</span><span class="id"> notXz;</span><span class="id"> rewrite</span><span class="id"> /q</span><span class="id"> /r</span><span class="id"> n3</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> oxr</span><span class="id"> ox</span>.<br/>
&nbsp;&nbsp;<span class="id">suff</span><span class="id"> xz:</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> =</span><span class="id"> x^-1</span><span class="gallina-kwd"> by</span><span class="id"> case/cycleP:</span><span class="id"> Xt</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> conjXg</span><span class="id"> xz</span><span class="id"> expgVn</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> memJ_norm</span><span class="id"> ?cycle_id</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> nXG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> invg_expg</span><span class="id"> /X</span><span class="id"> cycle_traject</span><span class="id"> ox</span><span class="id"> !inE</span><span class="id"> /=</span><span class="id"> !mulg1</span><span class="id"> -order_eq1</span><span class="id"> orderJ</span><span class="id"> ox</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case/or3P;</span><span class="id"> move/eqP=&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> move/</span>(<span class="id">congr1</span><span class="id"> order</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> orderJ</span><span class="id"> ox</span><span class="id"> oxr</span>.<br/>
&nbsp;&nbsp;<span class="id">move/conjg_fixP;</span><span class="id"> rewrite</span> (<span class="id">sameP</span><span class="id"> commgP</span><span class="id"> cent1P</span>)<span class="id"> cent1C</span><span class="id"> -cent_cycle</span><span class="id"> -/X</span><span class="id"> =&gt;</span><span class="id"> cXz</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defXz:</span><span class="id"> X</span><span class="id"> *</span><span class="id"> &lt;[z]&gt;</span><span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span>)<span class="id"> ?cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Gz</span><span class="id"> -defXz</span><span class="id"> centM</span><span class="id"> inE</span><span class="id"> cXz</span><span class="id"> cent_cycle</span><span class="id"> cent1id</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defZ</span><span class="id"> =&gt;</span><span class="id"> Xr_z;</span><span class="id"> rewrite</span> (<span class="id">subsetP</span> (<span class="id">cycleX</span><span class="id"> x</span><span class="id"> r</span>))<span class="gallina-kwd"> in</span><span class="id"> notXz</span>.<br/>
<span class="id">have</span><span class="id"> nXiG</span><span class="id"> k:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">&lt;[x</span><span class="id"> ^+</span><span class="id"> k]&gt;</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> char_norm_trans</span><span class="id"> nXG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subgroup_char</span><span class="id"> //</span><span class="id"> cycle_subG</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> memL</span><span class="id"> i:</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>)<span class="id"> \in</span><span class="id"> 'L_i</span>.<span class="id">+1</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> IHi;</span><span class="id"> rewrite</span><span class="id"> -groupV</span><span class="id"> expnSr</span><span class="id"> expgM</span><span class="id"> invMg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}</span>(<span class="id">invXX'</span><span class="id"> _</span><span class="id"> y</span>)<span class="id"> ?mem_cycle</span><span class="id"> ?cycle_id</span><span class="id"> ?mem_commg</span>.<br/>
<span class="id">have</span><span class="id"> defG':</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> cycle_subG</span> (<span class="id">memL</span><span class="id"> 1%N</span>)<span class="id"> ?der1_min</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">p2group_abelian</span> (<span class="id">quotient_pgroup</span><span class="id"> _</span><span class="id"> pG</span>))<span class="id"> ?card_quotient</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -divgS</span><span class="id"> ?cycle_subG</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ox2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def2q</span><span class="id"> -def2r</span><span class="id"> mulnA</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> defG1:</span><span class="id"> 'Mho^1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span> (<span class="id">MhoE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> eqEsubset</span><span class="id"> !gen_subG</span><span class="id"> sub1set</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_gen;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> imset_f</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> z2;</span><span class="id"> case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> -&gt;{z2}</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Xz:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">X'2</span><span class="id"> z</span>)<span class="id"> ?inE</span><span class="id"> ?Xz</span><span class="id"> //</span><span class="id"> -def_xr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /r</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>)<span class="id"> expnS</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> defPhi:</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pG</span>)<span class="id"> defG'</span><span class="id"> defG1</span> (<span class="id">joing_idPl</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> def_tG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> :*</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defJt:</span><span class="id"> {in</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> t</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^-</span><span class="id"> 2</span><span class="id"> *</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Xz;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> invMg</span><span class="id"> -mulgA</span> (<span class="id">conjgC</span><span class="id"> _</span><span class="id"> t</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">invXX'</span><span class="id"> _</span><span class="id"> t</span>)<span class="id"> ?groupV</span><span class="id"> ?invgK</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defGt:</span><span class="id"> X</span><span class="id"> *</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span>)<span class="id"> ?cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> tz;</span><span class="id"> apply/imsetP/rcosetP=&gt;</span><span class="id"> [[t'z]</span><span class="id"> |</span><span class="id"> [z]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defGt</span><span class="id"> -normC</span><span class="id"> ?cycle_subG</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> nXG</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/imset2P=&gt;</span><span class="id"> t'</span><span class="id"> z;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> Xz</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {tz</span><span class="id"> t'z</span><span class="id"> t'}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">z</span><span class="id"> ^-</span><span class="id"> 2</span>)<span class="id">;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> defJt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;{z}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> groupV</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {z</span><span class="id"> tz};</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^-</span><span class="id"> i</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> groupV</span><span class="id"> groupX</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defJt</span><span class="id"> ?groupV</span><span class="id"> ?mem_cycle</span><span class="id"> //</span><span class="id"> expgVn</span><span class="id"> invgK</span><span class="id"> -!expgM</span><span class="id"> mulnC</span>.<br/>
<span class="id">have</span><span class="id"> defMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> &lt;*&gt;</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_gen</span><span class="id"> ?class_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> def_tG</span><span class="id"> //</span><span class="id"> eqEsubset</span><span class="id"> join_subG</span><span class="id"> !cycle_subG</span><span class="id"> !gen_subG</span><span class="id"> =&gt;</span><span class="id"> tGt</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> tGt</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span><span class="id"> tGt</span>)<span class="id"> mem_gen</span><span class="id"> ?mem_mulg</span><span class="id"> ?cycle_id</span><span class="id"> ?set11</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul_subG</span><span class="id"> ?joing_subl</span><span class="id"> //</span><span class="id"> -gen_subG</span><span class="id"> joing_subr</span>.<br/>
<span class="id">have</span><span class="id"> sMtG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> \subset</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> case/setDP=&gt;</span><span class="id"> Gt</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gen_subG</span><span class="id"> class_subG</span>.<br/>
<span class="id">have</span><span class="id"> oMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #|&lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;|</span><span class="id"> =</span><span class="id"> q}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defMt</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">Lagrange</span> (<span class="id">joing_subl</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> -def2r</span><span class="id"> mulnC</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span> (_<span class="id"> *</span><span class="id"> r</span>)<span class="id">%N;</span><span class="id"> rewrite</span><span class="id"> -card_quotient</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defMt</span><span class="id"> //</span> (<span class="id">subset_trans</span><span class="id"> _</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> ?sMtG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> joingC</span><span class="id"> quotientYidr</span><span class="id"> ?</span>(<span class="id">subset_trans</span><span class="id"> _</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> quotient_cycle</span><span class="id"> ?</span>(<span class="id">subsetP</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> //=</span><span class="id"> -defPhi</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -orderE</span> (<span class="id">abelem_order_p</span> (<span class="id">Phi_quotient_abelem</span><span class="id"> pG</span>))<span class="id"> ?mem_quotient</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraNneq</span><span class="id"> notXt;</span><span class="id"> move/coset_idr;</span><span class="id"> move/implyP=&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defPhi</span><span class="id"> ?</span>(<span class="id">subsetP</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> apply:</span><span class="id"> cycleX</span>.<br/>
<span class="id">have</span><span class="id"> maxMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> maximal</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> p_index_maximal</span><span class="id"> -?divgS</span><span class="id"> ?sMtG</span><span class="id"> ?oMt</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> X'xy:</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> !groupMl</span><span class="id"> ?cycle_id</span><span class="id"> ?notXy</span>.<br/>
<span class="id">have</span><span class="id"> ti_yG_xyG:</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/pred0P=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //;</span><span class="id"> apply/andP=&gt;</span><span class="id"> [[yGt]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rcoset_sym</span> (<span class="id">rcoset_eqP</span><span class="id"> yGt</span>)<span class="id"> mem_rcoset</span><span class="id"> mulgK;</span><span class="id"> move/order_dvdG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> ox</span><span class="id"> gtnNdvd</span>.<br/>
<span class="id">have</span><span class="id"> s_tG_X':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> class_sub_norm</span><span class="id"> //</span><span class="id"> normsD</span><span class="id"> ?normG</span>.<br/>
<span class="id">have</span><span class="id"> defX':</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> subUset</span><span class="id"> !s_tG_X'</span><span class="id"> //=</span><span class="id"> -</span>(<span class="id">leq_add2l</span><span class="id"> q</span>)<span class="id"> -{1}ox</span><span class="id"> orderE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/X</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span><span class="id"> sXG</span>)<span class="id"> cardsID</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mul2n</span><span class="id"> -addnn</span><span class="id"> leq_add2l</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">leq_add2r</span><span class="id"> #|yG</span><span class="id"> :&amp;:</span><span class="id"> xyG|</span>)<span class="id"> cardsUI</span><span class="id"> disjoint_setI0</span><span class="id"> //</span><span class="id"> cards0</span><span class="id"> addn0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //</span><span class="id"> !card_rcoset</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> def2r</span>.<br/>
<span class="id">rewrite</span><span class="id"> pprodE</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> [|||n_gt3]</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> defG';</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">leq_trans</span> (<span class="id">nil_class_pgroup</span><span class="id"> pG</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span> (<span class="id">ltnW</span><span class="id"> n_gt2</span>))<span class="id"> subn2</span><span class="id"> ltnNge</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span> (<span class="id">lcn_nil_classP</span><span class="id"> _</span> (<span class="id">pgroup_nil</span><span class="id"> pG</span>))<span class="id"> eqP</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/trivgPn;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?memL</span><span class="id"> //</span><span class="id"> -order_gt1</span><span class="id"> oxr</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> {2}def_xr</span><span class="id"> defZ;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> extend_cyclic_Mho</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> apply/eqP;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> sX'G2:</span><span class="id"> {subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> 'Ohm_2</span>(<span class="id">G</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> X'z;</span><span class="id"> have</span><span class="id"> [Gz</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X'z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> 2</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Gz</span><span class="id"> -order_dvdn</span><span class="id"> oX'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> Ohm_sub</span><span class="id"> -{1}defXY</span><span class="id"> mulG_subG</span><span class="id"> !cycle_subG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span> (<span class="id">sX'G2</span><span class="id"> y</span><span class="id"> X'y</span>))<span class="id"> !sX'G2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset</span> (<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pG</span>)<span class="id"> cycle_subG</span><span class="id"> gen_subG</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_gen</span><span class="id"> ?inE</span><span class="id"> ?groupX</span><span class="id"> -?order_dvdn</span><span class="id"> ?oxr</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> t;</span><span class="id"> case/setIP=&gt;</span><span class="id"> Gt;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -order_dvdn</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dvdn_divisors</span><span class="id"> ?inE</span><span class="id"> //=</span><span class="id"> order_eq1</span>.<br/>
&nbsp;&nbsp;<span class="id">case/pred2P=&gt;</span><span class="id"> [-&gt;|];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> group1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/def_ur=&gt;</span><span class="id"> -&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> def_xr</span><span class="id"> cycle_id</span>.<br/>
<span class="id">-</span><span class="id"> split=&gt;</span><span class="id"> //=</span><span class="id"> H;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [maxH</span><span class="id"> |];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/or3P=&gt;</span><span class="id"> /eqP-&gt;;</span><span class="id"> rewrite</span><span class="id"> ?maxMt</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sHG</span><span class="id"> nHG]:=</span><span class="id"> andP</span> (<span class="id">p_maximal_normal</span><span class="id"> pG</span><span class="id"> maxH</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oH:</span><span class="id"> #|H|</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -</span>(<span class="id">p_maximal_index</span><span class="id"> pG</span><span class="id"> maxH</span>)<span class="id"> Lagrange</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">eq_sym</span> (<span class="id">gval</span><span class="id"> H</span>))<span class="id"> -eq_sym</span><span class="id"> !eqEcard</span><span class="id"> oH</span><span class="id"> -orderE</span><span class="id"> ox</span><span class="id"> !oMt</span><span class="id"> //</span><span class="id"> !leqnn</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> sHX:</span> (<span class="id">H</span><span class="id"> \subset</span><span class="id"> X</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> case/subsetPn:</span><span class="id"> sHX</span><span class="id"> =&gt;</span><span class="id"> z</span><span class="id"> Hz</span><span class="id"> notXz</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX'</span><span class="id"> inE</span><span class="id"> notXz</span> (<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !andbT</span><span class="id"> !gen_subG</span><span class="id"> /yG</span><span class="id"> /xyG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setUP=&gt;</span><span class="id"> /class_eqP</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> !class_sub_norm</span><span class="id"> ?Hz</span><span class="id"> ?orbT</span>.<br/>
<span class="id">have</span><span class="id"> isoMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> &lt;&lt;z</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> \isog</span><span class="id"> 'Q_q}</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n1_gt2:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> X'z</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_quaternion</span><span class="id"> ?oMt</span><span class="id"> //</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp_quaternion</span><span class="id"> //;</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> z</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defMt</span><span class="id"> //</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> !xpair_eqE</span><span class="id"> -!expgM</span><span class="id"> def2r</span><span class="id"> -order_dvdn</span><span class="id"> ox</span><span class="id"> dvdnn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expnS</span><span class="id"> prednK;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subn2</span><span class="id"> subn_gt0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> X'2</span><span class="id"> //</span><span class="id"> def_xr</span><span class="id"> !eqxx</span><span class="id"> /=</span><span class="id"> invXX'</span><span class="id"> ?mem_cycle</span>.<br/>
<span class="id">rewrite</span><span class="id"> !isoMt</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> //</span><span class="id"> C;</span><span class="id"> case/cyclicP=&gt;</span><span class="id"> z</span><span class="id"> -&gt;{C}</span><span class="id"> sCG</span><span class="id"> iCG</span>.<br/>
<span class="id">rewrite</span><span class="id"> [X]defU</span><span class="id"> //</span><span class="id"> defU</span><span class="id"> -?cycle_subG</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -iCG</span><span class="id"> Lagrange</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> semidihedral_structure</span><span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> -&gt;</span><span class="id"> extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'SD_m</span><span class="id"> -&gt;</span><span class="id"> #[y]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> [/\</span><span class="id"> X</span><span class="id"> &gt;&lt;|</span><span class="id"> Y</span><span class="id"> =</span><span class="id"> G,</span><span class="id"> #[x</span><span class="id"> *</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> 4</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-1}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;,</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id">,</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">-1],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;,</span><span class="id"> #|'Z</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> 2,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> My</span><span class="id"> /\</span><span class="id"> 'Ohm_2</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> 'Mho^k</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">]&gt;],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> /\</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> H,</span><span class="id"> maximal</span><span class="id"> H</span><span class="id"> G</span><span class="id"> =</span><span class="id"> pred3</span><span class="id"> X</span><span class="id"> My</span><span class="id"> Mxy</span><span class="id"> H]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> [/\</span><span class="id"> My</span><span class="id"> \isog</span><span class="id"> 'D_q,</span><span class="id"> Mxy</span><span class="id"> \isog</span><span class="id"> 'Q_q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> cyclic</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> =</span><span class="id"> X]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> n_gt3</span><span class="id"> genG</span><span class="id"> isoG</span><span class="id"> oy</span>.<br/>
<span class="id">have</span><span class="id"> [def2q</span><span class="id"> def2r</span><span class="id"> ltqm</span><span class="id"> ltrq]</span><span class="id"> :=</span><span class="id"> def2qr</span> (<span class="id">ltnW</span> (<span class="id">ltnW</span><span class="id"> n_gt3</span>)).<br/>
<span class="id">have</span><span class="id"> [oG</span><span class="id"> Gx</span><span class="id"> ox</span><span class="id"> X'y]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/m</span><span class="id"> -/q</span><span class="id"> -/X</span><span class="gallina-kwd"> in</span><span class="id"> oG</span><span class="id"> ox</span><span class="id"> X'y</span>.<br/>
<span class="id">case/extremal_generators_facts:</span><span class="id"> genG;</span><span class="id"> rewrite</span><span class="id"> -/X</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> pG</span><span class="id"> maxX</span><span class="id"> nsXG</span><span class="id"> defXY</span><span class="id"> nXY</span>.<br/>
<span class="id">have</span><span class="id"> [sXG</span><span class="id"> nXG]:=</span><span class="id"> andP</span><span class="id"> nsXG;</span><span class="id"> have</span><span class="id"> [Gy</span><span class="id"> notXy]:=</span><span class="id"> setDP</span><span class="id"> X'y</span>.<br/>
<span class="id">have</span><span class="id"> ox2:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> 2]</span><span class="id"> =</span><span class="id"> r</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mulr</span><span class="id"> ?mulKn</span>.<br/>
<span class="id">have</span><span class="id"> oxr:</span><span class="id"> #[x</span><span class="id"> ^+</span><span class="id"> r]</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def2r</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="id">have</span><span class="id"> [[u</span><span class="id"> v]</span><span class="id"> [_</span><span class="id"> Gu</span><span class="id"> ou</span><span class="id"> U'v]</span><span class="id"> [ov</span><span class="id"> uv]]</span><span class="id"> :=</span><span class="id"> generators_semidihedral</span><span class="id"> n_gt3</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> defUv:</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> &lt;[u]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> rcoset_index2;</span><span class="id"> rewrite</span><span class="id"> -?divgS</span><span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ou</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> invUV:</span><span class="id"> {in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &amp;</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-1}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> t;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> case/rcosetP=&gt;</span><span class="id"> ?;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> -&gt;{z</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX2</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> conjXg</span><span class="id"> uv</span><span class="id"> -!expgM</span><span class="id"> mulnC</span>.<br/>
<span class="id">have</span><span class="id"> [vV</span><span class="id"> yV]:</span><span class="id"> v^-1</span><span class="id"> =</span><span class="id"> v</span><span class="id"> /\</span><span class="id"> y^-1</span><span class="id"> =</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !invg_expg</span><span class="id"> ov</span><span class="id"> oy</span>.<br/>
<span class="id">have</span><span class="id"> defU:</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> -&gt;</span><span class="id"> &lt;[z]&gt;</span><span class="id"> =</span><span class="id"> &lt;[u]&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> /=</span><span class="id"> oz;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> -!orderE</span><span class="id"> oz</span><span class="id"> ou</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraLR</span> (<span class="id">n_gt3</span>)<span class="id"> =&gt;</span><span class="id"> notUz;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt3</span>)<span class="id"> ltnS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">@dvdn_Pexp2l</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -/q</span><span class="id"> -{}oz</span><span class="id"> order_dvdn</span><span class="id"> expgM</span> (<span class="id">expgS</span><span class="id"> z</span>).<br/>
&nbsp;&nbsp;<span class="id">have{Gz</span><span class="id"> notUz}</span><span class="id"> [z'</span><span class="id"> Uz'</span><span class="id"> -&gt;{z}]:</span><span class="gallina-kwd"> exists2</span><span class="id"> z',</span><span class="id"> z'</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> &amp;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> z'</span><span class="id"> *</span><span class="id"> v</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/rcosetP;</span><span class="id"> rewrite</span><span class="id"> defUv</span><span class="id"> inE</span><span class="id"> -cycle_subG</span><span class="id"> notUz</span><span class="id"> Gz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {2}</span>(<span class="id">conjgC</span><span class="id"> z'</span>)<span class="id"> invUV</span><span class="id"> ?rcoset_refl</span><span class="id"> //</span><span class="id"> mulgA</span><span class="id"> -{2}vV</span><span class="id"> mulgK</span><span class="id"> -expgS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prednK</span><span class="id"> //</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> def2r</span><span class="id"> -order_dvdn</span><span class="id"> /q</span><span class="id"> -ou</span><span class="id"> order_dvdG</span>.<br/>
<span class="id">have{invUV}</span><span class="id"> invXX':</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z</span><span class="id"> t,</span><span class="id"> z</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-1}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /X</span><span class="id"> defU</span><span class="id"> -?defUv</span>.<br/>
<span class="id">have</span><span class="id"> xy2:</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id"> ^+</span><span class="id"> 2</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expgS</span><span class="id"> {2}</span>(<span class="id">conjgC</span><span class="id"> x</span>)<span class="id"> invXX'</span><span class="id"> ?cycle_id</span><span class="id"> //</span><span class="id"> mulgA</span><span class="id"> -{2}yV</span><span class="id"> mulgK</span><span class="id"> -expgS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prednK</span>.<br/>
<span class="id">have</span><span class="id"> oxy:</span><span class="id"> #[x</span><span class="id"> *</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> 4</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">@orderXprime</span><span class="id"> _</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> ?xy2</span>.<br/>
<span class="id">have</span><span class="id"> r_gt2:</span><span class="id"> r</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 1</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
<span class="id">have</span><span class="id"> coXr1:</span><span class="id"> coprime</span><span class="id"> #[x]</span> (<span class="id">2</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> 3</span>)).<span class="id">-1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ox</span><span class="id"> coprimeXl</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">@coprime_pexpl</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> 3</span>))<span class="id"> ?coprimenP</span><span class="id"> ?subn_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span>.<br/>
<span class="id">have</span><span class="id"> def2r1:</span> (<span class="id">2</span><span class="id"> *</span> (<span class="id">2</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> 3</span>)).<span class="id">-1</span>).<span class="id">+1</span><span class="id"> =</span><span class="id"> r</span>.<span class="id">-1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!subn1</span><span class="id"> mulnBr</span><span class="id"> -expnS</span><span class="id"> [_</span>.<span class="id">+1]subnSK</span><span class="id"> ?</span>(<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /r</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
<span class="id">have</span><span class="id"> defZ:</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> andbC</span><span class="id"> -orderE</span><span class="id"> oxr</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span> (<span class="id">center_sub</span><span class="id"> G</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cardG_gt1</span><span class="id"> /=</span><span class="id"> meet_center_nil</span><span class="id"> ?</span>(<span class="id">pgroup_nil</span><span class="id"> pG</span>)<span class="id"> //;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oG</span> (<span class="id">leq_trans</span><span class="id"> _</span><span class="id"> ltqm</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> z</span><span class="id"> /setIP[Gz</span><span class="id"> cGz]</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> X'z:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/eqP:</span> (<span class="id">invXX'</span><span class="id"> _</span><span class="id"> _</span> (<span class="id">cycle_id</span><span class="id"> x</span>)<span class="id"> X'z</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /conjg</span><span class="id"> -</span>(<span class="id">centP</span><span class="id"> cGz</span>)<span class="id"> //</span><span class="id"> mulKg</span><span class="id"> -def2r1</span><span class="id"> eq_mulVg1</span><span class="id"> expgS</span><span class="id"> mulKg</span><span class="id"> mulnC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -order_dvdn</span><span class="id"> Gauss_dvdr</span><span class="id"> //</span><span class="id"> order_dvdn</span><span class="id"> -order_eq1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ox2</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> r_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">move/idPn:</span><span class="id"> X'z;</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> Gz</span><span class="id"> andbT</span><span class="id"> negbK</span><span class="id"> =&gt;</span><span class="id"> Xz</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Ohm_p_cycle</span><span class="id"> 1</span> (<span class="id">mem_p_elt</span><span class="id"> pG</span><span class="id"> Gx</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ox</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> subn1</span><span class="id"> =&gt;</span><span class="id"> &lt;-</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span> (<span class="id">mem_p_elt</span><span class="id"> pG</span><span class="id"> Gx</span>))<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Xz</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">expgK</span><span class="id"> coXr1</span><span class="id"> Xz</span>)<span class="id"> -!expgM</span><span class="id"> mulnCA</span><span class="id"> -order_dvdn</span><span class="id"> dvdn_mull</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulnC</span><span class="id"> order_dvdn</span><span class="id"> -</span>(<span class="id">inj_eq</span> (<span class="id">mulgI</span><span class="id"> z</span>))<span class="id"> -expgS</span><span class="id"> mulg1</span><span class="id"> def2r1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">invXX'</span><span class="id"> z</span><span class="id"> y</span>)<span class="id"> //</span><span class="id"> /conjg</span> (<span class="id">centP</span><span class="id"> cGz</span>)<span class="id"> ?mulKg</span>.<br/>
<span class="id">have</span><span class="id"> nXiG</span><span class="id"> k:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> 'N</span>(<span class="id">&lt;[x</span><span class="id"> ^+</span><span class="id"> k]&gt;</span>).<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> char_norm_trans</span><span class="id"> nXG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycle_subgroup_char</span><span class="id"> //</span><span class="id"> cycle_subG</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> memL</span><span class="id"> i:</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>)<span class="id"> \in</span><span class="id"> 'L_i</span>.<span class="id">+1</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">elim:</span><span class="id"> i</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> i</span><span class="id"> IHi;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">expgK</span><span class="id"> coXr1</span> (<span class="id">mem_cycle</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> groupX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgM</span><span class="id"> expnSr</span><span class="id"> -mulnA</span><span class="id"> expgM</span><span class="id"> -</span>(<span class="id">mulKg</span> (<span class="id">x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> i</span>)) (_<span class="id"> ^+</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -expgS</span><span class="id"> def2r1</span><span class="id"> -</span>(<span class="id">invXX'</span><span class="id"> _</span><span class="id"> y</span>)<span class="id"> ?mem_cycle</span><span class="id"> ?mem_commg</span>.<br/>
<span class="id">have</span><span class="id"> defG':</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> cycle_subG</span> (<span class="id">memL</span><span class="id"> 1%N</span>)<span class="id"> ?der1_min</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">p2group_abelian</span> (<span class="id">quotient_pgroup</span><span class="id"> _</span><span class="id"> pG</span>))<span class="id"> ?card_quotient</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -divgS</span><span class="id"> ?cycle_subG</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -orderE</span><span class="id"> ox2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def2q</span><span class="id"> -def2r</span><span class="id"> mulnA</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> defG1:</span><span class="id"> 'Mho^1</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span> (<span class="id">MhoE</span><span class="id"> _</span><span class="id"> pG</span>)<span class="id"> eqEsubset</span><span class="id"> !gen_subG</span><span class="id"> sub1set</span><span class="id"> andbC</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_gen;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> imset_f</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> z2;</span><span class="id"> case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> Gz</span><span class="id"> -&gt;{z2}</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Xz:</span> (<span class="id">z</span><span class="id"> \in</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> mulnC</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">have{Xz</span><span class="id"> Gz}</span><span class="id"> [xi</span><span class="id"> Xxi</span><span class="id"> -&gt;{z}]:</span><span class="gallina-kwd"> exists2</span><span class="id"> xi,</span><span class="id"> xi</span><span class="id"> \in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> xi</span><span class="id"> *</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> Uvy:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> &lt;[u]&gt;</span><span class="id"> :*</span><span class="id"> v</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defUv</span><span class="id"> -</span>(<span class="id">defU</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/rcosetP;</span><span class="id"> rewrite</span><span class="id"> /X</span><span class="id"> defU</span><span class="id"> //</span> (<span class="id">rcoset_eqP</span><span class="id"> Uvy</span>)<span class="id"> defUv</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> -</span>(<span class="id">defU</span><span class="id"> x</span>)<span class="id"> ?Xz</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expn1</span><span class="id"> expgS</span><span class="id"> {2}</span>(<span class="id">conjgC</span><span class="id"> xi</span>)<span class="id"> -{2}[y]/</span>(<span class="id">y</span><span class="id"> ^+</span><span class="id"> 2</span>.<span class="id">-1</span>)<span class="id"> -{1}oy</span><span class="id"> -invg_expg</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulgA</span><span class="id"> mulgK</span><span class="id"> invXX'</span><span class="id"> //</span><span class="id"> -expgS</span><span class="id"> prednK</span><span class="id"> //</span><span class="id"> /r</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>)<span class="id"> expnS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/cycleP:</span><span class="id"> Xxi</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> mulnCA</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> defPhi:</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pG</span>)<span class="id"> defG'</span><span class="id"> defG1</span> (<span class="id">joing_idPl</span><span class="id"> _</span>).<br/>
<span class="id">have</span><span class="id"> def_tG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> :*</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defJt:</span><span class="id"> {in</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> t</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> =</span><span class="id"> z</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-2</span><span class="id"> *</span><span class="id"> t}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> z</span><span class="id"> Xz</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mulKg</span><span class="id"> z</span> (<span class="id">z</span><span class="id"> ^+</span><span class="id"> _</span>))<span class="id"> -expgS</span><span class="id"> -subn2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> X'tV:</span><span class="id"> t^-1</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> !groupV</span><span class="id"> notXt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subnSK</span><span class="id"> 1?ltnW</span><span class="id"> //</span><span class="id"> subn1</span><span class="id"> -</span>(<span class="id">invXX'</span><span class="id"> _</span><span class="id"> t^-1</span>)<span class="id"> //</span><span class="id"> -mulgA</span><span class="id"> -conjgCV</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defGt:</span><span class="id"> X</span><span class="id"> *</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span>)<span class="id"> ?cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/setP=&gt;</span><span class="id"> tz;</span><span class="id"> apply/imsetP/rcosetP=&gt;</span><span class="id"> [[t'z]</span><span class="id"> |</span><span class="id"> [z]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defGt</span><span class="id"> -normC</span><span class="id"> ?cycle_subG</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> nXG</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/imset2P=&gt;</span><span class="id"> t'</span><span class="id"> z;</span><span class="id"> case/cycleP=&gt;</span><span class="id"> j</span><span class="id"> -&gt;</span><span class="id"> Xz</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {t'</span><span class="id"> t'z</span><span class="id"> tz}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">z</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-2</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX</span><span class="id"> //</span><span class="id"> mulKg</span><span class="id"> defJt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/cycleP:</span><span class="id"> Xz</span><span class="id"> =&gt;</span><span class="id"> i</span><span class="id"> -&gt;{z}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def2r1</span><span class="id"> -expgM</span><span class="id"> mulnCA</span><span class="id"> expgM</span><span class="id"> mem_cycle</span>.<br/>
&nbsp;&nbsp;<span class="id">case/cycleP=&gt;</span><span class="id"> i</span><span class="id"> -&gt;</span><span class="id"> -&gt;</span><span class="id"> {z</span><span class="id"> tz}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">x</span><span class="id"> ^+</span> (<span class="id">i</span><span class="id"> *</span><span class="id"> expg_invn</span><span class="id"> X</span> (<span class="id">2</span><span class="id"> ^</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> 3</span>)).<span class="id">-1</span>))<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> groupX</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defJt</span><span class="id"> ?mem_cycle</span><span class="id"> //</span><span class="id"> -def2r1</span><span class="id"> -!expgM</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulnAC</span><span class="id"> mulnA</span><span class="id"> mulnC</span><span class="id"> muln2</span><span class="id"> !expgM</span><span class="id"> expgK</span><span class="id"> ?mem_cycle</span>.<br/>
<span class="id">have</span><span class="id"> defMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;</span><span class="id"> &lt;*&gt;</span><span class="id"> &lt;[t]&gt;</span><span class="id"> =</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mem_gen</span><span class="id"> ?class_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> def_tG</span><span class="id"> //</span><span class="id"> eqEsubset</span><span class="id"> join_subG</span><span class="id"> !cycle_subG</span><span class="id"> !gen_subG</span><span class="id"> =&gt;</span><span class="id"> tGt</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> tGt</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span><span class="id"> tGt</span>)<span class="id"> mem_gen</span><span class="id"> ?mem_mulg</span><span class="id"> ?cycle_id</span><span class="id"> ?set11</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mul_subG</span><span class="id"> ?joing_subl</span><span class="id"> //</span><span class="id"> -gen_subG</span><span class="id"> joing_subr</span>.<br/>
<span class="id">have</span><span class="id"> sMtG:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> \subset</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t;</span><span class="id"> case/setDP=&gt;</span><span class="id"> Gt</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> gen_subG</span><span class="id"> class_subG</span>.<br/>
<span class="id">have</span><span class="id"> oMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> #|&lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;|</span><span class="id"> =</span><span class="id"> q}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> notXt]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defMt</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">Lagrange</span> (<span class="id">joing_subl</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> -def2r</span><span class="id"> mulnC</span>.<br/>
&nbsp;&nbsp;<span class="id">congr</span> (_<span class="id"> *</span><span class="id"> r</span>)<span class="id">%N;</span><span class="id"> rewrite</span><span class="id"> -card_quotient</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defMt</span><span class="id"> //</span> (<span class="id">subset_trans</span><span class="id"> _</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> ?sMtG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> joingC</span><span class="id"> quotientYidr</span><span class="id"> ?</span>(<span class="id">subset_trans</span><span class="id"> _</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> ?cycle_subG</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> quotient_cycle</span><span class="id"> ?</span>(<span class="id">subsetP</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> //=</span><span class="id"> -defPhi</span><span class="id"> -orderE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">abelem_order_p</span> (<span class="id">Phi_quotient_abelem</span><span class="id"> pG</span>))<span class="id"> ?mem_quotient</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraNneq</span><span class="id"> notXt;</span><span class="id"> move/coset_idr;</span><span class="id"> move/implyP=&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> defPhi</span> (<span class="id">subsetP</span> (<span class="id">nXiG</span><span class="id"> 2</span>))<span class="id"> //;</span><span class="id"> apply:</span><span class="id"> subsetP;</span><span class="id"> apply:</span><span class="id"> cycleX</span>.<br/>
<span class="id">have</span><span class="id"> maxMt:</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> maximal</span><span class="id"> &lt;&lt;t</span><span class="id"> ^:</span><span class="id"> G&gt;&gt;</span><span class="id"> G}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> p_index_maximal</span><span class="id"> -?divgS</span><span class="id"> ?sMtG</span><span class="id"> ?oMt</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mulnK</span>.<br/>
<span class="id">have</span><span class="id"> X'xy:</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> !groupMl</span><span class="id"> ?cycle_id</span><span class="id"> ?notXy</span>.<br/>
<span class="id">have</span><span class="id"> ti_yG_xyG:</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/pred0P=&gt;</span><span class="id"> t;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //;</span><span class="id"> apply/andP=&gt;</span><span class="id"> [[yGt]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> rcoset_sym</span> (<span class="id">rcoset_eqP</span><span class="id"> yGt</span>)<span class="id"> mem_rcoset</span><span class="id"> mulgK;</span><span class="id"> move/order_dvdG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> ox</span><span class="id"> gtnNdvd</span>.<br/>
<span class="id">have</span><span class="id"> s_tG_X':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> t</span><span class="id"> ^:</span><span class="id"> G</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move=&gt;</span><span class="id"> t</span><span class="id"> X't</span><span class="id"> /=;</span><span class="id"> rewrite</span><span class="id"> class_sub_norm</span><span class="id"> //</span><span class="id"> normsD</span><span class="id"> ?normG</span>.<br/>
<span class="id">have</span><span class="id"> defX':</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> subUset</span><span class="id"> !s_tG_X'</span><span class="id"> //=</span><span class="id"> -</span>(<span class="id">leq_add2l</span><span class="id"> q</span>)<span class="id"> -{1}ox</span><span class="id"> orderE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -/X</span><span class="id"> -{1}</span>(<span class="id">setIidPr</span><span class="id"> sXG</span>)<span class="id"> cardsID</span><span class="id"> oG</span><span class="id"> -def2q</span><span class="id"> mul2n</span><span class="id"> -addnn</span><span class="id"> leq_add2l</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">leq_add2r</span><span class="id"> #|yG</span><span class="id"> :&amp;:</span><span class="id"> xyG|</span>)<span class="id"> cardsUI</span><span class="id"> disjoint_setI0</span><span class="id"> //</span><span class="id"> cards0</span><span class="id"> addn0</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /yG</span><span class="id"> /xyG</span><span class="id"> !def_tG</span><span class="id"> //</span><span class="id"> !card_rcoset</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> -orderE</span><span class="id"> ox2</span><span class="id"> def2r</span>.<br/>
<span class="id">split</span>.<br/>
<span class="id">-</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sdprodE</span><span class="id"> //</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> ?cycle_subG</span><span class="id"> //</span><span class="id"> -orderE</span><span class="id"> oy</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> defG';</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span> (<span class="id">leq_trans</span> (<span class="id">nil_class_pgroup</span><span class="id"> pG</span>))<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span> (<span class="id">ltnW</span> (<span class="id">ltnW</span><span class="id"> n_gt3</span>)))<span class="id"> subn2</span><span class="id"> ltnNge</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span> (<span class="id">lcn_nil_classP</span><span class="id"> _</span> (<span class="id">pgroup_nil</span><span class="id"> pG</span>))<span class="id"> eqP</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/trivgPn;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> r</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?memL</span><span class="id"> //</span><span class="id"> -order_gt1</span><span class="id"> oxr</span>.<br/>
<span class="id">-</span><span class="id"> rewrite</span><span class="id"> defZ;</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="id"> exact:</span><span class="id"> extend_cyclic_Mho</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> apply/eqP;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> sX'G2:</span><span class="id"> {subset</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> &lt;=</span><span class="id"> 'Ohm_2</span>(<span class="id">G</span>)<span class="id">}</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> have</span><span class="id"> [Gt</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X't;</span><span class="id"> rewrite</span><span class="id"> -defX'</span><span class="gallina-kwd"> in</span><span class="id"> X't</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> 2</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Gt</span><span class="id"> -order_dvdn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setUP:</span><span class="id"> X't;</span><span class="id"> case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> _</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> orderJ</span><span class="id"> ?oy</span><span class="id"> ?oxy</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> Ohm_sub</span><span class="id"> -{1}defXY</span><span class="id"> mulG_subG</span><span class="id"> !cycle_subG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">groupMr</span><span class="id"> _</span> (<span class="id">sX'G2</span><span class="id"> y</span><span class="id"> X'y</span>))<span class="id"> !sX'G2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqEsubset</span><span class="id"> andbC</span><span class="id"> gen_subG</span><span class="id"> class_sub_norm</span><span class="id"> ?gFnorm</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pG</span>)<span class="id"> mem_gen</span><span class="id"> ?inE</span><span class="id"> ?Gy</span><span class="id"> -?order_dvdn</span><span class="id"> ?oy</span><span class="id"> //</span><span class="id"> gen_subG</span><span class="id"> /=</span><span class="id"> -/My</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> t</span><span class="id"> /[!inE];</span><span class="id"> case/andP=&gt;</span><span class="id"> Gt</span><span class="id"> t2</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> pX</span><span class="id"> :=</span><span class="id"> pgroupS</span><span class="id"> sXG</span><span class="id"> pG</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Xt:</span> (<span class="id">t</span><span class="id"> \in</span><span class="id"> X</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">X</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pX</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Xt</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> subsetP;</span><span class="id"> rewrite</span> (<span class="id">Ohm_p_cycle</span><span class="id"> 1</span><span class="id"> pX</span>)<span class="id"> ox</span><span class="id"> pfactorK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>)<span class="id"> expgM</span> (<span class="id">subset_trans</span> (<span class="id">cycleX</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /My</span><span class="id"> -defMt</span><span class="id"> ?joing_subl</span>.<br/>
&nbsp;&nbsp;<span class="id">have{Xt}:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX'</span><span class="id"> inE</span><span class="id"> Xt</span>.<br/>
&nbsp;&nbsp;<span class="id">case/setUP;</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> mem_gen</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/imsetP=&gt;</span><span class="id"> z</span><span class="id"> _</span><span class="id"> def_t;</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> def_t</span><span class="id"> orderJ</span><span class="id"> oxy</span><span class="gallina-kwd"> in</span><span class="id"> t2</span>.<br/>
<span class="id">-</span><span class="id"> split=&gt;</span><span class="id"> //=</span><span class="id"> H;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [maxH</span><span class="id"> |];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/or3P=&gt;</span><span class="id"> /eqP-&gt;;</span><span class="id"> rewrite</span><span class="id"> ?maxMt</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sHG</span><span class="id"> nHG]:=</span><span class="id"> andP</span> (<span class="id">p_maximal_normal</span><span class="id"> pG</span><span class="id"> maxH</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oH:</span><span class="id"> #|H|</span><span class="id"> =</span><span class="id"> q</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -</span>(<span class="id">p_maximal_index</span><span class="id"> pG</span><span class="id"> maxH</span>)<span class="id"> Lagrange</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">eq_sym</span> (<span class="id">gval</span><span class="id"> H</span>))<span class="id"> -eq_sym</span><span class="id"> !eqEcard</span><span class="id"> oH</span><span class="id"> -orderE</span><span class="id"> ox</span><span class="id"> !oMt</span><span class="id"> //</span><span class="id"> !leqnn</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> sHX:</span> (<span class="id">H</span><span class="id"> \subset</span><span class="id"> X</span>)<span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> case/subsetPn:</span><span class="id"> sHX</span><span class="id"> =&gt;</span><span class="id"> t</span><span class="id"> Ht</span><span class="id"> notXt</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> t</span><span class="id"> \in</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX'</span><span class="id"> inE</span><span class="id"> notXt</span> (<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !andbT</span><span class="id"> !gen_subG</span><span class="id"> /yG</span><span class="id"> /xyG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setUP=&gt;</span><span class="id"> /class_eqP</span><span class="id"> &lt;-;</span><span class="id"> rewrite</span><span class="id"> !class_sub_norm</span><span class="id"> ?Ht</span><span class="id"> ?orbT</span>.<br/>
<span class="id">have</span><span class="id"> n1_gt2:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> [rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>)<span class="id">];</span><span class="id"> have</span><span class="id"> n1_gt1</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n1_gt2</span>.<br/>
<span class="id">rewrite</span><span class="id"> !isogEcard</span><span class="id"> card_2dihedral</span><span class="id"> ?card_quaternion</span><span class="id"> ?oMt</span><span class="id"> //</span><span class="id"> leqnn</span><span class="id"> !andbT</span>.<br/>
<span class="id">have</span><span class="id"> invX2X':</span><span class="id"> {in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> ^</span><span class="id"> t</span><span class="id"> ==</span><span class="id"> x</span><span class="id"> ^-</span><span class="id"> 2}</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> t</span><span class="id"> X't;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> invXX'</span><span class="id"> ?mem_cycle</span><span class="id"> //</span><span class="id"> eq_sym</span><span class="id"> eq_invg_mul</span><span class="id"> -expgS</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prednK</span><span class="id"> //</span><span class="id"> -order_dvdn</span><span class="id"> ox2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp_2dihedral</span><span class="id"> ?Grp_quaternion</span><span class="id"> //;</span><span class="id"> split=&gt;</span><span class="id"> [||C]</span>.<br/>
<span class="id">-</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> defMt</span><span class="id"> //</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -!expgM</span><span class="id"> def2r</span><span class="id"> -!order_dvdn</span><span class="id"> ox</span><span class="id"> oy</span><span class="id"> dvdnn</span><span class="id"> eqxx</span><span class="id"> /=</span><span class="id"> invX2X'</span>.<br/>
<span class="id">-</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> 2,</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> defMt</span><span class="id"> //</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!expgM</span><span class="id"> def2r</span><span class="id"> -order_dvdn</span><span class="id"> ox</span><span class="id"> xy2</span><span class="id"> dvdnn</span><span class="id"> eqxx</span><span class="id"> invX2X'</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> andbT</span><span class="id"> /r</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
<span class="id">case/cyclicP=&gt;</span><span class="id"> z</span><span class="id"> -&gt;{C}</span><span class="id"> sCG</span><span class="id"> iCG;</span><span class="id"> rewrite</span><span class="id"> [X]defU</span><span class="id"> //</span><span class="id"> defU</span><span class="id"> -?cycle_subG</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> double_inj;</span><span class="id"> rewrite</span><span class="id"> -muln2</span><span class="id"> -iCG</span><span class="id"> Lagrange</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> -mul2n</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ExtremalStructure</span>.<br/>
<br/>
<span class="vernacular">Section</span><span class="id"> ExtremalClass</span>.<br/>
<br/>
<span class="vernacular">Variables</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>).<br/>
<br/>
<span class="vernacular">Inductive</span><span class="id"> extremal_group_type</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">ModularGroup</span><span class="id"> |</span><span class="id"> Dihedral</span><span class="id"> |</span><span class="id"> SemiDihedral</span><span class="id"> |</span><span class="id"> Quaternion</span><span class="id"> |</span><span class="id"> NotExtremal</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> index_extremal_group_type</span><span class="id"> c</span><span class="id"> :</span><span class="id"> nat</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">match</span><span class="id"> c</span><span class="gallina-kwd"> with</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> ModularGroup</span><span class="id"> =&gt;</span><span class="id"> 0</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Dihedral</span><span class="id"> =&gt;</span><span class="id"> 1</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> SemiDihedral</span><span class="id"> =&gt;</span><span class="id"> 2</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> Quaternion</span><span class="id"> =&gt;</span><span class="id"> 3</span><br/>
&nbsp;&nbsp;<span class="id">|</span><span class="id"> NotExtremal</span><span class="id"> =&gt;</span><span class="id"> 4</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">end</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> enum_extremal_groups</span><span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="id">[::</span><span class="id"> ModularGroup;</span><span class="id"> Dihedral;</span><span class="id"> SemiDihedral;</span><span class="id"> Quaternion]</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cancel_index_extremal_groups</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">cancel</span><span class="id"> index_extremal_group_type</span> (<span class="id">nth</span><span class="id"> NotExtremal</span><span class="id"> enum_extremal_groups</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case</span>. Qed.</div></details>
<span class="vernacular">Local</span><span class="vernacular"> Notation</span><span class="id"> extgK</span><span class="id"> :=</span><span class="id"> cancel_index_extremal_groups</span>.<br/>
<br/>
<span class="id">#[export]</span><br/>
<span class="id">HB</span>.<span class="id">instance</span><span class="vernacular"> Definition</span><span class="id"> _</span><span class="id"> :=</span><span class="id"> Countable</span>.<span class="id">copy</span><span class="id"> extremal_group_type</span> (<span class="id">can_type</span><span class="id"> extgK</span>).<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> bound_extremal_groups</span> (<span class="id">c</span><span class="id"> :</span><span class="id"> extremal_group_type</span>)<span class="id"> :</span><span class="id"> pickle</span><span class="id"> c</span><span class="id"> &lt;</span><span class="id"> 6</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> c</span>. Qed.</div></details>
<br/>
<span class="vernacular">Definition</span><span class="id"> extremal_class</span> (<span class="id">A</span><span class="id"> :</span><span class="id"> {set</span><span class="id"> gT}</span>)<span class="id"> :=</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> m</span><span class="id"> :=</span><span class="id"> #|A|</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> p</span><span class="id"> :=</span><span class="id"> pdiv</span><span class="id"> m</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> logn</span><span class="id"> p</span><span class="id"> m</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> (<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 1</span>)<span class="id"> &amp;&amp;</span> (<span class="id">A</span><span class="id"> \isog</span><span class="id"> 'D_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>))<span class="gallina-kwd"> then</span><span class="id"> Dihedral</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> (<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">A</span><span class="id"> \isog</span><span class="id"> 'Q_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>))<span class="gallina-kwd"> then</span><span class="id"> Quaternion</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> (<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 3</span>)<span class="id"> &amp;&amp;</span> (<span class="id">A</span><span class="id"> \isog</span><span class="id"> 'SD_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>))<span class="gallina-kwd"> then</span><span class="id"> SemiDihedral</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">if</span> (<span class="id">n</span><span class="id"> &gt;</span><span class="id"> 2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">A</span><span class="id"> \isog</span><span class="id"> 'Mod_</span>(<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>))<span class="gallina-kwd"> then</span><span class="id"> ModularGroup</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;<span class="id">NotExtremal</span>.<br/>
<br/>
<span class="vernacular">Definition</span><span class="id"> extremal2</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> extremal_class</span><span class="id"> A</span><span class="id"> \in</span><span class="id"> behead</span><span class="id"> enum_extremal_groups</span>.<br/>
<br/>
<span class="vernacular">Lemma</span><span class="id"> dihedral_classP</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> Dihedral</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> n,</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'D_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /extremal_class;</span><span class="id"> split=&gt;</span><span class="id"> [</span><span class="id"> |</span><span class="id"> [n</span><span class="id"> n_gt1</span><span class="id"> isoG]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span> (<span class="id">logn</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> do</span><span class="id"> 4?case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case/andP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_2dihedral</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt1</span>)<span class="id"> pdiv_pfactor</span><span class="id"> //</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> pfactorK</span><span class="id"> //</span> (<span class="id">ltn_predK</span><span class="id"> n_gt1</span>)<span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> quaternion_classP</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> Quaternion</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> n,</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'Q_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /extremal_class;</span><span class="id"> split=&gt;</span><span class="id"> [</span><span class="id"> |</span><span class="id"> [n</span><span class="id"> n_gt2</span><span class="id"> isoG]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span> (<span class="id">logn</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> do</span><span class="id"> 4?case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case/andP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_quaternion</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt2</span>)<span class="id"> pdiv_pfactor</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> pfactorK</span><span class="id"> //</span> (<span class="id">ltn_predK</span><span class="id"> n_gt2</span>)<span class="id"> n_gt2</span><span class="id"> isoG</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [[n_gt1</span><span class="id"> isoGD]]</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> [oy</span><span class="id"> _</span><span class="id"> _]]:=</span><span class="id"> generators_quaternion</span><span class="id"> n_gt2</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> X'y]</span><span class="id"> :=</span><span class="id"> genG</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case/dihedral2_structure:</span><span class="id"> genG</span><span class="id"> oy</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [[_</span><span class="id"> -&gt;]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> semidihedral_classP</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> SemiDihedral</span><span class="id"> &lt;-&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> n,</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'SD_</span>(<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /extremal_class;</span><span class="id"> split=&gt;</span><span class="id"> [</span><span class="id"> |</span><span class="id"> [n</span><span class="id"> n_gt3</span><span class="id"> isoG]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move:</span> (<span class="id">logn</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> n;</span><span class="id"> do</span><span class="id"> 4?case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case/andP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<br/>
<span class="id">rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_semidihedral</span><span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt3</span>)<span class="id"> pdiv_pfactor</span><span class="id"> //</span><span class="id"> pfactorK</span><span class="id"> //</span> (<span class="id">ltn_predK</span><span class="id"> n_gt3</span>)<span class="id"> n_gt3</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> [oy</span><span class="id"> _]]:=</span><span class="id"> generators_semidihedral</span><span class="id"> n_gt3</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> Gx</span><span class="id"> _</span><span class="id"> X'y]:=</span><span class="id"> genG</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> [[n_gt1</span><span class="id"> isoGD]|_]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[_</span><span class="id"> oxy</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]:=</span><span class="id"> semidihedral_structure</span><span class="id"> n_gt3</span><span class="id"> genG</span><span class="id"> isoG</span><span class="id"> oy</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">dihedral2_structure</span><span class="id"> n_gt1</span><span class="id"> genG</span><span class="id"> isoGD</span>)<span class="id"> oxy</span><span class="id"> =&gt;</span><span class="id"> [[_</span><span class="id"> -&gt;]]</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> !groupMl</span><span class="id"> ?cycle_id</span><span class="gallina-kwd"> in</span><span class="id"> X'y</span><span class="id"> *</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [[n_gt2</span><span class="id"> isoGQ]|];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> isoG</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">quaternion_structure</span><span class="id"> n_gt2</span><span class="id"> genG</span><span class="id"> isoGQ</span>)<span class="id"> oy</span><span class="id"> =&gt;</span><span class="id"> [[_</span><span class="id"> -&gt;]]</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> odd_not_extremal2</span><span class="id"> :</span><span class="id"> odd</span><span class="id"> #|G|</span><span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> extremal2</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /extremal2</span><span class="id"> /extremal_class;</span><span class="id"> case:</span><span class="id"> logn</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n'</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> [[n_gt1</span><span class="id"> isoG]</span><span class="id"> |</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_2dihedral</span><span class="id"> ?oddX</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> [[n_gt2</span><span class="id"> isoG]</span><span class="id"> |</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_quaternion</span><span class="id"> ?oddX</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> =&gt;</span><span class="id"> [[n_gt3</span><span class="id"> isoG]</span><span class="id"> |</span><span class="id"> _]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">card_isog</span><span class="id"> isoG</span>)<span class="id"> card_semidihedral</span><span class="id"> ?oddX</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> modular_group_classP</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> ModularGroup</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&lt;-&gt;</span> (<span class="gallina-kwd">exists2</span><span class="id"> p,</span><span class="id"> prime</span><span class="id"> p</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> n,</span><span class="id"> n</span><span class="id"> &gt;=</span> (<span class="id">p</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> +</span><span class="id"> 3</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> \isog</span><span class="id"> 'Mod_</span>(<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">rewrite</span><span class="id"> /extremal_class;</span><span class="id"> split=&gt;</span><span class="id"> [</span><span class="id"> |</span><span class="id"> [p</span><span class="id"> p_pr</span><span class="id"> [n</span><span class="id"> n_gt23</span><span class="id"> isoG]]]</span>.<br/>
&nbsp;&nbsp;<span class="id">move:</span> (<span class="id">pdiv</span><span class="id"> _</span>)<span class="id"> =&gt;</span><span class="id"> p;</span><span class="id"> set</span><span class="id"> n</span><span class="id"> :=</span><span class="id"> logn</span><span class="id"> p</span><span class="id"> _;</span><span class="id"> do</span><span class="id"> 4?case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP=&gt;</span><span class="id"> n_gt2</span><span class="id"> isoG</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> ltnW</span><span class="id"> //=</span><span class="id"> =&gt;</span><span class="id"> not_isoG</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> p;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> move:</span><span class="id"> n_gt2;</span><span class="id"> rewrite</span><span class="id"> /n</span><span class="id"> lognE;</span><span class="id"> case</span> (<span class="id">prime</span><span class="id"> p</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> p2;</span><span class="id"> rewrite</span><span class="id"> ltn_neqAle;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n3</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/idP:</span><span class="id"> not_isoG;</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="id"> -n3</span><span class="gallina-kwd"> in</span><span class="id"> isoG</span><span class="id"> *</span>.<br/>
<span class="id">have</span><span class="id"> n_gt2</span><span class="id"> :=</span><span class="id"> leq_trans</span> (<span class="id">leq_addl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> n_gt23;</span><span class="id"> have</span><span class="id"> n_gt1</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt2</span>.<br/>
<span class="id">have</span><span class="id"> n_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt1;</span><span class="id"> have</span><span class="id"> def_n</span><span class="id"> :=</span><span class="id"> prednK</span><span class="id"> n_gt0</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> mod_xy]</span><span class="id"> :=</span><span class="id"> generators_modular_group</span><span class="id"> p_pr</span><span class="id"> n_gt2</span><span class="id"> isoG</span>.<br/>
<span class="id">case/modular_group_structure:</span> (<span class="id">genG</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> nil2G]</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">have</span><span class="id"> [oG</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> have</span><span class="id"> [oy</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> mod_xy</span>.<br/>
<span class="id">rewrite</span><span class="id"> oG</span><span class="id"> -def_n</span><span class="id"> pdiv_pfactor</span><span class="id"> //</span><span class="id"> def_n</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> n_gt1</span><span class="id"> n_gt2</span><span class="id"> {}isoG</span><span class="id"> /=</span>.<br/>
<span class="id">case:</span> (<span class="id">ltngtP</span><span class="id"> p</span><span class="id"> 2</span>)<span class="id"> =&gt;</span><span class="id"> [|p_gt2|p2];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> prime_gt1</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">isog_sym</span><span class="id"> G</span>)<span class="id"> !isogEcard</span><span class="id"> card_2dihedral</span><span class="id"> ?card_quaternion</span><span class="id"> //=</span><span class="id"> oG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> leq_exp2r</span><span class="id"> //</span><span class="id"> leqNgt</span><span class="id"> p_gt2</span><span class="id"> !andbF;</span><span class="id"> case:</span><span class="id"> and3P=&gt;</span><span class="id"> //</span><span class="id"> [[n_gt3</span><span class="id"> _]]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_semidihedral</span><span class="id"> //</span><span class="id"> leq_exp2r</span><span class="id"> //</span><span class="id"> leqNgt</span><span class="id"> p_gt2</span>.<br/>
<span class="id">rewrite</span><span class="id"> p2</span><span class="gallina-kwd"> in</span><span class="id"> genG</span><span class="id"> oy</span><span class="id"> n_gt23;</span><span class="id"> rewrite</span><span class="id"> n_gt23</span>.<br/>
<span class="id">have:</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> &lt;&gt;</span><span class="id"> n</span>.<span class="id">-1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> neq_ltn</span><span class="id"> -ltnS</span><span class="id"> nil2G</span><span class="id"> def_n</span><span class="id"> n_gt23</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [isoG</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case/dihedral2_structure:</span><span class="id"> genG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> []</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [isoG</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case/quaternion_structure:</span><span class="id"> genG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> []</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> isoG;</span><span class="id"> case/semidihedral_structure:</span><span class="id"> genG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> []</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ExtremalClass</span>.<br/>
<br/>
<span class="vernacular">Theorem</span><span class="id"> extremal2_structure</span> (<span class="id">gT</span><span class="id"> :</span><span class="id"> finGroupType</span>) (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> n</span><span class="id"> x</span><span class="id"> y</span><span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> cG</span><span class="id"> :=</span><span class="id"> extremal_class</span><span class="id"> G</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> m</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> r</span><span class="id"> :=</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> &lt;[x]&gt;</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> yG</span><span class="id"> :=</span><span class="id"> y</span><span class="id"> ^:</span><span class="id"> G</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> xyG</span><span class="id"> :=</span> (<span class="id">x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id"> ^:</span><span class="id"> G</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">let</span><span class="id"> My</span><span class="id"> :=</span><span class="id"> &lt;&lt;yG&gt;&gt;</span><span class="gallina-kwd"> in</span><span class="gallina-kwd"> let</span><span class="id"> Mxy</span><span class="id"> :=</span><span class="id"> &lt;&lt;xyG&gt;&gt;</span><span class="gallina-kwd"> in</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extremal_generators</span><span class="id"> G</span><span class="id"> 2</span><span class="id"> n</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extremal2</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="id">cG</span><span class="id"> ==</span><span class="id"> SemiDihedral</span>)<span class="id"> ==&gt;</span> (<span class="id">#[y]</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> -&gt;</span><br/>
&nbsp;<span class="id">[/\</span><span class="id"> [/\</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Quaternion</span><span class="gallina-kwd"> then</span><span class="id"> pprod</span><span class="id"> X</span><span class="id"> &lt;[y]&gt;</span><span class="gallina-kwd"> else</span><span class="id"> X</span><span class="id"> &gt;&lt;|</span><span class="id"> &lt;[y]&gt;</span>)<span class="id"> =</span><span class="id"> G,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> SemiDihedral</span><span class="gallina-kwd"> then</span><span class="id"> #[x</span><span class="id"> *</span><span class="id"> y]</span><span class="id"> =</span><span class="id"> 4</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Dihedral</span><span class="gallina-kwd"> then</span><span class="id"> 2</span><span class="gallina-kwd"> else</span><span class="id"> 4</span>)<span class="id">},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> !=</span><span class="id"> Quaternion</span><span class="gallina-kwd"> then</span><span class="id"> True</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">{in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> z,</span><span class="id"> #[z]</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> z</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r}</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> {in</span><span class="id"> X</span><span class="id"> &amp;</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="gallina-kwd"> forall</span><span class="id"> t</span><span class="id"> z,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">t</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> SemiDihedral</span><span class="gallina-kwd"> then</span><span class="id"> t</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">-1</span><span class="gallina-kwd"> else</span><span class="id"> t^-1</span>)<span class="id">}],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> 2]&gt;,</span><span class="id"> 'Phi</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><span class="id"> ^`</span>(<span class="id">1</span>)<span class="id">,</span><span class="id"> #|G^`</span>(<span class="id">1</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> r</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> nil_class</span><span class="id"> G</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">-1],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> then</span><span class="id"> 'Z</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span><span class="id"> /\</span><span class="id"> #|'Z</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> 2</span><span class="gallina-kwd"> else</span><span class="id"> 2</span>.<span class="id">-abelem</span><span class="id"> G,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_1</span>(<span class="id">G</span>)<span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Quaternion</span><span class="gallina-kwd"> then</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> SemiDihedral</span><span class="gallina-kwd"> then</span><span class="id"> My</span><span class="gallina-kwd"> else</span><span class="id"> G</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_2</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> k,</span><span class="id"> k</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> -&gt;</span><span class="id"> 'Mho^k</span>(<span class="id">G</span>)<span class="id"> =</span><span class="id"> &lt;[x</span><span class="id"> ^+</span> (<span class="id">2</span><span class="id"> ^</span><span class="id"> k</span>)<span class="id">]&gt;],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> yG</span><span class="id"> :|:</span><span class="id"> xyG</span><span class="id"> =</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X,</span><span class="id"> [disjoint</span><span class="id"> yG</span><span class="id"> &amp;</span><span class="id"> xyG]</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> forall</span><span class="id"> H</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><span class="id"> maximal</span><span class="id"> H</span><span class="id"> G</span><span class="id"> =</span> (<span class="id">gval</span><span class="id"> H</span><span class="id"> \in</span><span class="id"> pred3</span><span class="id"> X</span><span class="id"> My</span><span class="id"> Mxy</span>)<span class="id">]</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> if</span><span class="id"> n</span><span class="id"> &lt;=</span> (<span class="id">cG</span><span class="id"> ==</span><span class="id"> Quaternion</span>)<span class="id"> +</span><span class="id"> 2</span><span class="gallina-kwd"> then</span><span class="id"> True</span><span class="gallina-kwd"> else</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="gallina-kwd"> forall</span><span class="id"> U,</span><span class="id"> cyclic</span><span class="id"> U</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> =</span><span class="id"> X,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Quaternion</span><span class="gallina-kwd"> then</span><span class="id"> My</span><span class="id"> \isog</span><span class="id"> 'Q_q</span><span class="gallina-kwd"> else</span><span class="id"> My</span><span class="id"> \isog</span><span class="id"> 'D_q,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">extremal_class</span><span class="id"> My</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Quaternion</span><span class="gallina-kwd"> then</span><span class="id"> cG</span><span class="gallina-kwd"> else</span><span class="id"> Dihedral</span>)<span class="id">,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Dihedral</span><span class="gallina-kwd"> then</span><span class="id"> Mxy</span><span class="id"> \isog</span><span class="id"> 'D_q</span><span class="gallina-kwd"> else</span><span class="id"> Mxy</span><span class="id"> \isog</span><span class="id"> 'Q_q</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> extremal_class</span><span class="id"> Mxy</span><span class="id"> =</span> (<span class="gallina-kwd">if</span><span class="id"> cG</span><span class="id"> ==</span><span class="id"> Dihedral</span><span class="gallina-kwd"> then</span><span class="id"> cG</span><span class="gallina-kwd"> else</span><span class="id"> Quaternion</span>)<span class="id">]]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> cG</span><span class="id"> m</span><span class="id"> q</span><span class="id"> r</span><span class="id"> X</span><span class="id"> yG</span><span class="id"> xyG</span><span class="id"> My</span><span class="id"> Mxy</span><span class="id"> genG;</span><span class="id"> have</span><span class="id"> [oG</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> genG</span>.<br/>
<span class="id">have</span><span class="id"> logG:</span><span class="id"> logn</span> (<span class="id">pdiv</span><span class="id"> #|G|</span>)<span class="id"> #|G|</span><span class="id"> =</span><span class="id"> n</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oG</span><span class="id"> pfactorKpdiv</span>.<br/>
<span class="id">rewrite</span><span class="id"> /extremal2</span><span class="id"> -/cG;</span><span class="id"> do</span><span class="id"> [rewrite</span><span class="id"> {1}/extremal_class</span><span class="id"> /=</span><span class="id"> {}logG]</span><span class="gallina-kwd"> in</span><span class="id"> cG</span><span class="id"> *</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [isoG</span><span class="id"> |</span><span class="id"> _]</span><span class="gallina-kwd"> in</span><span class="id"> cG</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> /=|]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP:</span><span class="id"> isoG</span><span class="id"> =&gt;</span><span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> dihedral2_structure</span><span class="id"> n_gt1</span><span class="id"> genG</span><span class="id"> isoG;</span><span class="id"> rewrite</span><span class="id"> -/X</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> -/yG</span><span class="id"> -/xyG</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> [[defG</span><span class="id"> oX'</span><span class="id"> invXX']</span><span class="id"> nilG</span><span class="id"> [defOhm</span><span class="id"> defMho]</span><span class="id"> maxG</span><span class="id"> defZ]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqn_leq</span><span class="id"> n_gt1</span><span class="id"> andbT</span><span class="id"> add0n</span><span class="gallina-kwd"> in</span><span class="id"> defZ</span><span class="id"> *;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> leqP</span><span class="id"> defZ</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> Ohm_sub</span><span class="id"> -{1}defOhm</span><span class="id"> Ohm_leq</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> leqP</span><span class="id"> defZ</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n_gt2</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> isoMy</span><span class="id"> isoMxy</span><span class="id"> defX]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n1_gt1:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/dihedral_classP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">-1</span>.<br/>
<span class="id">case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [isoG</span><span class="id"> |</span><span class="id"> _]</span><span class="gallina-kwd"> in</span><span class="id"> cG</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> /=|]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP:</span><span class="id"> isoG</span><span class="id"> =&gt;</span><span class="id"> n_gt2</span><span class="id"> isoG;</span><span class="id"> rewrite</span><span class="id"> n_gt2</span><span class="id"> add1n</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> quaternion_structure</span><span class="id"> n_gt2</span><span class="id"> genG</span><span class="id"> isoG;</span><span class="id"> rewrite</span><span class="id"> -/X</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> -/yG</span><span class="id"> -/xyG</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> [[defG</span><span class="id"> oX'</span><span class="id"> invXX']</span><span class="id"> nilG</span><span class="id"> [defZ</span><span class="id"> oZ</span><span class="id"> def2</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]</span><span class="id"> defMho]]</span>.<br/>
&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> [[-&gt;</span><span class="id"> -&gt;]</span><span class="id"> maxG]</span><span class="id"> isoM;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> leqP</span><span class="id"> isoM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> n_gt3</span><span class="id"> [//|isoMy</span><span class="id"> isoMxy</span><span class="id"> defX]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n1_gt2:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> apply/quaternion_classP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">-1</span>.<br/>
<span class="id">do</span><span class="id"> [case:</span><span class="id"> ifP</span><span class="id"> =&gt;</span><span class="id"> [isoG</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> case:</span><span class="id"> ifP]</span><span class="gallina-kwd"> in</span><span class="id"> cG</span><span class="id"> *</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> _;</span><span class="id"> move/eqnP=&gt;</span><span class="id"> oy</span>.<br/>
<span class="id">case/andP:</span><span class="id"> isoG</span><span class="id"> =&gt;</span><span class="id"> n_gt3</span><span class="id"> isoG;</span><span class="id"> rewrite</span> (<span class="id">leqNgt</span><span class="id"> n</span>) (<span class="id">ltnW</span><span class="id"> n_gt3</span>)<span class="id"> /=</span>.<br/>
<span class="id">have</span><span class="id"> n1_gt2:</span><span class="id"> n</span>.<span class="id">-1</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
<span class="id">have:=</span><span class="id"> semidihedral_structure</span><span class="id"> n_gt3</span><span class="id"> genG</span><span class="id"> isoG</span><span class="id"> oy</span>.<br/>
<span class="id">rewrite</span><span class="id"> -/X</span><span class="id"> -/q</span><span class="id"> -/r</span><span class="id"> -/yG</span><span class="id"> -/xyG</span><span class="id"> -/My</span><span class="id"> -/Mxy</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [[defG</span><span class="id"> oxy</span><span class="id"> invXX']</span><span class="id"> nilG</span><span class="id"> [defZ</span><span class="id"> oZ</span><span class="id"> [-&gt;</span><span class="id"> -&gt;]</span><span class="id"> defMho]</span><span class="id"> [[defX'</span><span class="id"> tiX']</span><span class="id"> maxG]]</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> isoMy</span><span class="id"> isoMxy</span><span class="id"> defX;</span><span class="id"> do</span><span class="id"> 2!split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/dihedral_classP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">-1;</span><span class="id"> first</span><span class="id"> apply:</span><span class="id"> ltnW</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> apply/quaternion_classP;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span>.<span class="id">-1</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> maximal_cycle_extremal</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> X</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> abelian</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> X</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> X|</span><span class="id"> =</span><span class="id"> p</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;(<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> ==</span><span class="id"> ModularGroup</span>)<span class="id"> ||</span> (<span class="id">p</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> &amp;&amp;</span><span class="id"> extremal2</span><span class="id"> G</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> not_cGG</span><span class="id"> cycX</span><span class="id"> sXG</span><span class="id"> iXG;</span><span class="id"> rewrite</span><span class="id"> /extremal2;</span><span class="id"> set</span><span class="id"> cG</span><span class="id"> :=</span><span class="id"> extremal_class</span><span class="id"> G</span>.<br/>
<span class="id">have</span><span class="id"> [|p_pr</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> pG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> not_cGG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> abelian1</span>.<br/>
<span class="id">have</span><span class="id"> p_gt1</span><span class="id"> :=</span><span class="id"> prime_gt1</span><span class="id"> p_pr;</span><span class="id"> have</span><span class="id"> p_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> p_gt1</span>.<br/>
<span class="id">have</span><span class="id"> [n</span><span class="id"> oG]</span><span class="id"> :=</span><span class="id"> p_natP</span><span class="id"> pG;</span><span class="id"> have</span><span class="id"> n_gt2:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> not_cGG;</span><span class="id"> rewrite</span><span class="id"> -leqNgt</span><span class="id"> =&gt;</span><span class="id"> n_le2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">p2group_abelian</span><span class="id"> pG</span>)<span class="id"> //</span><span class="id"> oG</span><span class="id"> pfactorK</span>.<br/>
<span class="id">have</span><span class="id"> def_n</span><span class="id"> :=</span><span class="id"> subnKC</span><span class="id"> n_gt2;</span><span class="id"> have</span><span class="id"> n_gt1</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt2;</span><span class="id"> have</span><span class="id"> n_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt1</span>.<br/>
<span class="id">pose</span><span class="id"> q</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N;</span><span class="id"> pose</span><span class="id"> r</span><span class="id"> :=</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span>.<br/>
<span class="id">have</span><span class="id"> q_gt1:</span><span class="id"> q</span><span class="id"> &gt;</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">ltn_exp2l</span><span class="id"> 0</span>)<span class="id"> //</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
<span class="id">have</span><span class="id"> r_gt0:</span><span class="id"> r</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> expn_gt0</span><span class="id"> p_gt0</span>.<br/>
<span class="id">have</span><span class="id"> def_pr:</span> (<span class="id">p</span><span class="id"> *</span><span class="id"> r</span>)<span class="id">%N</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /q</span><span class="id"> /r</span><span class="id"> -def_n</span>.<br/>
<span class="id">have</span><span class="id"> oX:</span><span class="id"> #|X|</span><span class="id"> =</span><span class="id"> q</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">divg_indexS</span><span class="id"> sXG</span>)<span class="id"> oG</span><span class="id"> iXG</span><span class="id"> /q</span><span class="id"> -def_n</span><span class="id"> mulKn</span>.<br/>
<span class="id">have</span><span class="id"> ntX:</span><span class="id"> X</span><span class="id"> :!=:</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oX</span>.<br/>
<span class="id">have</span><span class="id"> maxX:</span><span class="id"> maximal</span><span class="id"> X</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> p_index_maximal</span><span class="id"> ?iXG</span>.<br/>
<span class="id">have</span><span class="id"> nsXG:</span><span class="id"> X</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> p_maximal_normal</span><span class="id"> pG</span><span class="id"> maxX;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> nXG]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsXG</span>.<br/>
<span class="id">have</span><span class="id"> cXX:</span><span class="id"> abelian</span><span class="id"> X</span><span class="id"> :=</span><span class="id"> cyclic_abelian</span><span class="id"> cycX</span>.<br/>
<span class="id">have</span><span class="id"> scXG:</span><span class="id"> 'C_G</span>(<span class="id">X</span>)<span class="id"> =</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> subsetI</span><span class="id"> sXG</span><span class="id"> -abelianE</span><span class="id"> cXX</span><span class="id"> !andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> not_cGG;</span><span class="id"> case/subsetPn=&gt;</span><span class="id"> y;</span><span class="id"> case/setIP=&gt;</span><span class="id"> Gy</span><span class="id"> cXy</span><span class="id"> notXy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -!cycle_subG</span><span class="gallina-kwd"> in</span><span class="id"> Gy</span><span class="id"> notXy;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span><span class="id"> _</span><span class="id"> Gy</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> abelianM</span><span class="id"> cycle_abelian</span><span class="id"> cyclic_abelian</span><span class="id"> ?cycle_subG</span>.<br/>
<span class="id">have</span><span class="id"> [x</span><span class="id"> defX]</span><span class="id"> :=</span><span class="id"> cyclicP</span><span class="id"> cycX;</span><span class="id"> have</span><span class="id"> pX</span><span class="id"> :=</span><span class="id"> pgroupS</span><span class="id"> sXG</span><span class="id"> pG</span>.<br/>
<span class="id">have</span><span class="id"> Xx:</span><span class="id"> x</span><span class="id"> \in</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> [rewrite</span><span class="id"> defX</span><span class="id"> cycle_id];</span><span class="id"> have</span><span class="id"> Gx</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sXG</span><span class="id"> x</span><span class="id"> Xx</span>.<br/>
<span class="id">have</span><span class="id"> [ox</span><span class="id"> p_x]:</span><span class="id"> #[x]</span><span class="id"> =</span><span class="id"> q</span><span class="id"> /\</span><span class="id"> p</span>.<span class="id">-elt</span><span class="id"> x</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX</span><span class="gallina-kwd"> in</span><span class="id"> pX</span><span class="id"> oX</span>.<br/>
<span class="id">pose</span><span class="id"> Z</span><span class="id"> :=</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> r]&gt;</span>.<br/>
<span class="id">have</span><span class="id"> defZ:</span><span class="id"> Z</span><span class="id"> =</span><span class="id"> 'Ohm_1</span>(<span class="id">X</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defX</span> (<span class="id">Ohm_p_cycle</span><span class="id"> _</span><span class="id"> p_x</span>)<span class="id"> ox</span><span class="id"> subn1</span><span class="id"> pfactorK</span>.<br/>
<span class="id">have</span><span class="id"> oZ:</span><span class="id"> #|Z|</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -orderE</span><span class="id"> orderXdiv</span><span class="id"> ox</span><span class="id"> -def_pr</span><span class="id"> ?dvdn_mull</span><span class="id"> ?mulnK</span>.<br/>
<span class="id">have</span><span class="id"> cGZ:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nsZG:</span><span class="id"> Z</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defZ</span><span class="id"> gFnormal_trans</span>.<br/>
&nbsp;&nbsp;<span class="id">move/implyP:</span> (<span class="id">meet_center_nil</span> (<span class="id">pgroup_nil</span><span class="id"> pG</span>)<span class="id"> nsZG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oZ</span><span class="id"> p_gt1</span><span class="id"> setIA</span> (<span class="id">setIidPl</span> (<span class="id">normal_sub</span><span class="id"> nsZG</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraR;</span><span class="id"> move/prime_TIg=&gt;</span><span class="id"> -&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> oZ</span>.<br/>
<span class="id">have</span><span class="id"> X_Gp</span><span class="id"> y:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> p</span><span class="id"> \in</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;<span class="id">move=&gt;</span><span class="id"> Gy;</span><span class="id"> have</span><span class="id"> nXy:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">X</span>)<span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> nXG</span><span class="id"> y</span><span class="id"> Gy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> coset_idr</span><span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> morphX</span><span class="id"> //;</span><span class="id"> apply/eqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> -iXG</span><span class="id"> -card_quotient</span><span class="id"> //</span><span class="id"> order_dvdG</span><span class="id"> ?mem_quotient</span>.<br/>
<span class="id">have</span><span class="id"> [y</span><span class="id"> X'y]:</span><span class="gallina-kwd"> exists2</span><span class="id"> y,</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> :\:</span><span class="id"> X</span><span class="id"> &amp;</span><br/>
&nbsp;&nbsp;(<span class="id">p</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> +</span><span class="id"> 3</span><span class="id"> &lt;=</span><span class="id"> n</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">+1</span><span class="id"> \/</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> /\</span><span class="id"> x</span><span class="id"> *</span><span class="id"> x</span><span class="id"> ^</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> Z</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [y</span><span class="id"> Gy</span><span class="id"> notXy]:</span><span class="gallina-kwd"> exists2</span><span class="id"> y,</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> y</span><span class="id"> \notin</span><span class="id"> X</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/subsetPn;</span><span class="id"> rewrite</span><span class="id"> proper_subn</span><span class="id"> ?</span>(<span class="id">maxgroupp</span><span class="id"> maxX</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> nXy:</span><span class="id"> y</span><span class="id"> \in</span><span class="id"> 'N</span>(<span class="id">X</span>)<span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> nXG</span><span class="id"> y</span><span class="id"> Gy;</span><span class="id"> pose</span><span class="id"> ay</span><span class="id"> :=</span><span class="id"> conj_aut</span><span class="id"> X</span><span class="id"> y</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oay:</span><span class="id"> #[ay]</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> nt_prime_order</span><span class="id"> =&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -morphX</span><span class="id"> //</span><span class="id"> mker</span><span class="id"> //</span><span class="id"> ker_conj_aut</span> (<span class="id">subsetP</span><span class="id"> cXX</span>)<span class="id"> ?X_Gp</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span><span class="id"> eqP</span> (<span class="id">kerP</span><span class="id"> _</span><span class="id"> nXy</span>))<span class="id"> ker_conj_aut</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> notXy</span><span class="id"> =&gt;</span><span class="id"> cXy;</span><span class="id"> rewrite</span><span class="id"> -scXG</span><span class="id"> inE</span><span class="id"> Gy</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [m</span><span class="id"> []]:=</span><span class="id"> cyclic_pgroup_Aut_structure</span><span class="id"> pX</span><span class="id"> cycX</span><span class="id"> ntX</span>.<br/>
&nbsp;&nbsp;<span class="id">set</span><span class="id"> Ap</span><span class="id"> :=</span><span class="id"> 'O_p</span>(_)<span class="id">;</span><span class="id"> case=&gt;</span><span class="id"> def_m</span><span class="id"> [m1</span><span class="id"> _]</span><span class="id"> [m_inj</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sylAp:</span><span class="id"> p</span>.<span class="id">-Sylow</span>(<span class="id">Aut</span><span class="id"> X</span>)<span class="id"> Ap</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> nilpotent_pcore_Hall</span><span class="id"> //</span><span class="id"> abelian_nil</span><span class="id"> //</span><span class="id"> Aut_cyclic_abelian</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Ap1ay:</span><span class="id"> ay</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">Ap</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> _</span> (<span class="id">pcore_pgroup</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> -order_dvdn</span><span class="id"> oay</span><span class="id"> dvdnn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">mem_normal_Hall</span><span class="id"> sylAp</span>)<span class="id"> ?pcore_normal</span><span class="id"> ?Aut_aut</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /p_elt</span><span class="id"> oay</span><span class="id"> pnat_id</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1}oX</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -{1}def_n</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> odd_p]</span><span class="id"> :=</span><span class="id"> even_prime</span><span class="id"> p_pr;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span><span class="id"> eqP</span> (<span class="id">prime_oddPn</span><span class="id"> p_pr</span>))<span class="id"> odd_p</span><span class="id"> n_gt2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case=&gt;</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [s</span><span class="id"> [As</span><span class="id"> os</span><span class="id"> m_s</span><span class="id"> defAp1]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [j</span><span class="id"> def_s]:</span><span class="gallina-kwd"> exists</span><span class="id"> j,</span><span class="id"> s</span><span class="id"> =</span><span class="id"> ay</span><span class="id"> ^+</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/cycleP;</span><span class="id"> rewrite</span><span class="id"> -cycle_subG</span><span class="id"> subEproper</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> -!orderE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defAp1</span><span class="id"> cycle_subG</span><span class="id"> Ap1ay</span><span class="id"> oay</span><span class="id"> os</span><span class="id"> leqnn</span> .<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span> (<span class="id">y</span><span class="id"> ^+</span><span class="id"> j</span>)<span class="id">;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">left;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">norm_conj_autE</span><span class="id"> _</span><span class="id"> Xx</span>)<span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> morphX</span><span class="id"> //</span><span class="id"> -def_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def_m</span><span class="id"> //</span><span class="id"> m_s</span><span class="id"> expg_znat</span><span class="id"> //</span><span class="id"> oX</span><span class="id"> pfactorK</span><span class="id"> ?eqxx</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -scXG</span><span class="id"> !inE</span><span class="id"> groupX</span><span class="id"> //=</span><span class="id"> andbT</span><span class="id"> -ker_conj_aut</span><span class="id"> !inE</span><span class="id"> morphX</span><span class="id"> //</span><span class="id"> -def_s</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> andbC</span><span class="id"> -</span>(<span class="id">inj_in_eq</span><span class="id"> m_inj</span>)<span class="id"> ?group1</span><span class="id"> //</span><span class="id"> m_s</span><span class="id"> m1</span><span class="id"> oX</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -/r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mulrSr</span><span class="id"> -subr_eq0</span><span class="id"> addrK</span><span class="id"> -val_eqE</span><span class="id"> /=</span><span class="id"> val_Zp_nat</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> [_</span><span class="id"> ==</span><span class="id"> 0]dvdn_Pexp2l</span><span class="id"> //</span><span class="id"> -def_n</span><span class="id"> ltnn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> {1}p2</span><span class="id"> /=</span><span class="id"> =&gt;</span><span class="id"> [[t</span><span class="id"> [At</span><span class="id"> ot</span><span class="id"> m_t]]];</span><span class="id"> rewrite</span><span class="id"> {1}oX</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -{1}def_n</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> eqSS</span><span class="id"> subn_eq0</span><span class="id"> =&gt;</span><span class="id"> defA;</span><span class="gallina-kwd"> exists</span><span class="id"> y;</span><span class="id"> rewrite</span><span class="id"> ?inE</span><span class="id"> ?notXy</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> p2</span><span class="id"> -</span>(<span class="id">norm_conj_autE</span><span class="id"> _</span><span class="id"> Xx</span>)<span class="id"> //=</span><span class="id"> -/ay</span><span class="id"> -def_m</span><span class="id"> ?Aut_aut</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">case</span><span class="id"> Tay:</span> (<span class="id">ay</span><span class="id"> \in</span><span class="id"> &lt;[t]&gt;</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> cycle2g</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> -order_eq1</span><span class="id"> oay</span><span class="id"> p2</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> Tay</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> right;</span><span class="id"> rewrite</span> (<span class="id">eqP</span><span class="id"> Tay</span>)<span class="id"> m_t</span><span class="id"> expg_zneg</span><span class="id"> //</span><span class="id"> mulgV</span><span class="id"> group1</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> leqP</span><span class="id"> defA</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> defA|le3n</span><span class="id"> [a</span><span class="id"> [Aa</span><span class="id"> _</span><span class="id"> _</span><span class="id"> defA</span><span class="id"> [s</span><span class="id"> [As</span><span class="id"> os</span><span class="id"> m_s</span><span class="id"> m_st</span><span class="id"> defA1]]]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defA</span><span class="id"> Aut_aut</span><span class="gallina-kwd"> in</span><span class="id"> Tay</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> ay</span><span class="id"> \in</span><span class="id"> [set</span><span class="id"> s;</span><span class="id"> s</span><span class="id"> *</span><span class="id"> t]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:</span><span class="id"> ay</span><span class="id"> \in</span><span class="id"> 'Ohm_1</span>(<span class="id">Aut</span><span class="id"> X</span>)<span class="id"> :=</span><span class="id"> subsetP</span> (<span class="id">OhmS</span><span class="id"> 1</span> (<span class="id">pcore_sub</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> ay</span><span class="id"> Ap1ay</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case/dprodP:</span> (<span class="id">Ohm_dprod</span><span class="id"> 1</span><span class="id"> defA</span>)<span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> &lt;-</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defA1</span> (<span class="id">@Ohm_p_cycle</span><span class="id"> _</span><span class="id"> _</span><span class="id"> 2</span>)<span class="id"> /p_elt</span><span class="id"> ot</span><span class="id"> //=</span><span class="id"> expg1</span><span class="id"> cycle2g</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulUg</span><span class="id"> mul1g</span><span class="id"> inE</span><span class="id"> Tay</span><span class="id"> cycle2g</span><span class="id"> //</span><span class="id"> mulgU</span><span class="id"> mulg1</span><span class="id"> mulg_set1</span>.<br/>
&nbsp;&nbsp;<span class="id">case/set2P=&gt;</span><span class="id"> -&gt;;</span><span class="id"> [left</span><span class="id"> |</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> ?le3n</span><span class="id"> m_s</span><span class="id"> expg_znat</span><span class="id"> //</span><span class="id"> oX</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -p2</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> m_st</span><span class="id"> expg_znat</span><span class="id"> //</span><span class="id"> oX</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> -p2</span><span class="id"> -/r</span><span class="id"> -expgS</span><span class="id"> prednK</span><span class="id"> ?cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> [Gy</span><span class="id"> notXy]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X'y;</span><span class="id"> have</span><span class="id"> nXy</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> nXG</span><span class="id"> y</span><span class="id"> Gy</span>.<br/>
<span class="id">have</span><span class="id"> defG</span><span class="id"> j:</span><span class="id"> &lt;[x]&gt;</span><span class="id"> &lt;*&gt;</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> j</span><span class="id"> *</span><span class="id"> y]&gt;</span><span class="id"> =</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defX</span><span class="id"> -genM_join</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">mulg_normal_maximal</span><span class="id"> nsXG</span>)<span class="id"> ?cycle_subG</span><span class="id"> ?groupMl</span><span class="id"> ?groupX</span><span class="id"> ?genGid</span>.<br/>
<span class="id">have[i</span><span class="id"> def_yp]:</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> y</span><span class="id"> ^-</span><span class="id"> p</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/cycleP;</span><span class="id"> rewrite</span><span class="id"> -defX</span><span class="id"> groupV</span><span class="id"> X_Gp</span>.<br/>
<span class="id">have</span><span class="id"> p_i:</span><span class="id"> p</span><span class="id"> %|</span><span class="id"> i</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> notXy;</span><span class="id"> rewrite</span><span class="id"> -prime_coprime</span><span class="id"> //</span><span class="id"> =&gt;</span><span class="id"> co_p_j</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> genX:</span><span class="id"> generator</span><span class="id"> X</span> (<span class="id">y</span><span class="id"> ^-</span><span class="id"> p</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> def_yp</span><span class="id"> defX</span><span class="id"> generator_coprime</span><span class="id"> ox</span><span class="id"> coprimeXl</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -scXG</span> (<span class="id">setIidPl</span><span class="id"> _</span>)<span class="id"> //</span><span class="id"> centsC</span> ((<span class="id">X</span><span class="id"> :=P:</span><span class="id"> _</span>)<span class="id"> genX</span>)<span class="id"> cycle_subG</span><span class="id"> groupV</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -</span>(<span class="id">defG</span><span class="id"> 0</span>)<span class="id"> mul1g</span><span class="id"> centY</span><span class="id"> inE</span><span class="id"> -defX</span> (<span class="id">subsetP</span><span class="id"> cXX</span>)<span class="id"> ?X_Gp</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span> (<span class="id">cycle_abelian</span><span class="id"> y</span>))<span class="id"> ?mem_cycle</span>.<br/>
<span class="id">case=&gt;</span><span class="id"> [[n_gt23</span><span class="id"> xy]</span><span class="id"> |</span><span class="id"> [p2</span><span class="id"> Z_xxy]]</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> cG</span><span class="id"> =</span><span class="id"> ModularGroup</span><span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> apply/modular_group_classP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> p</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_modular_group</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> oG</span><span class="id"> leqnn</span><span class="id"> andbT</span><span class="id"> Grp_modular_group</span><span class="id"> //</span><span class="id"> -/q</span><span class="id"> -/r</span>.<br/>
&nbsp;&nbsp;<span class="id">have{i</span><span class="id"> def_yp</span><span class="id"> p_i}</span><span class="id"> [i</span><span class="id"> def_yp]:</span><span class="gallina-kwd"> exists</span><span class="id"> i,</span><span class="id"> y</span><span class="id"> ^-</span><span class="id"> p</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> ^+</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/dvdnP:</span><span class="id"> p_i</span><span class="id"> =&gt;</span><span class="id"> j</span><span class="id"> def_i;</span><span class="gallina-kwd"> exists</span><span class="id"> j;</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> -def_i</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Zyx:</span><span class="id"> [~</span><span class="id"> y,</span><span class="id"> x]</span><span class="id"> \in</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -groupV</span><span class="id"> invg_comm</span><span class="id"> commgEl</span><span class="id"> xy</span><span class="id"> expgS</span><span class="id"> mulKg</span><span class="id"> cycle_id</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> def_yxj</span><span class="id"> j:</span><span class="id"> [~</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> j]</span><span class="id"> =</span><span class="id"> [~</span><span class="id"> y,</span><span class="id"> x]</span><span class="id"> ^+</span><span class="id"> j</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> commgX</span><span class="id"> /commute</span><span class="id"> ?</span>(<span class="id">centsP</span><span class="id"> cGZ</span><span class="id"> _</span><span class="id"> Zyx</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Zyxj</span><span class="id"> j:</span><span class="id"> [~</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> j]</span><span class="id"> \in</span><span class="id"> Z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> def_yxj</span><span class="id"> groupX</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> x_xjy</span><span class="id"> j:</span><span class="id"> x</span><span class="id"> ^</span> (<span class="id">x</span><span class="id"> ^+</span><span class="id"> j</span><span class="id"> *</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<span class="id">+1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> commuteX</span><span class="id"> //=</span><span class="id"> mulKg</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [cyxi</span><span class="id"> |</span><span class="id"> not_cyxi]</span><span class="id"> :=</span><span class="id"> eqVneq</span> (<span class="id">[~</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i]</span><span class="id"> ^+</span><span class="id"> 'C</span>(<span class="id">p,</span><span class="id"> 2</span>))<span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i</span><span class="id"> *</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defG</span><span class="id"> x_xjy</span><span class="id"> -order_dvdn</span><span class="id"> ox</span><span class="id"> dvdnn</span><span class="id"> !eqxx</span><span class="id"> andbT</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expMg_Rmul</span><span class="id"> /commute</span><span class="id"> ?</span>(<span class="id">centsP</span><span class="id"> cGZ</span><span class="id"> _</span> (<span class="id">Zyxj</span><span class="id"> _</span>))<span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> cyxi</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -def_yp</span><span class="id"> -mulgA</span><span class="id"> mulKg</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> odd_p]</span><span class="id"> :=</span><span class="id"> even_prime</span><span class="id"> p_pr;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span><span class="id"> bin2odd</span><span class="id"> ?dvdn_mulr</span><span class="id"> //</span><span class="id"> -oZ</span><span class="id"> order_dvdG</span><span class="gallina-kwd"> in</span><span class="id"> not_cyxi</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> def_yxi:</span><span class="id"> [~</span><span class="id"> y,</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> i]</span><span class="id"> =</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> r</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Zyxj</span><span class="id"> i;</span><span class="id"> rewrite</span><span class="id"> /Z</span><span class="id"> cycle_traject</span><span class="id"> orderE</span><span class="id"> oZ</span><span class="id"> p2</span><span class="id"> !inE</span><span class="id"> mulg1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/pred2P=&gt;</span><span class="id"> //</span><span class="id"> cyxi;</span><span class="id"> rewrite</span><span class="id"> cyxi</span><span class="id"> p2</span><span class="id"> eqxx</span><span class="gallina-kwd"> in</span><span class="id"> not_cyxi</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> x</span><span class="id"> ^+</span> (<span class="id">i</span><span class="id"> +</span><span class="id"> r</span><span class="id"> %/</span><span class="id"> 2</span>)<span class="id"> *</span><span class="id"> y</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> !xpair_eqE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defG</span><span class="id"> x_xjy</span><span class="id"> -order_dvdn</span><span class="id"> ox</span><span class="id"> dvdnn</span><span class="id"> !eqxx</span><span class="id"> andbT</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expMg_Rmul</span><span class="id"> /commute</span><span class="id"> ?</span>(<span class="id">centsP</span><span class="id"> cGZ</span><span class="id"> _</span> (<span class="id">Zyxj</span><span class="id"> _</span>))<span class="id"> ?groupX</span><span class="id"> //</span><span class="id"> def_yxj</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgM</span><span class="id"> mulnDl</span><span class="id"> addnC</span><span class="id"> !expgD</span> (<span class="id">expgM</span><span class="id"> x</span><span class="id"> i</span>)<span class="id"> -def_yp</span><span class="id"> mulgKV</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -def_yxj</span><span class="id"> def_yxi</span><span class="id"> p2</span><span class="id"> mulgA</span><span class="id"> -expgD</span><span class="gallina-kwd"> in</span><span class="id"> n_gt23</span><span class="id"> *</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expg_mod_order</span><span class="id"> ox</span><span class="id"> /q</span><span class="id"> /r</span><span class="id"> p2</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt23</span>)<span class="id"> mulnC</span><span class="id"> !expnS</span><span class="id"> mulKn</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> modnn</span><span class="id"> mul1g</span><span class="id"> -order_dvdn</span><span class="id"> dvdn_mulr</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -p2</span><span class="id"> -oZ</span><span class="id"> order_dvdG</span>.<br/>
<span class="id">have{i</span><span class="id"> def_yp</span><span class="id"> p_i}</span><span class="id"> Zy2:</span><span class="id"> y</span><span class="id"> ^+</span><span class="id"> 2</span><span class="id"> \in</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defZ</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pX</span>)<span class="id"> -groupV</span><span class="id"> -p2</span><span class="id"> def_yp</span><span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> groupX</span><span class="id"> //=</span><span class="id"> p2</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> expgS</span><span class="id"> -{2}def_yp</span><span class="id"> -</span>(<span class="id">mulKg</span><span class="id"> y</span><span class="id"> y</span>)<span class="id"> -conjgE</span><span class="id"> -conjXg</span><span class="id"> -conjVg</span><span class="id"> def_yp</span><span class="id"> conjXg</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -expgMn</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">centsP</span><span class="id"> cXX</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> ?memJ_norm</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -order_dvdn</span> (<span class="id">dvdn_trans</span> (<span class="id">order_dvdG</span><span class="id"> Z_xxy</span>))<span class="id"> ?oZ</span>.<br/>
<span class="id">rewrite</span><span class="id"> !cycle_traject</span><span class="id"> !orderE</span><span class="id"> oZ</span><span class="id"> p2</span><span class="id"> !inE</span><span class="id"> !mulg1</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> Z_xxy</span><span class="id"> Zy2</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> -eq_invg_mul</span><span class="id"> eq_sym</span><span class="id"> -[r]prednK</span><span class="id"> //</span><span class="id"> expgS</span> (<span class="id">inj_eq</span> (<span class="id">mulgI</span><span class="id"> _</span>))<span class="gallina-kwd"> in</span><span class="id"> Z_xxy</span>.<br/>
<span class="id">case/pred2P:</span><span class="id"> Z_xxy</span><span class="id"> =&gt;</span><span class="id"> xy;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> cG</span><span class="id"> =</span><span class="id"> SemiDihedral</span><span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> apply/semidihedral_classP</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n_gt3:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 3</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> ltngtP</span><span class="id"> notXy</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [|n3];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> ltnNge</span><span class="id"> n_gt2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -scXG</span><span class="id"> inE</span><span class="id"> Gy</span><span class="id"> defX</span><span class="id"> cent_cycle;</span><span class="id"> case/cent1P;</span><span class="id"> red</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">conjgC</span><span class="id"> x</span>)<span class="id"> xy</span><span class="id"> /r</span><span class="id"> p2</span><span class="id"> -n3</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_semidihedral</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> p2</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp_semidihedral</span><span class="id"> //;</span><span class="id"> apply/existsP=&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">case/pred2P:</span><span class="id"> Zy2</span><span class="id"> =&gt;</span><span class="id"> y2;</span><span class="id"> [exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> |</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> x</span><span class="id"> *</span><span class="id"> y</span>)<span class="id">]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -{1}[y]mul1g</span> (<span class="id">defG</span><span class="id"> 0</span>)<span class="id"> y2</span><span class="id"> xy</span><span class="id"> -p2</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> expg_order</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span> (<span class="id">defG</span><span class="id"> 1%N</span>)<span class="id"> conjgM</span><span class="id"> {2}/conjg</span><span class="id"> mulKg</span><span class="id"> -p2</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> expg_order</span><span class="id"> -xy</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !xpair_eqE</span><span class="id"> !eqxx</span><span class="id"> /=</span><span class="id"> andbT</span><span class="id"> p2</span><span class="id"> expgS</span><span class="id"> {2}</span>(<span class="id">conjgC</span><span class="id"> x</span>)<span class="id"> xy</span><span class="id"> mulgA</span><span class="id"> -</span>(<span class="id">mulgA</span><span class="id"> x</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> [y</span><span class="id"> *</span><span class="id"> y]y2</span><span class="id"> -expgS</span><span class="id"> -expgD</span><span class="id"> addSnnS</span><span class="id"> prednK</span><span class="id"> //</span><span class="id"> addnn</span><span class="id"> -mul2n</span><span class="id"> -p2</span><span class="id"> def_pr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -ox</span><span class="id"> expg_order</span>.<br/>
<span class="id">case/pred2P:</span><span class="id"> Zy2</span><span class="id"> =&gt;</span><span class="id"> y2</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> cG</span><span class="id"> =</span><span class="id"> Dihedral</span><span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> apply/dihedral_classP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_2dihedral</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> p2</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> Grp_2dihedral</span><span class="id"> //;</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -{1}[y]mul1g</span> (<span class="id">defG</span><span class="id"> 0</span>)<span class="id"> y2</span><span class="id"> xy</span><span class="id"> -p2</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> expg_order</span>.<br/>
<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> cG</span><span class="id"> =</span><span class="id"> Quaternion</span><span class="gallina-kwd"> by</span><span class="id"> [];</span><span class="id"> apply/quaternion_classP</span>.<br/>
<span class="gallina-kwd">exists</span><span class="id"> n</span><span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> rewrite</span><span class="id"> isogEcard</span><span class="id"> card_quaternion</span><span class="id"> //</span><span class="id"> oG</span><span class="id"> p2</span><span class="id"> leqnn</span><span class="id"> andbT</span>.<br/>
<span class="id">rewrite</span><span class="id"> Grp_quaternion</span><span class="id"> //;</span><span class="id"> apply/existsP;</span><span class="gallina-kwd"> exists</span> (<span class="id">x,</span><span class="id"> y</span>)<span class="id"> =&gt;</span><span class="id"> /=</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -{1}[y]mul1g</span> (<span class="id">defG</span><span class="id"> 0</span>)<span class="id"> y2</span><span class="id"> xy</span><span class="id"> -p2</span><span class="id"> -/q</span><span class="id"> -ox</span><span class="id"> expg_order</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> cyclic_SCN</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> U</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> U</span><span class="id"> \in</span><span class="id"> 'SCN</span>(<span class="id">G</span>)<span class="id"> -&gt;</span><span class="id"> ~~</span><span class="id"> abelian</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> U</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 2,</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> &amp;</span><span class="id"> extremal2</span><span class="id"> G]</span><br/>
<span class="id">\/</span><span class="gallina-kwd"> exists</span><span class="id"> M</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> M</span><span class="id"> :=:</span><span class="id"> 'C_G</span>(<span class="id">'Mho^1</span>(<span class="id">U</span>))<span class="id">,</span><span class="id"> #|M</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> p,</span><span class="id"> extremal_class</span><span class="id"> M</span><span class="id"> =</span><span class="id"> ModularGroup,</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">'Ohm_1</span>(<span class="id">M</span>)<span class="id">%G</span><span class="id"> \in</span><span class="id"> 'E_p^2</span>(<span class="id">G</span>)<span class="id"> &amp;</span><span class="id"> 'Ohm_1</span>(<span class="id">M</span>)<span class="id"> \char</span><span class="id"> G]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> /SCN_P[nsUG</span><span class="id"> scUG]</span><span class="id"> not_cGG</span><span class="id"> cycU;</span><span class="id"> have</span><span class="id"> [sUG</span><span class="id"> nUG]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsUG</span>.<br/>
<span class="id">have</span><span class="id"> [cUU</span><span class="id"> pU]</span><span class="id"> :=</span> (<span class="id">cyclic_abelian</span><span class="id"> cycU,</span><span class="id"> pgroupS</span><span class="id"> sUG</span><span class="id"> pG</span>).<br/>
<span class="id">have</span><span class="id"> ltUG:</span><span class="id"> ~~</span> (<span class="id">G</span><span class="id"> \subset</span><span class="id"> U</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> not_cGG</span><span class="id"> =&gt;</span><span class="id"> sGU;</span><span class="id"> apply:</span><span class="id"> abelianS</span><span class="id"> cUU</span>.<br/>
<span class="id">have</span><span class="id"> ntU:</span><span class="id"> U</span><span class="id"> :!=:</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> contraNneq</span><span class="id"> ltUG</span><span class="id"> =&gt;</span><span class="id"> U1;</span><span class="id"> rewrite</span><span class="id"> -scUG</span><span class="id"> subsetIidl</span><span class="id"> U1</span><span class="id"> cents1</span>.<br/>
<span class="id">have</span><span class="id"> [p_pr</span><span class="id"> _</span><span class="id"> [n</span><span class="id"> oU]]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> pU</span><span class="id"> ntU</span>.<br/>
<span class="id">have</span><span class="id"> p_gt1</span><span class="id"> :=</span><span class="id"> prime_gt1</span><span class="id"> p_pr;</span><span class="id"> have</span><span class="id"> p_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> p_gt1</span>.<br/>
<span class="id">have</span><span class="id"> [u</span><span class="id"> defU]</span><span class="id"> :=</span><span class="id"> cyclicP</span><span class="id"> cycU;</span><span class="id"> have</span><span class="id"> Uu:</span><span class="id"> u</span><span class="id"> \in</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defU</span><span class="id"> cycle_id</span>.<br/>
<span class="id">have</span><span class="id"> Gu</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> sUG</span><span class="id"> u</span><span class="id"> Uu;</span><span class="id"> have</span><span class="id"> p_u</span><span class="id"> :=</span><span class="id"> mem_p_elt</span><span class="id"> pG</span><span class="id"> Gu</span>.<br/>
<span class="id">have</span><span class="id"> defU1:</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="id"> =</span><span class="id"> &lt;[u</span><span class="id"> ^+</span><span class="id"> p]&gt;</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defU</span> (<span class="id">Mho_p_cycle</span><span class="id"> _</span><span class="id"> p_u</span>).<br/>
<span class="id">have</span><span class="id"> modM1</span> (<span class="id">M</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id">:</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> M,</span><span class="id"> #|M</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> p</span><span class="id"> &amp;</span><span class="id"> extremal_class</span><span class="id"> M</span><span class="id"> =</span><span class="id"> ModularGroup]</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">M</span><span class="id"> :=:</span><span class="id"> 'C_M</span>(<span class="id">'Mho^1</span>(<span class="id">U</span>))<span class="id"> /\</span><span class="id"> 'Ohm_1</span>(<span class="id">M</span>)<span class="id">%G</span><span class="id"> \in</span><span class="id"> 'E_p^2</span>(<span class="id">M</span>).<br/>
<span class="id">-</span><span class="id"> case=&gt;</span><span class="id"> sUM</span><span class="id"> iUM</span><span class="id"> /modular_group_classP[q</span><span class="id"> q_pr</span><span class="id"> {n</span><span class="id"> oU}[n</span><span class="id"> n_gt23</span><span class="id"> isoM]]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> n_gt2:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> leq_trans</span> (<span class="id">leq_addl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> n_gt23</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> def_n:</span><span class="id"> n</span><span class="id"> =</span> (<span class="id">n</span><span class="id"> -</span><span class="id"> 3</span>).<span class="id">+3</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{1}</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oM:</span><span class="id"> #|M|</span><span class="id"> =</span> (<span class="id">q</span><span class="id"> ^</span><span class="id"> n</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">card_isog</span><span class="id"> isoM</span>)<span class="id"> card_modular_group</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> pM:</span><span class="id"> q</span>.<span class="id">-group</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> /pgroup</span><span class="id"> oM</span><span class="id"> pnatX</span><span class="id"> pnat_id</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> def_q:</span><span class="id"> q</span><span class="id"> =</span><span class="id"> p;</span><span class="id"> last</span><span class="id"> rewrite</span><span class="id"> {q</span><span class="id"> q_pr}def_q</span><span class="gallina-kwd"> in</span><span class="id"> oM</span><span class="id"> pM</span><span class="id"> isoM</span><span class="id"> n_gt23</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> [p</span><span class="id"> ==</span><span class="id"> q]</span>(<span class="id">pgroupP</span><span class="id"> pM</span>)<span class="id"> //</span><span class="id"> -iUM</span><span class="id"> dvdn_indexg</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genM</span><span class="id"> modM]</span><span class="id"> :=</span><span class="id"> generators_modular_group</span><span class="id"> p_pr</span><span class="id"> n_gt2</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;<span class="id">case/modular_group_structure:</span><span class="id"> genM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> [defZ</span><span class="id"> _</span><span class="id"> oZ]</span><span class="id"> _</span><span class="id"> defMho</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">M</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> oZ</span><span class="id"> defZ</span><span class="id"> -</span>(<span class="id">defMho</span><span class="id"> 1%N</span>)<span class="id"> ?MhoS</span><span class="id"> //=</span><span class="id"> defU1</span><span class="id"> -orderE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suff</span><span class="id"> ou:</span><span class="id"> #[u]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> *</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> orderXdiv</span><span class="id"> ou</span><span class="id"> ?dvdn_mulr</span><span class="id"> ?mulKn</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> orderE</span><span class="id"> -defU</span><span class="id"> -</span>(<span class="id">divg_indexS</span><span class="id"> sUM</span>)<span class="id"> iUM</span><span class="id"> oM</span><span class="id"> def_n</span><span class="id"> mulKn</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [[p2</span><span class="id"> n3]</span><span class="id"> |</span><span class="id"> _</span><span class="id"> defOhm];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="id"> n3</span><span class="gallina-kwd"> in</span><span class="id"> n_gt23</span>.<br/>
&nbsp;&nbsp;<span class="id">have{defOhm}</span><span class="id"> [|defM1</span><span class="id"> oM1]</span><span class="id"> :=</span><span class="id"> defOhm</span><span class="id"> 1%N;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> def_n</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> rewrite</span><span class="id"> ?</span>(<span class="id">setIidPl</span><span class="id"> _</span>)<span class="id"> //;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> centsC</span><span class="id"> subsetIr</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> oM1</span><span class="id"> pfactorK</span><span class="id"> //</span><span class="id"> andbT</span><span class="id"> inE</span><span class="id"> Ohm_sub</span><span class="id"> abelem_Ohm1</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">exact:</span> (<span class="id">card_p2group_abelian</span><span class="id"> p_pr</span><span class="id"> oM1</span>).<br/>
<span class="id">have</span><span class="id"> ou:</span><span class="id"> #[u]</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">+1</span>)<span class="id">%N</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defU</span><span class="gallina-kwd"> in</span><span class="id"> oU</span>.<br/>
<span class="id">pose</span><span class="id"> Gs</span><span class="id"> :=</span><span class="id"> G</span><span class="id"> /</span><span class="id"> U;</span><span class="id"> have</span><span class="id"> pGs:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> Gs</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> quotient_pgroup</span>.<br/>
<span class="id">have</span><span class="id"> ntGs:</span><span class="id"> Gs</span><span class="id"> !=</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subG1</span><span class="id"> quotient_sub1</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [[|k]</span><span class="id"> oGs]]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> pGs</span><span class="id"> ntGs</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> iUG:</span><span class="id"> #|G</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -card_quotient</span><span class="id"> ?oGs</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span> (<span class="id">predU1P</span> (<span class="id">maximal_cycle_extremal</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> iUG</span>))<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> [modG</span><span class="id"> |</span><span class="id"> ext2G]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> G;</span><span class="id"> case:</span> (<span class="id">modM1</span><span class="id"> G</span>)<span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> &lt;-</span><span class="id"> -&gt;;</span><span class="id"> rewrite</span><span class="id"> Ohm_char</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> left;</span><span class="id"> case:</span><span class="id"> eqP</span><span class="id"> ext2G</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> &lt;-</span>.<br/>
<span class="id">pose</span><span class="id"> M</span><span class="id"> :=</span><span class="id"> 'C_G</span>(<span class="id">'Mho^1</span>(<span class="id">U</span>))<span class="id">;</span><span class="id"> right;</span><span class="gallina-kwd"> exists</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> M]</span>.<br/>
<span class="id">have</span><span class="id"> sMG:</span><span class="id"> M</span><span class="id"> \subset</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> subsetIl</span>.<br/>
<span class="id">have</span><span class="id"> [pM</span><span class="id"> nUM]</span><span class="id"> :=</span> (<span class="id">pgroupS</span><span class="id"> sMG</span><span class="id"> pG,</span><span class="id"> subset_trans</span><span class="id"> sMG</span><span class="id"> nUG</span>).<br/>
<span class="id">have</span><span class="id"> sUM:</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> M</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> sUG</span><span class="id"> sub_abelian_cent</span><span class="id"> ?Mho_sub</span>.<br/>
<span class="id">pose</span><span class="id"> A</span><span class="id"> :=</span><span class="id"> Aut</span><span class="id"> U;</span><span class="id"> have</span><span class="id"> cAA:</span><span class="id"> abelian</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Aut_cyclic_abelian</span>.<br/>
<span class="id">have</span><span class="id"> sylAp:</span><span class="id"> p</span>.<span class="id">-Sylow</span>(<span class="id">A</span>)<span class="id"> 'O_p</span>(<span class="id">A</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> nilpotent_pcore_Hall</span><span class="id"> ?abelian_nil</span>.<br/>
<span class="id">have</span><span class="id"> [f</span><span class="id"> [injf</span><span class="id"> sfGsA</span><span class="id"> fG]]:</span><span class="gallina-kwd"> exists</span><span class="id"> f</span><span class="id"> :</span><span class="id"> {morphism</span><span class="id"> Gs</span><span class="id"> &gt;-&gt;</span><span class="id"> {perm</span><span class="id"> gT}},</span><br/>
&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> 'injm</span><span class="id"> f,</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span><span class="id"> \subset</span><span class="id"> A</span><span class="id"> &amp;</span><span class="id"> {in</span><span class="id"> G,</span><span class="gallina-kwd"> forall</span><span class="id"> y,</span><span class="id"> f</span> (<span class="id">coset</span><span class="id"> U</span><span class="id"> y</span>)<span class="id"> u</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^</span><span class="id"> y}]</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> []</span><span class="id"> :=</span><span class="id"> first_isom_loc</span><span class="id"> [morphism</span><span class="id"> of</span><span class="id"> conj_aut</span><span class="id"> U]</span><span class="id"> nUG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> ker_conj_aut</span><span class="id"> scUG</span><span class="id"> /=</span><span class="id"> -/Gs</span><span class="id"> =&gt;</span><span class="id"> f</span><span class="id"> injf</span><span class="id"> im_f</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> f;</span><span class="id"> rewrite</span><span class="id"> im_f</span><span class="id"> ?Aut_conj_aut</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //</span><span class="id"> y</span><span class="id"> Gy;</span><span class="id"> have</span><span class="id"> nUy</span><span class="id"> :=</span><span class="id"> subsetP</span><span class="id"> nUG</span><span class="id"> y</span><span class="id"> Gy</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> f</span> (<span class="id">coset</span><span class="id"> U</span><span class="id"> y</span>)<span class="id"> =</span><span class="id"> conj_aut</span><span class="id"> U</span><span class="id"> y</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> norm_conj_autE</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> set1_inj;</span><span class="id"> rewrite</span><span class="id"> -!morphim_set1</span><span class="id"> ?mem_quotient</span><span class="id"> //</span><span class="id"> im_f</span><span class="id"> ?sub1set</span>.<br/>
<span class="id">have</span><span class="id"> cGsGs:</span><span class="id"> abelian</span><span class="id"> Gs</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">injm_abelian</span><span class="id"> injf</span>)<span class="id"> //</span> (<span class="id">abelianS</span><span class="id"> sfGsA</span>).<br/>
<span class="id">have</span><span class="id"> p_fGs:</span><span class="id"> p</span>.<span class="id">-group</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> Gs</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> morphim_pgroup</span>.<br/>
<span class="id">have</span><span class="id"> sfGsAp:</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span><span class="id"> \subset</span><span class="id"> 'O_p</span>(<span class="id">A</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">sub_Hall_pcore</span><span class="id"> sylAp</span>).<br/>
<span class="id">have</span><span class="id"> [a</span><span class="id"> [fGa</span><span class="id"> oa</span><span class="id"> au</span><span class="id"> n_gt01</span><span class="id"> cycGs]]:</span><span class="gallina-kwd"> exists</span><span class="id"> a,</span><br/>
&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs,</span><span class="id"> #[a]</span><span class="id"> =</span><span class="id"> p,</span><span class="id"> a</span><span class="id"> u</span><span class="id"> =</span><span class="id"> u</span><span class="id"> ^+</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>).<span class="id">+1,</span> (<span class="id">p</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> +</span><span class="id"> 1</span><span class="id"> &lt;=</span><span class="id"> n</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> cyclic</span><span class="id"> Gs</span><span class="id"> \/</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 2</span><span class="id"> /\</span> (<span class="gallina-kwd">exists2</span><span class="id"> c,</span><span class="id"> c</span><span class="id"> \in</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span><span class="id"> &amp;</span><span class="id"> c</span><span class="id"> u</span><span class="id"> =</span><span class="id"> u^-1</span>)<span class="id">]</span>.<br/>
<span class="id">-</span><span class="id"> have</span><span class="id"> [m</span><span class="id"> [[def_m</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> cyclic_pgroup_Aut_structure</span><span class="id"> pU</span><span class="id"> cycU</span><span class="id"> ntU</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> -&gt;:</span><span class="id"> logn</span><span class="id"> p</span><span class="id"> #|U|</span><span class="id"> =</span><span class="id"> n</span>.<span class="id">+1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oU</span><span class="id"> pfactorK</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -/A;</span><span class="id"> case:</span><span class="id"> posnP</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> defA</span><span class="id"> |</span><span class="id"> n_gt0</span><span class="id"> [c</span><span class="id"> [Ac</span><span class="id"> oc</span><span class="id"> m_c</span><span class="id"> defA]]]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> cardSg</span><span class="id"> sfGsAp;</span><span class="id"> rewrite</span> (<span class="id">card_Hall</span><span class="id"> sylAp</span>)<span class="id"> /=</span><span class="id"> -/A</span><span class="id"> defA</span><span class="id"> card_injm</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> oGs</span> (<span class="id">part_p'nat</span> (<span class="id">pcore_pgroup</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> pfactor_dvdn</span><span class="id"> //</span><span class="id"> logn1</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [p2</span><span class="id"> |</span><span class="id"> odd_p]</span><span class="id"> :=</span><span class="id"> even_prime</span><span class="id"> p_pr;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [-&gt;</span><span class="id"> //</span><span class="id"> |</span><span class="id"> _]</span><span class="gallina-kwd"> in</span><span class="id"> odd_p</span><span class="id"> *;</span><span class="id"> rewrite</span><span class="id"> odd_p</span><span class="gallina-kwd"> in</span><span class="id"> defA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[cycA</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> [a</span><span class="id"> [Aa</span><span class="id"> oa</span><span class="id"> m_a</span><span class="id"> defA1]]]</span><span class="id"> :=</span><span class="id"> defA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> a;</span><span class="id"> rewrite</span><span class="id"> -def_m</span><span class="id"> //</span><span class="id"> oa</span><span class="id"> m_a</span><span class="id"> expg_znat</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">injm_cyclic</span><span class="id"> injf</span>)<span class="id"> ?</span>(<span class="id">cyclicS</span><span class="id"> sfGsA</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span><span class="id"> !=</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> morphim_injm_eq1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cycle_subG;</span><span class="id"> apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> not_sfGs_a</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setIidPl</span><span class="id"> sfGsAp</span>)<span class="id"> TI_Ohm1</span><span class="id"> //</span><span class="id"> defA1</span><span class="id"> setIC</span><span class="id"> prime_TIg</span><span class="id"> -?orderE</span><span class="id"> ?oa</span>.<br/>
&nbsp;&nbsp;<span class="id">do</span><span class="id"> [rewrite</span><span class="id"> {1}p2</span><span class="id"> /=</span><span class="id"> eqn_leq</span><span class="id"> n_gt0;</span><span class="id"> case:</span><span class="id"> leqP</span><span class="id"> =&gt;</span><span class="id"> /=</span><span class="id"> [_</span><span class="id"> |</span><span class="id"> n_gt1]]</span><span class="gallina-kwd"> in</span><span class="id"> defA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> cardSg</span><span class="id"> sfGsAp;</span><span class="id"> rewrite</span> (<span class="id">card_Hall</span><span class="id"> sylAp</span>)<span class="id"> /=</span><span class="id"> -/A</span><span class="id"> defA</span><span class="id"> -orderE</span><span class="id"> oc</span><span class="id"> p2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_injm</span><span class="id"> //</span><span class="id"> oGs</span><span class="id"> p2</span><span class="id"> pfactor_dvdn</span><span class="id"> //</span><span class="id"> p_part</span>.<br/>
&nbsp;&nbsp;<span class="id">have{defA}</span><span class="id"> [s</span><span class="id"> [As</span><span class="id"> os</span><span class="id"> _</span><span class="id"> defA</span><span class="id"> [a</span><span class="id"> [Aa</span><span class="id"> oa</span><span class="id"> m_a</span><span class="id"> _</span><span class="id"> defA1]]]]</span><span class="id"> :=</span><span class="id"> defA;</span><span class="gallina-kwd"> exists</span><span class="id"> a</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> fGs_a:</span><span class="id"> a</span><span class="id"> \in</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">suffices:</span><span class="id"> f</span><span class="id"> @*</span><span class="id"> Gs</span><span class="id"> :&amp;:</span><span class="id"> &lt;[s]&gt;</span><span class="id"> !=</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> not_fGs_a;</span><span class="id"> rewrite</span><span class="id"> TI_Ohm1</span><span class="id"> //</span><span class="id"> defA1</span><span class="id"> setIC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prime_TIg</span><span class="id"> -?orderE</span><span class="id"> ?oa</span><span class="id"> //</span><span class="id"> cycle_subG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:</span> (<span class="id">f</span><span class="id"> @*</span><span class="id"> Gs</span>)<span class="id"> *</span><span class="id"> &lt;[s]&gt;</span><span class="id"> \subset</span><span class="id"> A</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> mulG_subG</span><span class="id"> cycle_subG</span><span class="id"> sfGsA</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/subset_leq_card;</span><span class="id"> apply:</span><span class="id"> contraL;</span><span class="id"> move/eqP;</span><span class="id"> move/TI_cardMg-&gt;</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">dprod_card</span><span class="id"> defA</span>)<span class="id"> -ltnNge</span><span class="id"> mulnC</span><span class="id"> -!orderE</span><span class="id"> ltn_pmul2r</span><span class="id"> //</span><span class="id"> oc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> card_injm</span><span class="id"> //</span><span class="id"> oGs</span><span class="id"> p2</span> (<span class="id">ltn_exp2l</span><span class="id"> 1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -def_m</span><span class="id"> //</span><span class="id"> oa</span><span class="id"> m_a</span><span class="id"> expg_znat</span><span class="id"> //</span><span class="id"> p2;</span><span class="id"> split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> //</span> (<span class="id">rank_pgroup</span><span class="id"> pGs</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">injm_p_rank</span><span class="id"> injf</span>)<span class="id"> //</span><span class="id"> p_rank_abelian</span><span class="id"> 1?morphim_abelian</span><span class="id"> //=</span><span class="id"> p2</span><span class="id"> -/Gs</span>.<br/>
&nbsp;&nbsp;<span class="id">case:</span><span class="id"> leqP</span><span class="id"> =&gt;</span><span class="id"> [|fGs1_gt1];</span><span class="id"> [by</span><span class="id"> left</span><span class="id"> |</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;<span class="id">split=&gt;</span><span class="id"> //;</span><span class="gallina-kwd"> exists</span><span class="id"> c;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -def_m</span><span class="id"> //</span><span class="id"> m_c</span><span class="id"> expg_zneg</span>.<br/>
&nbsp;&nbsp;<span class="id">have{}</span><span class="id"> defA1:</span><span class="id"> &lt;[a]&gt;</span><span class="id"> \x</span><span class="id"> &lt;[c]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_1</span>(<span class="id">Aut</span><span class="id"> U</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">Ohm_dprod</span><span class="id"> 1</span><span class="id"> defA</span>)<span class="id"> defA1</span> (<span class="id">@Ohm_p_cycle</span><span class="id"> 1</span><span class="id"> _</span><span class="id"> 2</span>)<span class="id"> /p_elt</span><span class="id"> oc</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> def_fGs1:</span><span class="id"> 'Ohm_1</span>(<span class="id">f</span><span class="id"> @*</span><span class="id"> Gs</span>)<span class="id"> =</span><span class="id"> 'Ohm_1</span>(<span class="id">A</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> OhmS</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">dprod_card</span><span class="id"> defA1</span>)<span class="id"> -!orderE</span><span class="id"> oa</span><span class="id"> oc</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> ?</span>(<span class="id">@pfactor_dvdn</span><span class="id"> 2</span><span class="id"> 2</span>)<span class="id"> ?cardG_gt0</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">subsetP</span> (<span class="id">Ohm_sub</span><span class="id"> 1</span><span class="id"> _</span>))<span class="id"> //</span><span class="id"> def_fGs1</span><span class="id"> -cycle_subG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/dprodP:</span><span class="id"> defA1</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> &lt;-</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> rewrite</span><span class="id"> mulG_subr</span>.<br/>
<span class="id">have</span><span class="id"> n_gt0:</span><span class="id"> n</span><span class="id"> &gt;</span><span class="id"> 0</span><span class="id"> :=</span><span class="id"> leq_trans</span> (<span class="id">leq_addl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> n_gt01</span>.<br/>
<span class="id">have</span><span class="id"> [ys</span><span class="id"> Gys</span><span class="id"> _</span><span class="id"> def_a]</span><span class="id"> :=</span><span class="id"> morphimP</span><span class="id"> fGa</span>.<br/>
<span class="id">have</span><span class="id"> oys:</span><span class="id"> #[ys]</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">order_injm</span><span class="id"> injf</span>)<span class="id"> //</span><span class="id"> -def_a</span><span class="id"> oa</span>.<br/>
<span class="id">have</span><span class="id"> defMs:</span><span class="id"> M</span><span class="id"> /</span><span class="id"> U</span><span class="id"> =</span><span class="id"> &lt;[ys]&gt;</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eq_sym</span><span class="id"> eqEcard</span><span class="id"> -orderE</span><span class="id"> oys</span><span class="id"> cycle_subG;</span><span class="id"> apply/andP;</span><span class="id"> split</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [y</span><span class="id"> nUy</span><span class="id"> Gy</span><span class="id"> /=</span><span class="id"> def_ys]</span><span class="id"> :=</span><span class="id"> morphimP</span><span class="id"> Gys</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> def_ys</span><span class="id"> mem_quotient</span><span class="id"> //=</span><span class="id"> inE</span><span class="id"> Gy</span><span class="id"> defU1</span><span class="id"> cent_cycle</span><span class="id"> cent1C</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span><span class="id"> cent1P</span><span class="id"> commgP</span>)<span class="id"> commgEl</span><span class="id"> conjXg</span><span class="id"> -fG</span><span class="id"> //=</span><span class="id"> -def_ys</span><span class="id"> -def_a</span><span class="id"> au</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -expgM</span><span class="id"> mulSn</span><span class="id"> expgD</span><span class="id"> mulKg</span><span class="id"> -expnSr</span><span class="id"> -ou</span><span class="id"> expg_order</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> card_quotient</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">setIidPr</span><span class="id"> sUM</span>)<span class="id"> -scUG</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sMG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defU</span><span class="id"> cent_cycle</span><span class="id"> index_cent1</span><span class="id"> -</span>(<span class="id">card_imset</span><span class="id"> _</span> (<span class="id">mulgI</span><span class="id"> u^-1</span>))<span class="id"> -imset_comp</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> &lt;-:</span><span class="id"> #|'Ohm_1</span>(<span class="id">U</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defU</span> (<span class="id">Ohm_p_cycle</span><span class="id"> 1</span><span class="id"> p_u</span>)<span class="id"> -orderE</span> (<span class="id">orderXexp</span><span class="id"> _</span><span class="id"> ou</span>)<span class="id"> ou</span><span class="id"> pfactorK</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subKn</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pU</span>)<span class="id"> subset_leq_card</span><span class="id"> ?sub_gen</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imsetP[z</span><span class="id"> /setIP[/</span>(<span class="id">subsetP</span><span class="id"> nUG</span>)<span class="id"> nUz</span><span class="id"> cU1z]</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Uv'</span><span class="id"> :=</span><span class="id"> groupVr</span><span class="id"> Uu;</span><span class="id"> have</span><span class="id"> Uuz:</span><span class="id"> u</span><span class="id"> ^</span><span class="id"> z</span><span class="id"> \in</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> memJ_norm</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !inE</span><span class="id"> groupM</span><span class="id"> //</span><span class="id"> expgMn</span><span class="id"> /commute</span><span class="id"> 1?</span>(<span class="id">centsP</span><span class="id"> cUU</span><span class="id"> u^-1</span>)<span class="id"> //=</span><span class="id"> expgVn</span><span class="id"> -conjXg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">sameP</span><span class="id"> commgP</span><span class="id"> cent1P</span>)<span class="id"> cent1C</span><span class="id"> -cent_cycle</span><span class="id"> -defU1</span>.<br/>
<span class="id">have</span><span class="id"> iUM:</span><span class="id"> #|M</span><span class="id"> :</span><span class="id"> U|</span><span class="id"> =</span><span class="id"> p</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -card_quotient</span><span class="id"> ?defMs</span>.<br/>
<span class="id">have</span><span class="id"> not_cMM:</span><span class="id"> ~~</span><span class="id"> abelian</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> contraL</span><span class="id"> p_pr</span><span class="id"> =&gt;</span><span class="id"> cMM;</span><span class="id"> rewrite</span><span class="id"> -iUM</span><span class="id"> -indexgI</span><span class="id"> /=</span><span class="id"> -/M</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">setIidPl</span><span class="id"> _</span>)<span class="id"> ?indexgg</span><span class="id"> //</span><span class="id"> -scUG</span><span class="id"> subsetI</span><span class="id"> sMG</span><span class="id"> sub_abelian_cent</span>.<br/>
<span class="id">have</span><span class="id"> modM:</span><span class="id"> extremal_class</span><span class="id"> M</span><span class="id"> =</span><span class="id"> ModularGroup</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sU1Z:</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="id"> \subset</span><span class="id"> 'Z</span>(<span class="id">M</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> gFsub_trans</span><span class="id"> //</span><span class="id"> centsC</span><span class="id"> subsetIr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /maximal_cycle_extremal/predU1P[]</span><span class="id"> //=</span><span class="id"> :=</span><span class="id"> iUM;</span><span class="id"> rewrite</span><span class="id"> -/M</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP=&gt;</span><span class="id"> /eqP-p2</span><span class="id"> ext2M;</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="id"> add1n</span><span class="gallina-kwd"> in</span><span class="id"> n_gt01</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices{sU1Z}:</span><span class="id"> #|'Z</span>(<span class="id">M</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> 2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">move/eqP;</span><span class="id"> rewrite</span><span class="id"> eqn_leq</span><span class="id"> leqNgt</span> (<span class="id">leq_trans</span><span class="id"> _</span> (<span class="id">subset_leq_card</span><span class="id"> sU1Z</span>))<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defU1</span><span class="id"> -orderE</span> (<span class="id">orderXexp</span><span class="id"> 1</span><span class="id"> ou</span>)<span class="id"> subn1</span><span class="id"> p2</span> (<span class="id">ltn_exp2l</span><span class="id"> 1</span>).<br/>
&nbsp;&nbsp;<span class="id">move:</span><span class="id"> ext2M;</span><span class="id"> rewrite</span><span class="id"> /extremal2</span><span class="id"> !inE</span><span class="id"> orbC</span><span class="id"> -orbA;</span><span class="id"> case/or3P;</span><span class="id"> move/eqP</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> case/semidihedral_classP=&gt;</span><span class="id"> m</span><span class="id"> m_gt3</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[x</span><span class="id"> z]</span><span class="id"> genM</span><span class="id"> [oz</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> generators_semidihedral</span><span class="id"> m_gt3</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/semidihedral_structure:</span><span class="id"> genM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">-</span><span class="id"> case/quaternion_classP=&gt;</span><span class="id"> m</span><span class="id"> m_gt2</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[x</span><span class="id"> z]</span><span class="id"> genM</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> generators_quaternion</span><span class="id"> m_gt2</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/quaternion_structure:</span><span class="id"> genM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> []</span>.<br/>
&nbsp;&nbsp;<span class="id">case/dihedral_classP=&gt;</span><span class="id"> m</span><span class="id"> m_gt1</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[x</span><span class="id"> z]</span><span class="id"> genM</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> generators_2dihedral</span><span class="id"> m_gt1</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;<span class="id">case/dihedral2_structure:</span><span class="id"> genM</span><span class="id"> not_cMM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">m</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> =&gt;</span><span class="id"> [|[]//];</span><span class="id"> move/abelem_abelian-&gt;</span>.<br/>
<span class="id">split=&gt;</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [//|_]</span><span class="id"> :=</span><span class="id"> modM1</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> M];</span><span class="id"> rewrite</span><span class="id"> !inE</span><span class="id"> -andbA</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/andP=&gt;</span><span class="id"> /subset_trans-&gt;</span>.<br/>
<span class="id">have{cycGs}</span><span class="id"> [cycGs</span><span class="id"> |</span><span class="id"> [p2</span><span class="id"> [c</span><span class="id"> fGs_c</span><span class="id"> u_c]]]</span><span class="id"> :=</span><span class="id"> cycGs</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> 'Ohm_1</span>(<span class="id">M</span>)<span class="id"> =</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> Ohm_char</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> sG1M:</span><span class="id"> 'Ohm_1</span>(<span class="id">G</span>)<span class="id"> \subset</span><span class="id"> M</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> -{2}</span>(<span class="id">Ohm_id</span><span class="id"> 1</span><span class="id"> G</span>)<span class="id"> !OhmS</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">quotientSGK</span><span class="id"> _</span><span class="id"> sUM</span>)<span class="id"> ?</span>(<span class="id">subset_trans</span> (<span class="id">Ohm_sub</span><span class="id"> _</span><span class="id"> G</span>))<span class="id"> //=</span><span class="id"> defMs</span>.<br/>
&nbsp;&nbsp;<span class="id">suffices</span><span class="id"> -&gt;:</span><span class="id"> &lt;[ys]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_1</span>(<span class="id">Gs</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> morphim_Ohm</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> -orderE</span><span class="id"> cycle_subG</span><span class="id"> /=</span><span class="id"> {1}</span>(<span class="id">OhmE</span><span class="id"> 1</span><span class="id"> pGs</span>)<span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> mem_gen</span><span class="id"> ?inE</span><span class="id"> ?Gys</span><span class="id"> -?order_dvdn</span><span class="id"> oys</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">part_pnat_id</span> (<span class="id">pgroupS</span> (<span class="id">Ohm_sub</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> pGs</span>))<span class="id"> p_part</span> (<span class="id">leq_exp2l</span><span class="id"> _</span><span class="id"> 1</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -p_rank_abelian</span><span class="id"> -?rank_pgroup</span><span class="id"> -?abelian_rank1_cyclic</span>.<br/>
<span class="id">suffices</span><span class="id"> charU1:</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="id"> \char</span><span class="id"> G^`</span>(<span class="id">1</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> gFchar_trans</span><span class="id"> //</span><span class="id"> subcent_char</span><span class="id"> ?</span>(<span class="id">char_trans</span><span class="id"> charU1</span>)<span class="id"> ?gFchar</span>.<br/>
<span class="id">suffices</span><span class="id"> sUiG':</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="id"> \subset</span><span class="id"> G^`</span>(<span class="id">1</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> /cyclicP[zs</span><span class="id"> cycG']:</span><span class="id"> cyclic</span><span class="id"> G^`</span>(<span class="id">1</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">cyclicS</span><span class="id"> _</span><span class="id"> cycU</span>)<span class="id"> ?der1_min</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cycG'</span><span class="gallina-kwd"> in</span><span class="id"> sUiG'</span><span class="id"> *;</span><span class="id"> apply:</span><span class="id"> cycle_subgroup_char</span>.<br/>
<span class="id">rewrite</span><span class="id"> defU1</span><span class="id"> cycle_subG</span><span class="id"> p2</span><span class="id"> -groupV</span><span class="id"> invMg</span><span class="id"> -{2}u_c</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> /morphimP[z</span><span class="id"> _</span><span class="id"> Gz</span><span class="id"> -&gt;]</span><span class="id"> -&gt;]</span><span class="id"> :=</span><span class="id"> morphimP</span><span class="id"> fGs_c;</span><span class="id"> rewrite</span><span class="id"> fG</span><span class="id"> ?mem_commg</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> normal_rank1_structure</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><span class="id"> X</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> abelian</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">cyclic</span><span class="id"> G</span><span class="id"> \/</span><span class="id"> [&amp;&amp;</span><span class="id"> p</span><span class="id"> ==</span><span class="id"> 2,</span><span class="id"> extremal2</span><span class="id"> G</span><span class="id"> &amp;</span> (<span class="id">#|G|</span><span class="id"> &gt;=</span><span class="id"> 16</span>)<span class="id"> ||</span> (<span class="id">G</span><span class="id"> \isog</span><span class="id"> 'Q_8</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> dn_G_1</span>.<br/>
<span class="id">have</span><span class="id"> [cGG</span><span class="id"> |</span><span class="id"> not_cGG]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">abelian</span><span class="id"> G</span>)<span class="id">;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> dn_G_1</span>.<br/>
<span class="id">have</span><span class="id"> [X</span><span class="id"> maxX]:</span><span class="id"> {X</span><span class="id"> |</span><span class="id"> [max</span><span class="id"> X</span><span class="id"> |</span><span class="id"> X</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="id"> &amp;</span><span class="id"> abelian</span><span class="id"> X]}</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span><span class="id"> ex_maxgroup;</span><span class="gallina-kwd"> exists</span><span class="id"> 1%G;</span><span class="id"> rewrite</span><span class="id"> normal1</span><span class="id"> abelian1</span>.<br/>
<span class="id">have</span><span class="id"> cycX:</span><span class="id"> cyclic</span><span class="id"> X</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> dn_G_1;</span><span class="id"> case/andP:</span> (<span class="id">maxgroupp</span><span class="id"> maxX</span>).<br/>
<span class="id">have</span><span class="id"> scX:</span><span class="id"> X</span><span class="id"> \in</span><span class="id"> 'SCN</span>(<span class="id">G</span>)<span class="id"> :=</span><span class="id"> max_SCN</span><span class="id"> pG</span><span class="id"> maxX</span>.<br/>
<span class="id">have</span><span class="id"> [[p2</span><span class="id"> _</span><span class="id"> cG]</span><span class="id"> |</span><span class="id"> [M</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _]]]</span><span class="id"> :=</span><span class="id"> cyclic_SCN</span><span class="id"> pG</span><span class="id"> scX</span><span class="id"> not_cGG</span><span class="id"> cycX;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> 2!inE</span><span class="id"> -andbA</span><span class="id"> =&gt;</span><span class="id"> /and3P[sEG</span><span class="id"> abelE</span><span class="id"> dimE_2]</span><span class="id"> charE</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> dn_G_1</span><span class="id"> _</span> (<span class="id">char_normal</span><span class="id"> charE</span>) (<span class="id">abelem_abelian</span><span class="id"> abelE</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">abelem_cyclic</span><span class="id"> abelE</span>) (<span class="id">eqP</span><span class="id"> dimE_2</span>).<br/>
<span class="id">have</span><span class="id"> [n</span><span class="id"> oG]</span><span class="id"> :=</span><span class="id"> p_natP</span><span class="id"> pG;</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="id"> cG</span><span class="id"> /=</span><span class="gallina-kwd"> in</span><span class="id"> oG</span><span class="id"> *</span>.<br/>
<span class="id">rewrite</span><span class="id"> oG</span> (<span class="id">@leq_exp2l</span><span class="id"> 2</span><span class="id"> 4</span>)<span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> /extremal2</span><span class="id"> /extremal_class</span><span class="id"> oG</span><span class="id"> pfactorKpdiv</span><span class="id"> //</span><span class="gallina-kwd"> in</span><span class="id"> cG</span>.<br/>
<span class="id">case:</span><span class="id"> andP</span><span class="id"> cG</span><span class="id"> =&gt;</span><span class="id"> [[n_gt1</span><span class="id"> isoG]</span><span class="id"> _</span><span class="id"> |</span><span class="id"> _];</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case:</span> (<span class="id">ltngtP</span><span class="id"> 3</span><span class="id"> n</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> &lt;-;</span><span class="id"> do</span><span class="id"> 2?case:</span><span class="id"> ifP</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> generators_2dihedral</span><span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> maxG]]</span><span class="id"> :=</span><span class="id"> dihedral2_structure</span><span class="id"> n_gt1</span><span class="id"> genG</span><span class="id"> isoG</span>.<br/>
<span class="id">rewrite</span><span class="id"> 2!ltn_neqAle</span><span class="id"> n_gt1</span><span class="id"> !</span>(<span class="id">eq_sym</span><span class="id"> _</span><span class="id"> n</span>).<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [_</span><span class="id"> abelG|</span><span class="id"> _];</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">abelem_abelian</span><span class="id"> abelG</span>)<span class="gallina-kwd"> in</span><span class="id"> not_cGG</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> -&gt;</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> isoY</span><span class="id"> _</span><span class="id"> _];</span><span class="id"> set</span><span class="id"> Y</span><span class="id"> :=</span><span class="id"> &lt;&lt;_&gt;&gt;</span><span class="gallina-kwd"> in</span><span class="id"> isoY</span>.<br/>
<span class="id">have</span><span class="id"> nxYG:</span><span class="id"> Y</span><span class="id"> &lt;|</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">p_maximal_normal</span><span class="id"> pG</span>)<span class="id"> //</span><span class="id"> maxG</span><span class="id"> !inE</span><span class="id"> eqxx</span><span class="id"> orbT</span>.<br/>
<span class="id">have</span><span class="id"> [//</span><span class="id"> |</span><span class="id"> [u</span><span class="id"> v]</span><span class="id"> genY</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> generators_2dihedral</span><span class="id"> _</span><span class="id"> isoY</span>.<br/>
<span class="id">case/dihedral2_structure:</span> (<span class="id">genY</span>)<span class="id"> =&gt;</span><span class="id"> //=</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _</span><span class="id"> abelY</span>.<br/>
<span class="id">have:=</span><span class="id"> dn_G_1</span><span class="id"> _</span><span class="id"> nxYG</span> (<span class="id">abelem_abelian</span><span class="id"> abelY</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">abelem_cyclic</span><span class="id"> abelY</span>)<span class="id">;</span><span class="id"> case:</span><span class="id"> genY</span><span class="id"> =&gt;</span><span class="id"> -&gt;</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> odd_pgroup_rank1_cyclic</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> odd</span><span class="id"> #|G|</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> G</span><span class="id"> =</span> (<span class="id">'r_p</span>(<span class="id">G</span>)<span class="id"> &lt;=</span><span class="id"> 1</span>).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> oddG;</span><span class="id"> rewrite</span><span class="id"> -rank_pgroup</span><span class="id"> //;</span><span class="id"> apply/idP/idP=&gt;</span><span class="id"> [cycG</span><span class="id"> |</span><span class="id"> dimG1]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -abelian_rank1_cyclic</span><span class="id"> ?cyclic_abelian</span>.<br/>
<span class="id">have</span><span class="id"> [X</span><span class="id"> nsXG</span><span class="id"> cXX|//|]</span><span class="id"> :=</span><span class="id"> normal_rank1_structure</span><span class="id"> pG;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">negPf</span> (<span class="id">odd_not_extremal2</span><span class="id"> oddG</span>))<span class="id"> andbF</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> //</span> (<span class="id">leq_trans</span> (<span class="id">rankS</span> (<span class="id">normal_sub</span><span class="id"> nsXG</span>))).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Lemma</span><span class="id"> prime_Ohm1P</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> G</span><span class="id"> :!=:</span><span class="id"> 1</span><span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="id">reflect</span> (<span class="id">#|'Ohm_1</span>(<span class="id">G</span>)<span class="id">|</span><span class="id"> =</span><span class="id"> p</span>)<br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(<span class="id">cyclic</span><span class="id"> G</span><span class="id"> ||</span> (<span class="id">p</span><span class="id"> ==</span><span class="id"> 2</span>)<span class="id"> &amp;&amp;</span> (<span class="id">extremal_class</span><span class="id"> G</span><span class="id"> ==</span><span class="id"> Quaternion</span>)).<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> ntG;</span><span class="id"> have</span><span class="id"> [p_pr</span><span class="id"> p_dvd_G</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span><span class="id"> pG</span><span class="id"> ntG</span>.<br/>
<span class="id">apply:</span> (<span class="id">iffP</span><span class="id"> idP</span>)<span class="id"> =&gt;</span><span class="id"> [|oG1p]</span>.<br/>
&nbsp;&nbsp;<span class="id">case/orP=&gt;</span><span class="id"> [cycG|];</span><span class="id"> first</span><span class="id"> exact:</span><span class="id"> Ohm1_cyclic_pgroup_prime</span>.<br/>
&nbsp;&nbsp;<span class="id">case/andP=&gt;</span><span class="id"> /eqP</span><span class="id"> p2</span><span class="id"> /eqP/quaternion_classP[n</span><span class="id"> n_gt2</span><span class="id"> isoG]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> p2;</span><span class="id"> have</span><span class="id"> [[x</span><span class="id"> y]]</span><span class="id"> :=</span><span class="id"> generators_quaternion</span><span class="id"> n_gt2</span><span class="id"> isoG</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/quaternion_structure=&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [&lt;-</span><span class="id"> oZ</span><span class="id"> _</span><span class="id"> [-&gt;]]</span>.<br/>
<span class="id">have</span><span class="id"> [X</span><span class="id"> nsXG</span><span class="id"> cXX|-&gt;</span><span class="id"> //|]:=</span><span class="id"> normal_rank1_structure</span><span class="id"> pG</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [sXG</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsXG;</span><span class="id"> have</span><span class="id"> pX</span><span class="id"> :=</span><span class="id"> pgroupS</span><span class="id"> sXG</span><span class="id"> pG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> //</span> (<span class="id">rank_pgroup</span><span class="id"> pX</span>)<span class="id"> p_rank_abelian</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -{2}</span>(<span class="id">pfactorK</span><span class="id"> 1</span><span class="id"> p_pr</span>)<span class="id"> -{3}oG1p</span><span class="id"> dvdn_leq_log</span><span class="id"> ?cardG_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> cardSg</span><span class="id"> ?OhmS</span>.<br/>
<span class="id">case/and3P=&gt;</span><span class="id"> /eqP</span><span class="id"> p2;</span><span class="id"> rewrite</span><span class="id"> p2</span> (<span class="id">orbC</span> (<span class="id">cyclic</span><span class="id"> G</span>))<span class="id"> /extremal2</span>.<br/>
<span class="id">case</span><span class="id"> cG:</span> (<span class="id">extremal_class</span><span class="id"> G</span>)<span class="id"> =&gt;</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> notF</span>.<br/>
&nbsp;&nbsp;<span class="id">case/dihedral_classP:</span><span class="id"> cG</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> generators_2dihedral</span><span class="id"> n_gt1</span><span class="id"> isoG</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [oG</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> genG;</span><span class="id"> case/dihedral2_structure:</span><span class="id"> genG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [defG1</span><span class="id"> _]</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/idPn:</span><span class="id"> n_gt1;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">@ltn_exp2l</span><span class="id"> 2</span>)<span class="id"> //</span><span class="id"> -oG</span><span class="id"> -defG1</span><span class="id"> oG1p</span><span class="id"> p2</span>.<br/>
<span class="id">case/semidihedral_classP:</span><span class="id"> cG</span><span class="id"> =&gt;</span><span class="id"> n</span><span class="id"> n_gt3</span><span class="id"> isoG</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genG</span><span class="id"> [oy</span><span class="id"> _]]</span><span class="id"> :=</span><span class="id"> generators_semidihedral</span><span class="id"> n_gt3</span><span class="id"> isoG</span>.<br/>
<span class="id">case/semidihedral_structure:</span><span class="id"> genG</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> _</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [defG1</span><span class="id"> _]</span><span class="id"> _]</span><span class="id"> _</span><span class="id"> [isoG1</span><span class="id"> _</span><span class="id"> _]</span>.<br/>
<span class="id">case/idPn:</span> (<span class="id">n_gt3</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">ltn_predK</span><span class="id"> n_gt3</span>)<span class="id"> ltnS</span><span class="id"> -leqNgt</span><span class="id"> -</span>(<span class="id">@leq_exp2l</span><span class="id"> 2</span>)<span class="id"> //</span>.<br/>
<span class="id">rewrite</span><span class="id"> -card_2dihedral</span><span class="id"> //;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt3</span>).<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">card_isog</span><span class="id"> isoG1</span>)<span class="id"> /=</span><span class="id"> -defG1</span><span class="id"> oG1p</span><span class="id"> p2</span>.<br/>
Qed.</div></details>
<br/>
<span class="vernacular">Theorem</span><span class="id"> symplectic_type_group_structure</span><span class="id"> gT</span><span class="id"> p</span> (<span class="id">G</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT}</span>)<span class="id"> :</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">p</span>.<span class="id">-group</span><span class="id"> G</span><span class="id"> -&gt;</span> (<span class="gallina-kwd">forall</span><span class="id"> X</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><span class="id"> X</span><span class="id"> \char</span><span class="id"> G</span><span class="id"> -&gt;</span><span class="id"> abelian</span><span class="id"> X</span><span class="id"> -&gt;</span><span class="id"> cyclic</span><span class="id"> X</span>)<span class="id"> -&gt;</span><br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists2</span><span class="id"> E</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><span class="id"> E</span><span class="id"> :=:</span><span class="id"> 1</span><span class="id"> \/</span><span class="id"> extraspecial</span><span class="id"> E</span><br/>
&nbsp;&nbsp;<span class="id">&amp;</span><span class="gallina-kwd"> exists</span><span class="id"> R</span><span class="id"> :</span><span class="id"> {group</span><span class="id"> gT},</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">[/\</span><span class="id"> cyclic</span><span class="id"> R</span><span class="id"> \/</span><span class="id"> [/\</span><span class="id"> p</span><span class="id"> =</span><span class="id"> 2,</span><span class="id"> extremal2</span><span class="id"> R</span><span class="id"> &amp;</span><span class="id"> #|R|</span><span class="id"> &gt;=</span><span class="id"> 16],</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">E</span><span class="id"> \*</span><span class="id"> R</span><span class="id"> =</span><span class="id"> G</span><br/>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">&amp;</span><span class="id"> E</span><span class="id"> :&amp;:</span><span class="id"> R</span><span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">E</span>)<span class="id">]</span>.<br/>
<details>
<summary class="toggleproof">Proof.</summary>
<div class="proofscript">
<span class="id">move=&gt;</span><span class="id"> pG</span><span class="id"> sympG;</span><span class="id"> have</span><span class="id"> [H</span><span class="id"> [charH]]</span><span class="id"> :=</span><span class="id"> Thompson_critical</span><span class="id"> pG</span>.<br/>
<span class="id">have</span><span class="id"> sHG</span><span class="id"> :=</span><span class="id"> char_sub</span><span class="id"> charH;</span><span class="id"> have</span><span class="id"> pH</span><span class="id"> :=</span><span class="id"> pgroupS</span><span class="id"> sHG</span><span class="id"> pG</span>.<br/>
<span class="id">set</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> 'Z</span>(<span class="id">H</span>)<span class="id"> =&gt;</span><span class="id"> sPhiH_U</span><span class="id"> sHG_U</span><span class="id"> defU;</span><span class="id"> set</span><span class="id"> Z</span><span class="id"> :=</span><span class="id"> 'Ohm_1</span>(<span class="id">U</span>).<br/>
<span class="id">have</span><span class="id"> sZU:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> Ohm_sub</span>.<br/>
<span class="id">have</span><span class="id"> charU:</span><span class="id"> U</span><span class="id"> \char</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> gFchar_trans</span><span class="id"> _</span><span class="id"> charH</span>.<br/>
<span class="id">have</span><span class="id"> cUU:</span><span class="id"> abelian</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> center_abelian</span><span class="id"> H</span>.<br/>
<span class="id">have</span><span class="id"> cycU:</span><span class="id"> cyclic</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> sympG</span>.<br/>
<span class="id">have</span><span class="id"> pU:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> U</span><span class="id"> :=</span><span class="id"> pgroupS</span> (<span class="id">char_sub</span><span class="id"> charU</span>)<span class="id"> pG</span>.<br/>
<span class="id">have</span><span class="id"> cHU:</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">H</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subsetIr</span>.<br/>
<span class="id">have</span><span class="id"> cHsHs:</span><span class="id"> abelian</span> (<span class="id">H</span><span class="id"> /</span><span class="id"> Z</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> sub_der1_abelian</span><span class="id"> //=</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pU</span>)<span class="id"> genS</span><span class="id"> //=</span><span class="id"> -/U</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imset2P[h</span><span class="id"> k</span><span class="id"> Hh</span><span class="id"> Hk</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Uhk:</span><span class="id"> [~</span><span class="id"> h,</span><span class="id"> k]</span><span class="id"> \in</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span><span class="id"> sHG_U</span>)<span class="id"> ?mem_commg</span><span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sHG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> Uhk</span><span class="id"> inE</span><span class="id"> -commXg;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> red;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">centsP</span><span class="id"> cHU</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/commgP;</span><span class="id"> red;</span><span class="id"> rewrite</span> (<span class="id">centsP</span><span class="id"> cHU</span>)<span class="id"> //</span> (<span class="id">subsetP</span><span class="id"> sPhiH_U</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pH</span>)<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> inE</span><span class="id"> orbC</span> (<span class="id">Mho_p_elt</span><span class="id"> 1</span>)<span class="id"> ?</span>(<span class="id">mem_p_elt</span><span class="id"> pH</span>).<br/>
<span class="id">have</span><span class="id"> nsZH:</span><span class="id"> Z</span><span class="id"> &lt;|</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sub_center_normal</span>.<br/>
<span class="id">have</span><span class="id"> [K</span><span class="id"> /=]</span><span class="id"> :=</span><span class="id"> inv_quotientS</span><span class="id"> nsZH</span> (<span class="id">Ohm_sub</span><span class="id"> 1</span> (<span class="id">H</span><span class="id"> /</span><span class="id"> Z</span>))<span class="id">;</span><span class="id"> fold</span><span class="id"> Z</span><span class="id"> =&gt;</span><span class="id"> defKs</span><span class="id"> sZK</span><span class="id"> sKH</span>.<br/>
<span class="id">have</span><span class="id"> nsZK:</span><span class="id"> Z</span><span class="id"> &lt;|</span><span class="id"> K</span><span class="id"> :=</span><span class="id"> normalS</span><span class="id"> sZK</span><span class="id"> sKH</span><span class="id"> nsZH;</span><span class="id"> have</span><span class="id"> [_</span><span class="id"> nZK]</span><span class="id"> :=</span><span class="id"> andP</span><span class="id"> nsZK</span>.<br/>
<span class="id">have</span><span class="id"> abelKs:</span><span class="id"> p</span>.<span class="id">-abelem</span> (<span class="id">K</span><span class="id"> /</span><span class="id"> Z</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defKs</span><span class="id"> Ohm1_abelem</span><span class="id"> ?quotient_pgroup</span>.<br/>
<span class="id">have</span><span class="id"> charK:</span><span class="id"> K</span><span class="id"> \char</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> charZ:</span><span class="id"> Z</span><span class="id"> \char</span><span class="id"> H</span><span class="id"> :=</span><span class="id"> gFchar_trans</span><span class="id"> _</span> (<span class="id">center_char</span><span class="id"> H</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">char_trans</span><span class="id"> _</span><span class="id"> charH</span>)<span class="id"> //</span> (<span class="id">char_from_quotient</span><span class="id"> nsZK</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defKs</span><span class="id"> Ohm_char</span>.<br/>
<span class="id">have</span><span class="id"> cycZK:</span><span class="id"> cyclic</span><span class="id"> 'Z</span>(<span class="id">K</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> sympG</span><span class="id"> ?center_abelian</span><span class="id"> ?gFchar_trans</span>.<br/>
<span class="id">have</span><span class="id"> [cKK</span><span class="id"> |</span><span class="id"> not_cKK]</span><span class="id"> :=</span><span class="id"> orP</span> (<span class="id">orbN</span> (<span class="id">abelian</span><span class="id"> K</span>)).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defH:</span><span class="id"> U</span><span class="id"> =</span><span class="id"> H</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> center_idP;</span><span class="id"> apply:</span><span class="id"> cyclic_factor_abelian</span> (<span class="id">Ohm_sub</span><span class="id"> 1</span><span class="id"> _</span>)<span class="id"> _</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -/Z</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> cKsKs:</span><span class="id"> abelian</span> (<span class="id">K</span><span class="id"> /</span><span class="id"> Z</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defKs</span> (<span class="id">abelianS</span> (<span class="id">Ohm_sub</span><span class="id"> 1</span><span class="id"> _</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> cycK:</span><span class="id"> cyclic</span><span class="id"> K</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">center_idP</span><span class="id"> cKK</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -rank_Ohm1</span><span class="id"> defKs</span><span class="id"> -abelian_rank1_cyclic</span><span class="id"> ?quotient_cyclic</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> scH:</span><span class="id"> H</span><span class="id"> \in</span><span class="id"> 'SCN</span>(<span class="id">G</span>)<span class="gallina-kwd"> by</span><span class="id"> apply/SCN_P;</span><span class="id"> rewrite</span><span class="id"> defU</span><span class="id"> char_normal</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [cGG</span><span class="id"> |</span><span class="id"> not_cGG]</span><span class="id"> :=</span><span class="id"> orP</span> (<span class="id">orbN</span> (<span class="id">abelian</span><span class="id"> G</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> 1%G;</span><span class="id"> [by</span><span class="id"> left</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> G;</span><span class="id"> rewrite</span><span class="id"> cprod1g</span> (<span class="id">setIidPl</span><span class="id"> _</span>)<span class="id"> ?sub1G</span><span class="id"> //]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> ?center1</span><span class="id"> //</span><span class="id"> sympG</span><span class="id"> ?char_refl</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cycH:</span><span class="id"> cyclic</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -{}defH</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [[p2</span><span class="id"> _</span><span class="id"> cG2]|[M</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> _]]]</span><span class="id"> :=</span><span class="id"> cyclic_SCN</span><span class="id"> pG</span><span class="id"> scH</span><span class="id"> not_cGG</span><span class="id"> cycH;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">do</span><span class="id"> 2![case/setIdP]</span><span class="id"> =&gt;</span><span class="id"> _</span><span class="id"> abelE</span><span class="id"> dimE_2</span><span class="id"> charE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> sympG</span><span class="id"> _</span><span class="id"> charE</span> (<span class="id">abelem_abelian</span><span class="id"> abelE</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">abelem_cyclic</span><span class="id"> abelE</span>) (<span class="id">eqP</span><span class="id"> dimE_2</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n</span><span class="id"> oG]</span><span class="id"> :=</span><span class="id"> p_natP</span><span class="id"> pG;</span><span class="id"> rewrite</span><span class="id"> p2</span><span class="gallina-kwd"> in</span><span class="id"> oG</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> [n_gt3</span><span class="id"> |</span><span class="id"> n_le3]</span><span class="id"> :=</span><span class="id"> ltnP</span><span class="id"> 3</span><span class="id"> n</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> 1%G;</span><span class="id"> [by</span><span class="id"> left</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> G;</span><span class="id"> rewrite</span><span class="id"> cprod1g</span> (<span class="id">setIidPl</span><span class="id"> _</span>)<span class="id"> ?sub1G</span><span class="id"> //]</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> first</span><span class="id"> right;</span><span class="id"> rewrite</span><span class="id"> ?center1</span><span class="id"> //</span><span class="id"> oG</span> (<span class="id">@leq_exp2l</span><span class="id"> 2</span><span class="id"> 4</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> esG:</span><span class="id"> extraspecial</span><span class="id"> G</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply:</span> (<span class="id">p3group_extraspecial</span><span class="id"> pG</span>)<span class="id">;</span><span class="id"> rewrite</span><span class="id"> //</span><span class="id"> p2</span><span class="id"> oG</span><span class="id"> pfactorK</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> G;</span><span class="id"> [by</span><span class="id"> right</span><span class="id"> |</span><span class="gallina-kwd"> exists</span> (<span class="id">'Z</span>(<span class="id">G</span>))<span class="id">%G;</span><span class="id"> rewrite</span><span class="id"> cprod_center_id</span><span class="id"> setIA</span><span class="id"> setIid]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> prime_cyclic;</span><span class="id"> case:</span><span class="id"> esG</span>.<br/>
<span class="id">have</span><span class="id"> ntK:</span><span class="id"> K</span><span class="id"> :!=:</span><span class="id"> 1</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> not_cKK</span><span class="id"> =&gt;</span><span class="id"> /eqP-&gt;;</span><span class="id"> apply:</span><span class="id"> abelian1</span>.<br/>
<span class="id">have</span><span class="id"> [p_pr</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span> (<span class="id">pgroupS</span><span class="id"> sKH</span><span class="id"> pH</span>)<span class="id"> ntK</span>.<br/>
<span class="id">have</span><span class="id"> p_gt1</span><span class="id"> :=</span><span class="id"> prime_gt1</span><span class="id"> p_pr;</span><span class="id"> have</span><span class="id"> p_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> p_gt1</span>.<br/>
<span class="id">have</span><span class="id"> oZ:</span><span class="id"> #|Z|</span><span class="id"> =</span><span class="id"> p</span>.<br/>
&nbsp;&nbsp;<span class="id">apply:</span><span class="id"> Ohm1_cyclic_pgroup_prime</span><span class="id"> =&gt;</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> ntK;</span><span class="id"> move/eqP</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> move/</span>(<span class="id">trivg_center_pgroup</span><span class="id"> pH</span>)<span class="id">=&gt;</span><span class="id"> GH;</span><span class="id"> rewrite</span><span class="id"> -subG1</span><span class="id"> -GH</span>.<br/>
<span class="id">have</span><span class="id"> sZ_ZK:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> 'Z</span>(<span class="id">K</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> sZK</span><span class="id"> gFsub_trans</span><span class="id"> //</span><span class="id"> subIset</span><span class="id"> ?centS</span><span class="id"> ?orbT</span>.<br/>
<span class="id">have</span><span class="id"> sZsKs:</span><span class="id"> 'Z</span>(<span class="id">K</span>)<span class="id"> /</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> K</span><span class="id"> /</span><span class="id"> Z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> quotientS</span><span class="id"> ?center_sub</span>.<br/>
<span class="id">have</span><span class="id"> [Es</span><span class="id"> /=</span><span class="id"> splitKs]</span><span class="id"> :=</span><span class="id"> abelem_split_dprod</span><span class="id"> abelKs</span><span class="id"> sZsKs</span>.<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> /=</span><span class="id"> defEsZs</span><span class="id"> cEsZs</span><span class="id"> tiEsZs]</span><span class="id"> :=</span><span class="id"> dprodP</span><span class="id"> splitKs</span>.<br/>
<span class="id">have</span><span class="id"> sEsKs:</span><span class="id"> Es</span><span class="id"> \subset</span><span class="id"> K</span><span class="id"> /</span><span class="id"> Z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defEsZs</span><span class="id"> mulG_subr</span>.<br/>
<span class="id">have</span><span class="id"> [E</span><span class="id"> defEs</span><span class="id"> sZE</span><span class="id"> sEK]</span><span class="id"> :=</span><span class="id"> inv_quotientS</span><span class="id"> nsZK</span><span class="id"> sEsKs;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -/Z</span><span class="gallina-kwd"> in</span><span class="id"> defEs</span><span class="id"> sZE</span>.<br/>
<span class="id">have</span><span class="id"> [nZE</span><span class="id"> nZ_ZK]</span><span class="id"> :=</span> (<span class="id">subset_trans</span><span class="id"> sEK</span><span class="id"> nZK,</span><span class="id"> subset_trans</span> (<span class="id">center_sub</span><span class="id"> K</span>)<span class="id"> nZK</span>).<br/>
<span class="id">have</span><span class="id"> defK:</span><span class="id"> 'Z</span>(<span class="id">K</span>)<span class="id"> *</span><span class="id"> E</span><span class="id"> =</span><span class="id"> K</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">mulSGid</span><span class="id"> sZ_ZK</span>)<span class="id"> -mulgA</span><span class="id"> -quotientK</span><span class="id"> ?mul_subG</span><span class="id"> ?quotientMl</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defEs</span><span class="id"> defEsZs</span><span class="id"> quotientGK</span>.<br/>
<span class="id">have</span><span class="id"> defZE:</span><span class="id"> 'Z</span>(<span class="id">E</span>)<span class="id"> =</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cEZK:</span><span class="id"> 'Z</span>(<span class="id">K</span>)<span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">E</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> subIset</span><span class="id"> //</span><span class="id"> orbC</span><span class="id"> centS</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cE_Z:</span><span class="id"> E</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">Z</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> centsC</span> (<span class="id">subset_trans</span><span class="id"> sZ_ZK</span>).<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> andbC</span><span class="id"> subsetI</span><span class="id"> sZE</span><span class="id"> centsC</span><span class="id"> cE_Z</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -quotient_sub1</span><span class="id"> ?subIset</span><span class="id"> ?nZE</span><span class="id"> //=</span><span class="id"> -/Z</span><span class="id"> -tiEsZs</span><span class="id"> subsetI</span><span class="id"> defEs</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> !quotientS</span><span class="id"> ?center_sub</span><span class="id"> //=</span><span class="id"> subsetI</span><span class="id"> subIset</span><span class="id"> ?sEK</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defK</span><span class="id"> centM</span><span class="id"> setSI</span><span class="id"> //</span><span class="id"> centsC</span>.<br/>
<span class="id">have</span><span class="id"> sEH</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sEK</span><span class="id"> sKH;</span><span class="id"> have</span><span class="id"> pE</span><span class="id"> :=</span><span class="id"> pgroupS</span><span class="id"> sEH</span><span class="id"> pH</span>.<br/>
<span class="id">have</span><span class="id"> esE:</span><span class="id"> extraspecial</span><span class="id"> E</span>.<br/>
&nbsp;&nbsp;<span class="id">split;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> defZE</span><span class="id"> oZ</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sPhiZ:</span><span class="id"> 'Phi</span>(<span class="id">E</span>)<span class="id"> \subset</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -quotient_sub1</span><span class="id"> ?gFsub_trans</span><span class="id"> ?</span>(<span class="id">quotient_Phi</span><span class="id"> pE</span>)<span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> subG1</span> (<span class="id">trivg_Phi</span> (<span class="id">quotient_pgroup</span><span class="id"> _</span><span class="id"> pE</span>))<span class="id"> /=</span><span class="id"> -defEs</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">abelemS</span><span class="id"> sEsKs</span>)<span class="id"> //=</span><span class="id"> -defKs</span><span class="id"> Ohm1_abelem</span><span class="id"> ?quotient_pgroup</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sE'Phi:</span><span class="id"> E^`</span>(<span class="id">1</span>)<span class="id"> \subset</span><span class="id"> 'Phi</span>(<span class="id">E</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">Phi_joing</span><span class="id"> pE</span>)<span class="id"> joing_subl</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> ntE':</span><span class="id"> E^`</span>(<span class="id">1</span>)<span class="id"> !=</span><span class="id"> 1</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">sameP</span><span class="id"> eqP</span><span class="id"> commG1P</span>)<span class="id"> -abelianE;</span><span class="id"> apply:</span><span class="id"> contra</span><span class="id"> not_cKK</span><span class="id"> =&gt;</span><span class="id"> cEE</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defK</span><span class="id"> mulGSid</span><span class="id"> ?center_abelian</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">center_idP</span><span class="id"> cEE</span>)<span class="id"> defZE</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defE':</span><span class="id"> E^`</span>(<span class="id">1</span>)<span class="id"> =</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span> (<span class="id">subset_trans</span><span class="id"> sE'Phi</span>)<span class="id"> //=</span><span class="id"> oZ</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> [_</span><span class="id"> _</span><span class="id"> [n</span><span class="id"> -&gt;]]</span><span class="id"> :=</span><span class="id"> pgroup_pdiv</span> (<span class="id">pgroupS</span> (<span class="id">der_sub</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> pE</span>)<span class="id"> ntE'</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">leq_exp2l</span><span class="id"> 1</span>)<span class="id"> ?prime_gt1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split;</span><span class="id"> rewrite</span><span class="id"> defZE</span><span class="id"> //;</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> sPhiZ</span><span class="id"> -defE'</span>.<br/>
<span class="id">have</span><span class="id"> [spE</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> esE;</span><span class="id"> have</span><span class="id"> [defPhiE</span><span class="id"> defE']</span><span class="id"> :=</span><span class="id"> spE</span>.<br/>
<span class="id">have{defE'}</span><span class="id"> sEG_E':</span><span class="id"> [~:</span><span class="id"> E,</span><span class="id"> G]</span><span class="id"> \subset</span><span class="id"> E^`</span>(<span class="id">1</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defE'</span><span class="id"> defZE</span><span class="id"> /Z</span> (<span class="id">OhmE</span><span class="id"> _</span><span class="id"> pU</span>)<span class="id"> commGC</span><span class="id"> genS</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /imset2P[g</span><span class="id"> e</span><span class="id"> Gg</span><span class="id"> Ee</span><span class="id"> -&gt;]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> He:</span><span class="id"> e</span><span class="id"> \in</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span><span class="id"> sKH</span>)<span class="id"> ?</span>(<span class="id">subsetP</span><span class="id"> sEK</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> Uge:</span><span class="id"> [~</span><span class="id"> g,</span><span class="id"> e]</span><span class="id"> \in</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">subsetP</span><span class="id"> sHG_U</span>)<span class="id"> ?mem_commg</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> Uge</span><span class="id"> inE</span><span class="id"> -commgX;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> red;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">centsP</span><span class="id"> cHU</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sZ_ZG:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> 'Z</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have</span><span class="id"> charZ:</span><span class="id"> Z</span><span class="id"> \char</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> gFchar_trans</span><span class="id"> _</span><span class="id"> charU</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">have/implyP:=</span><span class="id"> meet_center_nil</span> (<span class="id">pgroup_nil</span><span class="id"> pG</span>) (<span class="id">char_normal</span><span class="id"> charZ</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cardG_gt1</span><span class="id"> oZ</span><span class="id"> prime_gt1</span><span class="id"> //=;</span><span class="id"> apply:</span><span class="id"> contraR</span><span class="id"> =&gt;</span><span class="id"> not_sZ_ZG</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> prime_TIg</span><span class="id"> ?oZ</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> e</span><span class="id"> ^+</span><span class="id"> p</span><span class="id"> \in</span><span class="id"> 'Z</span>(<span class="id">G</span>).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">subsetP</span><span class="id"> sZ_ZG</span>)<span class="id"> //</span><span class="id"> -defZE</span><span class="id"> -defPhiE</span> (<span class="id">Phi_joing</span><span class="id"> pE</span>)<span class="id"> mem_gen</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> inE</span><span class="id"> orbC</span> (<span class="id">Mho_p_elt</span><span class="id"> 1</span>)<span class="id"> ?</span>(<span class="id">mem_p_elt</span><span class="id"> pE</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/setIP=&gt;</span><span class="id"> _</span><span class="id"> /centP</span><span class="id"> cGep;</span><span class="id"> apply/commgP;</span><span class="id"> red;</span><span class="id"> rewrite</span><span class="id"> cGep</span>.<br/>
<span class="id">have</span><span class="id"> sEG:</span><span class="id"> E</span><span class="id"> \subset</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> subset_trans</span><span class="id"> sEK</span> (<span class="id">char_sub</span><span class="id"> charK</span>).<br/>
<span class="id">set</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> 'C_G</span>(<span class="id">E</span>).<br/>
<span class="id">have{sEG_E'}</span><span class="id"> defG:</span><span class="id"> E</span><span class="id"> \*</span><span class="id"> R</span><span class="id"> =</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> apply:</span> (<span class="id">critical_extraspecial</span><span class="id"> pG</span>).<br/>
<span class="id">have</span><span class="id"> [_</span><span class="id"> defER</span><span class="id"> cRE]</span><span class="id"> :=</span><span class="id"> cprodP</span><span class="id"> defG</span>.<br/>
<span class="id">have</span><span class="id"> defH:</span><span class="id"> E</span><span class="id"> \*</span><span class="id"> 'C_H</span>(<span class="id">E</span>)<span class="id"> =</span><span class="id"> H</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">setIidPr</span><span class="id"> sHG</span>)<span class="id"> setIAC</span> (<span class="id">cprod_modl</span><span class="id"> defG</span>).<br/>
<span class="id">have{defH}</span><span class="id"> [_</span><span class="id"> defH</span><span class="id"> cRH_E]</span><span class="id"> :=</span><span class="id"> cprodP</span><span class="id"> defH</span>.<br/>
<span class="id">have</span><span class="id"> cRH_RH:</span><span class="id"> abelian</span><span class="id"> 'C_H</span>(<span class="id">E</span>).<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sZ_ZRH:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> 'Z</span>(<span class="id">'C_H</span>(<span class="id">E</span>)).<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> subsetI</span><span class="id"> -{1}defZE</span><span class="id"> setSI</span><span class="id"> //=</span> (<span class="id">subset_trans</span><span class="id"> sZU</span>)<span class="id"> //</span><span class="id"> centsC</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subIset</span><span class="id"> //</span><span class="id"> centsC</span><span class="id"> cHU</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">cyclic_factor_abelian</span><span class="id"> sZ_ZRH</span>)<span class="id"> //=</span><span class="id"> -/Z</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> defHs:</span><span class="id"> Es</span><span class="id"> \x</span> (<span class="id">'C_H</span>(<span class="id">E</span>)<span class="id"> /</span><span class="id"> Z</span>)<span class="id"> =</span><span class="id"> H</span><span class="id"> /</span><span class="id"> Z</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defEs</span><span class="id"> dprodE</span><span class="id"> ?quotient_cents</span><span class="id"> //</span><span class="id"> -?quotientMl</span><span class="id"> ?defH</span><span class="id"> -?quotientGI</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span><span class="id"> sEH</span>)<span class="id"> ['C_E</span>(<span class="id">E</span>)<span class="id">]defZE</span><span class="id"> trivg_quotient</span>.<br/>
&nbsp;&nbsp;<span class="id">have:=</span><span class="id"> Ohm_dprod</span><span class="id"> 1</span><span class="id"> defHs;</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> defKs</span> (<span class="id">Ohm1_id</span> (<span class="id">abelemS</span><span class="id"> sEsKs</span><span class="id"> abelKs</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dprodC;</span><span class="id"> case/dprodP=&gt;</span><span class="id"> _</span><span class="id"> defEsRHs1</span><span class="id"> cRHs1Es</span><span class="id"> tiRHs1Es</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> sRHsHs:</span><span class="id"> 'C_H</span>(<span class="id">E</span>)<span class="id"> /</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> H</span><span class="id"> /</span><span class="id"> Z</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> quotientS</span><span class="id"> ?subsetIl</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cRHsRHs:</span><span class="id"> abelian</span> (<span class="id">'C_H</span>(<span class="id">E</span>)<span class="id"> /</span><span class="id"> Z</span>)<span class="gallina-kwd"> by</span><span class="id"> apply:</span><span class="id"> abelianS</span><span class="id"> cHsHs</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> pHs:</span><span class="id"> p</span>.<span class="id">-group</span> (<span class="id">H</span><span class="id"> /</span><span class="id"> Z</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> quotient_pgroup</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> //</span> (<span class="id">rank_pgroup</span> (<span class="id">pgroupS</span><span class="id"> sRHsHs</span><span class="id"> pHs</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> p_rank_abelian</span><span class="id"> //</span><span class="id"> -</span>(<span class="id">leq_add2r</span> (<span class="id">logn</span><span class="id"> p</span><span class="id"> #|Es|</span>))<span class="id"> -lognM</span><span class="id"> ?cardG_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -TI_cardMg</span><span class="id"> //</span><span class="id"> defEsRHs1</span><span class="id"> /=</span><span class="id"> -defEsZs</span><span class="id"> TI_cardMg</span><span class="id"> ?lognM</span><span class="id"> ?cardG_gt0</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> leq_add2r</span><span class="id"> -abelem_cyclic</span><span class="id"> ?</span>(<span class="id">abelemS</span><span class="id"> sZsKs</span>)<span class="id"> //</span><span class="id"> quotient_cyclic</span>.<br/>
<span class="id">have{cRH_RH}</span><span class="id"> defRH:</span><span class="id"> 'C_H</span>(<span class="id">E</span>)<span class="id"> =</span><span class="id"> U</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEsubset</span><span class="id"> andbC</span><span class="id"> setIS</span><span class="id"> ?centS</span><span class="id"> //</span><span class="id"> subsetI</span><span class="id"> subsetIl</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -{2}defH</span><span class="id"> centM</span><span class="id"> subsetI</span><span class="id"> subsetIr</span>.<br/>
<span class="id">have</span><span class="id"> scUR:</span><span class="id"> 'C_R</span>(<span class="id">U</span>)<span class="id"> =</span><span class="id"> U</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -setIA</span><span class="id"> -{1}defRH</span><span class="id"> -centM</span><span class="id"> defH</span>.<br/>
<span class="id">have</span><span class="id"> sUR:</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> R</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defRH</span><span class="id"> setSI</span>.<br/>
<span class="id">have</span><span class="id"> tiER:</span><span class="id"> E</span><span class="id"> :&amp;:</span><span class="id"> R</span><span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">E</span>)<span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> setIA</span> (<span class="id">setIidPl</span> (<span class="id">subset_trans</span><span class="id"> sEH</span><span class="id"> sHG</span>)).<br/>
<span class="id">have</span><span class="id"> [cRR</span><span class="id"> |</span><span class="id"> not_cRR]</span><span class="id"> :=</span><span class="id"> boolP</span> (<span class="id">abelian</span><span class="id"> R</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> E;</span><span class="id"> [by</span><span class="id"> right</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> R];</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> left]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /=</span><span class="id"> -</span>(<span class="id">setIidPl</span> (<span class="id">sub_abelian_cent</span><span class="id"> cRR</span><span class="id"> sUR</span>))<span class="id"> scUR</span>.<br/>
<span class="id">have{}</span><span class="id"> scUR:</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> U]</span><span class="id"> \in</span><span class="id"> 'SCN</span>(<span class="id">R</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/SCN_P;</span><span class="id"> rewrite</span> (<span class="id">normalS</span><span class="id"> sUR</span> (<span class="id">subsetIl</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> //</span><span class="id"> char_normal</span>.<br/>
<span class="id">have</span><span class="id"> pR:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> pgroupS</span> (<span class="id">subsetIl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> pG</span>.<br/>
<span class="id">have</span><span class="id"> [R_le_3</span><span class="id"> |</span><span class="id"> R_gt_3]</span><span class="id"> :=</span><span class="id"> leqP</span> (<span class="id">logn</span><span class="id"> p</span><span class="id"> #|R|</span>)<span class="id"> 3</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> esR:</span><span class="id"> extraspecial</span><span class="id"> R</span><span class="id"> :=</span><span class="id"> p3group_extraspecial</span><span class="id"> pR</span><span class="id"> not_cRR</span><span class="id"> R_le_3</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> esG:</span><span class="id"> extraspecial</span><span class="id"> G</span><span class="id"> :=</span><span class="id"> cprod_extraspecial</span><span class="id"> pG</span><span class="id"> defG</span><span class="id"> tiER</span><span class="id"> esE</span><span class="id"> esR</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> G;</span><span class="id"> [by</span><span class="id"> right</span><span class="id"> |</span><span class="gallina-kwd"> exists</span> (<span class="id">'Z</span>(<span class="id">G</span>))<span class="id">%G;</span><span class="id"> rewrite</span><span class="id"> cprod_center_id</span><span class="id"> setIA</span><span class="id"> setIid]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> left;</span><span class="id"> rewrite</span><span class="id"> prime_cyclic;</span><span class="id"> case:</span><span class="id"> esG</span>.<br/>
<span class="id">have</span><span class="id"> [[p2</span><span class="id"> _</span><span class="id"> ext2R]</span><span class="id"> |</span><span class="id"> [M</span><span class="id"> []]]</span><span class="id"> :=</span><span class="id"> cyclic_SCN</span><span class="id"> pR</span><span class="id"> scUR</span><span class="id"> not_cRR</span><span class="id"> cycU</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">exists</span><span class="id"> E;</span><span class="id"> [by</span><span class="id"> right</span><span class="id"> |</span><span class="gallina-kwd"> exists</span><span class="id"> [group</span><span class="id"> of</span><span class="id"> R];</span><span class="id"> split=&gt;</span><span class="id"> //;</span><span class="id"> right]</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> dvdn_leq</span><span class="id"> ?</span>(<span class="id">@pfactor_dvdn</span><span class="id"> 2</span><span class="id"> 4</span>)<span class="id"> ?cardG_gt0</span><span class="id"> //</span><span class="id"> -{2}p2</span>.<br/>
<span class="id">rewrite</span><span class="id"> /=</span><span class="id"> -/R</span><span class="id"> =&gt;</span><span class="id"> defM</span><span class="id"> iUM</span><span class="id"> modM</span><span class="id"> _</span><span class="id"> _;</span><span class="id"> pose</span><span class="id"> N</span><span class="id"> :=</span><span class="id"> 'C_G</span>(<span class="id">'Mho^1</span>(<span class="id">U</span>)).<br/>
<span class="id">have</span><span class="id"> charZN2:</span><span class="id"> 'Z</span>(<span class="id">'Ohm_2</span>(<span class="id">N</span>))<span class="id"> \char</span><span class="id"> G</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> !</span>(<span class="id">gFchar_trans,</span><span class="id"> subcent_char</span>).<br/>
<span class="id">have:=</span><span class="id"> sympG</span><span class="id"> _</span><span class="id"> charZN2</span> (<span class="id">center_abelian</span><span class="id"> _</span>).<br/>
<span class="id">rewrite</span><span class="id"> abelian_rank1_cyclic</span><span class="id"> ?center_abelian</span><span class="id"> //</span><span class="id"> leqNgt;</span><span class="id"> case/negP</span>.<br/>
<span class="id">have</span><span class="id"> defN:</span><span class="id"> E</span><span class="id"> \*</span><span class="id"> M</span><span class="id"> =</span><span class="id"> N</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> defM</span> (<span class="id">cprod_modl</span><span class="id"> defG</span>)<span class="id"> //</span><span class="id"> centsC</span><span class="id"> gFsub_trans</span><span class="id"> //=</span><span class="id"> -/U</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -defRH</span><span class="id"> subsetIr</span>.<br/>
<span class="id">case/modular_group_classP:</span><span class="id"> modM</span><span class="id"> =&gt;</span><span class="id"> q</span><span class="id"> q_pr</span><span class="id"> [n</span><span class="id"> n_gt23</span><span class="id"> isoM]</span>.<br/>
<span class="id">have{n_gt23}</span><span class="id"> n_gt2</span><span class="id"> :=</span><span class="id"> leq_trans</span> (<span class="id">leq_addl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> n_gt23</span>.<br/>
<span class="id">have</span><span class="id"> n_gt1</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt2;</span><span class="id"> have</span><span class="id"> n_gt0</span><span class="id"> :=</span><span class="id"> ltnW</span><span class="id"> n_gt1</span>.<br/>
<span class="id">have</span><span class="id"> [[x</span><span class="id"> y]</span><span class="id"> genM</span><span class="id"> modM]</span><span class="id"> :=</span><span class="id"> generators_modular_group</span><span class="id"> q_pr</span><span class="id"> n_gt2</span><span class="id"> isoM</span>.<br/>
<span class="id">have{q_pr}</span><span class="id"> defq:</span><span class="id"> q</span><span class="id"> =</span><span class="id"> p;</span><span class="id"> last</span><span class="id"> rewrite</span><span class="id"> {q}defq</span><span class="gallina-kwd"> in</span><span class="id"> genM</span><span class="id"> modM</span><span class="id"> isoM</span>.<br/>
&nbsp;&nbsp;<span class="id">have:</span><span class="id"> p</span><span class="id"> %|</span><span class="id"> #|M|</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -iUM</span><span class="id"> dvdn_indexg</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> have</span><span class="id"> [-&gt;</span><span class="id"> _</span><span class="id"> _</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> genM;</span><span class="id"> rewrite</span><span class="id"> Euclid_dvdX</span><span class="id"> //</span><span class="id"> dvdn_prime2</span><span class="id"> //;</span><span class="id"> case:</span><span class="id"> eqP</span>.<br/>
<span class="id">have</span><span class="id"> [oM</span><span class="id"> Mx</span><span class="id"> ox</span><span class="id"> X'y]</span><span class="id"> :=</span><span class="id"> genM;</span><span class="id"> have</span><span class="id"> [My</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> setDP</span><span class="id"> X'y;</span><span class="id"> have</span><span class="id"> [oy</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> modM</span>.<br/>
<span class="id">have</span><span class="id"> [sUM</span><span class="id"> sMR]:</span><span class="id"> U</span><span class="id"> \subset</span><span class="id"> M</span><span class="id"> /\</span><span class="id"> M</span><span class="id"> \subset</span><span class="id"> R</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> defM</span><span class="id"> subsetI</span><span class="id"> sUR</span><span class="id"> subsetIl</span><span class="id"> centsC</span><span class="id"> gFsub_trans</span>.<br/>
<span class="id">have</span><span class="id"> oU1:</span><span class="id"> #|'Mho^1</span>(<span class="id">U</span>)<span class="id">|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-2</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> oU:</span><span class="id"> #|U|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> n</span>.<span class="id">-1</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">divg_indexS</span><span class="id"> sUM</span>)<span class="id"> iUM</span><span class="id"> oM</span><span class="id"> -subn1</span><span class="id"> expnB</span>.<br/>
&nbsp;&nbsp;<span class="id">case/cyclicP:</span><span class="id"> cycU</span><span class="id"> pU</span><span class="id"> oU</span><span class="id"> =&gt;</span><span class="id"> u</span><span class="id"> -&gt;</span><span class="id"> p_u</span><span class="id"> ou</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">Mho_p_cycle</span><span class="id"> 1</span><span class="id"> p_u</span>)<span class="id"> -orderE</span> (<span class="id">orderXexp</span><span class="id"> 1</span><span class="id"> ou</span>)<span class="id"> subn1</span>.<br/>
<span class="id">have</span><span class="id"> sZU1:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">cardSg_cyclic</span><span class="id"> cycU</span>)<span class="id"> ?gFsub</span><span class="id"> //</span><span class="id"> oZ</span><span class="id"> oU1</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>)<span class="id"> expnS</span><span class="id"> dvdn_mulr</span>.<br/>
<span class="id">case/modular_group_structure:</span><span class="id"> genM</span><span class="id"> =&gt;</span><span class="id"> //</span><span class="id"> _</span><span class="id"> [defZM</span><span class="id"> _</span><span class="id"> oZM]</span><span class="id"> _</span><span class="id"> _</span>.<br/>
<span class="id">have:=</span><span class="id"> n_gt2;</span><span class="id"> rewrite</span><span class="id"> leq_eqVlt</span><span class="id"> eq_sym</span><span class="id"> !xpair_eqE</span><span class="id"> andbC</span>.<br/>
<span class="id">case:</span><span class="id"> eqP</span><span class="id"> =&gt;</span><span class="id"> [n3</span><span class="id"> _</span><span class="id"> _</span><span class="id"> |</span><span class="id"> _</span><span class="id"> /=</span><span class="id"> n_gt3</span><span class="id"> defOhmM]</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> eqZU1:</span><span class="id"> Z</span><span class="id"> =</span><span class="id"> 'Mho^1</span>(<span class="id">U</span>)<span class="gallina-kwd"> by</span><span class="id"> apply/eqP;</span><span class="id"> rewrite</span><span class="id"> eqEcard</span><span class="id"> sZU1</span><span class="id"> oZ</span><span class="id"> oU1</span><span class="id"> n3</span><span class="id"> /=</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">setIidPl</span><span class="id"> _</span>)<span class="gallina-kwd"> in</span><span class="id"> defM;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defM</span><span class="id"> oM</span><span class="id"> n3</span><span class="id"> pfactorK</span><span class="gallina-kwd"> in</span><span class="id"> R_gt_3</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -eqZU1</span><span class="id"> subIset</span><span class="id"> ?centS</span><span class="id"> ?orbT</span>.<br/>
<span class="id">have{defOhmM}</span><span class="id"> [|defM2</span><span class="id"> _]</span><span class="id"> :=</span><span class="id"> defOhmM</span><span class="id"> 2;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -subn1</span><span class="id"> ltn_subRL</span>.<br/>
<span class="id">do</span><span class="id"> [set</span><span class="id"> xpn3</span><span class="id"> :=</span><span class="id"> x</span><span class="id"> ^+</span><span class="id"> _;</span><span class="id"> set</span><span class="id"> X2</span><span class="id"> :=</span><span class="id"> &lt;[_]&gt;]</span><span class="gallina-kwd"> in</span><span class="id"> defM2</span>.<br/>
<span class="id">have</span><span class="id"> oX2:</span><span class="id"> #|X2|</span><span class="id"> =</span> (<span class="id">p</span><span class="id"> ^</span><span class="id"> 2</span>)<span class="id">%N</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> -orderE</span> (<span class="id">orderXexp</span><span class="id"> _</span><span class="id"> ox</span>)<span class="id"> -{1}</span>(<span class="id">subnKC</span><span class="id"> n_gt2</span>)<span class="id"> addSn</span><span class="id"> addnK</span>.<br/>
<span class="id">have</span><span class="id"> sZX2:</span><span class="id"> Z</span><span class="id"> \subset</span><span class="id"> X2</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> cycXp:</span><span class="id"> cyclic</span><span class="id"> &lt;[x</span><span class="id"> ^+</span><span class="id"> p]&gt;</span><span class="id"> :=</span><span class="id"> cycle_cyclic</span><span class="id"> _</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">cardSg_cyclic</span><span class="id"> cycXp</span>)<span class="id"> /=;</span><span class="id"> first</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> oZ</span><span class="id"> oX2</span><span class="id"> dvdn_mull</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -defZM</span><span class="id"> subsetI</span> (<span class="id">subset_trans</span> (<span class="id">Ohm_sub</span><span class="id"> _</span><span class="id"> _</span>))<span class="id"> //=</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">subset_trans</span><span class="id"> sZU1</span>)<span class="id"> //</span><span class="id"> centsC</span><span class="id"> defM</span><span class="id"> subsetIr</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> /xpn3</span><span class="id"> -subnSK</span><span class="id"> //expnS</span><span class="id"> expgM</span><span class="id"> cycleX</span>.<br/>
<span class="id">have{defM2}</span><span class="id"> [_</span><span class="id"> /=</span><span class="id"> defM2</span><span class="id"> cYX2</span><span class="id"> tiX2Y]</span><span class="id"> :=</span><span class="id"> dprodP</span><span class="id"> defM2</span>.<br/>
<span class="id">have{defN}</span><span class="id"> [_</span><span class="id"> defN</span><span class="id"> cME]</span><span class="id"> :=</span><span class="id"> cprodP</span><span class="id"> defN</span>.<br/>
<span class="id">have</span><span class="id"> cEM2:</span><span class="id"> E</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">'Ohm_2</span>(<span class="id">M</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> centsC</span> (<span class="id">subset_trans</span><span class="id"> _</span><span class="id"> cME</span>)<span class="id"> ?centS</span><span class="id"> ?Ohm_sub</span>.<br/>
<span class="id">have</span><span class="id"> [cEX2</span><span class="id"> cYE]:</span><span class="id"> X2</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">E</span>)<span class="id"> /\</span><span class="id"> E</span><span class="id"> \subset</span><span class="id"> 'C</span>(<span class="id">&lt;[y]&gt;</span>).<br/>
&nbsp;<span class="gallina-kwd">by</span><span class="id"> apply/andP;</span><span class="id"> rewrite</span><span class="id"> centsC</span><span class="id"> -subsetI</span><span class="id"> -centM</span><span class="id"> defM2</span>.<br/>
<span class="id">have</span><span class="id"> pN:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> N</span><span class="id"> :=</span><span class="id"> pgroupS</span> (<span class="id">subsetIl</span><span class="id"> _</span><span class="id"> _</span>)<span class="id"> pG</span>.<br/>
<span class="id">have</span><span class="id"> defN2:</span> (<span class="id">E</span><span class="id"> &lt;*&gt;</span><span class="id"> X2</span>)<span class="id"> \x</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 'Ohm_2</span>(<span class="id">N</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> dprodE</span><span class="id"> ?centY</span><span class="id"> ?subsetI</span><span class="id"> 1?centsC</span><span class="id"> ?cYE</span><span class="id"> //=;</span><span class="id"> last</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cycle_subG</span><span class="gallina-kwd"> in</span><span class="id"> My;</span><span class="id"> rewrite</span><span class="id"> joingC</span><span class="id"> cent_joinEl</span><span class="id"> //=</span><span class="id"> -/X2</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -</span>(<span class="id">setIidPr</span><span class="id"> My</span>)<span class="id"> setIA</span><span class="id"> -group_modl</span><span class="id"> ?cycle_subG</span><span class="id"> ?groupX</span><span class="id"> //</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> mulGSid</span><span class="id"> //</span> (<span class="id">subset_trans</span><span class="id"> _</span><span class="id"> sZX2</span>)<span class="id"> //</span><span class="id"> -defZE</span><span class="id"> -tiER</span><span class="id"> setIS</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/eqP;</span><span class="id"> rewrite</span><span class="id"> cent_joinEr</span><span class="id"> //</span><span class="id"> -mulgA</span><span class="id"> defM2</span><span class="id"> eqEsubset</span><span class="id"> mulG_subG</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> OhmS</span><span class="id"> ?andbT;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> -defN</span><span class="id"> mulG_subr</span>.<br/>
&nbsp;&nbsp;<span class="id">have</span><span class="id"> expE:</span><span class="id"> exponent</span><span class="id"> E</span><span class="id"> %|</span><span class="id"> p</span><span class="id"> ^</span><span class="id"> 2</span><span class="gallina-kwd"> by</span><span class="id"> rewrite</span><span class="id"> exponent_special</span><span class="id"> ?</span>(<span class="id">pgroupS</span><span class="id"> sEG</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> /=</span> (<span class="id">OhmE</span><span class="id"> 2</span><span class="id"> pN</span>)<span class="id"> sub_gen</span><span class="id"> /=;</span><span class="id"> last</span><span class="id"> 1</span><span class="id"> first</span>.<br/>
&nbsp;&nbsp;&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> subsetI</span><span class="id"> -defN</span><span class="id"> mulG_subl</span><span class="id"> sub_LdivT</span><span class="id"> expE</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -cent_joinEl</span><span class="id"> //</span><span class="id"> -genM_join</span><span class="id"> genS</span><span class="id"> //</span><span class="id"> -defN</span>.<br/>
&nbsp;&nbsp;<span class="id">apply/subsetP=&gt;</span><span class="id"> _</span><span class="id"> /setIP[/imset2P[e</span><span class="id"> z</span><span class="id"> Ee</span><span class="id"> Mz</span><span class="id"> -&gt;]]</span>.<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> inE</span><span class="id"> expgMn;</span><span class="id"> last</span><span class="gallina-kwd"> by</span><span class="id"> red;</span><span class="id"> rewrite</span><span class="id"> -</span>(<span class="id">centsP</span><span class="id"> cME</span>).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span> (<span class="id">exponentP</span><span class="id"> expE</span>)<span class="id"> //</span><span class="id"> mul1g</span><span class="id"> =&gt;</span><span class="id"> zp2;</span><span class="id"> rewrite</span><span class="id"> mem_mulg</span><span class="id"> //=</span>.<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">OhmE</span><span class="id"> 2</span> (<span class="id">pgroupS</span><span class="id"> sMR</span><span class="id"> pR</span>))<span class="id"> mem_gen</span><span class="id"> //</span><span class="id"> !inE</span><span class="id"> Mz</span>.<br/>
<span class="id">have{defN2}</span><span class="id"> defZN2:</span><span class="id"> X2</span><span class="id"> \x</span><span class="id"> &lt;[y]&gt;</span><span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">'Ohm_2</span>(<span class="id">N</span>)).<br/>
&nbsp;&nbsp;<span class="id">rewrite</span><span class="id"> -[X2]</span>(<span class="id">mulSGid</span><span class="id"> sZX2</span>)<span class="id"> /=</span><span class="id"> -/Z</span><span class="id"> -defZE</span><span class="id"> -</span>(<span class="id">center_dprod</span><span class="id"> defN2</span>).<br/>
&nbsp;&nbsp;<span class="id">do</span><span class="id"> 2!rewrite</span><span class="id"> -{1}</span>(<span class="id">center_idP</span> (<span class="id">cycle_abelian</span><span class="id"> _</span>))<span class="id"> -/X2;</span><span class="id"> congr</span> (_<span class="id"> \x</span><span class="id"> _</span>).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> case/cprodP:</span> (<span class="id">center_cprod</span> (<span class="id">cprodEY</span><span class="id"> cEX2</span>)).<br/>
<span class="id">have{defZN2}</span><span class="id"> strZN2:</span><span class="id"> \big[dprod/1]_</span>(<span class="id">z</span><span class="id"> &lt;-</span><span class="id"> [::</span><span class="id"> xpn3;</span><span class="id"> y]</span>)<span class="id"> &lt;[z]&gt;</span><span class="id"> =</span><span class="id"> 'Z</span>(<span class="id">'Ohm_2</span>(<span class="id">N</span>)).<br/>
&nbsp;&nbsp;<span class="gallina-kwd">by</span><span class="id"> rewrite</span><span class="id"> unlock</span><span class="id"> /=</span><span class="id"> dprodg1</span>.<br/>
<span class="id">rewrite</span><span class="id"> -size_abelian_type</span><span class="id"> ?center_abelian</span><span class="id"> //</span>.<br/>
<span class="id">have</span><span class="id"> pZN2:</span><span class="id"> p</span>.<span class="id">-group</span><span class="id"> 'Z</span>(<span class="id">'Ohm_2</span>(<span class="id">N</span>))<span class="gallina-kwd"> by</span><span class="id"> rewrite</span> (<span class="id">pgroupS</span><span class="id"> _</span><span class="id"> pN</span>)<span class="id"> //</span><span class="id"> subIset</span><span class="id"> ?Ohm_sub</span>.<br/>
<span class="id">rewrite</span> (<span class="id">perm_size</span> (<span class="id">abelian_type_pgroup</span><span class="id"> pZN2</span><span class="id"> strZN2</span><span class="id"> _</span>))<span class="id"> //=</span><span class="id"> !inE</span>.<br/>
<span class="id">rewrite</span><span class="id"> !</span>(<span class="id">eq_sym</span><span class="id"> 1</span>)<span class="id"> -!order_eq1</span><span class="id"> oy</span><span class="id"> orderE</span><span class="id"> oX2</span>.<br/>
<span class="gallina-kwd">by</span><span class="id"> rewrite</span> (<span class="id">eqn_exp2l</span><span class="id"> 2</span><span class="id"> 0</span>)<span class="id"> //</span> (<span class="id">eqn_exp2l</span><span class="id"> 1</span><span class="id"> 0</span>).<br/>
Qed.</div></details>
<br/>
<span class="vernacular">End</span><span class="id"> ExtremalTheory</span>.<br/>

      <div class="footer"><hr/>Generated by <a href="https://github.com/affeldt-aist/rocqnavi/">rocqnavi</a></div>
    </div>
  </div>
    </main>
</body>
</html>
